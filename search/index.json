[{"content":" 数据库完整性 数据库的完整性(integrity)是指数据的正确性(correctness)和相容性(compat-ability)。数据的正确性是指数据是符合现实世界语义、反映当前实际状况的；数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。\n例如，学生的学号必须唯一，性别只能是男或女，本科学生年龄的取值范围为14—50的整数，学生所选的课程必须是学校开设的课程，学生所在的院系必须是学校已成立的 院系等。\n数据的完整性和安全性是两个既有联系又不尽相同的概念。数据的完整性是为了防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据。数据的安全性是保护数据库防止恶意破坏和非法存取。因此，完整性检查和控制的防范对象是不合语义的、不正确的数据，防止它们进入数据库。安全性控制的防范对象是非法用户和非法操作，防止他们对数据库数据的非法存取。\n为维护数据库的完整性，数据库管理系统必须能够实现如下功能。\n关系数据库-关系的完整性中己经讲解了关系数据库三类完整性约束的基本概念，下面 将介绍SQL语言中实现这些完整性控制功能的方法。\n1. 提供定义完整性约束条件的机制\n完整性约束条件也称为完整性规则，是数据库中的数据必须满足的语义约束条件。它表达了给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。SQL标准使用了一系列概念来描述完整性，包括关系模型的实体完整性、参照完整性和用户定义完整性。这些完整性一般由SQL的数据定义语言语句来实现，它们作为数据库模式的一部分存入数据字典中。\n2. 提供完整性检查的方法\n数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。一般在INSERT、UPDATE、DELETE语句执行后开始检查，也可以在事务提交时检查。检查这些操作执行后数据库中的数据是否违背了完整性约束条件。\n3. 进行违约处理\n数据库管理系统若发现用户的操作违背了完整性约束条件将采取一定的动作，如拒绝(NO ACTION)执行该操作或级联(CASCADE)执行其他操作，进行违约处理以保证数据 的完整性。\n早期的数据库管理系统不支持完整性检查，因为完整性检查费时费资源。现在商用的关系数据库管理系统产品都支持完整性控制，即完整性定义和检查控制由关系数据库管理系统实现，不必由应用程序来完成，从而减轻了应用程序员的负担。更重要的是，关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。因为由应用程序来实现完整性控制是有漏洞的，有的应用程序定义的完整性约束条件可能被其他应用程序破坏，数据库数据的正确性仍然无法保障。\n实体完整性 定义实体完整性 关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。对单属性构成的码有两种说明方法，一种是定义为列级约束条件，另一种是定义为表级约束条件。对多个属性构成的码只有一种说明方法，即定义为表级约束条件。\n例1：将Student表中的Sno属性定义为码。\n1 2 3 4 5 6 7 CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, /*在列级定义主码*/ Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 或者\n1 2 3 4 5 6 7 8 CREATE TABLE Student (Sno CHAR(9), Sname CHAR(20) NOT NULL, Ssex CHAR(2), Sage SMALL INT, Sdept CHAR(20), PRIMARY KEY (Sno) /*在表级定义主码*/ ); 例2：将SC表中的Sno、Cno属性组定义为码。\n1 2 3 4 5 6 CREATE TABLE SC (Sno CHAR(9) NOT NULL, Cno CHAR(4) NOT NULL, Grade SMALLINT, PRIMARY KEY (Sno,Cno) /*只能在表级定义主码*/ ); 实体完整性检查和违约处理 用PRIMARY KEY短语定义了关系的主码后，每当用户程序对基本表插入一条记录或对主码列进行更新操作时，关系数据库管理系统将按照关系数据库-实体完整性中讲解的实体完整性规则自动进行检查。包括：\n(1)检查主码值是否唯一，如果不唯一则拒绝插入或修改。\n(2)检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。从而保证了实体完整性。\n检查记录中主码值是否唯一的一种方法是进行全表扫描，依次判断表中每一条记录的主码值与将插入记录的主码值（或者修改的新主码值）是否相同，如图1所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Key1 F21 F31 F41 F51 Key2 Key3 F22 F23 F32 F33 F42 F43 F53 F52 Keyi F2i F3i F4i F5i 基本表 图1\u0026emsp;用全表扫描方法检查主码唯一性\n全表扫描是十分耗时的。为了避免对基本表进行全表扫描，关系数据库管理系统一般都 在主码上自动建立一个索引，如图2的B+树索引，通过索引查找基本表中是否已经存在新的主码值将大大提高效率。例如，如果新插入记录的主码值是25，通过主码索引，从B+树的根结点开始查找，只要读取三个结点就可以知道该主码值已经存在，所以不能插入这条记录。这三个结点是根结点(51)、中间结点(12 30)和叶结点(15 20 25)。如果新插入记录的主码值是86，也只要查找三个结点就可以知道该主码值不存在，所以可以插入该记录。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 新记录的主码值 25 51 3 7 15 20 25 30 41 51 54 65 68 69 71 76 79 84 93 12 30 66 78 图2\u0026emsp;使用索引检查主码唯一\n参照完整性 ","date":"2024-12-02T17:46:49+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/database_system/database_integrity/","title":"数据库系统（五）：数据库完整性"},{"content":" 数据库安全性 在第一章中已经讲到，数据库的特点之一是由数据库管理系统提供统一的数据保护功能来保证数据的安全可靠和正确有效。数据库的数据保护主要包括数据的安全性和完整性。本篇主要介绍数据库的安全性。\n数据库安全性概述 数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。安全性问题不是数据库系统所独有的，所有计算机系统都存在不安全因素，只是在数据库系统中由于大量数据集中存放，而且为众多最终用户直接共享，从而使安全性问题更为突出。系统安全保护措施是否有效是数据库系统的主要技术指标之一。\n数据库的不安全因素 对数据库安全性产生威胁的因素主要有以下几方面。\n非授权用户对数据库的恶意存取和破坏 一些黑客(hacker)和犯罪分子在用户存取数据库时猎取用户名和用户口令，然后假冒合法用户偷取、修改甚至破坏用户数据。因此，必须阻止有损数据库安全的非法操作，以保证数据免受未经授权的访问和破坏，数据库管理系统提供的安全措施主要包括用户身份鉴别、存取控制和视图等技术。\n数据库中重要或敏感的数据被泄露 黑客和敌对分子千方百计盗窃数据库中的重要数据，一些机密信息被暴露。为防止数据泄露，数据库管理系统提供的主要技术有强制存取控制、数据加密存储和加密传输等。此外，在安全性要求较高的部门提供审计功能，通过分析审计日志，可以对潜在的威胁提前采取措施加以防范，对非授权用户的入侵行为及信息破坏情况能够进行跟踪，防止对数据库安全责任的否认。\n安全环境的脆弱性 数据库的安全性与计算机系统的安全性，包括计算机硬件、操作系统、网络系统等的安全性是紧密联系的。操作系统安全的脆弱，网络协议安全保障的不足等都会造成数据库安全性的破坏。因此，必须加强计算机系统的安全性保证。随着Internet技术的发展，计算机安全性问题越来越突出，对各种计算机及其相关产品、信息系统的安全性要求越来越高。为此，在计算机安全技术方面逐步发展建立了一套可信(trusted)计算机系统的概念 和标准。只有建立了完善的可信标准即安全标准，才能规范和指导安全计算机系统部件的生产，较为准确地测定产品的安全性能指标，满足民用和军用的不同需要。\n安全标准简介 计算机以及信息安全技术方面有一系列的安全标准，最有影响的当推TCSEC和CC这两个标准。\nTCSEC是指1985年美国国防部(Department of Defense, DoD)正式颁布的《DoD可信计算机系统评估准则》(Trusted Computer System Evaluation Criteria, TCSEC 或DoD85)。\n在TCSEC推出后的10年里，不同的国家都开始启动开发建立在TCSEC概念上的评估准则，如欧洲的信息技术安全评估准则(Information Technology Security Evaluation Criteria,ITSEC)、加拿大的可信计算机产品评估准则(Canadian Trusted Computer Product Evaluation Criteria,CTCPEC)、美国的信息技术安全联邦标准(Federal Criteria,FC)草案等。这些准则比TCSEC更加灵活，适应了IT技术的发展。\n为满足全球IT市场上互认标准化安全评估结果的需要，CTCPEC、FC、TCSEC和ITSEC的发起组织于1993年起开始联合行动，解决原标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的IT安全准则，这一行动被称为通用准则(Common Criteria,CC)项目。项目发起组织的代表建立了专门的委员会来开发通用准则，历经多次讨论和修订，CC V2.1版于1999年被ISO采用为国际标准，2001年被我国采用为国家标准。\n目前CC已经基本取代了TCSEC，成为评估信息产品安全性的主要标准。\n上述一系列标准的发展历史如图1所示。本节简要介绍TCSEC和CC V2.1的基本内容。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 1985年美国国防部 可信计算机系 统评估准则 ( T C S E C ) 1991年 欧洲信息技术安 全评估准则 (I T S E C ) 通用准则 ( C C ) V1.0 1996年 V2.0 1998年 V2.1 1999年 1999年 C C V2.1 成为国际标准 (I S O 15408) 1993年加拿大可 信计算机产品 评估准则 ( C T C P E C ) 1993年 美国信息技术 安全联邦标准 ( F C )草案 图1\u0026emsp;信息安全标准的发展简史\nTCSEC又称桔皮书。1991年4月，美国国家计算机安全中心(National Computer Security Center,NCSC)颁布了《可信计算机系统评估准则关于可信数据库系统的解释》(TCSEC/Trusted Database Interpretation, TCSEC/TDI)，即紫皮书)，将TCSEC扩展到数据库管理系统。TCSEC/TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准，从4个方面来描述安全性级别划分的指标，即安全策略、责任、保证和文档。每个方面又细分为若干项。\n根据计算机系统对各项指标的支持情况，TCSEC/TDI将系统划分为4组(division)7个等级，依次是D、C(Cl, C2)、B(Bl, B2, B3)、A(Al)，按系统可靠或可信程度逐渐增高，如表1所示。\n安全级别 定义 A1 验证设计 (verified design) B3 安全域 (security domains) B2 结构化保护 (structural protection) B1 标记安全保护 (labeled security protection) C2 受控的存取保护 (controlled access protection) C1 自主安全保护 (discretionary security protection) D 最小保护 (minimal protection) 表1\u0026emsp;TCSEC/TDI安全级别划分\nD级：该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。如DOS就是操作系统中安全标准为D级的典型例子，它具有操作系统的基本功能，如文件系统、进程调度等，但在安全性方面几乎没有什么专门的机制来保障。\nC1级：该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行自主存取控制(DAC)，保护或限制用户权限的传播。现有的商业系统往往稍作改进即可满足要求。\nC2级：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出“安全”（security）这一特色，如操作系统中的Windows 2000、数据库产品中的Oracle 7等。\nB1级：标记安全保护。对系统的数据加以标记，并对标记的主体和客体实施强制存取控制(MAC)以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，满足此级别的产品前一般多冠以“安全”（security）或\u0026quot;可信的”（trusted）字样，作为区别于普通产品的安全产品出售。\nB2级：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。\nB3级：安全域。该级的TCB(Trusted Computing Base)必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。\nA1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。\nCC是在上述各评估准则及具体实践的基础上通过相互总结和互补发展而来的。和早期的评估准则相比，CC具有结构开放、表达方式通用等特点。CC提出了目前国际上公认的表述信息技术安全性的结构，即把对信息产品的安全要求分为安全功能要求和安全保证要求。安全功能要求用以规范产品和系统的安全行为，安全保证要求解决如何正确有效地实施这些功能。安全功能要求和安全保证要求都以“类-子类-组件”的结构表述，组件是安全要求的最小构件块。\nCC的文本由三部分组成，三个部分相互依存，缺一不可。\n第一部分是简介和一般模型，介绍CC中的有关术语、基本概念和一般模型以及与评估有关的一些框架。\n第二部分是安全功能要求，列出了一系列类、子类和组件。由11大类、66个子类和135个组件构成。\n第三部分是安全保证要求，列出了一系列保证类、子类和组件，包括7大类、26个子类和74个组件。根据系统对安全保证要求的支持情况提出了评估保证级(Evaluation Assurance Level,EAL)，从EAL1至EAL7共分为7级，按保证程度逐渐增高。如表4.2所示。\n评估保证级 定义 TCSEC安全级别 (近似相当) EAL0 功能测试（functionally tested） EAL1 结构测试（structurally tested） C1 EAL2 系统地测试和检查（methodically tested and checked） C2 EAL3 系统地设计、测试和复查（methodically designed, tested and reviewed） B1 EAL4 半形式化设计和测试（semiformally designed and tested） B2 EAL5 半形式化验证的设计和测试（semiformally verified design and tested） B3 EAL6 形式化验证的设计和测试（formally verified design and tested） A1 表2\u0026emsp;CC评估保证级(EAL)的划分\nCC的附录部分主要介绍保护轮廓(Protection Profile,PP)和安全目标(Security Target,ST)的基本内容。\n这三部分的有机结合具体体现在保护轮廓和安全目标中，CC提出的安全功能要求和安全保证要求都可以在具体的保护轮廓和安全目标中进一步细化和扩展，这种开放式的结构更适应信息安全技术的发展。CC的具体应用也是通过保护轮廓和安全目标这两种结构来实现的。\n粗略而言，TCSEC的C1和C2级分别相当于EAL2和EAL3；Bl、B2和B3分别相当于EAL4、EAL5和EAL6；A1对应于EAL7。\n数据库安全性控制 在一般计算机系统中，安全措施是一级一级层层设置的。例如，在图2所示的安全模型中，用户要求进入计算机系统时，系统首先根据输入的用户标识进行用户身份鉴定，只有合法的用户才准许进入计算机系统；对已进入系统的用户，数据库管理系统还要进行存取控制，只允许用户执行合法操作；操作系统也会有自己的保护措施；数据最后还可以以密码形式存储到数据库中。操作系统的安全保护措施可参考操作系统的有关书籍，这里不再详述。另外，对于强力逼迫透露口令、盗窃物理存储设备等行为而采取的保安措施，例如出入机房登记、加锁等，也不在这里讨论之列。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 数据库管理系统 操作系统 数据库 用户标识和鉴别 数据库安全保护 操作系统安全保护 数据密码存储 图2\u0026emsp;计算机系统的安全模型\n下面讨论与数据库有关的安全性，主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据库用户 身份鉴别 简单入侵检测 审计 推理控制 强制存取控制 自主存取控制 S Q L层 多层存取控制策略 用户数据信息 用户数据备份 信息 安全数据信息 （ 包括审 计 ） 安全数据备份 信息 数据层 图3\u0026emsp;数据库管理系统安全性控制模型\n图3是数据库安全保护的一个存取控制流程。首先，数据库管理系统对提出SQL访问请求的数据库用户进行身份鉴别，防止不可信用户使用系统；然后，在SQL处理层进行自主存取控制和强制存取控制，进一步还可以进行推理控制。为监控恶意访问，可根据具体安全需求配置审计规则，对用户访问行为和系统关键操作进行审计。通过设置简单入侵检测规则，对异常用户行为进行检测和处理。在数据存储层，数据库管理系统不仅存放用户数据，还存储与安全有关的标记和信息（称为安全数据），提供存储加密功能等。\n用户身份鉴别 用户身份鉴别是数据库管理系统提供的最外层安全保护措施。每个用户在系统中都有一个用户标识。每个用户标识由用户名（user name）和用户标识号（UID）两部分组成。UID在系统的整个生命周期内是唯一的。系统内部记录着所有合法用户的标识，系统鉴别是指由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才提供使用数据库管理系统的权限。用户身份鉴别的方法有很多种，而且在一个系统中往往是多种方法结合，以获得更强的安全性。常用的用户身份鉴别方法有以下几种。\n静态口令鉴别 这种方式是当前常用的鉴别方法。静态口令一般由用户自己设定，鉴别时只要按要求输入正确的口令，系统将允许用户使用数据库管理系统。这些口令是静态不变的，在实际应用中，用户常常用自己的生日、电话、简单易记的数字等内容作为口令，很容易被破解。而一旦被破解，非法用户就可以冒充该用户使用数据库。因此，这种方式虽然简单，但容易被攻击，安全性较低。\n口令的安全可靠对数据库安全来说至关重要。因此，数据库管理系统从口令的复杂度，口令的管理、储及传输等多方面来保障口令的安全可靠。例如，要求口令长度至少是8个（或者更多）字符；口令要求是字母、数字和特殊字符混合，其中，特殊符号是除空白符、英文字母、单引号和数字外的所有可见字符。在此基础上，管理员还能根据应用需求灵活地设置口令强度，例如，设定口令中数字、字母或特殊符号的个数：设置口令是否可以是简单的常见单词，是否允许口令与用户名相同；设置重复使用口令的最小时间间隔等。此外，在存储和传输过程中口令信息不可见，均以密文方式存在。用户身份鉴别可以重复多次。\n动态口令鉴别 它是目前较为安全的鉴别方式。这种方式的口令是动态变化的，每次鉴别时均需使用动态产生的新口令登录数据库管理系统，即采用一次一密的方法。常用的方式如短信密码和动态令牌方式，每次鉴别时要求用户使用通过短信或令牌等途径获取的新口令登录数据库管理系统。与静态口令鉴别相比，这种认证方式增加了口令被窃取或破解的难度，安全性相对高一些。\n生物特征鉴别 它是一种通过生物特征进行认证的技术，其中，生物特征是指生物体唯一具有的，可测量、识别和验证的稳定生物特征，如指纹、虹膜和掌纹等。这种方式通过采用图像处理和模式识别等技术实现了基于生物特征的认证，与传统的口令鉴别相比，无疑产生了质的飞跃，安全性较高。\n智能卡鉴别 智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能。智能卡由用户随身携带，登录数据库管理系统时用户将智能卡插入专用的读卡器进行身份验证。由于每次从智能卡中读取的数据是静态的，通过内存扫描或网络监听等技术还是可能截取到用户的身份验证信息，存在安全隐患。因此，实际应用中一般采用个人身份识别码(PIN)和智能卡相结合的方式。这样，即使PIN或智能卡中有一种被窃取，用户身份仍不会被冒充。\n存取控制 数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。 存取控制机制主要包括定义用户权限和合法权限检查两部分。\n(1)定义用户权限，并将用户权限登记到数据字典中。用户对某一数据对象的操作权力称为权限。某个用户应该具有何种权限是个管理问题和政策问题，而不是技术问题。数据库管理系统的功能是保证这些决定的执行。为此，数据库管理系统必须提供适当的语言来定义用户权限，这些定义经过编译后存储在数据字典中，被称做安全规则或授权规则。\n(2)合法权限检查。每当用户发出存取数据库的操作请求后（请求一般应包括操作类型、操作对象和操作用户等信息），数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。定义用户权限和合法权限检查机制一起组成了数据库管理系统的存取控制子系统。C2级的数据库管理系统支持自主存取控制(Discretionary Access Control,DAC)。B1级的数据库管理系统支持强制存取控制(Mandatory Access Control,MAC)。\n这两类方法的简单定义是：\n(1)在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户，因此自主存取控制非常灵活。\n(2)在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。强制存取控制因此相对比较严格。\n下面介绍这两种存取控制方法。\n自主存取控制方法 大型数据库管理系统都支持自主存取控制，SQL标准也对自主存取控制提供支持，这主要通过SQL的GRANT语句和REVOKE语句来实现。\n用户权限是由两个要素组成的：数据库对象和操作类型。定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，定义存取权限称为授权(authorization)。\n在非关系系统中，用户只能对数据进行操作，存取控制的数据库对象也仅限于数据本身。在关系数据库系统中，存取控制的对象不仅有数据本身(基本表中的数据、属性列上的数据），还有数据库模式（包括数据库、基本表、视图和索引的创建等），表3列出了主要的存取权限。\n对象类型 对象 操作类型 数据库模式 模式 CREATE SCHEMA 基本表 CREATE TABLE, ALTER TABLE 视图 CREATE VIEW 索引 CREATE INDEX 数据 基本表和视图 SELECT, INSERT, UPDATE, DELETE, REFERENCES, ALL PRIVILEGES 属性列 SELECT, INSERT, UPDATE, REFERENCES, ALL PRIVILEGES 表3\u0026emsp;关系数据库系统中的存取权限\n表3中，列权限包括SELECT、REFERENCES、INSERT、UPDATE，其含义与表权限类似。需要说明的是，对列的UPDATE权限指对于表中存在的某一列的值可以进行修改。当然，有了这个权限之后，在修改的过程中还要遵守表在创建时定义的主码及其他约束。列上的INSERT权限指用户可以插入一个元组。对于插入的元组，授权用户可以插入指定的值，其他列或者为空，或者为默认值。在给用户授予列INSERT权限时，一定要包含主码的INSERT权限，否则用户的插入动作会因为主码为空而被拒绝。\n授权：授予与收回 SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回己经授予用户的权限。\nGRANT GRANT语句的一般格式为\n1 2 3 4 GRANT \u0026lt;权限\u0026gt; [,\u0026lt;权限\u0026gt;]··· ON \u0026lt;对象类型\u0026gt;\u0026lt;对象名\u0026gt; [,\u0026lt;对象类型\u0026gt;\u0026lt;对象名\u0026gt;]··· TO \u0026lt;用户\u0026gt;[,\u0026lt;用户\u0026gt;]··· [WITH GRANT OPTION]; 其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是数据库管理员，也可以是该数据库对象创建者（即属主owner），还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，即全体用户。\n如果指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。如果没有指定WITH GRANT OPTION子句，则获得某种权限的用户只能使用该权限，不能传播该权限。\nSQL标准允许具有WITH GRANT OPTION的用户把相应权限或其子集传递授予其他用户，但不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先，如图4所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e U1 U2 U3 U4 × 图4\u0026emsp;不允许循环授权\n例1：把查询Student表的权限给用户U1。\n1 2 3 GRANT SELECT ON TABLE Student TO U1; 例2：把对Student表和Course表的全部操作权限授予用户U2和U3。\n1 2 3 GRANT ALL PRIVILEGES ON TABLE Student, Course TO U2,U3; 例3：把对表SC的查询权限授予所有用户。\n1 2 3 GRANT SELECT ON TABLE SC TO PUBLIC; 例4：把查询Student表和修改学生学号的权限授给用户U4。\n1 2 3 GRANT UPDATE(Sno),SELECT ON TABLE Student TO U4; 这里，实际上要授予U4用户的是对基本表Student的SELECT权限和对属性列Sno的UPDATE权限。对属性列授权时必须明确指出相应的属性列名。\n例5：把对表SC的INSERT权限授予U5用户，并允许将此权限再授予其他用户。\n1 2 3 4 GRANT INSERT ON TABLE SC TO U5 WITH GRANT OPTION; 执行此SQL语句后，U5不仅拥有了对表SC的INSERT权限，还可以传播此权限，即由U5用户发上述GRANT命令给其他用户。例如U5可以将此权限授予U6（例6）。\n例6：\n1 2 3 4 GRANT INSERT ON TABLE SC TO U6 WITH GRANT OPTION; 同样，U6还可以将此权限授予U7（例7）。\n例7：\n1 2 3 GRANT INSERT ON TABLE SC TO U7; 因为U6未给U7传播的权限，因此U7不能再传播此权限。\n由上面的例子可以看到，GRANT语句可以一次向一个用户授权，如例1所示，这是 最简单的一种授权操作；也可以一次向多个用户授权，如例2、例3所示；还可以一次传播多个同类对象的权限，如例2所示；甚至一次可以完成对基本表和例3属性列这些不同对象的授权，如例4所示。表4是执行了例1~例7的语句后学生—课程数据库中的用户权限定义表。\n授权用户名 被授权用户名 数据库对象名 允许的操作类型 能否转授权 DBA U1 关系Student SELECT 不能 DBA U2 关系Student ALL 不能 DBA U2 关系Course ALL 不能 DBA U3 关系Student ALL 不能 DBA U3 关系Course ALL 不能 DBA PUBLIC 关系SC SELECT 不能 DBA U4 关系Student SELECT 不能 DBA U4 属性列Student.Sno UPDATE 不能 DBA U5 关系SC INSERT 能 U5 U6 关系SC INSERT 能 U6 U7 关系SC INSERT 不能 表4\u0026emsp;学生—课程数据库中的用户权限定义\nREVOKE 授予用户的权限可以由数据库管理员或其他授权者用REVOKE语句收回，REVOKE语句的一般格式为\n1 2 3 REVOKE \u0026lt;权限\u0026gt; [,\u0026lt;权限\u0026gt;] ··· ON \u0026lt;对象类型\u0026gt;\u0026lt;对象名\u0026gt; [,\u0026lt;对象类型\u0026gt;\u0026lt;对象名\u0026gt;] ··· FROM \u0026lt;用户\u0026gt; [,\u0026lt;用户\u0026gt;] ··· [CASCADE|RESTRICT]; 例8：把用户U4修改学生学号的权限收回。\n1 2 3 REVOKE UPDATE(Sno) ON TABLE Student FROM U4; 例9：收回所有用户对表SC的查询权限。\n1 2 3 REVOKE SELECT ON TABLE SC FROM PUBLIC; 例10：把用户U5对SC表的INSERT权限收回。\n1 2 3 REVOKE INSERT ON TABLE SC FROM U5 CASCADE; 将用户U5的INSERT权限收回的同时，级联（CASCADE）收回了U6和U7的INSERT权限，否则系统将拒绝执行该命令。因为在例6中，U5将对SC表的INSERT权限授予了U6，而U6又将其授予了U7（例7）。\n注意：这里默认值为CASCADE，有的数据库管理系统默认值为RESTRICT，将自动执行级联操作。如果U6或U7还从其他用户处获得对SC表的INSERT权限，则 他们仍具有此权限，系统只收回直接或间接从U5处获得的权限。 表5是执行了例8~例10的语句后学生-课程数据库的用户权限定义。\n授权用户名 被授权用户名 数据库对象名 允许的操作类型 能否转授权 DBA U1 关系Student SELECT 不能 DBA U2 关系Student ALL 不能 DBA U2 关系Course ALL 不能 DBA U3 关系Student ALL 不能 DBA U3 关系Course ALL 不能 DBA U4 关系Student SELECT 不能 表5\u0026emsp;学生—课程数据库中的用户权限定义\nSQL提供了非常灵活的授权机制。数据库管理员拥有对数据库中所有对象的所有权限，并可以根据实际情况将不同的权限授予不同的用户。\n用户对自己建立的基本表和视图拥有全部的操作权限，并且可以用GRANT语句把其中某些权限授予其他用户。被授权的用户如果有“继续授权”的许可，还可以把获得的权限再授予其他用户。\n所有授予出去的权力在必要时又都可以用REVOKE语句收回。\n可见，用户可以“自主”地决定将数据的存取权限授予何人、决定是否也将“授权” 的权限授予别人。因此称这样的存取控制是自主存取控制。\n创建数据库模式的权限 GRANT和REVOKE语句向用户授予或收回对数据的操作权限。对创建数据库模式一类的数据库对象的授权则由数据库管理员在创建用户时实现。\nCREATE USER语句一般格式如下：\n1 CREATE USER \u0026lt;usemame\u0026gt; [WITH] [DBA | RESOURCE | CONNECT]; 对CREATE USER语句说明如下：\n◦只有系统的超级用户才有权创建一个新的数据库用户。\n◦新创建的数据库用户有三种权限：CONNECT、RESOURCE和DBA。\n◦CREATE USER命令中如果没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库。由数据库管理员或其他用户授予他应有的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。\n◦拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主，但不能创建模式，不能创建新的用户。数据库对象的属主可以使用GRANT语句把该对象上的存取权限授予其他用户。\n◦拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基 本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。以上说明可以用表6来总结。\n拥有的权限 可否执行的操作 CREATE USER CREATE SCHEMA CREATE TABLE 登录数据库，执行数据查询和操纵 DBA 可以 可以 可以 可以 RESOURCE 不可以 不可以 可以 可以 CONNECT 不可以 不可以 不可以 可以，但必须拥有相应权限 表6\u0026emsp;权限与可执行的操作对照表\n注意：CREATE USER语句不是SQL标准，因此不同的关系数据库管理系统的语法和内容相差甚远。这里介绍该语句的目的是说明对于数据库模式这一类数据对象也有安全控制的需要，也是要授权的。\n数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。因此，可以为一组具有相同权限的用户创建一个角色，使用角色来管理数据库权限可以简化授权的过程。\n在SQL中首先用CREATE ROLE语句创建角色，然后用GRANT语句给角色授权，用REVOKE语句收回授予角色的权限。\n角色的创建 创建角色的SQL语句格式是\n1 CREATE ROLE \u0026lt;角色名\u0026gt; 刚刚创建的角色是空的，没有任何内容。可以用GRANT为角色授权。\n给角色授权 1 2 3 GRANT \u0026lt;权限\u0026gt; [,\u0026lt;权限\u0026gt;] ··· ON \u0026lt;对象类型\u0026gt; 对象名 TO \u0026lt;角色\u0026gt; [,\u0026lt;角色\u0026gt;] ··· 数据库管理员和用户可以利用GRANT语句将权限授予某一个或几个角色。\n将一个角色授予其他的角色或用户 1 2 3 GRANT \u0026lt;角色1\u0026gt; [,\u0026lt;角色2\u0026gt;] ··· TO \u0026lt;角色3\u0026gt; [,\u0026lt;用户1\u0026gt;] ··· [WITH ADMIN OPTION] 该语句把角色授予某用户，或授予另一个角色。这样，一个角色（例如角色3）所拥有的权限就是授予它的全部角色（例如角色1和角色2）所包含的权限的总和。\n授予者或者是角色的创建者，或者拥有在这个角色上的ADMIN OPTION。\n如果指定了WITH ADMIN OPTION子句，则获得某种权限的角色或用户还可以把这种权限再授予其他的角色。\n一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。\n角色权限的收回 1 2 3 REVOKE \u0026lt;权限\u0026gt;[,\u0026lt;权限\u0026gt;] ··· ON \u0026lt;对象类型\u0026gt; \u0026lt;对象名\u0026gt; FROM \u0026lt;角色\u0026gt; [,\u0026lt;角色\u0026gt;] ··· 用户可以收回角色的权限，从而修改角色拥有的权限。\nREVOKE动作的执行者或者是角色的创建者，或者拥有在这个（些）角色上的ADMIN OPTION。\n例11：通过角色来实现将一组权限授予一个用户。\n步骤如下： ①首先创建一个角色R1。\n1 CREATE ROLE R1; ②然后使用GRANT语句，使角色R1拥有Student表的SELECT、UPDATE、INSERT权限。\n1 2 3 GRANT SELECT,UPDATE,INSERT ON TABLE Student TO R1; ③将这个角色授予王平、张明、赵玲，使他们具有角色R1所包含的全部权限。\n1 2 GRANT R1 TO 王平，张明，赵玲; ④当然，也可以一次性地通过R1来收回王平的这三个权限。\n1 2 REVOKE R1 FROM王平; 例12：角色的权限修改。\n1 2 3 GRANT DELETE ON TABLE Student TO R1; 使角色R1在原来的基础上增加了Student表的DELETE权限。\n例13：\n1 2 3 REVOKE SELECT ON TABLE Student FROM R1; 使R1减少了SELECT权限。\n可以看出，数据库角色是一组权限的集合。使用角色来管理数据库权限可以简化授权的过程，使自主授权的执行更加灵活、方便。\n强制存取控制方法 自主存取控制（MAC）能够通过授权机制有效地控制对敏感数据的存取。但是由于用户对数据的存取权限是“自主”的，用户可以自由地决定将数据的存取权限授予何人，以及决定是否也将“授权”的权限授予别人。在这种授权机制下，仍可能存在数据的“无意泄露”。比如，甲将自己权限范围内的某些数据存取权限授权给乙，甲的意图是仅允许乙本人操纵这些数据。但甲的这种安全性要求并不能得到保证，因为乙一旦获得了对数据的权限，就可以将数据备份，获得自身权限内的副本，并在不征得甲同意的前提下传播副本。造成这一问题的根本原因就在于，这种机制仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记。要解决这一问题，就需要对系统控制下的所有主客体实施强制存取控制策略。\n所谓强制存取控制是指系统为保证更高程度的安全性，按照TDI/TCSEC标准中安全策略的要求所采取的强制存取检查手段。它不是用户能直接感知或进行控制的。强制存取控制适用于那些对数据有严格而固定密级分类的部门，例如军事部门或政府部门。\n在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类。\n主体是系统中的活动实体，既包括数据库管理系统所管理的实际用户，也包括代表用户的各进程。客体是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为它们每个实例（值）指派一个敏感度标记(label)。敏感度标记被分成若干级别，例如绝密(Top Secret,TS)、机密(Secret,S)、可信(Confidential,C)、公开(Public,P)等。密级的次序是TS\u0026gt;=S\u0026gt;=C\u0026gt;=P。主体的敏感度标记称为许可证级别(clearance level)，客体的敏感度标记称为密级(classification level)。强制存取控制机制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体。\n当某一用户（或某一主体）以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：\n(1)仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。\n(2)仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体。\n规则(1)的意义是明显的，而规则(2)需要解释一下。按照规则(2)，用户可以为写入的数据对象赋予高于自己的许可证级别的密级。这样一旦数据被写入，该用户自己也不能再读该数据对象了。如果违反了规则(2)，就有可能把数据的密级从高流向低，造成数据的泄漏。例如，某个TS密级的主体把一个密级为TS的数据恶意地降低为P，然后把它写回。这样原来是TS密级的数据大家都可以读到了，造成TS密级数据的泄露。\n强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据，从而提供了更高级别的安全性。前面已经提到，较高安全性级别提供的安全保护要包含较低级别的所有保护，因此在实现强制存取控制时要首先实现自主存取控制(DAC)，即自主存取控制与强制存取控制共同构成数据库管理系统的安全机制，如图5所示。系统首先进行自主存取控制检查，对通过自主存取控制检查的允许存取的数据库对象再由系统自动进行强制存取控制检查，只有通过强制存取控制检查的数据库对象方可存取。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S Q L语法分析\u0026amp;语义检查 D A C检查 M A C检查 继续语义检查 安全检查 图5\u0026emsp;DAC+MAC安全检查示意图\n视图机制 还可以为不同的用户定义不同的视图，把数据对象限制在一定的范围内。也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。\n视图机制间接地实现支持存取谓词的用户权限定义。例如，在某大学中假定王平老师只能检索计算机系学生的信息，系主任张明具有检索和增删改计算机系学生信息 的所有权限。这就要求系统能支持“存取谓词”的用户权限定义。在不直接支持存取谓词的系统中，可以先建立计算机系学生的视图CS_Student，然后在视图上进一步定义存取权限。\n例14：建立计算机系学生的视图，把对该视图的SELECT权限授予王平，把该视图上的所有操作权限授予张明。\n1 2 3 4 5 6 7 8 9 10 11 CREATE VIEW CS_Student /*先建立视图 CS Student*/ AS SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;; GRANT SELECT /*王平老师只能检索计算机系学生的信息*/ ON CS_Student TO 王平; GRANT ALL PRIVILEGES /*系主任具有检索和增删改计算机系学生信息的所有权限*/ ON CS Student TO 张明; 审计 前面讲的用户身份鉴别、存取控制是数据库安全保护的重要技术（安全策略方面），但不是全部。为了使数据库管理系统达到一定的安全级别，还需要在其他方面提供相应的支持。例如按照TDI/TCSEC标准中安全策略的要求，审计(audit)功能就是数据库管理系统达到C2以上安全级别必不可少的一项指标。 因为任何系统的安全保护措施都不是完美无缺的，蓄意盗窃、破坏数据的人总是想方设法打破控制。审计功能把用户对数据库的所有操作自动记录下来放入审计日志(audit log)中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。还可以通过对审计日志分析，对潜在的威胁提前采取措施加以防范。\n审计通常是很费时间和空间的，所以数据库管理系统往往都将审计设置为可选特征，允许数据库管理员根据具体应用对安全性的要求灵活地打开或关闭审计功能。审计功能主要用于安全性要求较高的部门。\n可审计事件有服务器事件、系统权限、语句事件及模式对象事件，还包括用户鉴别、自主访问控制和强制访问控事件。换句话说，它能对普通和特权用户行为、各种表操作、身份鉴别、自主和强制访问控制等操作进行审计。它既能审计成功操作，也能审计失败操作。\n审计事件 审计事件一般有多个类别，例如，\n◦服务器事件：审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数 据库服务器配置文件的重新加载。\n◦系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通 过系统权限获得的。\n◦语句事件：对SQL语句，如DDL、DML、DQL(Data Query Language,数据查询 语言)及DCL语句的审计。\n◦模式对象事件：对特定模式对象上进行的SELECT或DML操作的审计。模式对象 包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分 区表等。\n审计功能 审计功能主要包括以下几方面内容：\n◦基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。\n◦提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。\n◦提供审计分析和报表功能。\n◦审计日志管理功能，包括为防止审计员误删审计记录，审计日志必须先转储后删除；对转储的审计记录文件提供完整性和保密性保护；只允许审计员查阅和转储审计记录，不允许任何用户新增和修改审计记录；等等。\n◦系统提供查询审计设置及审计记录信息的专门视图。对于系统权限级别、语句级别 及模式对象级别的审计记录也可通过相关的系统表直接查看。\nAUDIT语句和NOAUDIT语句 AUDIT语句用来设置审计功能，NOAUDIT语句则取消审计功能。\n审计一般可以分为用户级审计和系统级审计。用户级审计是任何用户可设置的审计， 主要是用户针对自己创建的数据库表或视图进行审计，记录所有用户对这些表或视图的一切成功和(或)不成功的访问要求以及各种类型的SQL操作。\n系统级审计只能由数据库管理员设置，用以监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作。\n例15：对修改SC表结构或修改SC表数据的操作进行审计。\n1 2 AUDIT ALTER, UPDATE ON SC; 例16：取消对SC表的一切审计。\n1 2 NOAUDIT ALTER, UPDATE ON SC; 审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开（即把系统参数audit_trail设为true），才可以在系统表SYS_AUDITTRAIL中查看到审计信息。\n数据库安全审计系统提供了一种事后检查的安全机制。安全审计机制将特定用户或者 特定对象相关的操作记录到系统审计日志中，作为后续对操作的查询分析和追踪的依据。通过审计机制，可以约束用户可能的恶意操作。\n数据加密 对于高度敏感性数据，例如财务数据、军事数据、国家机密数据等，除前面介绍的安全性措施外，还可以采用数据加密技术。数据加密是防止数据库数据在存储和传输中失密的有效手段。加密的基本思想是根据一定的算法将原始数据——明文(plain text)变换为不可直接识别的格式——密文(cipher text)，从而使得不知道解密算法的人无法获知数据的内容。\n数据加密主要包括存储加密和传输加密。\n存储加密 对于存储加密，一般提供透明和非透明两种存储加密方式。透明存储加密是内核级加密保护方式，对用户完全透明；非透明存储加密则是通过多个加密函数实现的。\n透明存储加密是数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密。由于数据加密对用户透明，数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可。当对加密数据进行增、删、改、查询操作时，数据库管理系统将自动对数据进行加、解密工作。基于数据库内核的数据存储加密、解密方法性能较好，安全完备性较高。\n传输加密 在客户/服务器结构中，数据库用户与服务器之间若采用明文方式传输数据，容易被网 络恶意用户截获或篡改，存在安全隐患。因此，为保证二者之间的安全数据交换，数据库管理系统提供了传输加密功能。\n常用的传输加密方式如链路加密和端到端加密。其中，链路加密对传输数据在链路层进行加密，它的传输信息由报头和报文两部分组成，前者是路由选择信息，而后者是传送的数据信息。这种方式对报文和报头均加密。相对地，端到端加密对传输数据在发送端加密，接收端解密。它只加密报文，不加密报头。与链路加密相比，它只在发送端和接收端需要密码设备，而中间节点不需要密码设备，因此它所需密码设备数量相对较少。但这种方式不加密报头，从而容易被非法监听者发现并从中获取敏感信息。\n图6是一种基于基于安全套接层协议(Security Socket Layer, SSL)的数据库管理系统可信传输方案。它采用的是一种端到端的传输加密方式。在这个方案中，通信双方协商建立可信连接，一次会话采用一个密钥，传输数据在发送端加密，接收端解密，有效降低了重放攻击和恶意篡改的风险。此外，出于易用性考虑，这个方案的通信加密还对应用程序透明。它的实现思路包含以下三点。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 可 信 通 信 模 块 第一步 ： 创建可信链接 第二步 ： 确认通信双方断端点的可靠性 第三步 ： 协商加密算法和密钥 第四步 ： 可信传输数据 第五步 ： 关闭可信链接 可 信 通 信 模 块 用户 数据库服务器 图6\u0026emsp;数据库管理系统可信传输示意图\n(1)确认通信双方端点的可靠性\n数据库管理系统采用基于数字证书的服务器和客户端认证方式实现通信双方的可靠性确认。用户和服务器各自持有由知名数字证书认证(Certificate Authority, CA)中心或企业内建CA颁发的数字证书，双方在进行通信时均首先向对方提供己方证书，然后使用本地的CA信任列表和证书撤销列表(Certificate Revocation List, CRL)对接收到的对方证书进行验证，以确保证书的合法性和有效性，进而保证对方确系通信的目的端。\n(2)协商加密算法和密钥\n确认双方端点的可靠性后，通信双方协商本次会话的加密算法与密钥。在这个过程中, 通信双方利用公钥基础设施(Public Key Infrastructure, PKI)方式保证了服务器和客户端的协商过程通信的安全可靠。\n(3)可信数据传输\n在加密算法和密钥协商完成后，通信双方开始进行业务数据交换。与普通通信路径不同的是，这些业务数据在被发送之前将被用某一组特定的密钥进行加密和消息摘要计算，以密文形式在网络上传输。当业务数据被接收的时候，需用相同一组特定的密钥进行解密和摘要计算。所谓特定的密钥，是由先前通信双方磋商决定的，为且仅为双方共享，通常称之为会话密钥。第三方即使窃取传输密文，因无会话密钥也无法识别密文信息。一旦第三方对密文进行任何篡改，均将会被真实的接收方通过摘要算法识破。另外，会话密钥的生命周期仅限于本次通信，理论上每次通信所采用的会话密钥将不同，因此避免了使用固定密钥而引起的密钥存储类问题。\n数据库加密使用已有的密码技术和算法对数据库中存储的数据和传输的数据进行保护。加密后数据的安全性能够进一步提高。即使攻击者获取数据源文件，也很难获取原始数据。但是，数据库加密增加了查询处理的复杂性，查询效率会受到影响。加密数据的密钥的管理和数据加密对应用程序的影响也是数据加密过程中需要考虑的问题。\n其他安全性保护 为满足较高安全等级数据库管理系统的安全性保护要求，在自主存取控制和强制存取控制之外，还有推理控制以及数据库应用中隐蔽信道和数据隐私保护等技术。\n推理控制(inference control)‌处理的是强制存取控制未解决的问题。例如，利用列的函数依赖关系，用户能从低安全等级信息推导出其无权访问的高安全等级信息，进而导致信息泄露。\n数据库推理控制机制用来避免用户利用其能够访问的数据推知更高密级的数据，即用户利用其被允许的多次查询的结果，结合相关的领域背景知识以及数据之间的约束，推导出其不能访问的数据。在推理控制方面，常用的方法如基于函数依赖的推理控制和基于敏感关联的推理控制等。例如，某个公司信息系统中假设姓名和职务属于低安全等级（如公开）信息，而工资属于高安全等级（如机密）信息。用户A的安全等级较低，他通过授权可以查询自己的工资、姓名、职务，及其他用户的姓名和职务。由于工资是机密信息，因此用户A不应知道其他用户的工资。但是，若用户B的职务和用户A相同，则利用函数依赖关系职务—＞工资，用户A可通过自己的工资信息（假设3000元），推出B的工资也是3000元，从而导致高安全等级的敏感信息泄露。\n隐蔽信道(covert channa)处理内容也是强制存取控制未解决的问题。下面的例子就是利用未被强制存取控制的SQL执行后反馈的信息进行间接信息传递。\n通常，如果INSERT语句对UNIQUE属性列写入重复值，则系统会报错且操作失败。那么，针对UNIQUE约束列，高安全等级用户(发送者)可先向该列插入(或者不插入)数据，而低安全等级用户(接收者)向该列插入相同数据。\n如果插入失败，则表明发送者已向该列插入数据，此时二者约定发送者传输信息位为0；如果插入成功，则表明发送者未向该列插入数据，此时二者约定发送者传输信息位为1。通过这种方式，高安全等级用户按事先约定方式主动向低安全等级用户传输信息，使得信息流从高安全等级向低安全等级流动，从而导致高安全等级敏感信息泄露。\n随着人们对隐私的重视，数据隐私(data privacy)成为数据库应用中新的数据保护模式。\n所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力。数据隐私范围很广，涉及数据管理中的数据收集、数据存储、数据处理和数据发布等各个阶段。例如，在数据存储阶段应避免非授权的用户访问个人的隐私数据。通常可以使用数据库安全技术实现这一阶段的隐私保护。如使用自主访问控制、强制访问控制和基于角色的访问控制以及数据加密等。在数据处理阶段，需要考虑数据推理带来的隐私数据泄露。非授权用户可能通过分析多次查询的结果，或者基于完整性约束信息，推导出其他用户的隐私数据。在数据发布阶段，应使包含隐私的数据发布结果满足特定的安全性标准。如发布的关系数据表首先不能包含原有表的候选码，同时还要考虑准标识符的影响。\n准标识符是能够唯一确定大部分记录的属性集合。在现有安全性标准中，k-匿名化(k-anonymization)标准要求每个具有相同准标识符的记录组中至少包括k条记录，从而控制攻击者判别隐私数据所属个体的概率。还有1-多样化标准(1-diversity)、t-临近标准(t-closeness)等，从而使攻击者不能从发布数据中推导出额外的隐私数据。数据隐私保护也是当前研究的热点。\n要想万无一失地保证数据库安全，使之免于遭到任何蓄意的破坏几乎是不可能的。但高度的安全措施将使蓄意的攻击者付出高昂的代价，从而迫使攻击者不得不放弃他们的破坏企图。\n小结 随着数据库应用的深入和计算机网络的发展，数据的共享日益加强，数据的安全保密越来越重要。数据库管理系统是管理数据的核心，因而其自身必须具有一整套完整而有效的安全性机制。\n实现数据库系统安全性的技术和方法有多种，数据库管理系统提供的安全措施主要包括用户身份鉴别、自主存取控制和强制存取控制技术、视图技术和审计技术、数据加密存储和加密传输等。本章简要讲解了这些技术。\n\u0026emsp;\u0026emsp;在我的生命里，除了爱情找不到别的意义，于是紧紧抓着它。除了期待我的爱人到来之外，我什么也不等待，也不愿等待。 ― 安德烈·纪德, 《窄门》 ","date":"2024-12-01T15:18:44+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/database_system/database_safety/","title":"数据库系统（四）：数据库安全性"},{"content":" 处理机调度与死锁 在多道程序环境下，内存中存在着多个进程，其数目往往多于处理机数目。这就要求系统能按某种算法，动态地将处理机分配给处于就绪状态的一个进程，使之执行。分配处理机的任务是由处理机调度程序完成的。对于大型系统运行时的性能，如系统吞吐量、资源利用率、作业周转时间或响应的及时性等，在很大程度上都取决于处理机调度性能的好坏。因而，处理机调度便成为OS中至关重要的部分。\n处理机调度的层次和调度算法的目标 在多道程序系统中，调度的实质是一种资源分配，处理机调度是对处理机资源进行分配。处理机调度算法是指根据处理机分配策略所规定的处理机分配算法。在多道批处理系统中，一个作业从提交到获得处理机执行，直至作业运行完毕，可能需要经历多级处理机调度，下面先来了解处理机调度的层次。\n处理机调度的层次 高级调度(High Level Scheduling) 高级调度又称长程调度或作业调度，它的调度对象是作业。其主要功能是根据某种算法，决定将外存上处于后备队列中的哪几个作业调入内存，为它们创建进程、分配必要的资源，并将它们放入就绪队列。高级调度主要用于多道批处理系统中，而在分时和实时系统中不设置高级调度。\n低级调度(Low Level Scheduling) 低级调度又称为进程调度或短程调度，其所调度的对象是进程（或内核级线程）。其主要功能是，根据某种算法，决定就绪队列中的哪个进程应获得处理机，并由分派程序将处理机分配给被选中的进程。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。\n中级调度(Intermediate Scheduling) 中级调度又称为内存调度。引入中级调度的主要目的是，提高内存利用率和系统吞吐量。为此，应把那些暂时不能运行的进程，调至外存等待，此时进程的状态称为就绪驻外存状态（或挂起状态）。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。中级调度实际上就是存储器管理中的对换功能。\n在上述三种调度中，进程调度的运行频率最高，在分时系统中通常仅10〜 \\(100 \\text{ms}\\) 便进行一次进程调度，因此把它称为短程调度。为避免调度本身占用太多的CPU时间，不宜使进程调度算法太复杂。作业调度往往是发生在一批作业已运行完毕并退出系统，又需要重新调入一批作业进入内存时，作业调度的周期较长，大约几分钟一次，因此把它称为长程调度。由于其运行频率较低，故允许作业调度算法花费较多的时间。中级调度的运行频率基本上介于上述两种调度之间，因此把它称为中程调度。\n处理机调度算法的目标 一般而言，在一个操作系统的设计中，应如何选择调度方式和算法，在很大程度上取决于操作系统的类型及其设计目标，例如，在批处理系统、分时系统和实时系统中，通常都采用不同的调度方式和算法。\n处理机调度算法的共同目标 (1)资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算：\n\\[ \\text{CPU的利用率}=\\frac{\\text{CPU有效工作时间}}{\\text{CPU有效工作时间}+\\text{CPU空闲等待时间}} \\tag{1} \\] (2)公平性。公平性是指应使诸进程都获得合理的CPU时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。\n(3)平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。\n(4)策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。\n批处理系统的目标 (1)平均周转时间短。所谓周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔（称为作业周转时间）。它包括四部分时间：作业在外存后备队列上等待（作业）调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，以及进程等待I/O操作完成的时间。其中的后三项在一个作业的整个处理过程中，可能发生多次。\n对每个用户而言，都希望自己作业的周转时间最短。但作为计算机系统的管理者，则总是希望能使平均周转时间最短，这不仅会有效地提高系统资源的利用率，而且还可使大多数用户都感到满意。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为\n\\[ T=\\frac{1}{n}\\left(\\sum_{i=1}^{n}T_i\\right) \\tag{2} \\] 为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间的具体分配状况，往往使用带权周转时间，即作业的周转时间 \\(T\\) 与系统为它提供服务的时间 \\(T_s\\) 之比，即 \\(\\displaystyle W=\\frac{T}{T_s}\\) 。而平均带权周转时间则可表示为：\n\\[ W=\\frac{1}{n}\\sum_{i=1}^{n}\\frac{T_i}{T_s} \\tag{3} \\] (2)系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。\n(3)处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标：而调度方式和算法又对处理机的利用率起着十分重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由上所述可以看出，这些要求之间是存在着一定矛盾的。\n分时系统的目标 (1)响应时间快。响应时间快是选择分时系统中进程调度算法的重要准则。所谓响应时间，是从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。它包括三部分时间：一是请求信息从键盘输入开始，直至将其传送到处理机的时间；二是处理机对请求信息进行处理的时间；三是将所形成的响应信息回送到终端显示器的时间。\n(2)均衡性。用户对响应时间的要求并非完全相同。通常用户对较复杂任务的响应时间允许较长，而对较简单任务的响应时间则要短。所谓均衡性，是指系统响应时间的快慢应与用户所请求服务的复杂性相适应。\n实时系统的目标 (1)截止时间的保证。所谓截止时间，是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。对于严格的实时系统，其调度方式和调度算法必须能保证这一点，否则将可能造成难以预料的后果。对于实时系统而言，调度算法的一个主要目标是保证实时任务对截止时间的要求。对于HRT任务，其调度方式和调度算法必须确保对截止时间的要求，否则将可能造成难以预料的后果；而对于SRT任务，其调度方式和调度算法也应基本上能保证对截止时间的要求。\n(2)可预测性。在实时系统中，可预测性显得非常重要。例如，在多媒体系统中，无论是电影还是电视剧都应是连续播放的，这就提供了请求的可预测性。如果系统中采用了双缓冲，则因为可实现第 \\(i\\) 帧的播放和第 \\(i+1\\) 帧的读取并行处理，进而可提高其实时性。\n作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户 提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。\n批处理系统中的作业 作业和作业步 (1)作业(Job)。作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。\n(2)作业步(Job Step)。通常，在作业运行期间，每个作业都必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果。我们把其中的每一个加工步骤称为一个作业步，各作业步之间存在着相互联系，往往是上一个作业步的输出作为下一个作业步的输入。例如，一个典型的作业可分成：“编译”作业步，“链接装配”作业步和“运行”作业步。\n作业控制块(Job Control Block,JCB) 为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、资源使用情况等。\n每当一个作业进入系统时，便由“作业注册”程序为该作业建立一个作业控制块JCB。再根据作业类型，将它放到相应的作业后备队列中等待调度。调度程序依据一定的调度算法来调度它们，被调度到的作业将被装入内存。在作业运行期间，系统就按照JCB中的信息和作业说明书对作业进行控制。当一个作业执行结束进入完成状态时，系统负责回收已分配给它的资源，撤销该作业控制块。\n作业运行的三个阶段和三种状态 作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。\n(1)收容阶段。操作员把用户提交的作业通过某种输入方式或SPOOLing系统输入到硬盘上，再为该作业建立JCB，并把它放入作业后备队列中。相应地，此时作业的状态为“后备状态”。\n(2)运行阶段。当作业被作业调度选中后，便为它分配必要的资源和建立进程，并将它放入就绪队列。一个作业从第一次进入就绪状态开始，直到它运行结束前，在此期间都处于“运行状态”。\n(3)完成阶段。当作业运行完成、或发生异常情况而提前结束时，作业便进入完成阶段，相应的作业状态为“完成状态”。此时系统中的“终止作业”程序将会回收己分配给该作业的作业控制块和所有资源，并将作业运行结果信息形成输出文件后输出。\n作业调度的主要任务 作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度(Admission Scheduling)。在每次执行作业调度时，都需做出以下两个决定。\n接纳多少个作业 在每一次进行作业调度时，应当从后备队列中选取多少作业调入内存，取决于多道程序度(Degree of Multiprogramming)，即允许多少个作业同时在内存中运行。对系统来说，希望装入较多的作业，有利于提高CPU的利用率和系统的吞吐量。但如果内存中同时运行的作业太多时，进程在运行时因内存不足所发生的中断就会急剧增加。这将会使平均周转时间显著延长，影响到系统的服务质量。因此，多道程序度的确定是根据计算机的系统规模、运行速度、作业大小，以及能否获得较好的系统性能等情况作出适当的抉择的。\n接纳哪些作业 应选择后备队列中的哪些作业调入内存，取决于所采用的调度算法。最简单的是先来先服务调度算法，它是将最早进入外存的作业优先调入内存。较常用的一种算法是短作业优先调度算法，是将外存上所需执行时间最短的作业优先调入内存。另一种较常用的是基于作业优先级的调度算法，该算法是将外存上作业优先级最高的作业优先调入内存。比较好的一种算法是“响应比高者优先”的调度算法。我们将在后面对上述的几种算法作较详细的介绍。\n在批处理系统中，作业进入系统后，总是先驻留在外存的作业后备队列上，因此需要有作业调度，以便将它们分批地装入内存。然而在分时系统中，为了做到及时响应，用户通过键盘输入的命令或数据等都被直接送入内存，因而无需配置上述的作业调度机制，但也需要有某种接纳控制措施来限制进入系统的用户数目。即如果系统尚有能力处理更多的任务，将会接纳授权用户的请求，否则，便拒绝接纳。类似地，在实时系统中也不需要作业调度，而必需具有接纳控制措施。\n先来先服务(FCFS)和短作业优先(SJF)调度算法 先来先服务(first-come first-served,FCFS)调度算法 FCFS是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。\n当在进程调度中采用FCFS算法时，每次调度是从就绪的进程队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后，进程调度程序才将处理机分配给其它进程。\n顺便说明，FCFS算法在单处理机系统中已很少作为主调度算法，但经常把它与其它调度算法相结合使用，形成一种更为有效的调度算法。例如，可以在系统中按进程的优先级设置多个队列，每个优先级一个队列，其中每一个队列的调度都基于FCFS算法。\n短作业优先(short job first,SJF)的调度算法 由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。\nSJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。\nSJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点：\n(1)必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。\n(2)对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。\n(3)在采用FCFS算法时，人—机无法实现交互。\n(4)该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。\n优先级调度算法和高响应比优先调度算法 优先级调度算法(prioilty-scheduling algorithm,PSA) 我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。而在优先级调度算法中，则是基于作业的紧迫程度，由外部赋予作业相应的优先级，调度算法是根据该优先级进行调度的。这样就可以保证紧迫性作业优先运行。优先级调度算法可作为作业调度算法，也可作为进程调度算法。当把该算法用于作业调度时，系统是从后备队列中选择若干个优先级最高的作业装入内存。\n高响应比优先调度算法(Highest Response Ratio Next,HRRN) 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。\n高响应比优先算法是如何实现的呢？如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为：\n\\[ \\text{优先权}=\\frac{\\text{等待时间}+\\text{要求服务时间}}{\\text{要求服务时间}} \\tag{4} \\] 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比 \\(R_p\\) 。据此，优先又可表示为：\n\\[ R_p=\\frac{等待时间+要求服务时间}{要求服务时间}=\\frac{响应时间}{要求服务时间} \\tag{5} \\] 由上式可以看出：①如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业。②当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法。③对于长作业的优先级，可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机。因此该算法实现了较好的折中。当然在利用该算法时，每次要进行调度之前，都需要先做响应比的计算，显然会增加系统开销。\n进程调度 进程调度是OS中必不可少的一种调度。因此在三种类型的OS中，都无一例外地配置了进程调度。此外它也是对系统性能影响最大的一种处理机调度，相应的，有关进程调度的算法也较多。\n进程调度的任务、机制和方式 进程调度的任务 进程调度的任务主要有三：\n(1)保存处理机的现场信息。在进行调度时首先需要保存当前进程的处理机的现场信息，如程序计数器、多个通用寄存器中的内容等。\n(2)按某种算法选取进程。调度程序按某种算法从就绪队列中选取一个进程，将其状态改为运行状态，并准备把处理机分配给它。\n(3)把处理器分配给进程。由分派程序把处理器分配给该进程，此时需要将选中进程的进程控制块内有关处理机现场的信息装入处理器相应的各个寄存器中，把处理器的控制权交予该进程，让它从上次的断点处恢复运行。\n进程调度机制 为了实现进程调度，在进程调度机制中，应具有如下三个基本部分。\n(1)排队器。为了提高进程调度的效率，应事先将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便调度程序能最快地找到它。以后每当有一个进程转变为就绪状态时，排队器便将它插入到相应的就绪队列。\n(2)分派器。分派器依据进程调度程序所选定的进程，将其从就绪队列中取出，然后进行从分派器到新选出进程间的上下文切换，将处理机分配给新选出的进程。\n(3)上下文切换器。在对处理机进行切换时，会发生两对上下文的切换操作：①第一对上下文切换时，OS将保存当前进程的上下文，即把当前进程的处理机寄存器内容保存到该进程的进程控制块内的相应单元，再装入分派程序的上下文，以便分派程序运行；②第二对上下文切换是移出分派程序的上下文，而把新选进程的CPU现场信息装入到处理机的各个相应寄存器中，以便新选进程运行。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 就绪进程 来自其他状态 排队器 就绪队列 分派器 上下文 切换器 进程控制块 C P U 移出运行进程 调度程序 图1\u0026emsp;进程调度机制\n在进行上下文切换时，需要执行大量的load和store等操作指令，以保存寄存器的内容。即使是现代计算机，每一次上下文切换所花费的时间大约可执行上千条指令。为此，现在已有靠硬件实现的方法来减少上下文切换时间。一般采用两组（或多组）寄存器，其中的一组寄存器供处理机在系统态时使用，而另一组寄存器供应用程序使用。在这样条件下的上下文切换，只需改变指针，使其指向当前寄存器组即可。\n进程调度方式 早期所采用的非抢占方式存在着很大的局限性，很难满足交互性作业和实时任务的需求。为此，在进程调度中又引入了抢占方式。我们先了解一下非抢占方式时的情况。\n1. 非抢占方式(Nonpreemptive Mode)\n在采用这种调度方式时，一旦把处理机分配给某进程后，就一直让它运行下去，决不会因为时钟中断或任何其它原因去抢占当前正在运行进程的处理机，直至该进程完成，或发生某事件而被阻塞时，才把处理机分配给其它进程。\n在采用非抢占调度方式时，可能引起进程调度的因素可归结为：①正在执行的进程运行完毕，或因发生某事件而使其无法再继续运行；②正在执行中的进程因提出I/O请求而暂停执行；③在进程通信或同步过程中，执行了某种原语操作，如Block原语。这种调度方式的优点是实现简单，系统开销小，适用于大多数的批处理系统。但它不能用于分时系统和大多数实时系统。\n2. 抢占方式(Preemptive Mode)\n这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。在现代OS中广泛采用抢占方式，这是因为：对于批处理机系统，可以防止一个长进程长时间地占用处理机，以确保处理机能为所有进程提供更为公平的服务。在分时系统中，只有采用抢占方式才有可能实现人—机交互。在实时系统中，抢占方式能满足实时任务的需求。但抢占方式比较复杂，所需付出的系统开销也较大。\n“抢占”不是一种任意性行为，必须遵循一定的原则。主要原则有：\n①优先权原则，指允许优先级高的新到进程抢占当前进程的处理机，即当有新进程到达时，如果它的优先级比正在执行进程的优先级高，则调度程序将剥夺当前进程的运行，将处理机分配给新到的优先权高的进程。\n②短进程优先原则，指允许新到的短进程可以抢占当前长进程的处理机，即当新到达的进程比正在执行的进程（尚须运行的时间）明显短时，将处理机分配给新到的短进程。\n③时间片原则，即各进程按时间片轮转运行时，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度。\n轮转调度算法 在分时系统中，最简单也是较常用的是基于时间片的轮转(round robin,RR)调度算法。该算法采取了非常公平的处理机分配方式，即让就绪队列上的每个进程每次仅运行一个时间片。如果就绪队列上有 \\(n\\) 个进程，则每个进程每次大约都可获得 \\(\\cfrac{1}{n}\\) 的处理机时间。\n轮转法的基本原理 在轮转(RR)法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置每隔一定时间（如 \\(30 \\text{ms}\\) ）便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。\n进程切换时机 在RR调度算法中，应在何时进行进程的切换，可分为两种情况：①若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。②在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。\n时间片大小的确定 在轮转算法中，时间片的大小对系统性能有很大的影响。若选择很小的时间片，将有利于短作业，因为它能在该时间片内完成。但时间片小，意味着会频繁地执行进程调度和进程上下文的切换，这无疑会增加系统的开销。反之，若时间片选择得太长，且为使每个进程都能在一个时间片内完成，RR算法便退化为FCFS算法，无法满足短作业和交互式用户的需求。一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成，从而可以获得很小的响应时间。图2示出了时间片大小对响应时间的影响，其中图2(a)是时间片略大于典型交互的时间，而图2(b)是时间片小于典型交互的时间。表1示出了时间片分别为 \\(q=1\\) 和 \\(q=4\\) 时对平均周转时间的影响。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a )时间片大于交互时间 分配给进程 的时间片 交互结束 响应时间 时间片 时间 ( b )时间片小于交互时间 其他进程运行 分配给进程 的时间片 交互完成 分配给进程 的时间片 进程被抢占 图2\u0026emsp;时间片大小对响应时间的影响\n作业情况 时间片 进程名 A B C D E 平均 到达时间 0 1 2 3 4 服务时间 4 3 4 2 4 RRq=1 完成时间 15 12 16 9 17 周转时间 15 11 14 6 13 11.8 带权周转时间 3.75 3.67 3.5 3 3.33 3.46 RRq=4 完成时间 4 7 11 13 17 周转时间 4 6 9 10 13 8.4 带权周转时间 1 2 2.25 5 3.33 2.5 表1\u0026emsp;q=1和q=4时进程的周转时间\n优先级调度算法 在时间片轮转调度算法中，做了一个隐含的假设，即系统中所有进程的紧迫性是相同的。但实际情况并非如此。为了能满足实际情况的需要，在进程调度算法中引入优先级，而形成优先级调度算法。\n优先级调度算法的类型 优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种。\n(1)非抢占式优先级调度算法。该算法规定，一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成，或者因该进程发生某事件而放弃处理机时，系统方可将处理机重新分配给另一优先级最高的进程。\n(2)抢占式优先级调度算法。把处理机分配给优先级最高的进程，使之执行。但在其执行期间，只要出现了另一个其优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程。因此，在采用这种调度算法时，每当系统中出现一个新的就绪进程 \\(i\\) 时，就将其优先级 \\(P_i\\) 与正在执行的进程 \\(j\\) 的优先级 \\(P_j\\) 进行比较，如果 \\(P_i \\le P_j\\) ，原进程 \\(P_j\\) 便继续执行；但如果是 \\(P_i \u003e P_j\\) ，则立即停止 \\(P_j\\) 的执行，进行进程切换，使 \\(i\\) 进程投入执行。抢占式的优先级调度算法常用于对实时性要求较高的系统中。\n优先级的类型 优先级调度算法的关键在于：应如何确定进程的优先级，以及确定是使用静态优先级还是动态优先级。\n1. 静态优先级\n静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如10〜255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个：\n(1)进程类型。通常系统进程（如接收进程、对换进程）的优先级高于一般用户进程的优先级。\n(2)进程对资源的需求。对资源要求少的进程应赋予较高的优先级。\n(3)用户要求。根据进程的紧迫程度及用户所付费用的多少确定优先级。\n静态优先级法简单易行，系统开销小，但不够精确，可能会出现优先级低的进程长期没有被调度的情况。\n2. 动态优先级\n动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。例如，可以规定在就绪队列中的进程随其等待时间的增长，使其优先级相应提高。若所有的进程都具有相同优先级初值，则最先进入就绪队列的进程会因其优先级变得最高，而优先获得处理机，这相当于FCFS算法。若所有的就绪进程具有各不相同的优先级初值，那么对于优先级初值低的进程，在等待了足够的时间后，也可以获得处理机。当采用抢占式调度方式时，若再规定当前进程的优先级随运行时间的推移而下降，则可防止一个长作业长期地垄断处理机。\n多队列调度算法 如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多级队列调度算法能够在一定程度上弥补这一缺点。\n该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。\n多队列调度算法由于设置多个就绪队列，因此对每个就绪队列就可以实施不同的调度算法，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。\n在多处理机系统中，该算法由于安排了多个就绪队列，因此，很方便为每个处理机设置一个单独的就绪队列。这样，不仅对每个处理机的调度可以实施各自不同的调度策略，而且对于一个含有多个线程的进程而言，可以根据其要求将其所有线程分配在一个就绪队列，全部在一个处理机上运行。再者，对于一组需要相互合作的进程或线程而言，也可以将它们分配到一组处理机所对应的多个就绪队列，使得它们能同时获得处理机并行执行。\n多级反馈队列(multilevel feedback queue)调度算法 前面介绍的各种用于进程调度的算法都有一定的局限性。如果未指明进程长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而下述的多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，还可以较好地满足各种类型进程的需要，因而它是目前公认的一种较好的进程调度算法。\n调度机制 多级反馈队列调度算法的调度机制可描述如下：\n(1)设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。第一个队列的优先级最高，第二个次之，其余队列的优先级逐个降低。该算法为不同队列中的进程所赋予的执行时间片的大小也各不相同，在优先级愈高的队列中，其时间片就愈小。例如第二个队列的时间片要比第一个的时间片长一倍，···，第i+1个队列的时间片要比第i个的时间片长一倍。图3是多级反馈队列算法的示意图。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 就绪队列1 就绪队列2 就绪队列3 就绪队列n 至C P U 至C P U 至C P U 至C P U （ 时间片 ： ） 图3\u0026emsp;多级反馈队列调度算法\n(2)每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，···，依此类推。当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。\n(3)按队列优先级调度。调度程序首先调度最高优先级队列中的诸进程运行，仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1~(i-1)所有队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。\n调度算法的性能 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。\n(1)终端型用户。由于终端型用户提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列规定的时间片内完成，便可使终端型用户感到满意。\n(2)短批处理作业用户。对于这类作业，如果可在第一队列中执行完成，便获得与终端型作业一样的响应时间。对于稍长的短作业，也只需在第二和第三队列各执行一时间片完成，其周转时间仍然较短。\n(3)长批处理作业用户。对于长作业，它将依次在第1,2,···,n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。\n基于公平原则的调度算法 以上介绍的几种调度算法所保证的只是优先运行，如优先级算法是优先级最高的作业优先运行，但并不保证作业占用了多少处理机时间。另外也未考虑到调度的公平性。本小节将介绍两种相对公平的调度算法。\n保证调度算法 保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。一种比较容易实现的性能保证是处理机分配的公平性。如果在系统中有 \\(n\\) 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 \\(\\displaystyle\\frac{1}{n}\\) 。在实施公平调度算法时系统中必须具有这样一些功能：\n(1)跟踪计算每个进程自创建以来已经执行的处理时间。\n(2)计算每个进程应获得的处理机时间，即自创建以来的时间除以 \\(n\\) 。\n(3)计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。\n(4)比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5；而进程B的比率为0.8；进程C的比率为1.2等。\n(5)调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。\n公平分享调度算法 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。假如系统中仅有两个用户，用户1启动了4个进程，用户2只启动1个进程，采用轮转法让每个进程轮流运行一个时间片时间，对进程而言很公平，但用户1和用户2得到的处理机时间分别为80%和20%，显然对用户2而言就有失公平。在该调度算法中，调度的公平性主要是针对 用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例。然而调度又是以进程为基本单位，为此，必须考虑到每一个用户所拥有的进程数目。例如系统中有两个用 户，用户1有4个进程A、B、C、D，用户2只有1个进程E。为保证两个用户能获得相 同的处理机时间，则必须执行如下所示的强制调度序列：\nA E B E C E D E A E B E C E D E ···\n如果希望用户1所获得的处理机时间是用户2的两倍，则必须执行如下所示的强制调度序列：\nA B E C D E A B E C D E A B E C D E ···\n实时调度 在实时系统中，可能存在着两类不同性质的实时任务，即HRT任务和SRT任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。\n实现实时调度的基本条件 提供必要的信息 为了实现实时调度，系统应向调度程序提供有关任务的信息：\n(1)就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。\n(2)开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间，或者完成截止时间。\n(3)处理时间，一个任务从开始执行，直至完成时所需的时间。\n(4)资源要求，任务执行时所需的一组资源。\n(5)优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对”优先级，供调度程序参考。\n系统处理能力强 在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。假定系统中有 \\(m\\) 个周期性的硬实时任务HRT，它们的处理时间可表示为 \\(C_i\\) ，周期时间表示为 \\(P_i\\) ，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：\n\\[ \\sum_{i=1}^{m}\\frac{C_i}{P_i} \\le 1 \\tag{6} \\] 顺便说明一下，上述的限制条件并未考虑到任务切换所花费的时间，因此，当利用上述限制条件时，还应适当地留有余地。\n提高系统处理能力的途径有二：一是采用单处理机系统，但须增强其处理能力，以显著地减少对每一个任务的处理时间；二是采用多处理机系统。假定系统中的处理机数为 \\(N\\) ，则应将上述的限制条件改为：\n\\[ \\sum_{i=1}^{m}\\frac{C_i}{P_i} \\le N \\tag{7} \\] 采用抢占式调度机制 在含有HRT任务的实时系统中，广泛采用抢占机制。这样便可满足HRT任务对截止时间的要求。但这种调度机制比较复杂。对于一些小的实时系统，如果能预知任务的开始截止时间，则对实时任务的调度可采用非抢占调度机制，以简化调度程序和在任务调度时所花费的系统开销。在设计这种调度机制时，应使所有的实时任务都比较小，并在执行完关键性程序和临界区后，能及时地将自己阻塞起来，以便释放出处理机，供调度程序去调度那个开始截止时间即将到达的任务。\n具有快速切换机制 为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有加下两方面的能力：\n(1)对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。\n(2)快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。\n实时调度算法的分类 可以按不同方式对实时调度算法加以分类：①根据实时任务性质，可将实时调度的算法分为硬实时调度算法和软实时调度算法；②按调度方式，则可分为非抢占调度算法和抢占调度算法。\n非抢占式调度算法 (1)非抢占式轮转调度算法。由一台计算机控制若干个相同的（或类似的）对象，为每一个被控对象建立一个实时任务，并将它们排成一个轮转队列。调度程序每次选择队列中的第一个任务投入运行。当该任务完成后，便把它挂在轮转队列的末尾等待，调度程序再选择下一个队首任务运行。这种调度算法可获得数秒至数十秒的响应时间，可用于要求不太严格的实时控制系统中。\n(2)非抢占式优先调度算法。如果在系统中还含有少数具有一定要求的实时任务，则可采用非抢占式优先调度算法，系统为这些任务赋予了较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后，便可去调度执行队首的高优先进程。这种调度算法在做了精心的处理后有可能使其响应时间减少到数秒至数百毫秒，因而可用于有一定要求的实时控制系统中。\n抢占式调度算法 可根据抢占发生时间的不同而进一步分成以下两种调度算法：\n(1)基于时钟中断的抢占式优先级调度算法。在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。该算法能获得较好的响应效果，其调度延迟可降为几十至几毫秒，可用于大多数的实时系统中。\n(2)立即抢占(Immediate Preemption)的优先级调度算法。在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区，便能立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。这种算法能获得非常快的响应，可把调度延迟降低到几毫秒至100微秒，甚至更低。图4中的(a)、(b)、(c)、(d)分别示出了四种情况的调度时间。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 进程1 进程2 进程n ··· 实时进程 实时进程请求调度 调度实时进程运行 调度时间 （a ） 非抢占轮转调度 当前进程 实时进程 实时进程请求调度 时钟中断到来时 调度时间 （c ） 基于时钟中断抢占的优先权抢占调度 当前进程 实时进程 实时进程请求调度 当前进程运行完成 调度时间 当前进程 实时进程 实时进程请求调度 实时进程抢占当前 进 程 ， 并立即执行 调度时间 （b ） 非抢占优先权调度 ( d )立即抢占的优先权调度 图4\u0026emsp;实时进程调度\n最早截止时间优先EDF(Earliest Deadline First)算法 该算法是根据任务的截止时间确定任务的优先级，任务的截止时间愈早，其优先级愈高，具有最早截止时间的任务排在队列的队首。调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机。最早截止时间优先算法既可用于抢占式调度方式中，也可用于非抢占式调度方式中。\n非抢占式调度方式用于非周期实时任务 图5示出了将该算法用于非抢占调度方式之例。该例中具有四个非周期任务，它们先后到达。系统先调度任务1执行，在任务1执行期间，任务2、3又先后到达。由于任务3的开始截止时间早于任务2的，故系统在任务1后将先调度任务3执行。在此期间又到达作业4,其开始截止时间仍是早于任务2的，故在任务3执行完后，系统又先调度任务4执行，最后才调度任务2执行。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 1 3 4 2 1 2 3 4 1 3 4 2 开始截止时间 任务执行 任务到达 t 图5\u0026emsp;EDF算法用于非抢占调度方式\n抢占式调度方式用于周期实时任务 图6示出了将该算法用于抢占调度方式之例。在该例中有两个周期任务，任务A和任务B的周期时间分别为 \\(20 \\text{ms}\\) 和 \\(50 \\text{ms}\\) ，每个周期的处理时间分别为 \\(10 \\text{ms}\\) 和 \\(25 \\text{ms}\\) 。\n图6示出了将最早截止时间（最后期限）优先算法用于抢占调度的示意图。图中的第一行示出了两个任务的到达时间、截止时间和执行时间图。其中任务A的到达时间为 \\(0\\) 、 \\(20 \\text{ms}\\) 、 \\(40 \\text{ms}\\) ···，任务A的最后期限为 \\(20 \\text{ms}\\) 、 \\(40 \\text{ms}\\) 、 \\(60 \\text{ms}\\) ···，任务B的到达时间为 \\(0\\) 、 \\(50 \\text{ms}\\) 、 \\(100 \\text{ms}\\) ···，任务B的最后期限为 \\(50 \\text{ms}\\) 、 \\(100 \\text{ms}\\) ···。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 时间/ms 截止时间 截止时间 截止时间 截止时间 截止时间 截止时间 截止时间 到达时间、执行时间和 最后截止时间 固定优先级调度 固定优先级调度 （错过） （错过） （错过） 使用完成截止时间最早和 最后截止时间调度 图6\u0026emsp;最早截止时间优先算法用于抢占调度方式之例\n为了说明通常的优先级调度不能适用于实时系统，该图特增加了第二和第三行。在第二行中，假定任务A具有较高的优先级，所以在t= \\(0 \\text{ms}\\) 时，先调度 \\(A_1\\) 执行，在 \\(A_`\\) 完成后(t= \\(10 \\text{ms}\\) )才调度 \\(B_1\\) 执行。在t= \\(20 \\text{ms}\\) 时，又重新调度 \\(A_2\\) 执行，在t= \\(30 \\text{ms}\\) 时， \\(A_2\\) 完成，又调度 \\(B_1\\) 执行。在t= \\(40 \\text{ms}\\) 时，又调度 \\(A_3\\) 执行，在t= \\(50 \\text{ms}\\) 时，虽然 \\(A_3\\) 已完成，但 \\(B_1\\) 已错过了它的最后期限。这说明利用通常的优先级调度已经失败。第三行与第二行类似，只是假定任务B具有较高的优先级。\n第四行是采用最早截止时间优先算法的时间图。在 \\(t=0\\) 时， \\(A_1\\) 和 \\(B_1\\) 同时到达，由于 \\(A_1\\) 的截止时间比 \\(B_1\\) 早，故调度 \\(A_1\\) 执行。在 \\(t=10\\) 时， \\(A_1\\) 完成又调度 \\(B_1\\) 执行。在 \\(t=20\\) 时， \\(A_2\\) 到达，由于 \\(A_2\\) 的截止时间比 \\(B_2\\) 早， \\(B_1\\) 被中断而调度 \\(A_2\\) 执行。在 \\(t=30\\) 时， \\(A_2\\) 完成，又重新调度 \\(B_1\\) 执行。在 \\(t=40\\) 时， \\(A_3\\) 又到达，但 \\(B_1\\) 的截止时间要比 \\(A_3\\) 早，仍应让 \\(B_1\\) 继续执行直到完成( \\(t=45\\) )，然后再调度 \\(A_3\\) 执行。在 \\(t=55\\) 时， \\(A_3\\) 完成又调度 \\(B_2\\) 执行。在该例中，利用最早截止时间优先算法可以满足系统的要求。\n最低松弛度优先LLF(Least Laxity First)算法 该算法在确定任务的优先级时，根据的是任务的紧急(或松弛)程度。任务紧急程度愈高，赋予该任务的优先级就愈高，以使之优先执行。例如，一个任务在 \\(200 \\text{ms}\\) 时必须完成，而它本身所需的运行时间是 \\(100 \\text{ms}\\) ,因此调度程序必须在 \\(100 \\text{ms}\\) 之前调度执行，该任务的紧急程度(松弛程度)为 \\(100 \\text{ms}\\) 。又如另一任务在 \\(400 \\text{ms}\\) 时必须完成，它本身需要运行 \\(150 \\text{ms}\\) ,则其松弛程度为 \\(250 \\text{ms}\\) 。在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在最前面，调度程序选择队列中的队首任务执行。\n该算法主要用于可抢占调度方式中。假如在一个实时系统中有两个周期性实时任务A和B,任务A要求每 \\(20 \\text{ms}\\) 执行一次，执行时间为 \\(10 \\text{ms}\\) ，任务B要求每 \\(50 \\text{ms}\\) 执行一次，执行时间为 \\(25 \\text{ms}\\) 。由此可知，任务A和B每次必须完成的时间分别为： \\(A_1\\) 、 \\(A_2\\) 、 \\(A_3\\) 、···和 \\(B_1\\) 、 \\(B_2\\) 、 \\(B_3\\) 、···，见图7。为保证不遗漏任何一次截止时间，应采用最低松弛度优先的抢占调度策略。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图7\u0026emsp;A和B任务每次必须完成的时间\n在刚开始时( \\(t_1=0\\) )， \\(A_1\\) 必须在 \\(20 \\text{ms}\\) 时完成，而它本身运行又需 \\(10 \\text{ms}\\) ，可算出A1的松弛度为 \\(10 \\text{ms}\\) 。 \\(B_1\\) 必须在 \\(50 \\text{ms}\\) 时完成，而它本身运行就需 \\(25 \\text{ms}\\) ，可算出 \\(B_1\\) 的松弛度为为 \\(25 \\text{ms}\\) ，故调度程序应先调度 \\(A_1\\) 执行。在 \\(t_2=10 \\text{ms}\\) 时， \\(A_2\\) 的松弛度可按下式算出：\n\\[ \\begin{aligned} A2的松弛度=\u0026必须完成时间-其本身的运行时间-当前时间\\\\ =\u002640 \\text{ms} - 10 \\text{ms} - 10 \\text{ms} = 20 \\text{ms} \\end{aligned} \\tag{8} \\] 类似地，可算出 \\(B_1\\) 的松弛度为 \\(15 \\text{ms}\\) ,故调度程序应选择 \\(B_1\\) 运行。在 \\(t_3 = 30 \\text{ms}\\) 时， \\(A_2\\) 的松弛度已减为 \\(0\\) （即 \\(40-10-30\\) ），而 \\(B_1\\) 的松弛度为 \\(15 \\text{ms}\\) （即 \\(50-5-30\\) ），于是调度程序应抢占 \\(B_1\\) 的处理机而调度 \\(A_2\\) 运行。在 \\(Q = 40 \\text{ms}\\) 时， \\(A_3\\) 的松弛度为 \\(10 \\text{ms}\\) （即 \\(60-10-40\\) ），而 \\(B_1\\) 的松弛度仅为 \\(5 \\text{ms}\\) （即 \\(50-5-40\\) ），故又应重新调度为执行。在\\(t_5 = 45 \\text{ms}\\) 时， \\(B_1\\) 执行完成，而此时 \\(A_3\\) 的松弛度已减为 \\(5 \\text{ms}\\) （即 \\(60-10-45\\) ），而 \\(B_2\\) 的松弛度为 \\(30 \\text{ms}\\) （即 \\(100-25-45\\) ），于是又应调度 \\(A_3\\) 执行。在\\(t_6 = 55 \\text{ms}\\) 时，任务A尚未进入第4周期，而任务B已进入第2周期，故再调度 \\(B_2\\) 执行。在 \\(t_7 = 70 \\text{ms}\\) 时， \\(A_4\\) 的松弛度已减至 \\(0 \\text{ms}\\) （即 \\(80-10-70\\) ），而 \\(B_2\\) 的松弛度为 \\(20 \\text{ms}\\) （即 \\(100-10-70\\) ），故此时调度程序又应抢占 \\(B_2\\) 的处理机而调度 \\(A_4\\) 执行。图8示出了具有两个周期性实时任务的调度情况。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图8\u0026emsp;利用LLF算法进行调度的情况\n优先级倒置(priority inversion problem) 优先级倒置的形成 当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程（或线程）被低优先级进程（或线程）延迟或阻塞。我们通过一个例子来说明该问题。假如有三个完全独立的进程 \\(P_1\\) 、 \\(P_2\\) 和 \\(P_3\\) ， \\(P_1\\) 的优先级最高， \\(P_2\\) 次之， \\(P_3\\) 最低。 \\(P_1\\) 和 \\(P_3\\) 通过共享的一个临界资源进行交互。下面是一段代码：\n\\(P_1\\) ：... P(mutex); CS-1; V(mutex); ...\n\\(P_2\\) ：... program2 ...\n\\(P_3\\) ：... P(mutex); CS-3; V(mutex); ...\n假如 \\(P_3\\) 最先执行，在执行了P(mutex)操作后，进入到临界区CS-3。在时刻 \\(a\\) ， \\(P_2\\) 就绪，因为它比 \\(P_3\\) 的优先级高， \\(P_2\\) 抢占了 \\(P_3\\) 的处理机而运行，如图3-10所示。在时刻 \\(b\\) ， \\(P_1\\) 就绪，因为它又比 \\(P_2\\) 的优先级高， \\(P_1\\) 抢占了 \\(P_2\\) 的处理机而运行。在时刻 \\(c\\) ， \\(P_1\\) 执行P(mutex)操作，试图进入临界区CS-1，但因为相应的临界资源已被 \\(P_3\\) 占用，故 \\(P_1\\) 将被阻塞。由 \\(P_2\\) 继续运行，直到时刻 \\(d\\) 运行结束。然后由 \\(P_3\\) 接着运行，到时刻 \\(e\\) 时 \\(P_3\\) 退出临界区，并唤醒 \\(P_1\\) 。因为它比 \\(P_3\\) 的优先级高，故它抢占了 \\(P_3\\) 的处理机而运行。\n根据优先级原则，高优先级进程应当能优先执行，但在此例中， \\(P_1\\) 和 \\(P_3\\) 共享着“临界资源”，而出现了不合常理的现象，高优先级进程 \\(P_1\\) 因 \\(P_3\\) 进程被阻塞了，又因为 \\(P_2\\) 进程的存在而延长了 \\(P_1\\) 被阻塞的时间，而且被延长的时间是不可预知和无法限定的。由此所产生的“优先级倒置”的现象是非常有害的，它不应出现在实时系统中。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 抢占 抢占 阻塞在 P ( mute x ) 结束 抢占 进入 CS-1 ··· 图9\u0026emsp;优先级倒置示意图\n优先级倒置的解决办法 一种简单的解决方法是规定：假如进程 \\(P_3\\) 在进入临界区后 \\(P_3\\) 所占用的处理机就不允许被抢占。由图9可以看出， \\(P_2\\) 即使优先级高于 \\(P_3\\) 也不能执行。于是 \\(P_3\\) 就有可能会较快地退出临界区，不会出现上述情况。如果系统中的临界区都较短且不多，该方法是可行的。反之，如果 \\(P_3\\) 临界区非常长，则高优先级进程 \\(P_1\\) 仍会等待很长的时间，其效果是无法令人满意的。\n一个比较实用的方法是建立在动态优先级继承基础上的。该方法规定，当高优先级进程 \\(P_1\\) 要进入临界区，去使用临界资源 \\(R\\) ，如果已有一个低优先级进程 \\(P_3\\) 正在使用该资源，此时一方面 \\(P_1\\) 被阻塞，另一方面由 \\(P_3\\) 继承 \\(P_1\\) 的优先级，并一直保持到 \\(P_3\\) 退出临界区。这样做的目的在于不让比 \\(P_3\\) 优先级稍高，但比 \\(P_1\\) 优先级低的进程如 \\(P_2\\) 进程插进来，导致延缓 \\(P_3\\) 退出临界区。图10示出了采用动态优先级继承方法后， \\(P_1\\) 、 \\(P_2\\) 、 \\(P_3\\) 三个进程的运行情况。由图可以看出，在时刻 \\(c\\) ， \\(P_1\\) 被阻塞，但由于 \\(P_3\\) 已继承了 \\(P_1\\) 的优先级，它比 \\(P_2\\) 优先级高，这样就避免了 \\(P_2\\) 的插入，使 \\(P_1\\) 在时刻 \\(d\\) 进入临界区。该方法已在一些操作系统中得到应用，而在实时操作系统中是必须的。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 阻塞在 P ( mute x ) 进入 CS-1 ··· 继承 结束 图10\u0026emsp;采用了动态优先级继承方法的运行情况\n死锁概述 在第二章中，我们已经涉及到死锁的概念。例如，系统中只有一台扫描仪 \\(R_1\\) 和一台刻录机 \\(R_2\\) 。有两个进程 \\(P_1\\) 和 \\(P_2\\) ，它们都准备将扫描的文挡刻录到CD光盘上，进程 \\(P_1\\) 先请求扫描仪 \\(R_1\\) 并获得成功，进程 \\(P_2\\) 先请求CD刻录机 \\(R_2\\) 也获得成功。后来 \\(P_1\\) 又请求CD刻录机，因它已被分配给了 \\(P_2\\) 而阻塞。 \\(P_2\\) 又请求扫描仪，也因被分配给了 \\(P_1\\) 而阻塞，此时两个进程都被阻塞，双方都希望对方能释放出自己所需要的资源，但它们谁都因不能获得自己所需的资源去继续运行，从而无法释放出自己占有的资源，并且一直处于这样的僵持状态而形成死锁。又如，在哲学家进餐问题中，如果每一个哲学家因饥饿都拿起了他们左边的筷子，当每一个哲学家又试图去拿起他们右边的筷子时，将会因无筷子可拿而无限期地等待，从而产生死锁问题。在本篇的后半部分，我们将对死锁发生的原因、如何预防和避免死锁等问题作较详细的介绍。\n资源问题 在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印机、数据文件、队列、信号量等。\n可重用性资源和消耗性资源 1. 可重用性资源\n可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：\n(1)每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。\n(2)进程在使用可重用性资源时，须按照这样的顺序：①请求资源。如果请求资源失败，请求进程将会被阻塞或循环等待。②使用资源。进程对资源进行操作，如用打印机进行打印；③释放资源。当进程使用完后自己释放资源。\n(3)系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能 创建也不能删除它。\n对资源的请求和释放通常都是利用系统调用来实现的，例如对于设备，一般用request/release；对于文件，可用open/close。对于需要互斥访问的资源，进程可以用信号量的wait/signal操作来完成。进程在每次提出资源请求后，系统在执行时都需要做一系列的工作。计算机系统中大多数资源都属于可重用性资源。\n2. 可消耗性资源\n可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的，它具有如下性质：①每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0。②进程在运行过程中，可以不断地创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目。③进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。可消耗性资源通常是由生产者进程创建，由消费者进程消耗。最典型的可消耗性资源就是用于进程间通信的消息等。\n可抢占性资源和不可抢占性资源 1. 可抢占性资源\n可把系统中的资源分成两类，一类是可抢占性资源，是指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占。例如优先级高的进程可以抢占优先级低的进程的处理机。又如可把一个进程从一个存储区转移到另一个存储区，在内存紧张时，还可将一个进程从内存调出到外存上，即抢占该进程在内存的空间。可见，CPU和主存均属于可抢占性资源。对于这类资源是不会引起死锁的。\n2. 不可抢占性资源\n另一类资源是不可抢占性资源，即一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。例如，当一个进程已开始刻录光盘时，如果突然将刻录机分配给另一个进程，其结果必然会损坏正在刻录的光盘，因此只能等刻好光盘后由进程自己释放刻录机。另外磁带机、打印机等也都属于不可抢占性资源。\n计算机系统中的死锁 死锁的起因，通常是源于多个进程对资源的争夺，不仅对不可抢占资源进行争夺时会引起死锁，而且对可消耗资源进行争夺时，也会引起死锁。\n竞争不可抢占性资源引起死锁 通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。例如，系统中有两个进程 \\(P_1\\) 和 \\(P_2\\) ，它们都准备写两个文件 \\(F_1\\) 和 \\(F_2\\) ，而这两者都属于可重用和不可抢占性资源。进程 \\(P_1\\) 先打开 \\(F_1\\) ，然后再打开文件 \\(F_2\\) ；进程 \\(P_2\\) 先打开文件 \\(F_2\\) ，后打开 \\(F_1\\) ，下面示出了这段代码。\n\\(P_1\\) ：···Open(f1,w); Open(f2,w);···\n\\(P_2\\) ：···Open(f2.w); Open(f1,w);···\n两个进程 \\(P_1\\) 和 \\(P_2\\) 在并发执行时，如果 \\(P_1\\) 先打开 \\(F_1\\) 和 \\(F_2\\) ，然后 \\(P_2\\) 才去打开 \\(F_1\\) （或 \\(F_2\\) ）,由于文件 \\(F_1\\) （ \\(F_2\\) ）已被 \\(P_1\\) 打开，故 \\(P_2\\) 会被阻塞。当 \\(P_1\\) 写完文件 \\(F_1\\) （或 \\(F_2\\) ）而关闭 \\(F_1\\) （ \\(F_2\\) ）时， \\(P_2\\) 会由阻塞状态转为就绪状态，被调度执行后重新打开文件 \\(F_1\\) （或 \\(F_2\\) ）。在这种情况下， \\(P_1\\) 和 \\(P_2\\) 都能正常运行下去。若 \\(P_2\\) 先打开 \\(F_1\\) 和 \\(F_2\\) ，然后 \\(P_1\\) 才去打开 \\(F_1\\) （或 \\(F_2\\) ）， \\(P_1\\) 和 \\(P_2\\) 同样也可以正常运行下去。\n但如果在 \\(P_1\\) 打开 \\(F_1\\) 的同时， \\(P_2\\) 去打开 \\(F_2\\) ，每个进程都占有一个打开的文件，此时就可能出现问题。因为当 \\(P_1\\) 试图去打开 \\(F_2\\) ，而 \\(P_2\\) 试图去打开 \\(F_1\\) 时，这两个进程都会因文件 已被打开而阻塞，它们希望对方关闭自己所需要的文件，但谁也无法运行，因此这两个进程将会无限期地等待下去，而形成死锁。\n我们可将上面的问题利用资源分配图进行描述，用方块代表可重用的资源（文件），用圆圈代表进程，见图11所示。当箭头从进程指向文件时，表示进程请求资源（打开文件）；当箭头从资源指向进程时，表示该资源已被分配给该进程（已被进程打开）。从中可以看出，这时在 \\(P_1\\) 、 \\(P_2\\) 及 \\(F_1\\) 和 \\(F_2\\) 之间，已经形成了一个环路，说明已进入死锁状态。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图11\u0026emsp;共享文件时的死锁情况\n竞争可消耗资源引起死锁 现在进一步介绍竞争可消耗资源所引起的死锁。图12示出了在三个进程之间，在利用消息通信机制进行通信时所形成的死锁情况。图中， \\(m_1\\) 、 \\(m_2\\) 和 \\(m_3\\) 是可消耗资源。进程 \\(P_1\\) 一方面产生消息 \\(m_1\\) ，利用send(p2,m1)原语将它发送给 \\(P_2\\) ；另一方面，它又要求从 \\(P_3\\) 接收消息。而进程 \\(P_2\\) 一方面产生消息 \\(m_2\\) ，利用send(p3,m2)原语将它发送给 \\(P_3\\) ；另一方面，它又需要接收进程 \\(P_1\\) 所产生的消息 \\(m_1\\) 。类似地，进程 \\(P_3\\) 也产生消息 \\(m_3\\) ，利用send(P1,m3)原语将它发送给 \\(P_1\\) ，而它又要求从进程 \\(P_2\\) 接收其所产生的消息 \\(m_2\\) 。如果三个进程间的消息通信，则按下述顺序进行：\n\\(P_1\\) ：···send(p2,m1);receive(p3,m3);···\n\\(P_2\\) ：···send(p3,m2);receive(p1,m1);···\n\\(P_3\\) ：···send(p1,m3);receive(p2,m2);···\n这三个进程都可以先将消息发送给下一个进程，相应地它们也都能够接收到从上一个进程发来的消息，因此三个进程可以顺利地运行下去，而不会发生死锁。但若改成三个进程都先执行receive操作，后执行send操作，即按下述的运行顺序：\n\\(P_1\\) ：···receive(p3,m3);send(p2,m1);···\n\\(P_2\\) ：···receive(p1,m1);send(p3,m2);···\n\\(P_3\\) ：···receive(p2,m2);send(p1,m3);···\n则这三个进程就会永远阻塞在它们的receive操作上，等待一条永远不会发出的消息，于是发生了死锁。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 产生 接收 图12\u0026emsp;进程之间通信时的死锁\n进程推进顺序不当引起死锁 除了系统中多个进程对资源的竞争会引发死锁外，进程在运行过程中，对资源进行申请和释放的顺序是否合法，也是在系统中是否会产生死锁的一个重要因素。例如，系统中只有一台打印机 \\(R_1\\) 和一台磁带机 \\(R_2\\) ，可供进程 \\(P_1\\) 和 \\(P_2\\) 共享，由于进程在运行中具有异步性特征，这就可能使 \\(P_1\\) 和 \\(P_2\\) 两个进程按下述两种顺序向前推进。\n1. 进程推进顺序合法\n在进程 \\(P_1\\) 和 \\(P_2\\) 并发执行时，如果按图13中的曲线①所示的顺序推进:：P1:Request(R1)→P1:Request(R2)→P1:Release(R2)→P1:Release(R2)→P2:Request(R2)→P2:Request(R1)→P2:Release(R2)→P2:Release(R1)，两个进程可顺利完成。类似地，若按图中曲线②和③所示的顺序推进，两进程也可以顺利完成。我们称这种不会引起进程死锁的推进顺序是合法的。\n2. 进程推进顺序非法\n若并发进程 \\(P_1\\) 和 \\(P_2\\) 按图13中曲线④所示的顺序推进，它们将进入不安全区 \\(D\\) 内。此时 \\(P_1\\) 保持了资源 \\(R_1\\) ， \\(P_2\\) 保持了资源 \\(R_2\\) ，系统处于不安全状态。此刻，如果两个进程继续向前推进，就可能发生死锁。例如，当 \\(P_1\\) 运行到P1:Request(R2)时，将因 \\(R_2\\) 已被 \\(P_2\\) 占用而阻塞：当 \\(P_2\\) 运行到P2:Request(R1)时，也将因 \\(R_1\\) 已被 \\(P_1\\) 占用而阻塞，于是发生了进程死锁，这样的进程推进顺序就是非法的。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e P1 R eq(R1) P1 R eq(R2) P1 Re l(R1) P1 Re l(R2) P2 R eq(R2) P2 R eq(R1) P2 Re l(R2) P2 Re l(R1) ① ② ③ ④ 图13\u0026emsp;进程推进顺序对死锁的影响\n死锁的定义、必要条件和处理方法 死锁的定义 在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。或者说每个进程所等待的事件是该组中其它进程释放所占有的资源。但由于所有这些进程己都无法运行，因此它们谁也不能释放资源，致使没有任何一个进程可被唤醒。这样这组进程只能无限期地等待下去。由此可以给死锁做出如下的定义：\n如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的(Deadlock)。\n产生死锁的必要条件 虽然进程在运行过程中可能会发生死锁，但产生进程死锁是必须具备一定条件的。综上所述不难看出，产生死锁必须同时具备下面四个必要条件，只要其中任一个条件不成立, 死锁就不会发生：\n(1)互斥条件。进程对所分配到的资源进行排它性使用，即在一段时间内，某资源只能被一个进程占用。如果此时还有其它进程请求该资源，则请求进程只能等待，直至占有该资源的进程用毕释放。\n(2)请求和保持条件。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n(3)不可抢占条件。进程已获得的资源在未使用完之前不能被抢占，只能在进程使用完时由自己释放。\n(4)循环等待条件。在发生死锁时，必然存在一个进程一资源的循环链，即进程集合 \\(\\set{P_0,P_1,P_2,\\cdots,P_n}\\) 中的 \\(P_0\\) 正在等待一个 \\(P_1\\) 占用的资源， \\(P_1\\) 正在等待 \\(P_2\\) 占用的资源，···， \\(P_n\\) 正在等待已被 \\(P_0\\) 占用的资源。\n处理死锁的方法 目前处理死锁的方法可归结为四种：\n(1)预防死锁。这是一种较简单和直观的事先预防方法。该方法是通过设置某些限制条件，去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁。预防死锁是一种较 易实现的方法，已被广泛使用。\n(2)避免死锁。同样是属于事先预防策略，但它并不是事先采取各种限制措施，去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免发生死锁。\n(3)检测死锁。这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。\n(4)解除死锁。当检测到系统中已发生死锁时，就采取相应措施，将进程从死锁状态中解脱出来。常用的方法是撤消一些进程，回收它们的资源，将它们分配给己处于阻塞状态的进程，使其能继续运行。\n上述的四种方法，从(1)到(4)对死锁的防范程度逐渐减弱，但对应的是资源利用率的提高，以及进程因资源因素而阻塞的频度下降（即并发程度提高）。\n预防死锁 预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁。由于互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证，因此主要是破坏产生死锁的后三个条件。\n破坏“请求和保持”条件 为了能破坏“请求和保持”条件，系统必须保证做到：当一个进程在请求资源时，它不能持有不可抢占资源。该保证可通过如下两个不同的协议实现：\n第一种协议 该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统在分配资源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不分配给该进程，而让该进程等待。由于该进程在等待期间未占有任何资源，于是破坏了“保持”条件，从而可以预防死锁的发生。\n第一种协议的优点是简单、易行且安全。但缺点也极其明显：\n(1)资源被严重浪费，严重地恶化了资源的利用率。进程在开始运行时就一次性地占用了整个运行过程所需的全部资源，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。\n(2)使进程经常会发生饥饿现象。因为仅当进程在获得了其所需的全部资源后才能开始运行，这样就可能由于个别资源长期被其它进程占用，而致使等待该资源的进程迟迟不能开始运行，而个别资源有可能仅在进程运行到最后才需要，如打印机往往就是如此。\n第二种协议 该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。我们可以通过一个具体例子来说明，第二种协议比第一种协议要好。例如有一个进程，它所要完成的任务是，先将数据从磁带上复制到磁盘文件上，然后对磁盘文件进行排序，最后把结果打印出来。在采用第一种协议时，进程必须在开始时就请求磁带机、磁盘文件和打印机。然而打印机仅在最后才会用到，既影响到其利用率，还会影响到其它进程的运行。此外，又如磁带机和磁盘文件虽然空闲，但因打印机已分配给其它进程，因而进程还需要等待。\n在采用第二种协议时，进程在开始时只需请求磁带机、磁盘文件，然后就可运行。等到全部磁带上的数据已复制到磁盘文件中并已排序好后，便可将磁带机和磁盘文件释放掉，再去请求磁盘文件和打印机。这不仅能使进程更快地完成任务，提高设备的利用率，还可减少进程发生饥饿的机率。\n破坏“不可抢占”条件 为了能破坏“不可抢占”条件，协议中规定，当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已占有的资源会被暂时地释放，或者说是被抢占了，从而破坏了“不可抢占”条件。\n该方法实现起来比较复杂，且需付出很大的代价。因为一个不可抢占的资源如打印机、CD刻录机等在使用一段时间后被抢占，可能会造成进程前一阶段工作的失效，即使是采取了某些防范措施，也还会使进程前后两次运行的信息不连续。这种策略还可能因为反复地申请和释放资源致使进程的执行被无限地推迟，这不仅延长了进程的周转时间，而且也增加了系统开销，降低了系统吞吐量。\n破坏“循环等待”条件 一个能保证“循环等待”条件不成立的方法是，对系统所有资源类型进行线性排序，并赋予不同的序号。设 \\(R=(R_1,R_2,R_3,\\cdots,R_m)\\) 为资源类型的集合，为每个资源类型赋予唯一的序号。如果系统中有磁带驱动器、硬盘驱动器、打印机，则函数 \\(F\\) 可按如下形式来定义：\n\\(F(\\text{tape drive})=1\\) ；\n\\(F(\\text{disk drive})=5\\) ；\n\\(F(\\text{printer})=12\\) ；\n在对系统所有资源类型进行线性排序后，便可采用这样的预防协议：规定每个进程必须按序号递增的顺序请求资源。一个进程在开始时，可以请求某类资源 \\(R_i\\) 的单元。以后，当且仅当 \\(F(R_j)\u003eF(R_i)\\) 时，进程才可以请求资源 \\(R_j\\) 的单元。如果需要多个同类资源单元，则必须一起请求。例如，当某进程需要同时使用打印机和磁带机时，由于磁带机序号低，而打印机序号高，故必须先请求磁带机，再请求打印机。假如某进程已请求到一些序号较高的资源，后来它又想请求一个序号低的资源时，它必须先释放所有具有相同和更高序号的资源后，才能申请序号低的资源。在采用这种策略后所形成的资源分配图中，不可能再出现环路，因而破坏了“循环等待”条件。事实上，总有一个进程占据了较高序号的资源，此后它继续申请的资源必然是空闲的，因而进程可以一直向前推进。\n在采用这种策略时，应如何来规定每种资源的序号是十分重要的。通常应根据大多数进程需要资源的先后顺序来确定。一般情况下，进程总是先输入程序和数据，继而进行运算，最后将计算结果输出。故可以为输入设备规定较低的序号，如前面是将磁带机定为 \\(1\\) ；为输出设备规定较高的序号，如把打印机定为 \\(12\\) 。\n这种预防死锁的策略与前两种策略比较，其资源利用率和系统吞吐量都有较明显的改善。但也存在下述问题：首先，为系统中各类资源所规定的序号必须相对稳定，这就限制了新类型设备的增加；其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在实际使用这些资源时的顺序，但也经常会发生这种情况：作业使用各类资源的顺序与系统规定的顺序不同，造成对资源的浪费。第三，为方便用户，系统对用户在编程时所施加的限制条件应尽量少，然而这种按规定次序申请资源的方法必然会限制用户简单、自主地编程。\n避免死锁 避免死锁同样是属于事先预防的策略，但并不是事先采取某种限制措施，破坏产生死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可能获得较好的系统性能，目前常用此方法来避免发生死锁。\n系统安全状态 在死锁避免方法中，把系统的状态分为安全状态和不安全状态。当系统处于安全状态时，可避免发生死锁。反之，当系统处于不安全状态时，则可能进入到死锁状态。\n安全状态 在该方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，才可将资源分配给进程，否则，令进程等待。所谓安全状态，是指系统能按某种进程推进顺序 \\((P_1,P_2,\\cdots,P_n)\\) 为每个进程 \\(P_i\\) 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时称 \\((P_1,P_2,\\cdots,P_n)\\) 为安全序列。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。虽然并非所有不安全状态都必然会转为死锁状态，但当系统进入不安全状态后，就有可能进入死锁状态。反之，只要系统处于安全状态，系统便不会进入死锁状态。因此，避免死锁的实质在于，系统在进行资源分配时，，应使系统不进入不安全状态。\n安全状态之例 假定系统中有三个进程 \\(P_1\\) 、 \\(P_2\\) 和 \\(P_3\\) ，共有 \\(12\\) 台磁带机。进程 \\(P_1\\) 总共要求 \\(10\\) 台磁带机， \\(P_2\\) 和 \\(P_3\\) 分别要求 \\(4\\) 台和 \\(9\\) 台。假设在 \\(T_0\\) 时刻，进程 \\(P_1\\) 、 \\(P_2\\) 和 \\(P_3\\) 已分别获得 \\(5\\) 台、 \\(2\\) 台和 \\(2\\) 台磁带机，尚有 \\(3\\) 台空闲未分配，如下表所示：\n进程 最大需求 已分配 可用 \\(P_1\\) 10 5 3 \\(P_2\\) 4 2 \\(P_3\\) 9 2 表2\n经分析发现，在 \\(T_0\\) 时刻系统是安全的，因为这时存在一个安全序列 \\((P_2,P_1,P_3)\\) ，即只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如将剩余的磁带机取 \\(2\\) 台分配给 \\(P_2\\) ，使之继续运行，待 \\(P_2\\) 完成便可释放出 \\(4\\) 台磁带机，于是可用资源增至 \\(5\\) 台；以后再将这些全部分配给进程 \\(P_1\\) 使之运行，待 \\(P_1\\) 完成后，将释放出 \\(10\\) 台磁带机， \\(P_3\\) 便能获得足够的资源，从而使 \\(P_1\\) 、 \\(P_2\\) 、 \\(P_3\\) 每个进程都能顺利完成。\n由安全状态向不安全状态的转换 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如在 \\(T_0\\) 时刻以后 \\(P_3\\) 又请求 \\(1\\) 台磁带机，若此时系统把剩余 \\(3\\) 台中的 \\(1\\) 台分配给 \\(P_3\\) ,则系统便进入不安全状态。因为此时也无法再找到一个安全序列。例如把其余的 \\(2\\) 台分配给 \\(P_2\\) ,这样在 \\(P_2\\) 完成后，只能释放出 \\(4\\) 台，既不能满足 \\(P_1\\) 尚需 \\(5\\) 台的要求，也不能满足 \\(P_3\\) 需要 \\(6\\) 台的要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，结果导致死锁。类似地，如果我们将剩余的 \\(2\\) 台磁带机先分配给 \\(P_1\\) 或 \\(P_3\\) ,也同样都无法使它们推进到完成，因此从 给 \\(P_3\\) 分配了第3台磁带机开始，系统便又进入了不安全状态。\n在建立了系统安全状态的概念后，便可知道避免死锁的基本思想，就是确保系统始终处于安全状态。一个系统开始是处于安全状态的。当有进程请求一个可用资源时，系统需对该进程的请求进行计算，若将资源分配给进程后系统仍处于安全状态，才将该资源分配给进程。在上面的例子中，在 \\(P_3\\) 请求 \\(1\\) 台磁带机时，尽管系统中有可用的磁带机，但却不 能分配给它。必须等待到P1和 \\(P_2\\) 完成并释放出资源后再将足够的资源分配给 \\(P_3\\) 。\n利用银行家算法避免死锁 最有代表性的避免死锁的算法是Dijkstra的银行家算法。起这样的名字是由于该算法原本是为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。在OS中也可用它来实现避免死锁。\n为实现银行家算法，每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待。\n银行家算法中的数据结构 为了实现银行家算法，在系统中必须设置这样四个数据结构，分别用来描述系统中可利用的资源、所有进程对资源的最大需求、系统中的资源分配，以及所有进程还需要多少资源的情况。\n(1)可利用资源向量 \\(\\text{Available}\\) 。这是一个含有 \\(m\\) 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 \\(\\text{Available}[j]=K\\) ，则表示系统中现有 \\(R_j\\) 类资源 \\(K\\) 个。\n(2)最大需求矩阵 \\(\\text{Max}\\) 。这是一个 \\(n \\times m\\) 的矩阵，它定义了系统中 \\(n\\) 个进程中的每一个进程对 \\(m\\) 类资源的最大需求。如果 \\(\\text{Max}[i,j]=K\\) ，则表示进程 \\(i\\) 需要 \\(R_j\\) 类资源的最大数目为 \\(K\\) 。\n(3)分配矩阵 \\(\\text{Allocation}\\) 。这也是一个 \\(n \\times m\\) 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 \\(\\text{Allocation}[i,j]=K\\) ，则表示进程 \\(i\\) 当前已分得 \\(R_j\\) 类资源的数目为 \\(K\\) 。\n(4)需求矩阵 \\(\\text{Need}\\) 。这也是一个 \\(n \\times m\\) 的矩阵，用以表示每一个进程尚需的各类资源数。如果 \\(\\text{Need}[i,j]=K\\) ，则表示进程 \\(i\\) 还需要 \\(R_j\\) 类资源 \\(K\\) 个方能完成其任务。\n上述三个矩阵间存在下述关系：\n\\[ \\text{Need}[i,j] = \\text{Max}[i,j] - \\text{Allocation}[i,j] \\tag{9} \\] 银行家算法 设 \\(\\text{Request}_i\\) 是进程 \\(P_i\\) 的请求向量，如果 \\(\\text{Request}_i[j]=K\\) ，表示进程 \\(P_i\\) 需要 \\(K\\) 个 \\(R_j\\) 类型的资源。当 \\(P_i\\) 发出资源请求后，系统按下述步骤进行检查：\n(1)如果 \\(\\text{Request}_i[j] \\le \\text{Need}[i,j]\\) ，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。\n(2)如果 \\(\\text{Request}_i[j] \\le \\text{Available}[i,j]\\) ，便转向步骤(3)；否则，表示尚无足够资源， \\(P_i\\) 须等待。\n(3)系统试探着把资源分配给进程 \\(P_i\\) ，并修改下面数据结构中的数值：\n\\(\\text{Available}[j]=\\text{Available}[j]-Request_i[j];\\)\n\\(\\text{Allocation}[i,j]=\\text{Allocation}[i,j]+\\text{Request}_i[j];\\)\n\\(\\text{Need}[i,j]=\\text{Need}[i,j]-\\text{Request}_i[j];\\)\n(4)系统执行安全性算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程 \\(P_i\\) ，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 \\(P_i\\) 等待。\n安全性算法 系统所执行的安全性算法可描述如下：\n(1)设置两个向量：①工作向量 \\(\\text{Work}\\) ，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 \\(m\\) 个元素，在执行安全算法开始时， \\(\\text{Work}=\\text{Available}\\) ；② \\(\\text{Finish}\\) ：它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 \\(\\text{Finish}[i]=\\text{false}\\) ；当有足够资源分配给进程时，再令 \\(\\text{Finish}[i]=\\text{true}\\) 。\n(2)从进程集合中找到一个能满足下述条件的进程：\n① \\(\\text{Finish}[i]=\\text{false}\\)\n② \\(\\text{Need}[i,j]\\le \\text{Work}[i,j]\\)\n若找到，执行步骤(3)；否则，执行步骤(4)。\n(3)当进程 \\(P_i\\) 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：\n\\(\\text{Work}[j]=\\text{Work}[j]+\\text{Allocation}[i,j];\\)\n\\(\\text{Finish}[i]=\\text{true}\\) 。\n\\(\\text{go to step 2}\\) 。\n(4)如果所有进程的 \\(\\text{Finish}[i]=\\text{true}\\) 都满足，则表示系统处于安全状态；否则，系统处于不安全状态。\n","date":"2024-11-24T16:28:25+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/operating_system/processor_scheduling_and_deadlock/","title":"操作系统（三）：处理机调度与死锁"},{"content":" 自然语言处理基础 本章首先介绍自然语言处理中最基础、最本质的问题，即文本如何在计算机内表示，才能达到易于处理和计算的目的。其中，词的表示大体经过了早期的独热（One-hot）表示，到后来的分布式表示，再到最近的词向量三个阶段。至于更长文本的表示方法，本章只对最简单的词袋模型加以介绍，后续章节将介绍其他更好的表示方法。接着介绍三大类自然语言处理任务，即：语言模型、基础任务以及应用任务。其中，基础任务包括中文分词、词性标注、句法分析和语义分析等，应用任务包括信息抽取、情感分析、问答系统、机器翻译和对话系统等。由于这些任务基本可以归纳为文本分类、结构预测和序列到序列三大类问题，所以同时介绍这三大类问题的解决思路。最后，介绍自然语言处理任务的评价方法，主要包括针对确定答案的准确率和F值，针对非确定答案的BLEU值，以及针对开放答案的人工评价等。\n文本的表示 若要利用计算机对自然语言进行处理，首先需要解决语言（本书特指文本） 在计算机内部的存储和计算问题。字符串(String)‌是文本最自然，也是最常用的机内存储形式。所谓字符串，即字符序列，而其中的一个字符本质上就是一个整数。基于字符串的文本表示方式可以实现简单的字符串增删改查等编辑任务，并能够通过编辑距离等算法计算两个字符串之间的字面相似度。在使用字符串表示（也叫符号表示）计算文本的语义信息时，往往需要使用基于规则的方法。例如,要判断一个句子的情感极性（褒义或贬义），规则的形式可能为：如果句子中出现“喜欢””漂亮”等词则为褒义；如果出现“讨厌”“丑陋\u0026quot;等词则为贬义。\n这种基于规则的方法存在很多问题。首先，规则的归纳依赖专家的经验，需 要花费大量的人力、物力和财力；其次，规则的表达能力有限，很多语言现象无法用简单的规则描述；最后，随着规则的增多，规则之间可能存在矛盾和冲突的情况，导致最终无法做出决策。例如，一个句子中既出现了“喜欢”，又出现了“讨厌”，那么其极性应该是什么呢？\n为了解决基于规则的方法存在的以上诸多问题，基于机器学习的自然语言处理技术应运而生，其最本质的思想是将文本表示为向量，其中的每一维代表一个特征。在进行决策的时候，只要对这些特征的相应值进行加权求和，就可以得到一个分数用于最终的判断。仍然以情感极性识别为例，一种非常简单的将原始文本表示为向量的方法为：令向量 \\(\\bm{x}\\) 的每一维表示某个词在该文本中出现的次数，如 \\(x_1\\) 表示“我”出现的次数， \\(x_2\\) 表示“喜欢”出现的次数， \\(x_3\\) 表示“电影”出现的次数， \\(x_4\\) 表示“讨厌”出现的次数等，如果某个词在该句中没有出现，则相应的维数被设置为0。可见，输入向量 \\(\\bm{x}\\) 的大小恰好为整个词表（所有不相同的词）的大小。然后就可以根据每个词对判断情感极性的重要性进行加权，如“喜欢”（ \\(x_2\\) ）对应的权重 \\(w_2\\) 可能比较大，而“讨厌\u0026quot;（ \\(x_4\\) ）对应的权重 \\(w_4\\) 可能比较小（可以为负数），对于情感极性影响比较小的词，如“我”“电影”等，对应的权重可能会趋近于 \\(0\\) 。这种文本表示的方法是两种技术的组合，即词的独热表示和文本的词袋表示。除了可以应用于基于机器学习的方法，文本向量表示还可以用于计算两个文本之间的相似度，即使用余弦函数等度量函数表示两个向量之间的相似度，并应用于信息检索等任务。下面就以上提到的各项技术分别进行详细的介绍。\n词的独热表示 所谓词的独热表示，即使用一个词表大小的向量表示一个词（假设词表为 \\( \\mathbb{V}\\) ，则其大小为 \\(|\\mathbb{V}|\\) ),然后将词表中的第 \\(i\\) 个词 \\(w_i\\) 表示为向量：\n\\[ \\bm{e}_{w_i}=[0,0,\\cdots,\\underbrace{1}_{第i个词},\\cdots,0] \\in \\set{0,1}^{|\\mathbb{V}|} \\tag{1} \\] 在该向量中，词表中第 \\(i\\) 个词在第 \\(i\\) 维上被设置为 \\(1\\) ，其余维均为 \\(0\\) 。这种表示被称为词的独热表示或独热编码（One-hot Encoding）。\n独热表示的一个主要问题就是不同词使用完全不同的向量进行表示，这会导 致即使两个词在语义上很相似，但是通过余弦函数来度量它们之间的相似度时值却为 \\(0\\) 。另外，当应用于基于机器学习的方法时，独热模型会导致数据稀疏(Data Sparsity)‌问题。例如，假设在训练数据中只见过“漂亮”，在测试数据中出现了 “美丽”，虽然它们之间很相似，但是系统仍然无法恰当地对“美丽”进行加权。由于数据稀疏问题，导致当训练数据规模有限时，很多语言现象没有被充分地学习到。\n为了缓解数据稀疏问题，传统的做法是除了词自身，再提取更多和词相关的泛化特征，如词性特征、词义特征和词聚类特征等。以语义特征为例，通过引入WordNet等语义词典，可以获知“漂亮”和“美丽”是同义词，然后引入它们的共同语义信息作为新的额外特征，从而缓解同义词的独热表示不同的问题。可以说，在使用传统机器学习方法解决自然语言处理问题时，研究者的很大一部分精力都用在了挖掘有效的特征上。\n词的分布式表示 词的独热表示容易导致数据稀疏问题，而通过引入特征的方法虽然可以缓解 该问题，但是特征的设计费时费力。那么有没有办法自动提取特征并设置相应的特征值呢？\n分布式语义假设 人们在阅读过程中遇到从未见过的词时，通常会根据上下文来推断其含义以 及相关属性。基于这种思想，John Rupert Firth于1957年提出了分布式语义假设：词的含义可由其上下文的分布进行表示。基于该思想，可以利用大规模的未标注文本数据，根据每个词的上下文分布对词进行表示。当然，分布式语义假设仅仅提供了一种语义建模的思想。具体到表示形式和上下文的选择，以及如何利用上下文的分布特征，都是需要解决的问题。\n下面用一个具体的例子演示如何构建词的分布式表示。假设语料库中有以下三句话：\n1 2 3 我 喜欢 自然 语言 处理 。 我 爱 深度 学习 。 我 喜欢 机器 学习 。 假设以词所在句子中的其他词语作为上下文，那么可以创建如表1所示的词语共现频次表。其中，词表 \\(\\mathbb{V}\\) 包含“我”“喜欢”···“。”共10个词，即 \\(|\\mathbb{V}|=10\\) 。表中的每一项代表一个词 \\(w_i\\) 与另一个词 \\(w_j\\) （上下文）在同一个句子中的共现频次，每个词与自身的共现频次设置为 \\(0\\) 。\n\\(w_j\\) \\(w_i\\) 我喜欢自然语言处理爱深度学习机器。 我0211111213 喜欢2011100112 自然1101100001 语言1110100001 处理1111000001 爱1000001101 深度1000010101 学习2100011011 机器1100000101 。3211111210 表1\u0026emsp;词语共现频次表\n表中的每一行代表一个词的向量。通过计算两个向量之间的余弦函数，就可 以计算两个词的相似度。如“喜欢”和“爱”，由于有共同的上下文“我”和“学习”，使得它们之间具有了一定的相似性，而不是如独热表示一样，没有任何关系。\n除了词，上下文的选择有很多种方式，而选择不同的上下文得到的词向量表示性质会有所不同。例如，可以使用词在句子中的一个固定窗口内的词作为其上下文，也可以使用所在的文档本身作为上下文。前者得到的词表示将更多地反映词的局部性质：具有相似词法、句法属性的词将会具有相似的向量表示。而后者 将更多地反映词代表的主题信息。 不过，直接使用与上下文的共现频次作为词的向量表示，至少存在以下三个问题：\n◦高频词误导计算结果。如上例中，“我”“。”与其他词的共现频次很高，导致实际上可能没有关系的两个词由于都和这些词共现过，从而产生了较高的 相似度。\n◦共现频次无法反映词之间的高阶关系。例如，假设词“A”与”B”共现过，“B”与\u0026quot;C”共现过，“C”与“D\u0026quot;共现过，通过共现频次，只能获知“A”与“C”都与“B”共现过，它们之间存在一定的关系，而“A”与“D”这种高阶的关系则无法知晓。\n◦仍然存在稀疏性的问题。即向量中仍有大量的值为0，这一点从表1中也可以看出。\n下面分别介绍如何通过点互信息和奇异值分解两种技术来解决这些问题。\n点互信息 首先看如何解决高频词误导计算结果的问题。最直接的想法是：如果一个词与很多词共现，则降低其权重；反之，如果一个词只与个别词共现，则提高其权重。信息论中的点互信息（Pointwise Mutual Information，PMI）‌恰好能够做到这一点。对于词 \\(w\\) 和上下文 \\(c\\) ，其PMI为：\n\\[ \\text{PMI}(w,c)=\\log_2\\frac{P(w,c)}{P(w)P(c)} \\tag{2} \\] 式中， \\(P(w,c)\\) 、 \\(P(w)\\) 、 \\(P(c)\\) 分别是 \\(w\\) 与 \\(c\\) 的共现概率，以及 \\(w\\) 和 \\(c\\) 分别出现的概率。可见，通过PMI公式计算，如果 \\(w\\) 和 \\(c\\) 的共现概率（与频次正相关）较高, 但是 \\(w\\) 或者 \\(c\\) 出现的概率也较高（高频词），则最终的PMI值会变小；反之，即便 \\(w\\) 和 \\(e\\) 的共现概率不高，但是 \\(w\\) 或者 \\(c\\) 出现的概率较低（低频词），则最终的PMI值也可能会比较大。从而较好地解决高频词误导计算结果的问题。\n可以通过最大似然估计（Maximum Likelihood Estimation，MLE），分别计算相关的概率值。具体公式为：\n\\[ \\begin{aligned} P(w,c)=\u0026\\frac{C(w,c)}{\\sum_{w',c'}C(w',c')}\\\\[15pt] P(w)=\u0026\\frac{C(w)}{\\sum_{w'}C(w')}=\\frac{\\sum_{c'}C(w,c')}{\\sum_{w'}\\sum_{c'}C(w',c')}\\\\[15pt] P(c)=\u0026\\frac{C(c)}{\\sum_{c'}C(c')}=\\frac{\\sum_{w'}C(w',c)}{\\sum_{w'}\\sum_{c'}C(w',c')} \\end{aligned} \\tag{3} \\] 式中： \\(C(w,c)\\) 表示词 \\(w\\) 和上下文 \\(c\\) 在语料库中出现的次数（也成为频次）； \\(\\sum_{c'}C(w,c')\\) 为表1按行求和， \\(\\sum_{w'}C(w',c)\\) 为表1按列求和； \\(\\sum_{w'}\\sum_{c'}C(w',c')\\) 为全部共现频次的和。代入以上 \\(3\\) 个公式，式(2)可进一步写为\n\\[ \\begin{aligned} \\text{PMI}(w,c)=\u0026\\log_2\\frac{P(w,c)}{P(w)P(c)}\\\\[15pt] =\u0026\\log_2\\frac{\\displaystyle\\frac{C(w,c)}{\\sum_{w',c'}C(w',c')}}{\\displaystyle\\frac{\\sum_{c'}C(w,c')}{\\sum_{w'}\\sum_{c'}C(w',c')}\\cdot\\frac{\\sum_{w'}C(w',c)}{\\sum_{w'}\\sum_{c'}C(w',c')}}\\\\[30pt] =\u0026\\log_2\\frac{\\displaystyle C(w,c)}{\\displaystyle\\frac{\\sum_{c'}C(w,c')\\sum_{w'}C(w',c)}{\\sum_{w'}\\sum_{c'}C(w',c')}} \\end{aligned} \\tag{4} \\] 另外，当某个词与上下文之间共现次数较低时，可能会得到负的PMI值。考虑到这种情况下的PMI不太稳定（具有较大的方差），在实际应用中通常采用PPMI(Positive PMI)‌的形式，即：\n\\[ \\text{PPMI}(w,c)=\\max\\set{\\text{PMI}(w,c),0} \\tag{5} \\] 接下来介绍PMI的代码实现。首先，将类似表1形式的共现频次表定义为共现矩阵的形式，即 \\(\\bm{M} \\in \\mathbb{R}^{|\\mathbb{V}|\\times|\\mathbb{C}|}\\) ，其中 \\(|\\mathbb{V}|\\) 为词表， \\(\\mathbb{C}\\) 为全部的上下文， \\(M_{ij}\\) 为词 \\(w_i\\) 与上下文 \\(c_j\\) 在语料库中的共现频次。然后，编写如下代码计PPMI：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import numpy as np #共现矩阵 M = np.array([[0, 2, 1, 1, 1, 1, 1, 2, 1, 3], [2, 0, 1, 1, 1, 0, 0, 1, 1, 2], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [2, 1, 0, 0, 0, 1, 1, 0, 1, 2], [1, 1, 0, 0, 0, 0, 0, 1, 0, 1], [3, 2, 1, 1, 1, 1, 1, 2, 1, 0]]) #求PPMI值函数 def pmi(M, positive=True): col_totals = M.sum(axis=0) #按列求和 row_totals = M.sum(axis=1) #按行求和 total = col_totals.sum() #总频次 expected = np.outer(row_totals, col_totals) / total #获得每个元素的分子 M = M / expected #取对数前的PMI值 with np.errstate(divide=\u0026#39;ignore\u0026#39;): #不显示log(0)的警告 M = np.log(M) #取对数得PMI值 M[np.isinf(M)] = 0.0 #将log(0)置为0 if positive: M[M \u0026lt; 0] = 0.0 #执行PPMI的max操作 return M #PPMI值 M_pmi = pmi(M) #计算PPMI值 np.set_printoptions(precision=2) #控制输出结果精度为两位小数 print(M_pmi) #打印结果 则最终输出结果为\n1 2 3 4 5 6 7 8 9 10 [[0. 0.18 0.07 0.07 0.07 0.3 0.3 0.3 0.3 0.22] [0.18 0. 0.44 0.44 0.44 0. 0. 0. 0.66 0.18] [0.07 0.44 0. 1.03 1.03 0. 0. 0. 0. 0.07] [0.07 0.44 1.03 0. 1.03 0. 0. 0. 0. 0.07] [0.07 0.44 1.03 1.03 0. 0. 0. 0. 0. 0.07] [0.3 0. 0. 0. 0. 0. 1.48 0.78 0. 0.3 ] [0.3 0. 0. 0. 0. 1.48 0. 0.78 0. 0.3 ] [0.3 0. 0. 0. 0. 0.78 0.78 0. 0.78 0.3 ] [0.3 0.66 0. 0. 0. 0. 0. 0.78 0. 0.3 ] [0.22 0.18 0.07 0.07 0.07 0.3 0.3 0.3 0.3 0. ]] 除了PMI,还有很多种其他方法可以达到类似的目的，如信息检索中常用的 TF-IDF等，在此不再加以赘述。\n奇异值分解 下面看如何解决共现频次无法反映词之间高阶关系的问题。相关的技术有很 多，其中奇异值分解（Singular Value Decomposition，SVD）‌是一种常见的做法。对共现矩阵 \\(\\bm{M}\\) 进行奇异值分解：\n\\[ \\bm{M}=\\bm{U}\\bm{\\Sigma}\\bm{V}^T \\tag{6} \\] 式中： \\(\\bm{U} \\in \\mathbb{R}^{|\\mathbb{V}|\\times r}, \\bm{V} \\in \\mathbb{R}^{r \\times |\\mathbb{C}}|\\) 为正交矩阵，满足 \\(\\bm{U}^T\\bm{U}=\\bm{V}^T\\bm{V}=\\bm{I}\\) ； \\(\\bm{\\Sigma} \\in \\mathbb{R}^{r \\times r}\\) 是由 \\(r\\) 个奇异值(Singular Value)‌构成的对角矩阵。\n若在 \\(\\bm{\\Sigma}\\) 中仅保留 \\(d\\) 个（ \\(d \u003c r\\) ）最大的奇异值（ \\(\\bm{U}\\) 和 \\(\\bm{V}\\) 也只保留相应的维度），则被称为截断奇异值分解(Truncated Singular Value Decomposition)。截断奇异值分解实际上是对矩阵M的低秩近似（详细见截断奇异值分解）。\n通过截断奇异值分解所得到的矩阵 \\(\\bm{U}\\) 中的每一行，则为相应词的 \\(d\\) 维向量表示，该向量一般具有连续、低维和稠密的性质。由于 \\(\\bm{U}\\) 的各列相互正交，因此可以认为词表示的每一维表达了该词的一种独立的“潜在语义”，所以这种方法也被称作潜在语义分析（Latent Semantic Analysis，LSA）。相应地， \\(\\bm{\\Sigma}\\bm{V}^T\\) 的每一列也可以作为相应上下文的向量表示。\n在Python的numpy.linalg库中内置了SVD函数，只需要输入共现矩阵，然后调用相应的函数即可。如：\n1 U, s, Vh = np.linalg.svd(M_pmi) 执行结束后，矩阵 \\(\\bm{U}\\) 中的每一行为相应词经过奇异值分解后的向量表示。如果仅保留前两维，每个词就可以显示为二维平面中的一个点，然后使用下面的代码进行可视化：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import matplotlib.pyplot as plt plt.rcParams[\u0026#39;font.sans-serif\u0026#39;] = [\u0026#39;SimSun\u0026#39;] # 正常显示中文 plt.rcParams[\u0026#39;axes.unicode_minus\u0026#39;] = False # 正常显示负号 words = [\u0026#34;我\u0026#34;, \u0026#34;喜欢\u0026#34;, \u0026#34;自然\u0026#34;, \u0026#34;语言\u0026#34;, \u0026#34;处理\u0026#34;, \u0026#34;爱\u0026#34;, \u0026#34;深度\u0026#34;, \u0026#34;学习\u0026#34;, \u0026#34;机器\u0026#34;, \u0026#34;。\u0026#34;] for i in range(len(words)): plt.text(U[i, 0], U[i, 1], words[i]) plt.xlim(-0.6, 0) plt.ylim(-0.6, 0.6) plt.savefig(\u0026#39;svd.svg\u0026#39;) plt.show() 截断奇异值分解结果如图1所示，可见：上下文比较相近的词在空间上的距离比较近，如“深度”“学习”等；而“我”和等高频词则与其他词语距离比较远。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图1\u0026emsp;截断奇异值分解结果\n在信息检索等领域，也经常通过词与其出现的文档构成“词-文档”共现矩阵，此时也可以通过以上介绍的奇异值分解技术进行降维，并在低维空间（潜在语义空间）内计算词语或者文档之间的相似度，该技术也称潜在语义索引（Latent Semantic Indexing，LSI）。\n虽然在基于传统机器学习的方法中，词的分布式表示取得了不错的效果，但是其仍然存在一些问题。首先，当共现矩阵规模较大时，奇异值分解的运行速度非常慢；其次，如果想在原来语料库的基础上增加更多的数据，则需要重新运行奇异值分解算法，代价非常高；另外，分布式表示只能用于表示比较短的单元，如词或短语等，如果待表示的单元比较长，如段落、句子等，由于与其共现的上下文会非常少，则无法获得有效的分布式表示；最后，分布式表示一旦训练完成，则无法修改，也就是说，无法根据具体的任务调整其表示方式。为了解决这些问题，可引入一种新的词表示方式——词嵌入表示。\n词嵌入表示 与词的分布式表示类似，词嵌入表示(Word Embedding)‌也使用一个连续、低维、稠密的向量来表示词，经常直接简称为词向量，但与分布式表示不同之处在于其赋值方式。在词的分布式表示中，向量值是通过对语料库进行统计得到的，然后再经过点互信息、奇异值分解等变换，一旦确定则无法修改。而词向量中的向量值，是随着目标任务的优化过程自动调整的，也就是说，可以将词向量中的向量值看作模型的参数。不过，如果目标任务的训练数据比较少，学习合适的词向量难度会比较大，因此，利用自然语言文本中所蕴含的自监督学习信号（即词与上下文的共现信息），先来预训练词向量，往往会获得更好的结果。\n文本的词袋表示 上面介绍了几种常见的词表示方法，那么如何通过词的表示构成更长文本的 表示呢？在此介绍一种最简单的文本表示方法——**词袋（Bag-Of-Words，BOW）**表示。所谓词袋表示，就是假设文本中的词语是没有顺序的集合，将文本中的全部词所对应的向量表示（既可以是独热表示，也可以是分布式表示或词向量）相加，即构成了文本的向量表示。如在使用独热表示时，文本向量表示的每一维恰好是相应的词在文本中出现的次数。\n虽然这种文本表示的方法非常简单、直观，但是其缺点也非常明显：首先是 没有考虑词的顺序信息，导致“张三打李四”和“李四打张三”，虽然含义不同，但是由于它们包含的词相同，即使词序不同，词袋表示的结果也是一样的；其次是无法融入上下文信息。比如要表示“不喜欢”，只能将两个词的向量相加，无法进行更细致的语义操作。当然，可以通过增加词表的方法加以解决，比如引入二元词(Bigram)词表，将\u0026quot;不+喜欢\u0026quot;等作为\u0026quot;词”，然后同时学习二元词的词向量表示。这种方法既能部分解决否定词的问题，也能部分解决局部词序的问题，但是随着词表的增大，会引入更严重的数据稀疏问题。深度学习技术的引入为解决这些问题提供了更好的方案，后续将详细介绍。\n自然语言处理任务 本节依次介绍三大类常见的自然语言处理任务，即：语言模型、基础任务以 及应用任务。\n语言模型 语言模型（Language Model，LM）（也称统计语言模型）是描述自然语言概率分布的模型，是一个非常基础和重要的自然语言处理任务。利用语言模型，可以计算一个词序列或一句话的概率，也可以在给定上文的条件下对接下来可能出现 的词进行概率分布的估计。同时，语言模型是一项天然的预训练任务，在基于预训练模型的自然语言处理方法中起到非常重要的作用，因此这种预训练模型有时也被称为预训练语言模型。本篇将主要介绍经典的N元语言模型（N-gramLanguage Model），现代的神经网络语言模型(Neural Network Language Model)将在后续进行详细的介绍。\nN元语言模型 语言模型的基本任务是在给定词序列 \\(w_1w_2\\cdots w_{t-1}\\) 的条件下，对下一时刻 \\(t\\) 可能出现的词 \\(w_t\\) 的条件概率 \\(P(w_t | w_1w_2\\cdots w_{t-1})\\) 进行估计。一般地，把 \\(w_1w_2\\cdots w_{t-1}\\) 一称为 \\(w_t\\) 的历史。例如，对于历史“我 喜欢”，希望得到下一个词为“读书”的概率，即： \\(P(读书|我\\space 喜欢)\\) 。在给定一个语料库时，该条件概率可以理解为当语料中出现“我喜欢”时，有多少次下一个词为“读书”，然后通过最大似然估计进行计算：\n\\[ P(读书|我 喜欢)=\\frac{C(我\\space喜欢\\space读书)}{C(我\\space喜欢)} \\tag{7} \\] 式中， \\(C(\\cdot)\\) 表示相应词序列在语料库中出现的次数（也成为频次）。\n通过以上的条件概率，可以进一步计算一个句子出现的概率，即相应单词序 列的联合概率 \\(P(w_1w_2\\cdots w_l)\\) 为序列的长度。可以利用链式法则对该式进行分解，从而将其转化为条件概率的计算问题，即：\n\\[ \\begin{aligned} P(w_1w_2\\cdots w_l)=\u0026P(w_1)P(w_2|w_1)P(w_3|w_1w_2)\\cdots P(w_l|w_1w_2\\cdots w_{l-1})\\\\[10pt] =\u0026\\prod_{i=1}^{l}P(w_i|w_{1:i-1}) \\end{aligned} \\tag{8} \\] 式中， \\(w_{i:j}\\) 表示由位置 \\(i\\) 到 \\(j\\) 的子串 \\(w_iw_{i+1}\\cdots w_j\\) 。\n然而，随着句子长度的增加， \\(w_{1:i-1}\\) 出现的次数会越来越少，甚至从未出现过，那么 \\(P(w_i|w_{1:i-1})\\) 则很可能为 \\(0\\) ，此时对于概率估计就没有意义了。为了解决该问题，可以假设“下一个词出现的概率只依赖于它前面 \\(n-1\\) 个词\u0026quot;，即\n\\[ P(w_t|w_1w_2\\cdots w_{t-1})\\approx P(w_t|w_{t-(n-1):t-1}) \\tag{9} \\] 该假设被称为马尔可夫假设(Markov Assumption)。满足这种假设的模型，被称为N元语法或N元文法（N-gram）‌模型。特别地，当 \\(n=1\\) 时，下一个词的出现独立于其历史，相应的一元语法通常记作unigram。当 \\(n=2\\) 时，下一个词只依赖于前 \\(1\\) 个词，对应的二元语法记作bigram。二元语法模型也被称为一阶马尔可夫链(MarkovChain)。类似的，三元语法假设（ \\(n=3\\) ）也被称为二阶马尔可夫假设，相应的三元语法记作trigram。 \\(n\\) 的取值越大，考虑的历史越完整。在unigram模型中，由于词与词之间相互独立，因此它是与语序无关的。\n以bigram模型为例，式(8)可转换为\n\\[ P(w_1w_2 \\cdots w_l)= \\prod_{i=1}^{l}P(w_i|w_{i-1}) \\tag{10} \\] 为了使 \\(P(w_i|w_{i-1})\\) 对于 \\(i=1\\) 有意义，可在句子的开头增加一个句首标记\u0026lt;BOS\u0026gt;( Begin Of Sentence)，并设 \\(w_0=\\) \u0026lt;BOS\u0026gt;。同时，也可以在句子的结尾增加一个句尾标记\u0026lt;EOS\u0026gt;(End Of Sentence)，设 \\(w_{l+1}=\\) \u0026lt;EOS\u0026gt;。\n平滑 虽然马尔可夫假设（下一个词出现的概率只依赖于它前面 \\(n-1\\) 个词）降低了句子概率为 \\(0\\) 的可能性，但是当 \\(n\\) 比较大或者测试句子中含有未登录词（Out-Of-Vocabulary，OOV）‌时，仍然会出现“零概率”问题。由于数据的稀疏性，训练数据很难覆盖测试数据中所有可能出现的N-gram，但这并不意味着这些N-gram出现的概率为0。为了避免该问题，需要使用平滑(Smoothing)‌技术调整概率估计的结果。本节将介绍一种最基本，也最简单的平滑算法——折扣法。\n折扣法(Discounting)‌平滑的基本思想是“损有余而补不足”，即从频繁出现的N-gram中匀出一部分概率并分配给低频次（含零频次）的N-gram，从而使得整体概率分布趋于均匀。\n加1平滑（Add-one Discounting）‌是一种典型的折扣法，也被称为拉普拉斯平滑(Laplace Smoothing)，它假设所有N-gram的频次比实际出现的频次多一次。例如，对于unigram模型来说，平滑之后的概率可由以下公式计算\n\\[ P(w_i)=\\frac{C(w_i)+1}{\\sum_w(C(w)+1)}=\\frac{C(w_i)+1}{N+|\\mathbb{V}|} \\tag{11} \\] 式中， \\(|\\mathbb{V}|\\) 是词表大小。所有未登录词可以映射为一个区别于其他已知词汇的独立标记，如\u0026lt;UNK\u0026gt;。\n相应的，对于bigram模型，则有\n\\[ P(w_i|w_{i-1})=\\frac{C(w_{i-1}w_i)+1}{\\sum_{w}(C(w_{i-1}w)+1)}=\\frac{C(w_{i-1}w_{i})+1}{C(w_{i-1})+|\\mathbb{V}|} \\tag{12} \\] 在实际应用中，尤其当训练数据较小时，加1平滑将对低频次或零频次事件 给出过高的概率估计。一种自然的扩展是加 \\(\\delta\\) 平滑。在加 \\(\\delta\\) 平滑中，假设所有事件的频次比实际出现的频次多 \\(\\delta\\) 次，其中 \\(0 \\le \\delta \\le 1\\) 。\n以bigram语言模型为例，使用加 \\(\\delta\\) 平滑之后的条件概率为\n\\[ P(w_i|w_{i-1})=\\frac{C(w_{i-1}w_i)+\\delta}{\\sum_{w}(C(w_{i-1}w)+\\delta)}=\\frac{C(w_{i-1}w_{i})+\\delta}{C(w_{i-1})+\\delta|\\mathbb{V}|} \\tag{13} \\] 关于超参数 \\(\\delta\\) 的取值，需要用到开发集数据。根据开发集上的困惑度对不同 \\(\\delta\\) 取值下的语言模型进行评价，最终将最优的 \\(\\delta\\) 用于测试集。\n由于引入了马尔可夫假设，导致N元语言模型无法对长度超过N的长距离词语依赖关系进行建模，如果将N扩大，又会带来更严重的数据稀疏问题，同 时还会急剧增加模型的参数量（N-gram数目），为存储和计算都带来极大的挑战。在后续篇章中将要介绍的神经网络语言模型可以较好地解决N元语言模型的这些缺陷。\n语言模型性能评价 如何衡量一个语言模型的好坏呢？一种方法是将其应用于具体的外部任务（如机器翻译），并根据该任务上指标的高低对语言模型进行评价。这种方法也 被称为“外部任务评价”，是最接近实际应用需求的一种评价方法。但是，这种方式的计算代价较高，实现的难度也较大。因此，目前最为常用的是基于困惑度（Perplexity，PPL）‌的“内部评价”方式。\n为了进行内部评价，首先将数据划分为不相交的两个集合，分别称为训练集 \\(\\mathbb{D}^{\\text{train}}\\) 和测试集 \\(\\mathbb{D}^{\\text{test}}\\) ，其中 \\(\\mathbb{D}^{\\text{train}}\\) 用于估计语言模型的参数。由该模型计算出的测试集的概率 \\(P(\\mathbb{D}^{\\text{test}})\\) 则反映了模型在测试集上的泛化能力。\n假设测试集 \\(\\mathbb{D}^{\\text{test}}=w_1w_2 \\cdots w_N\\) （每个句子的开始和结束分布增加\u0026lt;BOS\u0026gt;与\u0026lt;EOS\u0026gt;标记），那么测试集的概率为：\n\\[ \\begin{aligned} P(\\mathbb{D}^{\\text{test}})=\u0026P(w_1w_2 \\cdots w_N)\\\\[5pt] =\u0026\\prod_{i=1}^{N}P(w_i|w_{1:i-1}) \\end{aligned} \\tag{14} \\] 困惑度则为模型分配给测试集中每一个词的概率的几何平均值的倒数\n\\[ \\text{PPL}(\\mathbb{D}^{\\text{test}})=\\left(\\prod_{i=1}^{N}P(w_i|w_{1:i-1})\\right)^{-\\frac{1}{N}} \\tag{15} \\] 例如，对于bigram语言模型而言\n\\[ \\text{PPL}(\\mathbb{D}^{\\text{test}})=\\left(\\prod_{i=1}^{N}P(w_i|w_{i-1})\\right)^{-\\frac{1}{N}} \\tag{16} \\] 考虑到多个概率的连乘可能带来浮点数下溢的问题，通常需要将式(16)转化为对数和的形式\n\\[ \\text{PPL}(\\mathbb{D}^{\\text{test}})=2^{-\\displaystyle\\frac{1}{N}\\sum_{i=1}^{N}\\log_2 P(w_i|w_{i-1})} \\tag{17} \\] 困惑度越小，意味着单词序列的概率越大，也意味着模型能够更好地解释测试集中的数据。需要注意的是，困惑度越低的语言模型并不总是能在外部任务上取得更好的性能指标，但是两者之间通常呈现出一定的正相关性。因此，困惑度可以作为一种快速评价语言模型性能的指标，而在将其应用于下游任务时，仍然需要根据其在具体任务上的表现进行评价。\n自然语言处理基础任务 自然语言处理的一大特点是任务种类纷繁复杂，有多种划分的方式。从处理 顺序的角度，可以分为底层的基础任务以及上层的应用任务。其中，基础任务往往是语言学家根据内省的方式定义的，输出的结果往往作为整个系统的一个环节或者下游任务的额外语言学特征，而并非面向普罗大众。本节介绍几种常见的基础任务，包括词法分析（分词、词性标注）、句法分析和语义分析等。\n中文分词 词(Word)是最小的能独立使用的音义结合体，是能够独立运用并能够表达语义或语用内容的最基本单元。在以英语为代表的印欧语（Indo-European languages）中，词之间通常用分隔符（空格等）区分。但是在以汉语为代表的汉藏语系（Sino-Tibetan languages），以及以阿拉伯语为代表的闪—含语系（Semito-Hamitic languages）中，却不包含明显的词之间的分隔符。因此，为了进行后续的自然语言处理，通常需要首先对不含分隔符的语言进行分词(Word Segmentation)‌操作。本节以中文分词为例，介绍词的切分问题和最简单的分词算法。\n中文分词就是将一串连续的字符构成的句子分割成词语序列，如“我喜欢读书”，分词后的结果为“我 喜欢 读书”。最简单的分词算法叫作正向最大匹配（Forward Maximum Matching，FMM）分词算法，即从前向后扫描句子中的字符 串，尽量找到词典中较长的单词作为分词的结果。具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def fmm_word_seg(sentence, lexicon, max_len): \u0026#34;\u0026#34;\u0026#34; sentence: 待分词的句子 lexicon: 词典（所有单词集合） max_len: 词典中最长单词长度 \u0026#34;\u0026#34;\u0026#34; begin = 0 end = min(begin + max_len, len(sentence)) words = [] while begin \u0026lt; end: word = sentence[begin:end] if word in lexicon or end - begin == 1: words.append(word) begin = end end = min(begin + max_len, len(sentence)) else: end -= 1 return words 通过下面的代码加载词典并调用正向最大匹配分词算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def load_dict(): f = open(\u0026#34;lexicon.txt\u0026#34;) lexicon = set() max_len = 0 for line in f: word = line.strip() lexicon.add(word) if len(word) \u0026gt; max_len: max_len = len(word) f.close() return lexicon, max_len lexicon, max_len = load_dict() words = fmm_word_seg(input(\u0026#34;请输入句子：\u0026#34;), lexicon, max_len) for word in words: print(word,) 这里提供一个可运行的辞典的例子lexicon.txt[点此下载]。\n正向最大匹配分词算法存在的明显缺点是倾向于切分出较长的词，这容易导致错误的切分结果，如“研究生命的起源”，由于“研究生”是词典中的词，所以使用正向最大匹配分词算法的分词结果为“研究生 命 的 起源”，显然分词结果不正确。\n这种情况一般被称为切分歧义问题，即同一个句子可能存在多种分词结果，一旦分词错误，则会影响对句子的语义理解。正向最大匹配分词算法除了存在切分歧义，对中文词的定义也不明确，如“哈尔滨市”可以是一个词，也可以认为“哈尔滨”是一个词，“市”是一个词。因此，目前存在多种中文分词的规范，根据不同规范又标注了不同的数据集。\n另外，就是未登录词问题，也就是说有一些词并没有收录在词典中，如新词、命名实体、领域相关词和拼写错误词等。由于语言的动态性，新词语的出现可谓是层出不穷，所以无法将全部的词都及时地收录到词典中，因此，一个好的分词系统必须能够较好地处理未登录词问题。相比于切分歧义问题，在真实应用环境中，由未登录词问题引起的分词错误比例更高。因此，分词任务本身也是一项富有挑战的自然语言处理基础任务。\n子词切分 一般认为，以英语为代表的印欧语系的语言，词语之间通常已有分隔符（空格等）进行切分，无须再进行额外的分词处理。然而，由于这些语言往往具有复杂的词形变化，如果仅以天然的分隔符进行切分，不但会造成一定的数据稀疏问题，还会导致由于词表过大而降低处理速度。如“computer”“computers”“computing”等，虽然它们语义相近，但是被认为是截然不同的单词。传统的处理方法是根据语言学规则，引入词形还原(Lemmatization)‌或者词干提取(Stemming)‌等任务， 提取出单词的词根，从而在一定程度上克服数据稀疏问题。其中，词形还原指的是将变形的词语转换为原形，如将“computing”还原为“compute”；而词干提取则是将前缀、后缀等去掉，保留词干(Stem)，如“computing”的词干为“comput”，可见，词干提取的结果可能不是一个完整的单词。\n词形还原或词干提取虽然在一定程度上解决了数据稀疏问题，但是需要人工撰写大量的规则，这种基于规则的方法既不容易扩展到新的领域，也不容易扩展到新的语言上。因此，基于统计的无监督子词(Subword)切分任务应运而生，并在现代的预训练模型中使用。\n所谓子词切分，就是将一个单词切分为若干连续的片段。目前有多种常用的 子词切分算法，它们的方法大同小异，基本的原理都是使用尽量长且频次高的子词对单词进行切分。此处重点介绍常用的字节对编码（Byte Pair Encoding，BPE）‌算法。\n首先，BPE通过算法1构造子词词表。\n算法1（BPE中子词词表构造算法）输入：大规模生文本语料库；期望子词词表大小L\n输出：子词词表\n1. 将语料库中每个单词切分成字符作为子词； 2. 用切分的子词构成初始子词词表。 3. while 子词词表小于或等于L do 4. \u0026emsp;\u0026emsp;在语料库中统计单词内相邻子词对的频次； 5. \u0026emsp;\u0026emsp;选取频次最高的子词对，合并成新的子词； 6. \u0026emsp;\u0026emsp;将新的子词加入子词词表； 7. \u0026emsp;\u0026emsp;将语料库中不再存在的子词从子词词表中删除。 8. end 下面，通过一个例子说明如何构造子词词表。首先，假设语料库中存在下列 Python词典中的3个单词以及每个单词对应的频次。其中，每个单词结尾增加了一个'\u0026lt;/w\u0026gt;'字符，并将每个单词切分成独立的字符构成子词。\n1 {\u0026#39;l o w e r \u0026lt;/w\u0026gt;\u0026#39; : 2, \u0026#39;n e w e s t \u0026lt;/w\u0026gt;\u0026#39; : 6, \u0026#39;w i d e s t \u0026lt;/w\u0026gt;\u0026#39; : 3} 初始化的子词词表表为3个单词包含的全部字符：\n1 {\u0026#39;l\u0026#39;, \u0026#39;o\u0026#39; ,\u0026#39;w\u0026#39; , \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;\u0026lt;/w\u0026gt;\u0026#39;, \u0026#39;n\u0026#39; , \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;d\u0026#39;} 然后，统计单词内相邻的两个子词的频次，并选取频次最高的子词对e，和s，合并成新的子词es（共出现9次），然后加入子词词表中，并将语料库中不再存在的子词s从子词词表中删除。此时，语料库以及子词词表变为：\n1 {\u0026#39;l o w e r \u0026lt;/w\u0026gt;\u0026#39; : 2, \u0026#39;n e w es t \u0026lt;/w\u0026gt;\u0026#39; : 6, \u0026#39;w i d es t \u0026lt;/w\u0026gt;\u0026#39; : 3} 1 {\u0026#39;l\u0026#39;, \u0026#39;o\u0026#39; ,\u0026#39;w\u0026#39; , \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;\u0026lt;/w\u0026gt;\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;es\u0026#39;} 然后，合并下一个子词对es和t，新的语料库和子词词表为：\n1 {\u0026#39;l o w e r \u0026lt;/w\u0026gt;\u0026#39; : 2, \u0026#39;n e w est \u0026lt;/w\u0026gt;\u0026#39; : 6, \u0026#39;w i d est \u0026lt;/w\u0026gt;\u0026#39; : 3} 1 {\u0026#39;l\u0026#39;, \u0026#39;o\u0026#39; ,\u0026#39;w\u0026#39; , \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;\u0026lt;/w\u0026gt;\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;est\u0026#39;} 重复以上过程，直到子词词表大小达到一个期望的词表大小为止。构造好子词词表后，如何将一个单词切分成子词序列呢？可以采用贪心的方法，即首先将子词词表按照子词的长度由大到小进行排序。然后，从前向后遍历子词词表，依次判断一个子词是否为单词的子串，如果是的话，则将该单词切分，然 后继续向后遍历子词词表。如果子词词表全部遍历结束，单词中仍然有子串没有被切分，那么这些子串一定为低频串，则使用统一的标记，如'\u0026lt;UNK\u0026gt;'进行替换。\n例如,对一个含有三个单词的句子['the\u0026lt;/w\u0026gt;', 'highest\u0026lt;/w\u0026gt;', 'mountain \u0026lt;/w\u0026gt;]进行切分，假设排好序的词表为['errrr\u0026lt;/w\u0026gt;'，'tain\u0026lt;/w\u0026gt;' ,'moun' , 'est\u0026lt;/w\u0026gt;' , 'high' , 'the\u0026lt;/w\u0026gt;' , 'a\u0026lt;/w\u0026gt;']，则子词切分的结果为['the\u0026lt;/w\u0026gt;', 'high', 'est\u0026lt;/w\u0026gt;', 'moun', 'tain\u0026lt;/w\u0026gt;']。此过程也叫作对句子（单词序列）进行编码。\n那么，如何对一个编码后的句子进行解码，也就是还原成原始的句子呢？此 时，单词结尾字符'\u0026lt;/w\u0026gt;'便发挥作用了。只要将全部子词进行拼接，然后将结尾字符替换为空格，就恰好为原始的句子了。\n通过以上过程可以发现，BPE算法中的编码步骤需要遍历整个词表，是一个 非常耗时的过程。可以通过缓存技术加快编码的速度，即将常见单词对应的编码结果事先存储下来，然后编码时通过查表的方式快速获得编码的结果。对于查不到的单词再实际执行编码算法。由于高频词能够覆盖语言中的大部分单词，因此 该方法实际执行编码算法的次数并不多，因此可以极大地提高编码过程的速度。\n除了BPE,还有很多其他类似的子词切分方法，如WordPiece、Unigram Language Model(ULM)算法等。其中，WordPiece与BPE算法类似，也是每次从子词词表中选出两个子词进行合并。与BPE的最大区别在于，选择两个子词进行合并的策略不同：BPE选择频次最高的相邻子词合并，而WordPiece选择能够提升语言模型概率最大的相邻子词进行合并。经过公式推导，提升语言模型概率最大的相邻子词具有最大的互信息值，也就是两子词在语言模型上具有较强的关联性，它们经常在语料中以相邻方式同时出现。\n与WordPiece一样，ULM同样使用语言模型挑选子词。不同之处在于，BPE和WordPiece算法的词表大小都是从小到大变化，属于增量法。而ULM则是减量法，即先初始化一个大词表，根据评估准则不断丢弃词表中的子词，直到满足限定条件。ULM算法考虑了句子的不同分词可能，因而能够输出带概率的多个子词分段。\n为了更方便地使用上述子词切分算法，Google推出了SentencePiece开源工具包，其中集成了 BPE、ULM等子词切分算法，并支持Python、C++编程语言的调 用，具有快速、轻量的优点。此外，通过将句子看作Unicode编码序列，从而使其能够处理多种语言。\n词性标注 词性是词语在句子中扮演的语法角色，也被称为词类（Part-Of-Speech，POS）。例如，表示抽象或具体事物名字（如“计算机”）的词被归为名词，而表示动作（如“打”）、状态（如“存在”）的词被归为动词。词性可为句法分析、语义理解等提供帮助。\n词性标注(POS Tagging)‌任务是指给定一个句子，输出句子中每个词相应的词性。例如，当输入句子为：\n1 他 喜欢 下 象棋 。 则词性标注的输出为：\n1 他/PN 喜欢/W 下/VV 象棋/NN 。/PU 其中，斜杠后面的PN、VV、NN和PU分别代表代词、动词、名词和标点符号。词性标注的主要难点在于歧义性，即一个词在不同的上下文中可能有不同的 词性。例如，上例中的“下”，既可以表示动词，也可以表示方位词。因此，需要结合上下文确定词在句子中的具体词性。\n句法分析 句法分析(SyntacticParsing)‌的主要目标是给定一个句子，分析句子的句法成分信息，例如主谓宾定状补等成分。最终的目标是将词序列表示的句子转换成树状结构，从而有助于更准确地理解句子的含义，并辅助下游自然语言处理任务。例如，对于以下两个句子：\n1 2 您转的这篇文章很无知。 您转这篇文章很无知。 虽然它们只相差一个“的”字，但是表达的语义是截然不同的，这主要是因为两句话的主语不同。其中，第一句话的主语是“文章”，而第二句话的主语是\u0026quot;转\u0026quot;的动作。通过对两句话进行句法分析，就可以准确地获知各自的主语，从而推导出不同的语义。\n典型的句法结构表示方法包含两种——短语结构句法表示和依存结构句法表示。它们的不同点在于依托的文法规则不一样。其中，短语结构句法表示依托上下文无关文法，属于一种层次性的表示方法。而依存结构句法表示依托依存文法。\n图2对比了两种句法结构表示方法。在短语结构句法表示中，S代表起始符号，NP和VP分别代表名词短语和动词短语。在依存结构句法表示中，sub和obj分别表示主语和宾语，root表示虚拟根节点，其指向整个句子的核心谓词。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S V P PN VV VV MN V P N P 他 喜欢 下 象棋 他 喜欢 下 象棋 R o o t sub r o o t o bj o bj ( a)短语结构句法树 ( b )依存结构句法树 图2\u0026emsp;两种句法结构表示方法结果对比\n语义分析 自然语言处理的核心任务即是让计算机“理解”自然语言所蕴含的意义，即语义(Semantic)。本章前面介绍的文本向量表示，可以被认为隐性地蕴含了很多语义信息。而一般意义上的语义分析指的是通过离散的符号及结构显性地表示语义。根据待表示语言单元粒度以及语义表示方法的不同，语义分析又可以被分为多种形式。\n从词语的粒度考虑，一个词语可能具有多种语义（词义），例如“打”，含义既可能是“攻击”（如“打人”），还可能是“玩”（如“打篮球”），甚至“编织”（如“打毛衣\u0026quot;）等。根据词语出现的不同上下文，确定其具体含义的自然语言处理任务被称为词义消歧（Word Sense Disambiguation，WSD）。对于每个词可能具有的词义，往往是通过语义词典确定的，如WordNet等。除了以上一词多义情况，还有多词一义的情况，如“马铃薯”和“土豆”具有相同的词义。\n由于语言的语义组合性和进化性，无法像词语一样使用词典定义句子、段落或篇章的语义，因此很难用统一的形式对句子等语言单元的语义进行表示。众多的语言学流派提出了各自不同的语义表示形式，如语义角色标注（Semantic Role Labeling，SRL）、语义依存分析（Semantic Dependency Parsing，SDP）等。\n其中，语义角色标注也称谓词论元结构（Predicate-Argument Structure），即首先识别句子中可能的谓词（一般为动词），然后为每个谓词确定所携带的语义角色（也称作论元），如表示动作发出者的施事(Agent)，表示动作承受者的受事(Patient)等。除了核心语义角色，还有一类辅助描述动作的语言成分，被称为附 加语义角色，如动作发生的时间、地点和方式等。表2展示了一个语义角色标注的示例，其中有两个谓词——“喜欢”和“下”并针对每个谓词产生相应的论元输出结果。\n输入 他 喜欢 下 象棋 输出1 施事 谓词 受事 输出2 施事 谓词 受事 表2\u0026emsp;语义角色标注示例\n语义依存分析则利用通用图表示更丰富的语义信息。根据图中节点类型的不同，又可分为两种表示——语义依存图(Semantic Dependency Graph)‌表示和概念语义图(Conceptual Graph)‌表示。其中，语义依存图中的节点是句子中实际存在的词语，在词与词之间创建语义关系边。而概念语义图首先将句子转化为虚拟的概念节点，然后在概念节点之间创建语义关系边。图3展示了一个语义依存图分析结果示例。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S V P PN VV VV MN V P N P 他 喜欢 下 象棋 他 喜欢 下 象棋 R o o t sub r o o t o bj o bj ( a)短语结构句法树 ( b )依存结构句法树 图3\u0026emsp;语义依存图分析结果示例\n以上的语义表示方式属于通用语义表示方式，也就是针对各种语言现象，设计统一的语义表示。除此之外，还有另一类语义分析用于专门处理具体的任务，如将自然语言表示的数据库查询转换成结构化查询语言(SQL)。例如，对于如表3所示的学生信息表，系统需要将用户的自然语言查询：年龄大于18岁的学生姓名, 转化为 SQL 语句：select name where age \u0026gt; 18。\n学号 姓名 年龄 \\(\\cdots\\) 1001 张三 18 \\(\\cdots\\) 1002 李四 19 \\(\\cdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) \\(\\vdots\\) 表3\u0026emsp;学生信息表\n自然语言处理应用任务 本节介绍信息抽取、情感分析、问答系统、机器翻译和对话系统等自然语言处理应用任务。这些任务可以直接或间接地以产品的形式为终端用户提供服务，是自然语言处理研究应用落地的主要技术。\n信息抽取 信息抽取（Information Extraction，IE）‌是从非结构化的文本中自动提取结构化信息的过程，这种结构化的信息方便计算机进行后续的处理。另外，抽取的结 果还可以作为新的知识加入知识库中。信息抽取一般包含以下几个子任务。\n命名实体识别（Named Entity Recognition，NER）‌是在文本中抽取每个提及的命名实体并标注其类型，一般包括人名、地名和机构名等，也包括专有名称等，如书名、电影名和药物名等。在文本中找到提及的命名实体后，往往还需要将这些命名实体链接到知识库或知识图谱中的具体实体，这一过程被称作实体链接(Entity Linking)。如“华盛顿\u0026quot;既可以指美国首任总统，也可以指美国首都，需要根据上下文进行判断，这一过程类似于词义消歧任务。\n关系抽取(Relation Extraction)‌用于识别和分类文本中提及的实体之间的语义关系，如夫妻、子女、工作单位和地理空间上的位置关系等二元关系。\n事件抽取(Event Extraction)‌的任务是从文本中识别人们感兴趣的事件以及事件所涉及的时间、地点和人物等关键元素。其中，事件往往使用文本中提及的具体触发词(Trigger)‌定义。可见，事件抽取与语义角色标注任务较为类似，其中触发词对应语义角色标注中的谓词，而事件元素则可认为是语义角色标注中的论元。\n事件的发生时间往往比较关键，因此时间表达式(Temporal Expression)‌识别也被认为是重要的信息抽取子任务，一般包括两种类型的时间：绝对时间（日期、 星期、月份和节假日等）和相对时间（如明天、两年前等）。使用时间表达归一化(Temporal Expression Normalization)将这些时间表达式映射到特定的日期或一天中的时间。\n下面通过一个例子，综合展示以上的各项信息抽取子任务。如通过下面的新 闻报道：\n1 2 10月28日，AMD宣布斥资350亿美元收购FPGA芯片巨头赛灵思。这两家传了多年绯闻的芯片 公司终于走到了一起。 信息抽取结果如表4所示。\n信息抽取子任务 抽取结果 命名实体识别 公司名：AMD公司名：赛灵思 关系抽取 赛灵思 \\(\\xRightarrow{\\text{从属}}\\) AMD 时间表达式抽取 10月28日 时间表达式归一化 10月28日 \\(\\to\\) 2020年10月28日 事件抽取 事件：收购事件：2020年10月28日收购者：AMD被收购者：赛灵思收购金额：350亿美元 表4\u0026emsp;信息抽取结果\n情感分析 情感(Sentiment)是人类重要的心理认知能力，使用计算机自动感知和处理人类情感已经成为人工智能领域重要的研究内容之一。自然语言处理中的情感分析主要研究人类通过文字表达的情感，因此也称为文本情感分析。但是，情感又是一个相对比较笼统的概念，既包括个体对外界事物的态度、观点或倾向性，如正面、负面等；又可以指人自身的情绪(Emotion)，如喜、怒、哀和惧等。随着互联网的迅速发展，产生了各种各样的用户生成内容(User Generated Content, UGC)，其中很多内容包含着人们的喜怒哀惧等情感，对这些情感的准确分析有助于了解人们对某款产品的喜好，随时掌握舆情的发展。因此，情感分析成为目前自然语言处理技术的主要应用之一。\n情感分析可以从任务角度分为两个主要的子任务，即情感分类（识别文本中蕴含的情感类型或者情感强度，其中，文本既可以是句子，也可以是篇章）和情感信息抽取（抽取文本中的情感元素，如评价词语、评价对象和评价搭配等）。针对下面的用户评论：\n1 这款手机的屏幕很不错，性能也还可以。 情感分析结果如表5所示。\n情感分析子任务 分析结果 情感分类 褒义 情感信息抽取 评价词：不错；可以评价对象：屏幕；性能评价搭配：屏幕 \\(\\Leftrightarrow\\) 不错；性能 \\(\\Leftrightarrow\\) 可以 表5\u0026emsp;情感分析结果\n由于情感分析具有众多的应用场景，如商品评论的分析、舆情分析等，因此, 情感分析受到工业界的广泛关注，已成为自然语言处理研究应用落地的重要体现。另外，情感分析还在社会学、经济学和管理学等领域显示出重要的研究意义和广泛的应用前景，这些需求对情感分析不断提出更高的要求，推动了情感分析研究 的内涵和外延不断扩展和深入。\n问答系统 问答系统（Question Answering，QA）‌是指系统接受用户以自然语言形式描述的问题，并从异构数据中通过检索、匹配和推理等技术获得答案的自然语言处理系统。根据数据来源的不同，问答系统可以分为4种主要的类型：①检索式问答系统，答案来源于固定的文本语料库或互联网，系统通过查找相关文档并抽取答案完成回答；②知识库问答系统，回答问题所需的知识以数据库等结构化形式存储，问答系统首先将问题解析为结构化的查询语句，通过查询相关知识点，并结合知识推理获取答案；③常问问题集问答系统，通过对历史积累的常问问题集进行检索，回答用户提出的类似问题；④阅读理解式问答系统，通过抽取给定文档中的文本片段或生成一段答案来回答用户提出的问题。在实际应用中，可以综合利用以上多种类型的问答系统来更好地回答用户提出的问题。\n机器翻译 机器翻译(Machine Translation, MT)‌是指利用计算机实现从一种自然语言（源语言）到另外一种自然语言（目标语言）的自动翻译。据统计，目前世界上存在约7,000种语言，其中，超过300种语言拥有100万个以上的使用者。而随着全球化趋势的发展和互联网的广泛普及，不同语言使用者之间的信息交流变得越来越重要。如何突破不同国家和不同民族之间的语言障碍，已成为全人类面临的共同难题。机器翻译为克服这一难题提供了有效的技术手段，其目标是建立自动翻译方法、模型和系统，打破语言壁垒，最终实现任意时间、任意地点和任意语言之间的自动翻译，完成人们无障碍自由交流的梦想。自从自然语言处理领域诞生以来，机器翻译一直是其主要的研究任务和应用场景。近年来，谷歌、百度等公司纷纷推出在线的机器翻译服务，科大讯飞等公司也推出了翻译机产品，能够直接将一种语言的语音翻译为另一种语言的语音，为具有不同语言的人们之间的互相交流提供了便利。\n下面给出一个中英互译的例子，其中源语言（中文）和目标语言（英文）都经过了分词处理：\n1 2 S：北京 是 中国 的 首都 。 T：Beijing is the capital of China . 机器翻译方法一般以句子为基本输入单位，研究从源语言句子到目标语言句子的映射函数。机器翻译自诞生以来，主要围绕理性主义和经验主义两种方法进行研究。所谓“理性主义”，是指基于规则的方法；而“经验主义”是指数据驱动的统计方法，在机器翻译领域表现为基于语料库（翻译实例库）的研究方法。近年来兴起的基于深度学习的机器翻译方法利用深度神经网络学习源语言句子到目标语言句子的隐式翻译规则，即所有的翻译规则都被编码在神经网络的模型参数中。该方法又被称为神经机器翻译（Neural Machine Translation，NMT）‌。\n对话系统 对话系统(Dialogue System)‌是指以自然语言为载体，用户与计算机通过多轮交互的方式实现特定目标的智能系统。其中，特定目标包括：完成特定任务、获取信息或推荐、获得情感抚慰和社交陪伴等。20世纪50年代，图灵提出用于评 测计算机系统智能化水平的“图灵测试”，就是以自然语言对话的形式进行的。对 话系统可以直接应用于语音助手、智能音箱和车载语音系统等众多场景。\n对话系统主要分为任务型对话系统（Task-Oriented Dialogue）‌和开放域对话系统（Open-Domain Dialogue）‌。前者是任务导向型的对话系统，主要用于垂直领域的自动业务助理等，具有明确的任务目标，如完成机票预订、天气查询等特定 的任务。后者是以社交为目标的对话系统，通常以闲聊、情感陪护等为目标，因此也被称为聊天系统或聊天机器人(Chatbot)‌，在领域和话题上具有很强的开放性。\n下面是一段开放域对话系统人机对话的示例，其中U代表用户的话语(Utterance)，S代表对话系统的回复。该类对话系统的主要目标是提升对话的轮次以及 用户的满意度。相比对话的准确性，开放域对话系统更关注对话的多样性以及对用户的吸引程度。\n1 2 3 4 U：今天天气真不错！ S：是啊，非常适合室外运动。 U：你喜欢什么运动？ S：我喜欢踢足球，你呢？ 任务型对话系统一般由顺序执行的三个模块构成，即自然语言理解、对话管理和自然语言生成。其中，自然语言理解（Natural Language Understanding， NLU）‌模块的主要功能是分析用户话语的语义，通常的表示形式为该话语的领域、意图以及相应的槽值等。如对于用户话语：\n1 U：帮我订一张明天去北京的机票 自然语言理解的结果如表6所示。\nNLU子任务 分析结果 领域 机票 意图 订机票 槽值 出发时间 \\(=\\) 明天；到达地 \\(=\\) 北京；数量 \\(=\\) 一张 表6\u0026emsp;自然语言理解的结果\n对话管理（Dialogue Management，DM）‌模块包括对话状态跟踪（Dialogue State Tracking，DST）‌和对话策略优化（Dialogue Policy Optimization，DPO）**‌两个子模块。对话状态一般表示为语义槽和值的列表。例如，通过对以上用户话语自然语言理解的结果进行对话状态跟踪，得到当前的对话状态（通常为语义槽及其对应的值构成的列表）：［到达地=北京；出发时间=明天；出发地=NULL；数量=1］。获得当前对话状态后，进行策略优化，即选择下一步采用什么样的策略，也叫作动作。动作有很多种，如此时可以询问出发地，也可以询问舱位类型等。\n在任务型对话系统里，**自然语言生成（Natural Language Generation，NLG）模块工作相对比较简单，通常通过写模板即可实现。比如要询问出发地，就直接问“请问您从哪里出发?”，然后经过语音合成（Text-to-Speech，TTS）反馈给用户。\n以上三个模块可以一直循环执行下去，随着每次用户的话语不同，对话状态也随之变化。然后，采用不同的回复策略，直到满足用户的订票需求为止。\n基本问题 上面介绍了两大类常见的自然语言处理任务，虽然这些任务从表面上看各不 相同，但是都可以归为文本分类问题、结构预测问题或序列到序列问题，下面就这三个基本问题分别加以介绍。\n文本分类问题 文本分类（Text Classification或Text Categorization）‌是最简单也是最基础的自然语言处理问题。即针对一段文本输入，输出该文本所属的类别，其中，类别是事先定义好的一个封闭的集合。文本分类具有众多的应用场景，如垃圾邮件过滤（将邮件分为垃圾和非垃圾两类）、新闻分类（将新闻分为政治、经济和体育等类别）等。先前介绍的文本情感分类任务就是典型的文本分类问题，类别既可以是褒、贬两类，也可以是喜、怒、哀和惧等多类。\n在使用机器学习，尤其是深度学习方法解决文本分类问题时，首先，需要使 用文本表示技术，将输入的文本转化为特征向量；然后，使用机器学习模型（也叫分类器），将输入的特征向量映射为一个具体的类别。\n除了直接使用文本分类技术解决实际问题，还有很多自然语言处理问题可以转换为文本分类问题，如文本匹配(Text Matching)，即判断两段输入文本之间的匹配关系，包括复述关系（Paraphrasing：判断两个表述不同的文本语义是否相同）、蕴含关系（Entailment：根据一个前提文本，推断与假设文本之间的蕴含或矛盾关系）等。一种转换的方法是将两段文本直接拼接起来，然后按复述或非复述、蕴含或矛盾等关系分类。\n结构预测问题 与文本分类问题不同，在结构预测问题中，输出类别之间具有较强的相互关 联性。例如，在词性标注任务中，一句话中不同词的词性之间往往相互影响，如副词之后往往出现动词或形容词，形容词之后往往跟着名词等。结构预测任务通常是自然语言处理独有的。下面介绍三种典型的结构预测问题——序列标注、序列分割和图结构生成。\n序列标注 所谓序列标注(Sequence Labeling)，指的是为输入文本序列中的每个词标注相应的标签，如词性标注是为每个词标注一个词性标签，包括名词、动词和形容词等。其中，输入词和输出标签数目相同且一一对应。表7展示了一个序列标注（词性标注）示例。序列标注问题可以简单地看成多个独立的文本分类问题，即针 对每个词提取特征，然后进行标签分类，并不考虑输出标签之间的关系。条件随机场（Conditional Random Field，CRF）模型是一种被广泛应用的序列标注模型，其不但考虑了每个词属于某一标签的概率（发射概率），还考虑了标签之间的相互关系（转移概率）。循环神经网络模型也隐含地建模了标签之间的相互关系，为了进一步提高准确率，也可以在循环神经网络之上再使用条件随机场模型。\n输入： 他 喜欢 下 象棋 。 输出： PN VV VV NN PU 表7\u0026emsp;序列标注示例\n序列分割 除了序列标注问题，还有很多自然语言处理问题可以被建模为序列分割问题，如分词问题，就是将字符序列切分成若干连续的子序列；命名实体识别问题，也是在文本序列中切分出子序列，并为每个子序列赋予一个实体的类别，如人名、地名和机构名等。可以使用专门的序列分割模型对这些问题进行建模，不过为了简化，往往将它们转换为序列标注任务统一加以解决。如命名实体识别，序列标注的输出标签可以为一个实体的开始（B-XXX）、中间（I-XXX）或者非实体(O)等，其中B代表开始(Begin)、I代表中间(Inside)、O代表其他(Other)、XXX代表实体的类型，如人名(PER)、地名(LOC)和机构名(ORG)等。分词问题也可以转换为序列标注问题，即为每个字符标注一个标签，指明该字符是一个词的开始(B)或者中间(I)等。表8展示了使用序列标注方法解决序列分割（分词和命名实体识别）问题示例。其中，对于输入：\u0026ldquo;我爱北京天安门。”分词输出结果是：“我 爱 北京 天安门 。”，命名实体识别输出结果是：“北京天安门=LOC”。\n输入 我 爱 北 京 天 安 门 。 分词输出 B B B I B I I B 命名实体识别输出 O O B-LOC I-LOC I-LOC I-LOC I-LOC O 表8\u0026emsp;使用序列标注方法解决序列分割（分词和命名实体识别）问题示例\n图结构生成 图结构生成也是自然语言处理特有的一类结构预测问题，顾名思义，其输入 是自然语言，输出结果是一个以图表示的结构。图中的节点既可以来自原始输入，也可以是新生成的；边连接了两个节点，并可以赋予相应的类型。句法分析就是典型的图结构生成问题，其中，在依存分析中，节点皆为原始输入的词，而边则连接了有句法关系的两个词，然后在其上标注句法关系类别。此外，还 可以对输出的图结构进行一定的约束，如需要为树结构（一种特殊的图结构，要 求每个节点有且只有一个父节点）等。在短语结构句法分析中，除了原始输入词作为终结节点，还需要新生成词性以及短语类型节点作为非终结节点，然后，使 用边将这些节点相连，并最终形成树结构。不过，树结构也不是必要的限制，如在语义依存图分析中，结果就不必是一棵树，而可以是更灵活的图结构。\n图结构生成算法主要包括两大类：基于图的算法和基于转移的算法。\n基于图（Graph-based）的算法首先为图中任意两个节点（输入的词）构成的边赋予一定的分数，算法的目标是求解出一个满足约束的分数最大的子图，其中，子图的分数可以简单看作所有边的分数和，如果要求输出结果满足树结构的约束，则需要使用最大生成树(Maximum Spanning Tree, MST)算法进行解码。除了解码算法，基于图的算法还需要解决如何为边打分以及参数如何优化等问题。\n基于转移（Transition-based）的算法将图结构的构建过程转化为一个状态转移序列，通过转移动作，从一个旧的状态转移到新的状态，也就是说转移动作是 状态向前前进一步的方式，体现了状态变化的策略，转移动作的选择本质上就是一个分类问题，其分类器的特征从当前的状态中加以提取。\n首先，来看如何使用基于转移的算法解决依存句法分析问题。在此，以一种非常简单的标准弧（Arc-standard）转移算法为例，转移状态由一个栈(Stack)和一个队列(Queue)构成，栈中存储的是依存结构子树序列 \\(S_m \\cdots S_1S_0\\) ，队列中存储的是未处理的词 \\(Q_0Q_1 \\cdots Q_n\\) 在初始转移状态中，栈为空，句子当中的所有词有序地填入队列中；在结束转移状态中，栈中存储着一棵完整的依存结构句法分析树，队列为空。\n另外，算法定义了以下三种转移动作，分别为移进（Shift，SH）、左弧归约（Reduce-Left，RL）和右弧归约（Reduce-Right，RR），具体含义如下：\n◦SH，将队列中的第一个元素移入栈顶，形成一个仅包含一个节点的依存子树；\n◦RL，将栈顶的两棵依存子树采用一个左弧 \\(S_1 \\curvearrowleft S_0\\) 进行合并，然后 \\(S_1\\) 下栈；\n◦RR，将栈顶的两棵依存子树采用一个右弧 \\(S_1 \\curvearrowright S_0\\) 进行合并，然后 \\(S_0\\) 下栈。\n图4展示了面向依存句法分析的标准弧转移算法中的三种动作。除了以上三个动作，还定义了一个特殊的完成动作（Finish，FIN）。根据上述的定义，可以使用表9中的动作序列逐步生成图2(b)所示的依存结构句法树。弧上的句法关系可以在生成弧的时候（采用RL或RR动作），使用额外的句法关系分类器加以预测。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e RR RL 栈 ··· ··· ··· ··· 队列 S H 图4\u0026emsp;面向依存句法分析的标准弧转移算法中的三种动作\n‌\n步骤 栈 队列 下一步动作 0 他 喜欢 下 象棋 SH 1 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 他 喜欢 下 象棋 SH 2 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 RL 3 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 SH 4 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 SH 5 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 RR 6 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 RR 7 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 喜欢 他 下 象棋 FIN 表9\u0026emsp;基于标准弧转移算法的依存句法树生成动作序列示例\n基于转移算法的短语结构句法分析方法过程也类似，只不过栈中存储的是短语结构句法子树序列，队列中同样存储的是未被处理的词。在此不再赘述。\n序列到序列问题 除了文本分类和结构预测问题，还有很多自然语言处理问题可以归为序列到序列（Sequence-to-Sequence，Seq2seq）问题。机器翻译问题就是典型的代表，其中，输入为源语言句子，输出为目标语言句子。将其推广到序列到序列问题，输入就是一个由若干词组成的序列，输出则是一个新的序列，其中，输入和输出的序列不要求等长，同时也不要求词表一致。\n使用传统的机器学习技术解决序列到序列问题是比较困难的，而基于深度学习模型，可以直接将输入序列表示为一个向量，然后，通过该向量生成输出序列。其中，对输入序列进行表示的过程又叫作编码，相应的模型则被称为编码器(Encoder)；生成输出序列的过程又叫作解码，相应的模型则被称为解码器(Decoder)。 因此，序列到序列模型也被称为编码器—解码器（Encoder-Decoder）模型。图5以机器翻译问题为例，展示了一个编码器-解码器模型的示例。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e I Lo v e y o u 我 爱 你 Encoder Decoder 图5\u0026emsp;编码器—解码器模型示例\n除了机器翻译，还有很多自然语言处理问题可以被建模为序列到序列问题，如对话系统中，用户话语可被视为输入序列，机器的回复则可被视为输出序列，甚至文本分类问题也可以被建模为序列到序列问题。首先，使用编码器对输入文本进行表示，然后，解码器只输出一个“词”，即文本所属的类别。结构预测问题也类似，首先，也需要使用编码器对输入文本进行表示，然后，在处理序列标注问题时，使用解码器生成输出标签序列（需要保证输出序列与输入序列长度相同）；在处理序列分割问题时，直接输出结果序列；在处理图结构生成问题时，需要将图表示的结果进行序列化，即通过一定的遍历顺序，将图中的节点和边转换为一个序列，然后再执行解码操作。不过，由于输入和输出有较强的对应关系，而序列到序列模型很难保证这种对应关系，所以结构预测问题较少直接使用序列到序列模型加以解决。但是无论如何，由于序列到序列模型具备强大的建模能力，其已成为自然语言处理的大一统框架，越来越多的问题都可以尝试使用该模型加以解决。也就是说，可以将复杂的自然语言处理问题转化为编码、解码两个子问题，然后就可以分别使用独立的模型建模了。\n评价指标 由于自然语言处理任务的多样性以及评价的主观性，因此很难使用单一的评 价指标衡量所有任务的性能，所以针对不同类型的任务，往往采用不同的评价方法。对评价方法的准确把握，有助于深入理解各项自然语言处理任务。\n准确率(Accuracy)‌是最简单、直观的评价指标，经常被应用于文本分类等问题。其计算公式为：\n\\[ \\text{ACC}^{\\text{pos}}=\\frac{\\text{正确分类的文本数}}{\\text{测试文本总数}} \\tag{18} \\] 词性标注等序列标注问题也可以采用准确率进行评价，即:\n\\[ \\text{ACC}^{\\text{pos}}=\\frac{\\text{正确标注的词数}}{\\text{测试文本中词的总数}} \\tag{19} \\] 但是，并非全部的序列标注问题都可以采用准确率进行评价，如在将分词、命名实体识别等序列分割问题转化为序列标注问题后，就不应该使用准确率进行评价。以命名实体识别为例，如果采用按词计算的准确率，则很多非命名实体（相应词对应的类别为O）也被计入准确率的计算之中。另外，如果错标了部分词，那么命名实体识别结果就是错误的，但是按照词准确率计算的话，仍然有部分词被认为分类正确了。如表10中的例子所示，按照词（此处为汉字）计算，在 \\(8\\) 个输入词中，仅仅预测错了 \\(1\\) 个（三），则准确率为 \\(8/7=0.875\\) ，这显然是不合理的。分词等其他序列分割问题的评价也存在类似的问题。\n输入 张 三 是 哈 尔 滨 人 。 正确标注序列 B-PER I-PER O B-LOC I-LOC I-LOC O O 预测标注序列 B-PER O O B-LOC I-LOC I-LOC O O 表10\u0026emsp;命名体识别评价示例\n那么，如何更合理地评价序列分割问题的性能呢？这就需要引入F值（F-Measure或F-Score）‌评价指标，其是精确率(Precision)和召回率(Recall)的加权调和平均，具体公式为\n\\[ \\text{F值}=\\frac{(\\beta^2+1)PR}{\\beta^2(P+R)} \\tag{20} \\] 式中， \\(\\beta\\) 是加权调和参数；\\(P\\) 是精确率， \\(R\\) 是召回率。当 \\(\\beta=1\\) 时，即精确率和召回率相同，此时F值又称 \\(\\text{F}_1\\) 值，具体公式为\n\\[ \\text{F}_1=\\frac{2PR}{P+R} \\tag{21} \\] 在命名实体识别问题中，精确率和召回率的定义分别为:\n\\[ P=\\frac{\\text{正确识别的命名实体树木}}{\\text{识别出的命名实体总数}} \\tag{22} \\] \\[ R=\\frac{\\text{正确识别的命名实体数目}}{\\text{测试文本中命名实体的总数}} \\tag{23} \\]\n仍以表10中的示例为例，其中，“正确识别的命名实体数目”为 \\(1\\) （“哈尔滨”），“识别出的命名实体总数”为 \\(2\\) （\u0026ldquo;张”和“哈尔滨”），“测试文本中命名实体的总数”为 \\(2\\) （\u0026ldquo;张三”和“哈尔滨”），那么此时精确率和召回率皆为 \\(1/2 = 0.5\\) ，最终的 \\(\\text{F}_1\\) 。与基于词计算的准确率（ \\(0.875\\) ）相比，该值更为合理了。\n理解了准确率和F值两种评价指标的区别和联系后，就可以很容易地为一个自然语言处理任务选择合适的评价指标。例如，在评价依存句法分析时（分析结果是一棵句法依存树），由于正确的标注结果为每个词都赋予了一个正确的父节点，因此可以使用以词为单位的准确率对依存句法分析结果进行评价，以表明有多大比例的词正确地找到了父节点。不过，评价指标通常不被直接称作准确率，而使用UAS (Unlabeled Attachment Score)指标，即词的父节点被正确识别的准确率。另外，在考虑一个词与父节点的关系时，则使用LAS(Labeled Attachment Score)指标进行评价，即词的父节点以及与父节点的句法关系都被正确识别的准确率。而在对语义依存图任务进行评价时，由于每个词的父节点的个数不确定，则无法使用准确率进行评价，此时就需要使用F值了，即以图中的弧为单位，计算 其识别的精确率和召回率，然后计算F值。与依存句法分析一样，F值也分为考虑语义关系和不考虑语义关系两种情况。类似地，短语结构句法分析也无法使用 准确率进行评价，可以使用句法结构中包含短语（包括短语类型及短语所覆盖的范围）的F值进行评价。\n虽然准确率和F值可以用来对标准答案比较明确的任务进行评价，但是很多自然语言处理问题的答案并不明确，或者说并不唯一。如语言模型问题，在给定历史文本预测下一个词时，除了在语料库中出现的词，还有许多其他词也是合理的。因此，不能简单地使用准确率进行评价，所以才引入了困惑度这一评价指标。\n对机器翻译系统的评价也类似，测试数据中的参考译文并非唯一正确的答案,目标语言翻译结果只要与源语言语义相同，其表达方式可以非常的灵活。BLEU值是最常用的机器翻译自动评价指标，其计算方法是统计机器译文与参考译文（可以不止一个）中N-gram匹配的数目占机器译文中所有N-gram总数的比率，即N-gram的精确率。其中N的取值不易过大，也不易过小。过大的N会导致机器译文与参考译文中共现的N-gram过少，而过小的N会无法衡量机器译文中词语的顺序信息，所以一般N最大取4。另外，由于此评价方法仅考虑了精确率，而忽视了召回率，所以其倾向于较短的翻译。因此，BLEU值引入了一个长度惩罚因子，鼓励机器译文中单词数目尽量接近参考译文中的数目。最终，BLEU值的区间是0〜1，得分越高表明机器翻译系统的译文质量越好。\n对人机对话系统的评价，虽然也可以利用历史上人人对话数据，采用BLEU值等指标，但是由于回复的开放性，这种自动评价的结果很难保证公正、客观。因为与机器翻译类似，人机对话系统的机器回复也没有唯一的标准答案，但比机器翻译评价更困难的是，人机对话系统的回复甚至都没有需要与输入语义相同这一约束，也就是说人机对话系统的答案是开放式的。此外，由于对话的交互性，不能简单地通过一轮人机对话就对系统进行评价。以上这些问题都给人机对话系统的自动评价带来了极大的挑战。因此，在评价一个人机对话系统时，往往采用人工评价的方式，即通过人与系统进行多轮对话后，最终给出一个总的或多个维度（流畅度、相关度和准确性等）的主观分数。由于评分的主观性，人工评价的一致性往往又比较低，也就是说不同人打分可能差异比较大，为了消除这种差异性,又需要多人进行评价并最终取一个平均分数。因此，人工评价的代价往往非常高,很难在系统开发的过程中多次进行。综上，人机对话系统的评价方法仍是目前自然语言处理领域一个非常棘手的开放性问题，并没有很好地被解决。\n小结 本篇首先介绍了词的向量表示方法，从传统的独热向量表示、分布式向量表 示到最新的词向量和词袋表示。然后，介绍了传统的N元语言模型，分词、词性标注等自然语言处理基础任务，其中以BPE为代表的子词切分经常被用于现代的预训练语言模型中。接着，简单介绍了信息抽取、情感分析等自然语言处理应用任务。以上任务看似纷繁复杂，但是基本可以归纳为三类问题，即：文本分类、结构预测和序列到序列问题，并可以使用相应的模型加以解决。最后，介绍了如何评价一个自然语言处理任务。\n\u0026emsp;\u0026emsp;我再也不会给你写信了，因为我终于意识到我们的联络不过是巨大的幻觉。事实上，我们每个人都不过是在给自己写信，我毫无疑问地深深地爱着你，但我又绝望地发现你远离我时，我爱你更深。 ― 安德烈·纪德, 《窄门》 ","date":"2024-11-13T01:11:04+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/artificial_intelligence/natural_language_processing/fundamentals_of_natural_language_processing/","title":"自然语言处理（二）：自然语言处理基础"},{"content":" 关系数据库标准语言SQL 结构化查询语言（Structured Query Language，SQL）‌是关系数据库的标准语言，也是一个通用的、功能极强的关系数据库语言。其功能不仅仅是查询，而是包括数据库模式创建、数据库数据的插入与修改、数据库安全性完整性定义与控制等一系列功能。本章详细介绍SQL的基本功能，并进一步讲述关系数据库的基本概念。\nSQL概述 自SQL成为国际标准语言以后，各个数据库厂家纷纷推出各自的SQL软件或与SQL的接口软件。这就使大多数数据库均用SQL作为共同的数据存取语言和标准接口，使不同数据库系统之间的互操作有了共同的基础。SQL已成为数据库领域中的主流语言，其意义十分重大。有人把确立SQL为关系数据库语言标准及其后的发展称为是一场革命。\nSQL的产生与发展 SQL是在1974年由Boyce和Chamberlin提出的，最初叫Sequel，并在IBM公司研制的关系数据库管理系统原型System R上实现。由于SQL简单易学，功能丰富，深受用户及计算机工业界欢迎，因此被数据库厂商所采用。经各公司的不断修改、扩充和完善，SQL得到业界的认可。1986年10月，美国国家标准（American National Standard Institute，ANSI）的数据库委员会X3H2批准了SQL作为关系数据库语言的美国标准，同年公布了SQL标准文本（简称SQL-86）。1987年，国际标准化组织(International Organizationfor Standardization，ISO)也通过了这一标准。\nSQL标准从公布以来随数据库技术的发展而不断发展、不断丰富。.1是SQL标准的进展过程。\n标准 大致页数 发布日期 SQL/86 1086年10月 SQL/89(FIPS 127-1) 120页 1989年 SQL/92 622页 1992年 SQL 99 (SQL 3) 1700页 1999年 SQL 2003 3600页 2003年 SQL 2008 3777页 2008年 SQL 2011 2010年 表1\u0026emsp;SQL标准的进展过程\n2008年、2011年又对SQL2003做了一些修改和补充。可以发现，SQL标准的内容越来越丰富，也越来越复杂。SQL99合计超过1700页。SQL/86和SQL/89都是单个文档。SQL/92和SQL99已经扩展为一系列开放的部分。例如，SQL/92除了SQL基本部分外还增加了SQL调用接口、SQL永久存储模块；而SQL99则进一步扩展为框架、SQL基础部分、SQL调用接口、SQL永久存储模块、SQL宿主语言绑定、SQL外部数据的管理和SQL 对象语言绑定等多个部分。\n目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩充和修改，又可以支持标准以外的一些功能特性。本文不是介绍完整的SQL，而是介绍SQL的基本概念和基本功能。因此，在使用具体系统时要查阅各产品的用户手册。\nSQL的特点 SQL之所以能够为用户和业界所接受并成为国际标准，是因为它是一个综合的、功能极强同时又简洁易学的语言。SQL集数据查询(data query)、数据操纵(data manipulation)、数据定义(data definition)和数据控制(data control)功能于一体，其主要特点包括以下几部分。\n综合统一 数据库系统的主要功能是通过数据库支持的数据语言来实现的。\n非关系模型（层次模型、网状模型）的数据语言一般都分为：\n(1)模式数据定义语言（Schema Data Definition Language，模式 DDL）。\n(2)外模式数据定义语言（Subschema Data Definition Language，外模式DDL或子模式DDL）。\n(3)数据存储有关的描述语言(Data Storage Description Language, DSDL)。\n(4)数据操纵语言(Data Manipulation Language, DML)。\n它们分别用于定义模式、外模式、内模式和进行数据的存取与处置。当用户数据库投入运行后，如果需要修改模式，必须停止现有数据库的运行，转储数据，修改模式并编译后再重装数据库，十分麻烦。\nSQL集数据定义语言、数据操纵语言、数据控制语言的功能于一体，语言风格统一，可以独立完成数据库生命周期中的全部活动，包括以下一系列操作要求：\n◦定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库。\n◦对数据库中的数据进行查询和更新。\n◦数据库重构和维护。\n◦数据库安全性、完整性控制，以及事务控制。\n◦嵌入式SQL和动态SQL定义。\n这就为数据库应用系统的开发提供了良好的环境。特别是用户在数据库系统投入运行后还可根据需要随时地、逐步地修改模式，并不影响数据库的运行，从而使系统具有良好的可扩展性。\n另外，在关系模型中实体和实体间的联系均用关系表示，这种数据结构的单一性带来了数据操作符的统一性，查找、插入、删除、更新等每一种操作都只需一种操作符， 从而克服了非关系系统由于信息表示方式的多样性带来的操作复杂性。例如，在DBTG网状数据库系统中，需要两种插入操作符：STORE用来把记录存入数据库，CONNECT用来把记录插入系值（系值是网状数据库中记录之间的一种联系方式）以建立数据之间的联系。\n高度非过程化 非关系数据模型的数据操纵语言是“面向过程”的语言，用“过程化”语言完成某项请求必须指定存取路径。而用SQL进行数据操作时，只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。 这不但大大减轻了用户负担，而且有利于提高数据独立性。\n面向集合的操作方式 非关系数据模型采用的是面向记录的操作方式，操作对象是一条记录。例如查询所有平均成绩在80分以上的学生姓名，用户必须一条一条地把满足条件的学生记录找出来（通常要说明具体处理过程，即按照哪条路径，如何循环等）。而SQL采用集合操作方式，不仅操作对象、查找结果可以是元组的集合，而且一次插入、删除、更新操作的对象也可以是元组的集合。\n以同一种语法结构提供多种使用方式 SQL既是独立的语言，又是嵌入式语言。作为独立的语言，它能够独立地用于联机交互的使用方式，用户可以在终端键盘上直接键入SQL命令对数据库进行操作；作为嵌入式语言，SQL语句能够嵌入到高级语言（例如C、C++、Java）程序中，供程序员设计程序时使用。而在两种不同的使用方式下，SQL的语法结构基本上是一致的。这种以统一的语法结构提供多种不同使用方式的做法，提供了极大的灵活性与方便性。\n语言简洁、易学易用 SQL功能极强，但由于设计巧妙，语言十分简洁，完成核心功能只用了9个动词，如表2所示。SQL接近英语口语，因此易于学习和使用。\nSQL功能 动词 数据查询 SELECT 数据定义 CREATE，DROP，ALTER 数据操纵 INSERT，UPDATE，DELETE 数据控制 GRANT、REVOKE 表2\u0026emsp;SQL的动词\nSQL的基本概念 支持SQL的关系数据库管理系统同样支持关系数据库三级模式结构。如图1所示，其中外模式包括若干视图(view)‌和部分基本表(base table)，数据库模式包括若干基本表，内模式包括若干存储文件(stored file)。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S Q L 视图1 基本表2 存储文件1 视图2 基本表1 基本表3 基本表4 存储文件2 图1\u0026emsp;SQL对关系数据库模式的支持\n用户可以用SQL对基本表和视图进行查询或其他操作，基本表和视图一样，都是关系。\n基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。存储文件的逻辑结构组成了关系数据库的内模式。存储文件的物理结构对最终用户是隐蔽的。\n视图是从一个或几个基本表导出的表。它本身不独立存储在数据库中，即数据库中只存放视图的定义而不存放视图对应的数据。这些数据仍存放在导出视图的基本表中，因此视图是一个虚表。视图在概念上与基本表等同，用户可以在视图上再定义视图。\n下面将逐一介绍各SQL语句的功能和格式。为了突出基本概念和基本功能，略去了许多语法细节。各个关系数据库管理系统产品在实现标准SQL时各有差别，与SQL标准的符合程度也不相同，一般在85%以上。因此，具体使用某个关系数据库管理系统产品时，还应参阅系统提供的有关手册。\n学生—课程数据库 本章以学生—课程数据库为例来讲解SQL的数据定义、数据操纵、数据查询和数据控制语句。\n为此，首先要定义一个学生—课程模式S-T（见例1）。学生-课程数据库中包括以下三个表，它们的定义见例5、例6和例7。\n◦学生表：Student(Sno,Sname,Ssex,Sage,Sdept)\n◦课程表：Course(Cno,Cnme,Cpno,Ccredit)\n◦学生选课表：SC(Sno,Cno,Grade)\n关系的主码加下划线表示。各个表中的数据示例如表3、表4、表5所示。\n\u0026emsp;\u0026emsp;Student\n学号Sno 姓名Sname 性别Ssex 年龄Sage 所在系Sdept 201215121 李勇 男 20 CS 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS 表3\u0026emsp;Student表格中的数据示例\n\u0026emsp;\u0026emsp;Course\n课程号Cno 课程名Cname 先行课Cpno 学分Ccredit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 PASCAL语言 6 4 表4\u0026emsp;Course表格中的数据示例\n\u0026emsp;\u0026emsp;SC\n学号Sno 课程号Cno 成绩Grade 201215121 1 92 201215121 2 85 201215121 3 88 201215122 2 90 201215122 3 80 表5\u0026emsp;SC表格中的数据示例\n数据定义 关系数据库系统支持三级模式结构，其模式、外模式和内模式中的基本对象有模式、表、视图和索引等。因此SQL的数据定义功能包括模式定义、表定义、视图和索引的定义, 如表6所示。\n操作对象 操作方式 创建 删除 修改 模式 CREATE SCHEMA DROP SCHEMA 表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW 索引 CREATE INDEX DROP INDEX ALTER INDEX 表6\u0026emsp;SQL的数据定义语句\nSQL标准不提供修改模式定义和修改视图定义的操作。用户如果想修改这些对象，只能先将它们删除然后再重建。SQL标准也没有提供索引相关的语句，但为了提高查询效率，商用关系数据库管理系统通常都提供了索引机制和相关的语句，如表6中创建、删除和修改索引等。\n在早期的数据库系统中，所有数据库对象都属于一个数据库，也就是说只有一个命名空间。现代的关系数据库管理系统提供了一个层次化的数据库对象命名机制，如图2所示。一个关系数据库管理系统的实例(instance)‌中可以建立多个数据库,一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据 库 （ 有的系统称为目 录 ） 模式 表以及视 图 、 索引等 图2\u0026emsp;数据库对象命名机制的层次结构\n模式的定义与删除 定义模式 在SQL中，模式定义语句如下：\n1 CREATE SCHEMA \u0026lt;模式名\u0026gt; AUTHORIZATION \u0026lt;用户名\u0026gt;; 如果没有指定\u0026lt;模式名\u0026gt;，那么\u0026lt;模式名\u0026gt;隐含为\u0026lt;用户名\u0026gt;。\n要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的CREATE SCHEMA的权限。\n例1：为用户WANG定义一个学生—课程模式S-T。\n1 CREATE SCHEMA \u0026#34;S-T\u0026#34; AUTHORIZATION WANG; 例2：\n1 CREATE SCHEMA AUTHORIZATION WANG; 该语句没有指定\u0026lt;模式名\u0026gt;，所以\u0026lt;模式名\u0026gt;隐含为用户名WANG。\n定义模式实际上定义了一个命名空间，在这个空间中可以进一步定义该模式包含的数据库对象，例如基本表、视图、索引等。\n这些数据库对象可以用表6中相应的CREATE语句来定义。\n目前，在CREATE SCHEMA中可以接受CREATE TABLE、CREATE VIEW和GRANT子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图，定义授权。即\n1 CREATE SCHEMA \u0026lt;模式名\u0026gt; AUTHORIZATION \u0026lt;用户名\u0026gt; [\u0026lt;表定义子句\u0026gt;|\u0026lt;视图定义子句\u0026gt;|\u0026lt;授权定义子句\u0026gt;]; 例3：为用户ZHANG创建一个模式TEST，并且在其中定义一个表TAB1。\n1 2 3 4 5 6 7 CREATE SCHEMA TEST AUTHORIZATION ZHANG CREATE TABLE TAB 1 (COL 1 SMALLINT, COL2 INT, COL3 CHAR(20), COL4 NUMERIC(10,3), COL5 DECIMAL(5,2) ); 删除模式 在SQL中，删除模式语句如下：\n1 DROP SCHEMA \u0026lt;模式名\u0026gt;\u0026lt;CASCADE|RESTRICT\u0026gt;; 其中CASCADE和RESTRICT两者必选其一。选择了CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了RESTRICT（限制），表示如果表示如果该模式中已经定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行DROP SCHEMA语句。\n例4：\n1 DROP SCHEMA ZHANG CASCADE; 该语句删除了模式ZHANG，同时，该模式中已经定义的表TAB1也被删除了。\n基本表的定义、删除与修改 定义基本表 创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。\nSQL语言使用CREATE TABLE语句定义基本表，其基本格式如下：\n1 2 3 4 CREATE TABLE \u0026lt;表名\u0026gt;(\u0026lt;列名\u0026gt;\u0026lt;数据类型\u0026gt; [列级完整性约束条件] [\u0026lt;列名\u0026gt;\u0026lt;数据类型\u0026gt; [列级完整性约束条件]] ... [,\u0026lt;表级完整性约束条件\u0026gt;]); 建表的同时通常还可以定义与该表有关的完整性约束条件，这些完整性约束条件被存入系统的数据字典中，当用户操作表中数据时由关系数据库管理系统自动检查该操作是否违背这些完整性约束条件。如果完整性约束条件涉及该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。\n例5：建立一个“学生”表Student。\n1 2 3 4 5 6 7 CREATE TABLE Student (Sno CHAR(9) PRIMARY KEY, /*列级完整性约束条件，Sno是主码*/ Sname CHAR(20) UNIQUE, /* Sname 取唯一值*/ Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 系统执行该CREATE TABLE语句后，就在数据库中建立一个新的空“学生”表Student，并将有关“学生”表的定义及有关约束条件存放在数据字典中。\n例6：建立一个课程表Course。\n1 2 3 4 5 6 7 8 CREATE TABLE Course (Cno CHAR(4) PRIMARY KEY, /*列级完整性约束条件，Cno是主码*/ Cname CHAR(40) NOT NULL, /*列级完整性约束条件，Cname不能取空值*/ Cpno CHAR(4), /* Cpno的含义是先修课*/ Ccredit SMALLINT, FOREIGN KEY (Cpno) REFERENCES Course(Cno) /*表级完整性约束条件，Cpno是外码，被参照表是Course，被参照列是Cno。*/ ); 本例说明参照表和被参照表可以是同一个表。\n例7：建立学生选课表SC。\n1 2 3 4 5 6 7 8 9 10 CREATE TABLE SC (Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), /*主码由两个属性构成，必须作为表级完整性进行定义*/ FOREIGN KEY (Sno) REFERENCES Student(Sno), /*表级完整性约束条件，Sno是外码，被参照表是Student */ FOREIGN KEY (Cno) REFERENCES Course(Cno) /*表级完整性约束条件，Cno是外码，被参照表是Course*/ ); 数据类型 关系模型中一个很重要的概念是域。每一个属性来自一个域，它的取值必须是域中的值。在SQL中域的概念用数据类型来实现。定义表的各个属性时需要指明其数据类型及长度。SQL标准支持多种数据类型，表7列出了几种常用数据类型。要注意，不同的关系数据库管理系统中支持的数据类型不完全相同。\n数据类型 含义 CHAR(n),CHARACTER(n) 长度为n的定长字符串 VARCHAR(n),CHARACTERVARYING(n) 最大长度为n的变长字符串 CLOB 字符串大对象 BLOB 二进制大对象 INT,INTEGER 长整数（4字节） SMALLINT 短整数（2字节） BIGINT 大整数（8字节） NUMBERIC(p,d) 定点数，由p位数字（不包括符号、小数点）组成，小数点后面有d位数字 DECIMAL(p,d),DEC(p,d) 同NUMERIC REAL 取决于机器精度的单精度浮点数 DOUBLE PRECISION 取决于机器精度的双精度浮点数 FLOAT(n) 可续西安精度的浮点数，精度至少为n位数字 BOOLEAN 逻辑布尔量 DATE 日期，包含年、月、日，格式为YYYY-MM-DD TIME 时间，包含一日的时、分、秒，格式为HH:MM:SS TIMESTAMP 时间戳类型 INTERVAL 时间间隔类型 表7\u0026emsp;数据类型\n一个属性选用哪种数据类型要根据实际情况来决定，一般要从两个方面来考虑，一是取值范围，二是要做哪些运算。例如，对于年龄(Sage)属性，可以采用CHAR(3)作为数据类型，但考虑到要在年龄上做算术运算（如求平均年龄），所以要采用整数作为数据类型，因为在CHAR(n)数据类型上不能进行算术运算。整数又有长整数和短整数两种，因为一个人的年龄在百岁左右，所以选用短整数作为年龄的数据类型。\n模式与表 每一个基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式。例如在例3.1中定义了一个学生—课程模式S-T。现在要在S-T中定义Student、Cource、SC等基本表。\n方法一，在表名中明显地给出模式名。\n1 2 3 CREATE TABLE \u0026#34;S-T\u0026#34;.Student(···); /* Student所属的模式是S-T */ CREATE TABLE \u0026#34;S-T\u0026#34;.Course(···); /* Course所属的模式是S-T */ CREATE TABLE \u0026#34;S-T\u0026#34;.SC(···); /* SC所属的模式是S-T */ 方法二，在创建模式语句中同时创建表，如例3所示。\n方法三，设置所属的模式，设置所属的模式，这样在创建表时表名中不必给出模式名。\n当用户创建基本表（其他数据库对象也一样）时若没有指定模式，系统根据搜索路径(search path)来确定该对象所属的模式。\n搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。使用下面的语句可以显示当前的搜索路径：\n1 SHOW search_path; 搜索路径的当前默认值是$user,PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式。\n数据库管理员也可以设置搜索路径，例如：\n1 SET search_path TO \u0026#34;S-T\u0026#34;,PUBLIC; 然后，定义基本表：\n1 CREATE TABLE Student (···); 实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现搜索路径中第一 个模式名S-T存在，就把该模式作为基本表Student所属的模式。\n修改基本表 随着应用环境和应用需求的变化，有时需要修改已建立好的基本表。SQL语言用ALTER TABLE语句修改基本表，其一般格式为\n1 2 3 4 5 6 ALTER TABLE \u0026lt;表名\u0026gt; [ADD [COLUMN] \u0026lt;新列名\u0026gt; \u0026lt;数据类型\u0026gt; [完整性约束]] [ADD \u0026lt;表级完整性约束\u0026gt;] [DROP [COLUMN] \u0026lt;列名\u0026gt; [CASCADE|RESTRICT]] [DROP CONSTRAINT \u0026lt;完整性约束名\u0026gt; [CASCADE|RESTRICT]] [ALTER COLUMN \u0026lt;列名\u0026gt; \u0026lt;数据类型\u0026gt;]; 其中\u0026lt;表名\u0026gt;是要修改的基本表，ADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件。DROP COLUMN子句用于删除表中的列，如果指定了CASCADE短语，则自动删除引用了该列的其他对象，比如视图；如果指定了RESTRICT短语，则如果该列被其他对象引用，RDBMS将拒绝删除该列。DROP CONSTRAINT子句用于删除指定的完整性约束条件。ALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型。\n例8：向Student表增加“入学时间”列，其数据类型为日期型。\n1 ALTER TABLE Student ADD Sentrance DATE; 不论基本表中原来是否已有数据，新增加的列一律为空值。\n例9：]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。\n1 ALTER TABLE Student ALTER COLUMN Sage INT; 例10：增加课程名称必须取唯一值的约束条件。\n1 ALTER TABLE Course ADD UNIQUE(Cname); 删除基本表 当某个基本表不再需要时，可以使用DROP TABLE语句删除它。其一般格式为：\n1 DROP TABLE \u0026lt;表名\u0026gt; [RESTRICT|CASCADE]; 若选择RESTRICT，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用（如CHECK，FOREIGN KEY等约束），不能有视图，不能有触发器(trigger)，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。\n若选择CASCADE，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。\n默认情况是RESTRICT。\n例11：删除Student表。\n1 DROP TABLE Student CASCADE; 基本表定义一旦被删除，不仅表中的数据和此表的定义将被删除，而且此表上建立的索引、触发器等对象一般也都将被删除。有的关系数据库管理系统还会同时删除在此表上建立的视图。如果欲删除的基本表被其他基本表所引用，则这些表也可能被删除。例如SC表通过外码Sno引用Student，则执行例例11后Student表被删除，SC也被级联删除。因此执行删除基本表的操作一定要格外小心。\n例12：若表上建有视图，选择RESTRICT时表不能删除；选择CASCADE时可以删除表，视图也自动被删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE VIEW IS_Student /* Student表上建立视图 */ AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=\u0026#39;IS\u0026#39;; DROP TABLE Student RESTRICT; /* 删除Student表 */ --ERROR: cannot drop table Student because other objects depend on it /* 系统返回错误信息，存在依赖该表的对象，此表不能被删除 */ DROP TABLE Student CASCADE; /* 删除 Student 表 */ --NOTICE: drop cascades to view IS Student /* 系统返回提示，此表上的视图也被删除 */ SELECT * FROM IS_Student; --ERROR: relation \u0026#34;IS_Student\u0026#34; does not exist 注意：不同的数据库产品在遵循SQL标准的基础上具体实现细节和处理策略会与标准有差别。\n下面就SQL 2011标准对DROP TABLE的规定，对比分析Kingbase ES、Oracle 12c Release 1(12.1)、MS SQL Server 2012这三种数据库产品对DROP TABLE的不同处理策略。\n表8中的R表示RESTRICT，即DROP TABLE \u0026lt;基本表名\u0026gt; RESTRICT；C表示CASCADE，即DROP TABLE \u0026lt;基本表名\u0026gt; CASCADE；其中Oracle 12c没有RESTRICT选项；SQL Server没有RESTRICT和CASCADE选项。\n序号 标准及主流数据库的处理方式 依赖基本表的对象 SQL2011 Kingbase ES Oracle 12c MS SQL Server 2012 RCRCC 1索引无规定√√√√√ 2视图×√×√√保留√保留√保留 3DEFAULT,PRIMARY KEY,CHECK（只含该表的列）,NOT NULL等约束√√√√√√√ 4外码FOREIGN KEY×√×√×√× 5触发器TRIGGER×√×√√√√ 6函数或存储过程×√√保留√保留√保留√保留√保留 表8\u0026emsp;DROP TABLE时，SQL2011与3个关系数据库管理系统的处理策略比较\n“×”表示不能删除基本表，“√”表示能删除基本表，“保留”表示删除基本表后，还保留依赖对象。从比较表中可以知道：\n(1)对于索引，删除基本表后，这三个关系数据库管理系统都自动删除该基本表上己经建立的所有索引。\n(2)对于视图，Oracle 12c与SQL Server 2012是删除基本表后，还保留此基本表上的视图定义，但是己经失效。Kingbase ES分两种情况，若删除基本表时带RESTRICT选项， 则不可以删除基本表；若删除基本表时带CASCADE选项，则可以删除基本表，同时也删 除视图。Kingbase ES的这种策略符合SQL 2011标准。\n(3)对于存储过程和函数，删除基本表后，这三个数据库产品都不自动删除建立在此基本表上的存储过程和函数，但是已经失效。\n(4)如果欲删除的基本表上有触发器，或者被其他基本表的约束所引用（CHECK、FOREIGN KEY等），读者可以从比较表中得到这三个系统的处理策略，这里就不一一说明了。同样，对于其他的SQL语句，不同的数据库产品在处理策略上会与标准有所差别。因此，如果发现本文中个别例子在某个数据库产品上不能通过时，请读者参见有关产品的用户手册，适当修改即可。\n索引的建立与删除 当表的数据量比较大时，查询操作会比较耗时。建立索引是加快查询速度的有效手段。数据库索引类似于图书后面的索引，能快速定位到需要查询的内容。用户可以根据应用环境的需要在基本表上建立一个或多个索引，以提供多种存取路径，加快查找速度。\n数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列(hash)索引、位图索引等。顺序文件上的索引是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。B+树索引是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。散列索引是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。位图索引是用位向量记录索引属性中可能出现的值，每个位向量对应一个可能值。\n索引虽然能够加速数据库查询，但需要占用一定的存储空间，当基本表更新时，索引要进行相应的维护，这些都会增加数据库的负担，因此要根据实际应用的需要有选择地创建索引。目前SQL标准中没有涉及索引，但商用关系数据库管理系统一般都支持索引机制，只是不同的关系数据库管理系统支持的索引类型不尽相同。\n一般说来，建立与删除索引由数据库管理员或表的属主(owner)，即建立表的人负责完成。关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式地选择索引。索引是关系数据库管理系统的内部实现技术，属于内模式的范畴。\n建立索引 在SQL语言中，建立索引使用CREATE INDEX语句，其一般格式为\n1 2 CREATE [UNIQUE] [CLUSTER] INDEX \u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt; (\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;][,\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;]]···); 其中，\u0026lt;表名\u0026gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个\u0026lt;列名\u0026gt;后面还可以用\u0026lt;次序\u0026gt;指定索引值的排列次序，可选ASC（升序）或DESC（降序），默认值为ASC。\nUNIQUE表明此索引的每一个索引值只对应唯一的数据记录。\nCLUSTER表示要建立的索引是聚簇索引。有关聚簇索引的概念在数据库系统（五）：数据库设计中介绍。\n例13：为学生—课程数据库中的Student、Course和SC三个表建立索引。其中Student表按学号升序唯一索引，Course表按课程号号升序建唯-索引，SC表按学号升序和课程号降序建唯一索引。\n1 2 3 CREATE UNIQUE INDEX Stusno ON Student(Sno); CREATE UNIQUE INDEX Coucno ON Course(Cno); CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC); 修改索引 对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX语句。其一般格式为\n1 ALTER INDEX \u0026lt;旧索引名\u0026gt; RENAME TO \u0026lt;新索引名\u0026gt;; 例14：将SC表的SCno索引名改为SCSno。\n1 ALTER INDEX SCno RENAME TO SCSno; 删除索引 索引一经建立就由系统使用和维护，不需用户干预。建立索引是为了减少查询操作的时间，但如果数据增、删、改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。这时可以删除一些不必要的索引。\n在SQL中，删除索引使用DROP INDEX语句，其一般格式为\n1 DROP INDEX \u0026lt;索引名\u0026gt;; 例15：删除Student表的Stusname索引。\n1 DROP INDEX Stusname; 删除索引时，系统会同时从数据字典中删去有关该索引的描述。\n数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。在进行查询优化和查询处理时，数据字典中的信息是其重要依据。\n数据查询 数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为\n1 2 3 4 5 SELECT [ALL|DISTINCT] \u0026lt;目标列表达式\u0026gt; [,\u0026lt;目标列表达式\u0026gt;] ··· FROM \u0026lt;表名或视图名\u0026gt;[,\u0026lt;表名或视图名\u0026gt;]|(\u0026lt;SELECT语句\u0026gt;) [AS] \u0026lt;别名\u0026gt; [WHERE \u0026lt;条件表达式\u0026gt;] [GROUP BY \u0026lt;列名1\u0026gt; [HAVING \u0026lt;条件表达式\u0026gt;]] [ORDER BY \u0026lt;列名2\u0026gt; [ASC|DESC]]; 整个SELECT语句的含义是，根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找出满足条件的元组，再按SELECT子句中的目标列表达式选出元组中的属性值形成结果表。\n如果有GROUP BY子句，则将结果按\u0026lt;列名1\u0026gt;的值进行分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数。如果GROUP BY子句带HAVING短语，则只 有满足指定条件的组才予以输出。\n如果有ORDER BY子句，则结果表还要按\u0026lt;列名2\u0026gt;的值的升序或降序排序。SELECT语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。 下面以学生—课程数据库为例说明SELECT语句的各种用法。\n单表查询 单表查询是指仅涉及一个表的查询。\n选择表中的若干列 选择表中的全部或部分列即关系代数的投影运算。\n1. 查询指定列\n在很多情况下，用户只对表中的一部分属性列感兴趣，这时可以通过在SELECT子句的\u0026lt;目标列表达式\u0026gt;中指定要查询的属性列。\n例16：查询全体学生的学号与姓名。\n1 2 SELECT Sno,Sname FROM Student; 该语句的执行过程可以是这样的：从Student表中取出一个元组，取出该元组在属性Sno和Sname上的值，形成一个新的元组作为输出。对Student表中的所有元组做相同的处理，最后形成一个结果关系作为输出。\n例17：查询全体学生的姓名、学号、所在系。\n1 2 SELECT Sname,Sno,Sdept FROM Student; \u0026lt;目标列表达式\u0026gt;中各个列的先后顺序可以与表中的顺序不一致。用户可以根据应用的需要改变列的显示顺序。本例中先列出姓名，再列出学号和所在系。\n2. 查询全部列\n将表中的所有属性列都选出来有两种方法，一种方法就是在SELECT关键字后列出所有列名；如果列的显示顺序与其在基表中的顺序相同，也可以简单地将\u0026lt;目标列表达式\u0026gt;指定为*。\n例18：查询全体学生的详细记录。\n1 2 SELECT * FROM Student; 等价于\n1 2 SELECT Sno,Sname,Ssex,Sage,Sdept FROM Student; 3. 查询经过计算的值\nSELECT子句的\u0026lt;目标列表达式\u0026gt;不仅可以是表中的属性列，也可以是表达式。\n例19：查询全体学生的姓名及其出生年份。\n1 2 SELECT Sname,2014-Sage /*查询结果的第2列是一个算术表达式*/ FROM Student; 查询结果中第2列不是列名而是一个计算表达式，是用当时的年份（假设为2014年）减去学生的年龄。这样所得的即是学生的出生年份。输出的结果为\nSname 2014-Sage 李勇 1994 刘晨 1995 王敏 1996 张立 1995 表9\n\u0026lt;目标列表达式\u0026gt;不仅可以是算术表达式，还可以是字符串常量、函数等。\n例20：查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。\n1 2 SELECT Sname,\u0026#39;Year of Birth: \u0026#39;,2014-Sage,LOWER(Sdept) FROM Student; 结果为\nSname \u0026lsquo;Year of Birth\u0026rsquo; 2014-Sage LOWER(Sdept) 李勇 Year of Birth: 1994 cs 刘晨 Year of Birth: 1995 cs 王敏 Year of Birth: 1996 ma 张立 Year of Birth: 1995 is 表10\n用户可以通过指定别名来改变查询结果的列标题，这对于含算术表达式、常量、函数 名的目标列表达式尤为有用。例如对于例20可以定义如下列别名：\n1 2 3 SELECT Sname NAME,\u0026#39;Year of Birth:\u0026#39; BIRTH,2014-Sage BIRTHDAY, LOWER(Sdept) DEPARTMENT FROM Student; 结果为\nNAME BIRTH BIRTHDAY DEPARTMENT 李勇 Year of Birth: 1994 cs 刘晨 Year of Birth: 1995 cs 王敏 Year of Birth: 1996 ma 张立 Year of Birth: 1995 is 表11\n选择表中的若干元组 1. 消除取值重复的行\n两个本来并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以用DISTINCT消除它们。\n例21：查询选修了课程的学生学号。\n1 2 SELECT Sno FROM SC; 执行上面的SELECT语句后，结果为\nSno 201215121 201215121 201215121 201215122 201215122 表12\n该查询结果里包含了许多重复的行。如想去掉结果表中的重复行，必须指定 DISTINCT：\n1 2 SELECT DISTINCT Sno FROM SC; 则执行结果为\nSno 201215121 201215122 表13\n如果没有指定DISTINCT关键词，则默认为ALL,即保留结果表中取值重复的行。\n1 2 SELECT Sno FROM SC; 等价于\n1 2 SELECT ALL Sno FROM SC; 2. 查询满足条件的元组\n查询满足指定条件的元组可以通过WHERE子句实现。WHERE子句常用的查询条件如表14所示。\n查询条件 谓词 示例 比较 =, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;=, !=, \u0026lt;\u0026gt;, !\u0026gt;, !\u0026lt;; NOT+上述比较运算符 确定范围 BETWEEN AND, NOT BETWEEN AND 确定集合 IN, NOT IN 字符匹配 LIKE, NOT LIKE 空值 IS NULL, IS NOT NULL 多重条件（逻辑运算） AND, OR, NOT 表14\n(1)比较大小\n用于进行比较的运算符一般包括=（等于），\u0026gt;（大于），\u0026lt;（小于），\u0026gt;=（大于等于），\u0026lt;=（小于等于），!=或\u0026lt;\u0026gt;（不等于），!\u0026gt;（不大于），!\u0026lt;（不小于）。\n例22：查询计算机科学系全体学生的名单。\n1 2 3 SELECT Sname FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;; 关系数据库管理系统执行该查询的一种可能过程是：对Student表进行全表扫描，取 出一个元组，检查该元组在Sdept列的值是否等于CS，如果相等，则取出Sname列的值形成一个新的元组输出；否则跳过该元组，取下一个元组。重复该过程，直到处理完Student表的所有元组。\n如果全校有数万个学生，计算机系的学生人数是全校学生的5%左右，可以在Student表的Sdept列上建立索引，系统会利用该索引找出Sdept='CS'的元组，从中取出Sname列值形成结果关系。这就避免了对Student表的全表扫描，加快了查询速度。注意如果学生较少，索引查找不一定能提高查询效率，系统仍会使用全表扫描。这由查询优化器按照某些规则或估计执行代价来作出选择。\n例23：查询所有年龄在20岁以下的学生姓名及其年龄。\n1 2 3 SELECT Sname, Sage FROM Student WHERE Sage\u0026lt;20; 例24：查询考试成绩不及格的学生的学号。\n1 2 3 SELECT DISTINCT Sno FROM SC WHERE Grade\u0026lt;60; 这里使用了DISTINCT短语，当一个学生有多门课程不及格，他的学号也只列一次。\n(2)确定范围\n谓词BETWEEN···AND···和NOT BETWEEN···AND··可以用来查找找属性值在（或不在）指定范围内的元组，其中BETWEEN后是范围的下限（即低值），AND后是范围的上限（即高值）。\n例25：查询年龄在20〜23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄。\n1 2 3 SELECT Sname,Sdept,Sage FROM Student WHERE Sage BETWEEN 20 AND 23; 例26：查询年龄不在20〜23岁之间的学生姓名、系别和年龄。\n1 2 3 SELECT Sname,Sdept,Sage FROM Student WHERE Sage NOT BETWEEN 20 AND 23; (3)确定集合\n谓词IN可以用来查找属性值属于指定集合的元组。\n例27：查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。\n1 2 3 SELECT Sname,Ssex FROM Student WHERE Sdept IN (\u0026#39;CS\u0026#39;,\u0026#39;MA\u0026#39;,\u0026#39;IS\u0026#39;); 与IN相对的谓词是NOT IN，用于查找属性值不属于指定集合的元组。\n例28：查询既不是计算机科学系、数学系，也不是信息系的学生的姓名和性别。\n1 2 3 SELECT Sname,Ssex FROM Student WHERE Sdept NOT IN (\u0026#39;CS\u0026#39;,\u0026#39;MA\u0026#39;,\u0026#39;IS\u0026#39;); (4)字符匹配\n谓词LIKE可以用来进行字符串的匹配。其一般语法格式如下：\n1 [NOT] LIKE \u0026#39;\u0026lt;匹配串\u0026gt;\u0026#39; [ESCAPE \u0026#39;换码字符\u0026#39; ] 其含义是查找指定的属性列值与\u0026lt;匹配串\u0026gt; 相匹配的元组。\u0026lt;匹配串\u0026gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：\n◦%（百分号）代表任意长度（长度可以为0）的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。如acb、addgb、ab等都满足该匹配串。\n◦_（下横线）代表任意单个字符。例如a_b表示以a开头，以b结尾的长度为3的任意字符串。如acb、afb等都满足该匹配串。\n例29：查询学号为201215121的学生的详细情况。\n1 2 3 SELECT * FROM Student WHERE Sno LIKE \u0026#39;201215121\u0026#39;; 等价于\n1 2 3 SELECT * FROM Student WHERE Sno=\u0026#39;201215121\u0026#39;; 如果LIKE后面的匹配串中不含通配符，则可以用=（等于）运算符取代LIKE谓词，用!=或\u0026lt;\u0026gt;（不等于）运算符取代NOT LIKE谓词。\n例30：查询所有姓刘的学生的姓名、学号和性别。\n1 2 3 SELECT Sname,Sno,Ssex FROM Student WHERE Sname LIKE \u0026#39;刘%\u0026#39;； 例31：查询姓“欧阳”且全名为三个汉字的学生的姓名。\n1 2 3 SELECT Sname FROM Student WHERE Sname LIKE \u0026#39;欧阳_\u0026#39;； 注意：数据库字符集为ASCII时一个汉字需要两个_；当字符集为GBK时只需要一个_。\n例32：查询名字中第二个字为“阳\u0026quot;的学生的姓名和学号。\n1 2 3 SELECT Sname, Sno FROM Student WHERE Sname LIKE \u0026#39;_阳%\u0026#39;; 例33：查询所有不姓刘的学生的姓名、学号和性别。\n1 2 3 SELECT Sname,Sno,Ssex FROM Student WHERE Sname NOT LIKE \u0026#39;刘％\u0026#39;; 如果用户要查询的字符串本身就含有通配符%或_，这时就要使用ESCAPE '\u0026lt;换码字符\u0026gt;'短语对通配符进行转义了。\n例34：查询DB_Design课程的课程号和学分。\n1 2 3 SELECT Cno,Ccredit FROM Course WHERE Cname LIKE `DB\\_Design` ESCAPE \u0026#39;\\\u0026#39;; ESCAPE '_'表示为“_”为换码字符。这样匹配串中紧跟在后面的字符“_”不再具有通配符的含义，转义为普通的字符。\n例35：查询以'DB_'开头，且倒数第三个字符为'i'的课程的详细情况。\n1 2 3 SELECT * FROM Course WHERE Cname LIKE \u0026#39;DB\\_%i__\u0026#39; ESCAPE \u0026#39;\\\u0026#39;; 这里的匹配串为'DB\\_%i__'。第一个_前面有换码字符所以它被转义为普通的_字符。而i后面的两个_的前面均没有换码字符\\，所以它们仍作为通配符。\n(5)涉及空值的查询\n例36：某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。查询缺少成绩的学生的学号和相应的课程号。\n1 2 3 SELECT Sno,Cno FROM SC WHERE Grade IS NULL; /*分数 Grade 是空值*/ 注意这里的IS不能用等号（=）代替。\n例37：查所有有成绩的学生学号和课程号。\n1 2 3 SELECT Sno,Cno FROM SC WHERE Grade IS NOT NULL; (6)多重条件查询\n逻辑运算符AND和OR可用来连接多个查询条件。AND的优先级高于OR，但用户可以用括号改变优先级。\n例38：查询计算机科学系年龄在20岁以下的学生姓名。\n1 2 3 SELECT Sname FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; AND Sage\u0026lt;20; 在例27中的IN谓词实际上是多个OR运算符的缩写，因此该例中的查询也可以用OR运算符写成如下等价形式：\n1 2 3 SELECT Sname,Ssex FROM Student WHERE Sdept=\u0026#39;CS \u0026#39; OR Sdept=\u0026#39;MA\u0026#39; OR Sdept=\u0026#39;IS\u0026#39;; ORDER BY子句 用户可以用ORDER BY子句对查询结果按照一个或多个属性列的升序（ASC）或降序 （DESC）排列，默认值为升序。\n例39：查询选修了3号课程的学生的学号及其成绩，查询结果按分数的降序排列。\n1 2 3 4 SELECT Sno,Grade FROM SC WHERE Cno=\u0026#39;3\u0026#39; ORDER BY Grade DESC; 对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。\n例40：查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。\n1 2 3 SELECT * FROM Student ORDER BY Sdept,Sage DESC; 聚集函数 为了进一步方便用户，增强检索功能，SQL提供了许多聚集函数，主要有：\n聚集函数 作用 COUNT(*) 统计元组个数 COUNT([DISTINCT|ALL] \u0026lt;列名\u0026gt;) 统计一列中值的个数 SUM([DISTINCT|ALL] \u0026lt;列名\u0026gt;) 计算一列值的总和（此列必须是数值型） AVG([DISTINCT|ALL] \u0026lt;列名\u0026gt;) 计算一列值的平均值（此列必须是数值型） MAX([DISTINCT|ALL] \u0026lt;列名\u0026gt;) 求一列值中的最大值 MIN([DISTINCT|ALL] \u0026lt;列名\u0026gt;) 求一列值中的最小值 表15\u0026emsp;SQL提供的聚集函数\n如果指定DISTINCT短语，则表示在计算时要取消指定列中的重复值。如果不指定DISTINCT短语或指定ALL短语（ALL为默认值），则表示不取消重复值。\n例41：查询学生总人数。\n1 2 SELECT COUNT(*) FROM Student; 例42：查询选修了课程的学生人数。\n1 2 SELECT COUNT(DISTINCT Sno) FROM SC; 学生每选修一门课，在SC中都有一条相应的记录。一个学生要选修多门课程，为避免重复计算学生人数，必须在COUNT函数中用DISTINCT短语。\n例43：计算选修1号课程的学生平均成绩。\n1 2 3 SELECT AVG(Grade) FROM SC WHERE Cno=\u0026#39;1\u0026#39;; 例44：查询选修1号课程的学生最高分数。\n1 2 3 SELECT MAX(Grade) FROM SC WHERE Cno=\u0026#39;1\u0026#39;; 例45：查询学生201215012选修课程的总学分数。\n1 2 3 SELECT SUM(Ccredit) FROM SC,Course WHERE Sno=\u0026#39;201215012\u0026#39; AND SC.Cno=Course.Cno; 当聚集函数遇到空值时，除COUNT(*)外，都跳过空值而只处理非空值。COUNT(*)是对元组进行计数，某个元组的一个或部分列取空值不影响COUNT的统计结果。\n注意，WHERE子句中是不能用聚集函数作为条件表达式的。聚集函数只能用于SELECT子句和GROUP BY中的HAVING子句。\nGROUP BY子句 GROUP BY子句将查询结果按某一列或多列的值分组，值相等的为一组。\n对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果，如前面的例41〜例45。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。\n例46：求各个课程号及相应的选课人数。\n1 2 3 SELECT Cno,COUNT(Sno) FROM SC GROUP BY Cno; 该语句对查询结果按Cno的值分组，所有具有相同Cno值的元组为一组，然后对每一组作用聚集函数COUNT进行计算，以求得该组的学生人数。\n查询结果可能为\nCno COUNT(Sno) 1 22 2 34 3 44 4 33 5 48 表16\n如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则可以使用HAVING短语指定筛选条件。\n例47：查询选修了三门以上课程的学生学号。\n1 2 3 4 SELECT Sno FROM SC GROUP BY Sno HAVING COUNT(*)\u0026gt;3; 这里先用GROUP BY子句按Sno进行分组，再用聚集函数COUNT对每一组计数；HAVING短语给出了选择组的条件，只有满足条件（即元组个数\u0026gt;3，表示此学生选修的课超过3门）的组才会被选出来。\nWHERE子句与HAVING短语的区别在于作用对象不同。WHERE子句作用于基本表或视图，从中选择满足条件的元组。HAVING短语作用于组，从中选择满足条件的组。\n例48：查询平均成绩大于等于90分的学生学号和平均成绩。\n下面的语句是不对的：\n1 2 3 4 SELECT Sno,AVG(Grade) FROM SC WHERE AVG(Grade)\u0026gt;=90 GROUP BY Sno; 因为WHERE子句中是不能用聚集函数作为条件表达式的，正确的查询语句应该是：\n1 2 3 4 SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)\u0026gt;=90; 连接查询 前面的查询都是针对一个表进行的。若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。\n等值与非等值连接查询 连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词，其一般格式为\n1 [\u0026lt;表名1\u0026gt;.] \u0026lt;列名1\u0026gt; \u0026lt;比较运算符\u0026gt; [\u0026lt;表名2\u0026gt;.] \u0026lt;列名2\u0026gt; 其中比较运算符主要有=、\u0026gt;、\u0026lt;、\u0026gt;=、\u0026lt;=、!=（或＜＞）等。\n此外连接谓词还可以使用下面形式：\n1 [\u0026lt;表名 1\u0026gt;.] \u0026lt;列名 1\u0026gt; BETWEEN [\u0026lt;表名 2\u0026gt;.] \u0026lt;列名 2\u0026gt; AND [\u0026lt;表名 2\u0026gt;.] \u0026lt;列名 3\u0026gt; 当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。\n连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。\n例49：查询每个学生及其选修课程的情况。\n学生情况存放在Student表中，学生选课情况存放在SC表中，所以本查询实际上涉及Student与SC两个表。这两个表之间的联系是通过公共属性Sno实现的。\n1 2 3 SELECT Student.*,SC.* FROM Student,SC WHERE Student.Sno=SC.Sno; /* 将Student与SC中同一学生的元组连接起来 */ 假设Student表、SC表的数据如表3和表5所示，该查询的执行结果如下表所示。\nStudent.Sno Sname Ssex Sage Sdept SC.Sno Cno Grade 201215121 李勇 男 20 CS 201215121 1 92 201215121 李勇 男 20 CS 201215121 2 85 201215121 李勇 男 20 CS 201215121 3 88 201215122 刘晨 女 19 CS 201215122 2 90 201215122 刘晨 女 19 CS 201215122 3 80 表17\n本例中，SELECT子句与WHERE子句中的属性名前都加上了表名前缀，这是为了避免混淆。如果属性名在参加连接的各表中是唯一的，则可以省略表名前缀。\n关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复上述操作，直到Student中的全部元组都处理完毕为止。这就是嵌套循环连接算法的基本思想。如图3所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S t u dent S C 学号 S n o 姓名 S nam e 性别 S s e x 年龄 S a g e 所在系 S d e p t 2 0 1 2 1 5 1 2 1 李勇 男 2 0 C S 2 0 1 2 1 5 1 2 2 刘晨 女 1 9 C S 2 0 1 2 1 5 1 2 3 王敏 女 1 8 M A 2 0 1 2 1 5 1 2 5 张立 男 1 9 I S 学号 S n o 课程号 C n o 成绩 G r a d e 2 0 1 2 1 5 1 2 1 1 92 2 0 1 2 1 5 1 2 1 2 8 5 2 0 1 2 1 5 1 2 1 3 8 8 2 0 1 2 1 5 1 2 2 2 90 2 0 1 2 1 5 1 2 2 3 8 0 图3\u0026emsp;关系数据库管理系统执行连接操作的示意图\n如果在SC表Sno上建立了索引的话，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。\n若在等值连接中把目标列中重复的属性列去掉则为自然连接。\n例50：对例49用自然连接完成。\n1 2 3 SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student,SC WHERE Student.Sno=SC.Sno; 本例中，由于Sname、Ssex、Sage、Sdept、Cno和Grade属性列在Student表与SC表中是唯一的，因此引用时可以去掉表名前缀；而Sno在两个表都出现了，因此引用时必须加上表名前缀。\n一条SQL语句可以同时完成选择和连接查询，这时WHERE子句是由连接谓词和选择谓词组成的复合条件。\n例51：查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。\n1 2 3 4 SELECT Student.Sno,Sname FROM Student,SC WHERE Student.Sno=SC.Sno AND /* 连接谓词 */ SC.Cno=\u0026#39;2\u0026#39; AND SC.Grade\u0026gt;90; /* 其他限定条件 */ 该查询的一种优化（高效）的执行过程是，先从SC中挑选出Cno='2'并且Grade\u0026gt;90的元组形成一个中间关系，再和Student中满足连接条件的元组进行连接得到最终的结果关系。\n自身连接 连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的自身连接。\n例52：查询每一门课的间接先修课（即先修课的先修课）。\n在Course表中只有每门课的直接先修课信息，而没有先修课的先修课。要得到这个信息，必须先对一门课找到其先修课，再按此先修课的课程号查找它的先修课程。这就要将Course表与其自身连接。\n为此，要为Course表取两个别名，一个是FIRST，另一个是SECOND。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Cno C n ame C pno Cc r edit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 P A S C A L语言 6 4 Cno C n ame C pno Cc r edit 1 数据库 5 4 2 数学 2 3 信息系统 1 4 4 操作系统 6 3 5 数据结构 7 4 6 数据处理 2 7 P A S C A L语言 6 4 F IR S T 表 （ C o u r se 表 ） S EC O N D 表 （ C o u r se 表 ） 图4\u0026emsp;Course表的两个别名FIRST和SECOND\n完成该查询的SQL语句为\n1 2 3 SELECT FIRST.Cno,SECOND.Cpno FROM Course FIRST,Course SECOND WHERE FIRST.Cpno=SECOND.Cno; 结果为\nCno Cpno 1 7 3 5 5 6 表18\n外连接 在通常的连接操作中，只有满足连接条件的元组才能作为结果输出。如例例49的结果表中没有201215123和201215125两个学生的信息，原因在于他们没有选课，在SC表中没有相应的元组，导致Student中这些元组在连接时被舍弃了。\n有时想以Student表为主体列出每个学生的基本情况及其选课情况。若某个学生没有选课，仍把Student的悬浮元组保存在结果关系中，而在SC表的属性上填空值NULL，这时就需要使用外连接。外连接的概念见关系数据库-外连接。可以参照例53改写例49。\n例53：\n1 2 SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno); 也可以使用USING来去掉重复值。\n1 2 SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade FROM Student LEFT OUTER JOIN SC USING (Sno); 执行结果如下。\nStudent.Sno Sname Ssex Sage Sdept Cno Grade 201215121 李勇 男 20 CS 1 92 201215121 李勇 男 20 CS 2 85 201215121 李勇 男 20 CS 3 88 201215122 刘晨 女 19 CS 2 90 201215122 刘晨 女 19 CS 3 80 201215123 刘晨 女 18 MA NULL NULL 201215125 刘晨 女 19 IS NULL NULL 表19\n左外连接列出左边关系（如本例Student）中所有的元组，右外连接列出右边关系中所有的元组。\n多表连接 连接操作除了可以是两表连接，一个表与其自身连接外，还可以是两个以上的表进行连接，后者通常称为多表连接。\n例54：查询每个学生的学号、姓名、选修的课程名及成绩。\n本查询涉及三个表，完成该查询的SQL语句如下：\n1 2 3 SELECT Student.Sno,Sname,Cname,Grade FROM Student,SC,Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno; 关系数据库管理系统在执行多表连接时，通常是先进行两个表的连接操作，再将其连接结果与第三个表进行连接。本例的一种可能的执行方式是，先将Student表与SC表进行连接，得到每个学生的学号、姓名、所选课程号和相应的成绩，然后再将其与Course表进行连接，得到最终结果。\n嵌套查询 在SQL语言中，一个SELECT-FROM-WHERE语句称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询(nested query)。例如：\n1 2 3 4 5 6 7 SELECT Sname FROM Student /*外层查询或父查询*/ WHERE Sno IN (SELECT Sno /*内层查询或子查询*/ FROM SC WHERE Cno=\u0026#39;2\u0026#39;); 本例中，下层查询块SELECT Sno FROM SC WHERE Cno='2'是嵌套在上层查询块SELECT Sname FROM Student WHERE Sno IN的WHERE条件中的。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。\nSQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出 的是，子查询的SELECT语句中不能使用ORDER BY子句，ORDER BY子句只能对最终查询结果排序。\n嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中“结构化”的含义所在。\n带有IN谓词的子查询 在嵌套查询中，子查询的结果往往是一个集合，所以谓词IN是嵌套查询中最经常使用的谓词。\n例55：查询与\u0026quot;刘晨”在同一个系学习的学生。\n先分步来完成此查询，然后再构造嵌套查询。\n①确定\u0026quot;刘晨”所在系名\n1 2 3 SELECT Sdept FROM Student WHERE Sname=\u0026#39;刘晨\u0026#39;; 结果为CS。\n②查找所有在CS系学习的学生。\n1 2 3 SELECT Sno,Sname,Sdept FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;; 结果为\nSno Sname Sdept 201215121 李勇 CS 201215121 刘晨 CS 表20\n将第一步查询嵌入到第二步查询的条件中，构造嵌套查询如下：\n1 2 3 4 5 6 SELECT Sno,Sname,Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname=\u0026#39;刘晨\u0026#39;); 本例中，子查询的查询条件不依赖于父查询，称为不相关子查询。一种求解方法是由里向外处理，即先执行子查询，子查询的结果用于建立其父查询的查找条件。得到如下的语句：\n1 2 3 SELECT Sno,Sname,Sdept FROM Student WHERE Sdept IN (\u0026#39;CS\u0026#39;); 然后执行该语句。\n本例中的查询也可以用自身连接来完成：\n1 2 3 SELECT S1.Sno,S1.Sname,S1.Sdept FROM Student S1,Student S2 WHERE S1.Sdept=S2.Sdept AND S2.Sname=\u0026#39;刘晨\u0026#39;; 可见，实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。\n例56：查询选修了课程名为“信息系统”的学生学号和姓名。\n本查询涉及学号、姓名和课程名三个属性。学号和姓名存放在Student表中，课程名存放在Course表中，但Student与Course两个表之间没有直接联系，必须通过SC表建立它们二者之间的联系。所以本查询实际上涉及三个关系。\n1 2 3 4 5 6 7 8 9 10 11 SELECT Sno,Sname /* ③最后在Student关系中 */ FROM Student /* 取出Sno和Sname */ WHERE Sno IN (SELECT Sno /* ②然后在SC关系中找出 */ FROM SC /* 选修了3号课程的学生 */ WHERE Cno IN /* 学号 */ (SELECT Cno /* ①首先在Course关系中 */ FROM Course /* 找出\u0026#34;信息系统\u0026#34;的课程 */ WHERE Cname=\u0026#39;信息系统\u0026#39; /* 号，结果为3号 */ ) ); 本查询同样可以用连接查询实现：\n1 2 3 4 5 SELECT Student.Sno,Sname FROM Student,SC,Course WHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno AND Course.Cname=\u0026#39;信息系统\u0026#39;; 有些嵌套查询可以用连接运算替代，有些是不能替代的。从例55和例56可以看到，查询涉及多个关系时，用嵌套查询逐步求解层次清楚，易于构造，具有结构化程序设计的优点。但是相比于连接运算，目前商用关系数据库管理系统对嵌套查询的优化做得还不够完善，所以在实际应用中，能够用连接运算表达的查询尽可能采用连接运算。\n例55和例56中子查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询(correlated subquery)‌整个查询语句称为相关嵌套查询(correlated nested query)‌语句。例57就是一个相关子查询的例子。\n带有比较运算符的子查询 带有比较运算符的子查询是指父查询与子查询之间用比较运算符进行连接。当用户能确切知道内层查询返回的是单个值时，可以用\u0026gt;、\u0026lt;、=、\u0026gt;=、\u0026lt;=、!=或\u0026lt;\u0026gt;等比较运算符。\n例如在例55中，由于一个学生只可能在一个系学习，也就是说内查询的结果是一个值，因此可以用=代替IN：\n1 2 3 4 5 6 SELECT Sno,Sname,Sdept FROM Student WHERE Sdept = (SELECT Sdept FROM Student WHERE Sname=\u0026#39;刘晨\u0026#39;); 例57：找出每个学生超过他自己选修课程平均成绩的课程号。\n1 2 3 4 5 SELECT Sno,Cno FROM SC x WHERE Grade\u0026gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); x是表SC的别名，又称为元组变量，可以用来表示SC的一个元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。这个语句的一种可能的执行过程采用以下三个步骤。\n①从外层查询中取出SC的一个元组x，将元组x的Sno值(201215121)传送给内层查询。\n1 2 3 SELECT AVG(Grade) FROM SC y WHERE y.Sno=\u0026#39;201215121‘; ②执行内层查询，得到AVG值为88（近似值），用该值代替内层查询，得到外层查询：\n1 2 3 SELECT Sno, Cno FROM SC x WHERE Grade\u0026gt;=88; ③执行这个查询，得到\nSno Cno 201215121 1 201215121 3 表21\n然后外层查询取出下一个元组重复做上述①至③步骤的处理，直到外层的SC元组全部处理完毕。结果为\nSno Cno 201215121 1 201215121 3 201215122 2 表22\n求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。内层查询由于与外层查询有关，因此必须反复求值。\n带有ANY(SOME)或(ALL)谓词的子查询 子查询返回单值时可以用比较运算符，但返回多值时要用ANY（有的系统用SOME）或ALL谓词修饰符。而使用ANY或ALL谓词时则必须同时使用比较运算符。其语义如下表所示：\n运算符 含义 \u0026gt;ANY 大于子查询结果中的某个值 \u0026gt;ALL 大于子查询结果中的所有值 \u0026lt;ANY 小于子查询结果中的某个值 \u0026lt;ALL 小于子查询结果中的所有值 \u0026gt;=ANY 大于等于子查询结果中的某个值 \u0026gt;=ALL 大于等于子查询结果中的所有值 \u0026lt;=ANY 小于等于子查询结果中的某个值 \u0026lt;=ALL 小于等于子查询结果中的所有值 =ANY 等于子查询结果中的某个值 =ALL 等于子查询结果中的所有值（通常没有实际意义） !=ANY 不等于子查询结果中的某个值 !=ALL 不等于子查询结果中的任何一个值 表23\u0026emsp;ANY或ALL运算符与比较运算符组合后的语义\n例58：查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄。\n1 2 3 4 5 6 SELECT Sname,Sage FROM Student WHERE Sage\u0026lt;ANY (SELECT Sage FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;) AND Sdept\u0026lt;\u0026gt;\u0026#39;CS\u0026#39;; 结果如下：\nSname Sage 王敏 18 张立 19 表24\n关系数据库管理系统执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个集合(20,19)；然后处理父查询，找所有不是CS系且年龄小于20或19的学生。\n本查询也可以用聚集函数来实现，首先用子查询找出CS系中最大年龄(20)，然后在父查询中查所有非CS系且年龄小于20岁的学生。SQL语句如下：\n1 2 3 4 5 6 7 SELECT Sname,Sage FROM Student WHERE Sage \u0026lt; (SELECT MAX(Sage) FROM Student WHERE SdepU \u0026#39;CS\u0026#39;) AND Sdept \u0026lt;\u0026gt; \u0026#39;CS\u0026#39;; 例59：查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄。\n1 2 3 4 5 6 7 SELECT Sname,Sage FROM Student WHERE Sage \u0026lt; ALL (SELECT Sage FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;) AND Sdept\u0026lt;\u0026gt;\u0026#39;CS\u0026#39;;\u0026#39; 关系数据库管理系统执行此查询时，首先处理子查询，找出CS系中所有学生的年龄，构成一个集合(20,19)。然后处理父查询，找所有不是CS系且年龄既小于20，也小于19的学生。查询结果为\nSname Sage 王敏 18 表25\n本查询同样也可以用聚集函数实现。SQL语句如下：\n1 2 3 4 5 6 7 SELECT Sname,Sage FROM Student WHERE Sage \u0026lt; (SELECT MIN(Sage) FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;) AND Sdept\u0026lt;\u0026gt;\u0026#39;CS\u0026#39;; 事实上，用聚集函数实现子查询通常比直接用ANY或ALL查询效率要高。ANY、ALL与聚集函数的对应关系如表26所示。\n= \u0026lt;\u0026gt;或!= \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= ANY IN -- \u0026lt;MAX \u0026lt;=MAX \u0026gt;MIN \u0026gt;=MIN ALL -- NOT IN \u0026lt;MIN \u0026lt;=MIN \u0026gt;MAX \u0026gt;=MAX 表26\u0026emsp;ANY（或SOME）、ALL谓词与聚集函数，IN谓词的等价转换关系\n表26中，=ANY等价于IN谓词，\u0026lt;ANY等价于\u0026lt;MAX，\u0026lt;\u0026gt;ALL等价于NOT IN谓词，\u0026lt;ALL等价于\u0026lt;MIN，等等。\n带有EXISTS谓词的子查询 EXISTS代表存在量词 \\(\\exists\\) 带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。\n可以利用EXISTS来判断 \\(x \\in S\\) 、 \\(S \\sube R\\) 、 \\(S = R\\) 、 \\(S \\cap R 非空\\) 等是否成立。\n例60：查询所有选修了1号课程的学生姓名。\n本查询涉及Student和SC表。可以在Student中依次取每个元组的Sno值，用此值去检查SC表。若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno='1'，则取此Student.Sname送入结果表。将此想法写成SQL语句是\n1 2 3 4 5 6 SELECT Sname FROM Student WHERE EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=\u0026#39;1\u0026#39;); 使用存在量词EXISTS后，若内层查询结果非空，则外层的WHERE子句返回真值，否则返回假值。\n由EXISTS引出的子查询，其目标列表达式通常都用*，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。\n本例中子查询的查询条件依赖于外层父查询的某个属性值（Student的Sno值），因此也是相关子查询。这个相关子查询的处理过程是：首先取外层查询中Student表的第一个元组，根据它与内层查询相关的属性值（Sno值）处理内层查询，若WHERE子句返回值为真，则取外层查询中该元组的Sname放入结果表:然后再取Student表的下一个元组； 重复这一过程，直至外层Student表全部检查完为止。 本例中的查询也可以用连接运算来实现，读者可以参照有关的例子自己给出相应的SQL语句。\n与EXISTS谓词相对应的是NOT EXISTS谓词。使用存在量词NOT EXISTS后，若内层查询结果为空，则外层的WHERE子句返回真值，否则返回假值。\n例61：查询没有选修1号课程的学生姓名。\n1 2 3 4 5 6 SELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=\u0026#39;1\u0026#39;); 一些带EXISTS或NOT EXISTS谓词的子查询不能被其他形式的子查询等价替换，但所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换。例如带有IN谓词的例55可以用如下带EXISTS谓词的子查询替换：\n1 2 3 4 5 6 7 SELECT Sno,Sname,Sdept FROM Student SI WHERE EXISTS (SELECT * FROM Student S2 WHERE S2.Sdept=S1.Sdept AND S2.Sname=\u0026#39;刘晨\u0026#39;); 由于带EXISTS量词的相关子查询只关心内层查询是否有返回值，并不需要查具体值，因此其效率并不一定低于不相关子查询，有时是高效的方法。\n例62：查询选修了全部课程的学生姓名。\nSQL中没有全称量词(for all)，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词：\n\\[ (\\forall x)P \\equiv \\lnot (\\exists x( \\lnot P)) \\tag{1} \\] \\(\\lnot (\\exists x( \\lnot P))\\) 由于没有全称量词，可将题目的意思转换成等价的用存在量词的形式：查询这样的学生，没有一门课程是他不选修的。其SQL语句如下：\n1 2 3 4 5 6 7 8 9 10 SELECT Sname FROM Student WHERE NOT EXISTS (SELECT * FROM Course WHERE NOT EXISTS (SELECT * FROM SC WHERE Sno=Student.Sno AND Cno=Course.Cno)); 从而用EXIST/NOT EXIST来实现带全称量词的查询。\n例63：查询至少选修了学生201215122选修的全部课程的学生号码。\n本查询可以用逻辑蕴涵来表达：查询学号为 \\(x\\) 的学生，对所有的课程 \\(y\\) ，只要201215122学生选修了课程y，则x也选修了y。形式化表示如下：\n用 \\(p\\) 表示谓词“学生201215122选修了课程 \\(y\\) ”\n用 \\(q\\) 表示谓词“学生 \\(x\\) 选修了课程 \\(y\\) ”\n则上述查询为\n\\[ (\\forall y)p \\to q \\tag{2} \\] SQL语言中没有蕴涵(implication)逻辑运算，但是可以利用谓词演算将一个逻辑蕴涵的谓词等价转换为\n\\[ p \\to q \\equiv \\lnot p \\lor q \\tag{3} \\] 由式(1)和式(3)该查询可以转换为如下等价形式：\n\\[ (\\forall y)p \\to q \\equiv \\lnot (\\exists x( \\lnot (p \\to q))) \\equiv \\lnot (\\exists x( \\lnot (\\lnot p \\lor q))) \\equiv \\lnot \\exists y(p \\land \\lnot q) \\tag{4} \\] 它所表达的语义为：不存在这样的课程y，学生201215122选修了y，而学生x没有选。用SQL语言表示如下：\n1 2 3 4 5 6 7 8 9 10 11 SELECT DISTINCT Sno FROM SC SCX WHERE NOT EXISTS (SELECT * FROM SC SCY WHERE SCY.Sno=\u0026#39;201215122\u0026#39; AND NOT EXISTS (SELECT * FROM SC SCZ WHERE SCZ.Sno=SCX.Sno AND SCZ.Cno=SCY.Cno)); 集合查询 SELECT语句的查询结果是元组的集合，所以多个SELECT语句的结果可进行集合操作。集合操作主要包括并操作UNION，交操作INTERSECT和差操作EXCEPT。\n注意，参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。\n例64：查询计算机科学系的学生及年龄不大于19岁的学生。\n1 2 3 4 5 6 7 SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; UNION SELECT * FROM Student WHERE Sage\u0026lt;=19; 本查询实际上是求计算机科学系的所有学生与年龄不大于19岁的学生的并集。使用UNION将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用UNION ALL操作符。\n例65：查询选修了课程1或者选修了课程2的学生。\n本例即查询选修课程1的学生集合与选修课程2的学生集合的并集。\n1 2 3 4 5 6 7 SELECT Sno FROM SC WHERE Cno= \u0026#39;1\u0026#39; UNION SELECT Sno FROM SC WHERE Cno=\u0026#39;2\u0026#39;; 例66：查询计算机科学系的学生与年龄不大于19岁的学生的交集。\n1 2 3 4 5 6 7 SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; INTERSECT SELECT * FROM Student WHERE Sage\u0026lt;=19; 这实际上就是查询计算机科学系中年龄不大于19岁的学生。\n1 2 3 4 SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; AND Sage\u0026lt;=19; 例67：查询既选修了课程1又选修了课程2的学生。就是查询选修课程1的学生 集合与选修课程2的学生集合的交集。\n1 2 3 4 5 6 7 SELECT Sno FROM SC WHERE Cno=\u0026#39;1\u0026#39; INTERSECT SELECT Sno FROM SC WHERE Cno=\u0026#39;2\u0026#39;; 本例也可以表示为\n1 2 3 4 5 6 SELECT Sno FROM SC WHERE Cno=\u0026#39;1\u0026#39; AND Sno IN (SELECT Sno FROM SC WHERE Cno=\u0026#39;2\u0026#39;); 例68：查询计算机科学系的学生与年龄不大于19岁的学生的差集。\n1 2 3 4 5 6 7 SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; EXCEPT SELECT * FROM Student WHERE Sage \u0026lt;=19; 也就是查询计算机科学系中年龄大于19岁的学生。\n1 2 3 SELECT * FROM Student WHERE Sdept=\u0026#39;CS\u0026#39; AND Sage\u0026gt;19; 基于派生表的查询 子查询不仅可以出现在WHERE子句中，还可以出现在FROM子句中，这时子查询生成的临时派生表(derived table)成为主查询的查询对象。例如，例57找出每个学生超过他自己选修课程平均成绩的课程号，也可以用如下的查询完成：\n1 2 3 4 SELECT Sno, Cno FROM SC, (SELECT Sno, Avg(Grade) FROM SC GROUP BY Sno) AS Avg_sc(avg_sno,avg_grade) WHERE SC.Sno = Avg_sc.avg_sno and SC.Grade \u0026gt;= Avg_sc.avg_grade 这里FROM子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出修课成绩大于其平均成绩的课程号。 如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列 名为其默认属性。例如例60查询所有选修了1号课程的学生姓名，可以用如下查询完成：\n1 2 3 SELECT Sname FROM Student, (SELECT Sno FROM SC WHERE Cno=\u0026#39;1\u0026#39;) AS SC1 WHERE Student.Sno=SC1.Sno; 需要说明的是，通过FROM子句生成派生表时，AS关键字可以省略，但必须为派生关系指定一个别名。而对于基本表，别名是可选择项。\nSELECT语句的一般格式 SELECT语句是SQL的核心语句，从前面的例子可以看到其语句成分丰富多样，下面总结一下它们的一般格式。\nSELECT语句的一般格式：\n1 2 3 4 5 SELECT [ALL|DISTINCT] \u0026lt;目标列表达式\u0026gt; [别名][,\u0026lt;目标列表达式\u0026gt; [别名]]··· FROM \u0026lt;表名或视图名\u0026gt; [别名][,\u0026lt;表名或视图名\u0026gt; [别名]]···| (\u0026lt;SELECT语句\u0026gt;)[AS] \u0026lt;别名\u0026gt; [WHERE \u0026lt;条件表达式\u0026gt;] [GROUP BY \u0026lt;列名 1\u0026gt; [HAVING \u0026lt;条件表达式\u0026gt;]] [ORDER BY \u0026lt;列名 2\u0026gt; [ASC|DESC]]; 目标列表达式的可选格式 (1)*\n(2)\u0026lt;表名\u0026gt;.*\n(3)COUNT([DISTINCT|ALL] *)\n(4)\u0026lt;表名\u0026gt;.] \u0026lt;属性列名表达式\u0026gt; [,[\u0026lt;表名\u0026gt;.] \u0026lt;属性列名表达式\u0026gt;]···\n其中，\u0026lt;属性列名表达式\u0026gt;可以是由属性列、作用于属性列的聚集函数和常量的任意算术运算（+、-、*、/）组成的运算公式。\n聚集函数的一般格式 \u0026emsp;\u0026emsp;\\(\\displaystyle \\begin{Bmatrix} \\textsf{COUNT} \\\\[5pt] \\textsf{SUM} \\\\[5pt] \\textsf{AVG} \\\\[5pt] \\textsf{MAX} \\\\[5pt] \\textsf{MIN} \\end{Bmatrix}\\space \\textsf{[DISTINCT|ALL] }\\text{\u003c列名\u003e} \\) WHERE子句的条件表达式的可选格式 (1)\n\u0026emsp;\u0026emsp;\\( \\text{\u003c属性列名\u003e}\\space\\theta\\space \\begin{Bmatrix} \\text{\u003c属性列名\u003e}\\\\[5pt] \\text{\u003c常量\u003e}\\\\[5pt] [\\textsf{ANY}|\\textsf{ALL}]\\space(\\textsf{SELECT}\\text{子句}) \\end{Bmatrix} \\) (2)\n\u0026emsp;\u0026emsp;\\( \\text{\u003c属性列名\u003e}\\space[\\textsf{NOT}]\\space\\textsf{BETWEEN}\\space \\begin{Bmatrix} \\text{\u003c属性列名\u003e}\\\\[5pt] \\text{\u003c常量\u003e}\\\\[5pt] (\\textsf{SELECT}\\text{语句}) \\end{Bmatrix} \\space\\textsf{AND}\\space \\begin{Bmatrix} \\text{\u003c属性列名\u003e}\\\\[5pt] \\text{\u003c常量\u003e}\\\\[5pt] (\\textsf{SELECT}\\text{语句}) \\end{Bmatrix} \\) (3)\n\u0026emsp;\u0026emsp;\\( \\text{\u003c属性列名\u003e}\\space[\\textsf{NOT}]\\space\\textsf{IN}\\space \\begin{Bmatrix} (\\text{\u003c值1\u003e}[,\\text{\u003c值2\u003e}]\\cdots)\\\\[5pt] (\\textsf{SELECT}\\text{语句}) \\end{Bmatrix} \\) (4)\u0026lt;属性列名\u0026gt; [NOT] LIKE \u0026lt;匹配串\u0026gt;\n(5)\u0026lt;属性列名\u0026gt; IS [NOT] NULL\n(6)[NOT] EXISTS(SELECT语句)\n(7)\n\u0026emsp;\u0026emsp;\\( \\text{\u003c条件表达式\u003e}\\space \\begin{Bmatrix} \\textsf{AND}\\\\[5pt] \\textsf{OR} \\end{Bmatrix} \\space\\text{\u003c条件表达式\u003e}\\space \\left( \\begin{Bmatrix} \\textsf{AND}\\\\[5pt] \\textsf{OR} \\end{Bmatrix} \\text{\u003c条件表达式\u003e}\\cdots \\right) \\) 数据更新 数据更新操作有三种：向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。在SQL中有相应的三类语句。\n插入数据 SQL的数据插入语句INSERT通常有两种形式，一种是插入一个元组，另一种是插入子查询结果。后者可以一次插入多个元组。\n插入元组 插入元组的INSERT语句的格式为\n1 2 3 INSERT INTO \u0026lt;表名\u0026gt; [(\u0026lt;属性列1\u0026gt; [,\u0026lt;属性列2\u0026gt;] ···)] VALUES (\u0026lt;常量 1\u0026gt; [,常量 2\u0026gt;]···); 其功能是将新元组插入指定表中。其中新元组的属性列1的值为常量1，属性列2的值为常量2，···。INTO子句中没有出现的属性列，新元组在这些列上将取空值。但必须注意的是，在表定义时说明了NOT NULL的属性列不能取空值，否则会出错。\n如果INTO子句中没有指明任何属性列名，则新插入的元组必须在每个属性列上均有值。\n例69：将一个新学生元组（学号：201215128；姓名：陈冬；性别：男；所在系： IS；年龄：18岁）插入到Student表中。\n1 2 3 INSERT INTO Student (Sno,Sname,Ssex,Sdept,Sage） VALUES (\u0026#39;201215128\u0026#39;,\u0026#39;陈冬\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;IS\u0026#39;, 18); 在INTO子句中指出了表名Student,并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与CREATE TABLE中的顺序不一样。VALUES子句对新元组的各属性赋值，字符串常数要用单引号（英文符号）括起来。\n例70将学生张成民的信息插入到Student表中。\n1 2 3 INSERT INTO Student VALUES (\u0026#39;201215126\u0026#39;,\u0026#39;张成民\u0026#39;,\u0026#39;男\u0026#39;,18,\u0026#39;CS\u0026#39;); 与例69的不同是在INTO子句中只指出了表名，没有指出属性名。这表示新元组要 在表的所有属性列上都指定值，属性列的次序与CREATE TABLE中的次序相同。VALUES 子句对新元组的各属性列赋值，一定要注意值与属性列要一一对应，如果像例69那样，成为（201215126\u0026rsquo;,\u0026lsquo;张成民,\u0026rsquo;,男,\u0026rsquo;,CS,18），则含义是将CS赋予了列Sage，而18赋予了列Sdept，这样则会因为数据类型不匹配出错。\n例71：例72插入一条选课记录('201215128','1')。\n1 2 3 INSERT INTO SC(Sno,Cno) VALUES (\u0026#39;201215128\u0026#39;,\u0026#39;1\u0026#39;); 关系数据库管理系统将在新插入记录的Grade列上自动地赋空值。 或者：\n1 2 3 INSERT INTO SC VALUES (\u0026#39;201215128\u0026#39;,\u0026#39;1\u0026#39;,NULL); 因为没有指出SC的属性名，在Grade列上要明确给出空值。\n插入子查询结果 子查询不仅可以嵌套在SELECT语句中用以构造父查询的条件， 也可以嵌套在INSERT语句中用以生成要插入的批量数据。\n插入子查询结果的INSERT语句格式为\n1 2 3 INSERT INTO \u0026lt;表名\u0026gt; [(\u0026lt;属性列1\u0026gt; [,\u0026lt;属性列2\u0026gt;···])] 子查询 例73：对每一个系，求学生的平均年龄，并把结果存入数据库。\n首先在数据库中建立一个新表，其中一列存放系名，另一列存放相应的学生平均年龄。\n1 2 3 CREATE TABLE Dept_age (Sdept CHAR(15) Avg_age SMALLINT); 然后对Student表按系分组求平均年龄，再把系名和平均年龄存入新表中。\n1 2 3 4 5 INSERT INTO Dept_age(Sdept,Avg_age) SELECT Sdept,AVG(Sage) FROM Student GROUP BY Sdept; 修改数据 修改操作又称为更新操作，其语句的一般格式为\n1 2 3 UPDATE \u0026lt;表名\u0026gt; SET \u0026lt;列名\u0026gt;=\u0026lt;表达式\u0026gt; [,\u0026lt;列名\u0026gt;=\u0026lt;表达式\u0026gt;]··· [WHERE \u0026lt;条件\u0026gt;]; 其功能是修改指定表中满足WHERE子句条件的元组。其中SET子句给出\u0026lt;表达式\u0026gt;的值 用于取代相应的属性列值。如果省略WHERE子句，则表示要修改表中的所有元组。\n修改某一个元组的值 例74：将学生201215121的年龄改为22岁。\n1 2 3 UPDATE Student SET Sage=22 WHERE Sno=\u0026#39;201215121\u0026#39;; 修改多个元组的值 例75：将所有学生的年龄增加1岁。\n1 2 UPDATE Student SET Sage=Sage+1; 带子查询的修改语句 子查询也可以嵌套在UPDATE语句中，用以构造修改的条件。\n例76：将计算机科学系全体学生的成绩置零。\n1 2 3 4 5 6 UPDATE SC SET Grade=O WHERE Sno IN (SELETE Sno FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;); 删除数据 删除语句的一般格式为\n1 2 3 DELETE FROM \u0026lt;表名\u0026gt; [WHERE \u0026lt;条件\u0026gt;]; DELETE语句的功能是从指定表中删除满足WHERE子句条件的所有元组。如果省略WHERE子句则表示删除表中全部元组，但表的定义仍在字典中。也就是说，DELETE语句删除的是表中的数据，而不是关于表的定义。\n删除某一个元组的值 例77：删除学号为201215128的学生记录。\n1 2 3 DELETE FROM Student WHERE Sno=\u0026#39;201215128\u0026#39;; 删除多个元组的值 删除所有的学生选课记录。\n1 2 DELETE FROM SC; 这条DELETE语句将使SC成为空表，它删除了SC的所有元组。\n带子查询的删除语句 子查询同样也可以嵌套在DELETE语句中，用以构造执行删除操作的条件。\n例78删除计算机科学系所有学生的选课记录。\n1 2 3 4 5 6 DELETE FROM SC WHERE Sno IN (SELECT Sno FROM Student WHERE Sdept=\u0026#39;CS\u0026#39;); 空值的处理 前面己经多处提到空值(NULL)的概念和空值的处理，这里再系统介绍一下这个问题。所谓空值就是“不知道”或“不存在”或\u0026quot;无意义”的值。SQL语言中允许某些元组 的某些属性在一定情况下取空值。一般有以下几种情况：\n◦该属性应该有一个值，但目前不知道它的具体值。例如，某学生的年龄属性，因为 学生登记表漏填了，不知道该学生年龄，因此取空值。\n◦该属性不应该有值。例如，缺考学生的成绩为空，因为他没有参加考试。\n◦由于某种原因不便于填写。例如，一个人的电话号码不想让大家知道，则取空值。\n因此，空值是一个很特殊的值，含有不确定性，对关系运算带来特殊的问题，需要做特殊的处理。\n空值的产生 例79：向SC表中插入一个元组，学生号是“201215126”，课程号是\u0026quot;1”，成绩为空。\n1 2 3 INSERT INTO SC(Sno,Cno,Grade) VALUES(\u0026#39;201215126\u0026#39;, \u0026#39;1\u0026#39;, NULL); /*在插入时该学生还没有考试成绩，取空值*/ 或\n1 2 3 INSERT INTO SC(Sno.Cno) VALUES(1201215126\u0026#39;,\u0026#39;1\u0026#39;); /*在插入语句中没有赋值的属性，其值为空值*/ 例80将Student表中学生号为“201215200”的学生所属的系改为空值。\n1 2 3 UPDATE Student SET Sdept = NULL WHERE Sno=\u0026#39;201215200\u0026#39;; 另外，外连接也会产生空值，参见外连接。空值的关系运算也会产生空值。\n空值的判断 判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示。\n例81：从Student表中找出漏填了数据的学生信息。\n1 2 3 SELECT * FROM Student WHERE Sname IS NULL OR Ssex IS NULL OR Sage IS NULL OR Sdept IS NULL; 空值的约束条件 属性定义（或者域定义）中有NOT NULL约束条件的不能取空值，加了 UNIQUE限制的属性不能取空值，码属性不能取空值。\n空值的算术运算，比较运算和逻辑运算 空值与另一个值（包括另一个空值）的算术运算的结果为空值，空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。有了UNKNOWN后，传统的逻辑运算中二值(TRUE, FALSE)逻辑就扩展成了三值逻辑。\nAND、OR、NOT的真值表如表27所示，其中T表示TRUE, F表示FALSE，U表示UNKNOWN。\n在查询语句中，只有使WHERE和HAVING子句中的选择条件为TRUE的元组才被选出作为输出结果。\nx y x AND y x OR y NOT x T T T T F T U U T F T F F T F U T U T U U U U U U U F F U U F T F T T F U F U T F F F F T 表27\u0026emsp;扩展后的逻辑运算符真值表\n在查询语句中，只有使WHERE和HAVING子句中的选择条件为TRUE的元组才被选出作为输出结果。\n例82：找出选修1号课程的不及格的学生。\n1 2 3 SELECT Sno FROM SC WHERE Grade \u0026lt; 60 AND Cno=\u0026#39;1\u0026#39;; 选出的学生是那些参加了考试（Grade属性为非空值）而不及格的学生，不包括缺考的学生。因为前者使条件Grade\u0026lt;60的值为TRUE，后者使条件的值为UNKNOWN。\n例83：选出选修1号课程的不及格的学生以及缺考的学生。\n1 2 3 4 5 6 7 SELECT Sno FROM SC WHERE Grade \u0026lt; 60 AND Cno=\u0026#39;1\u0026#39; UNION SELECT Sno FROM SC WHERE Grade IS NULL AND Cno=\u0026#39;1\u0026#39;; 或\n1 2 3 SELECT Sno FROM SC WHERE Cno=T AND (Grade \u0026lt; 60 OR Grade IS NULL); 视图 视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。\n视图一经定义，就可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但对视图的更新（增、删、改）操作则有一定的限制。\n本节专门讨论视图的定义、操作及作用。\n定义视图 建立视图 SQL语言用CREATE VIEW命令建立视图，其一般格式为\n1 2 3 CREATE VIEW \u0026lt;视图名\u0026gt; [(\u0026lt;列名\u0026gt; [,\u0026lt;列名\u0026gt;]···)] AS \u0026lt;子查询\u0026gt; [WITH CHECK OPTION]; 其中，子查询可以是任意的SELECT语句，是否可以含有ORDER BY子句和DISTINCT短语，则取决于具体系统的实现。\nWITH CHECK OPTION表示对视图进行UPDATE、INSERT和DELETE操作时要保证更新、插入或删除的行满足视图定义中的谓词条件（即子查询中的条件表达式）。\n组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中SELECT子句目标列中的诸字段组成但在下列三种情况下必须明确指定组成视图的所有列名：\n(1)某个目标列不是单纯的属性名，而是聚集函数或列表达式。\n(2)多表连接时选出了几个同名列作为视图的字段。\n(3)需要在视图中为某个列启用新的更合适的名字。\n例84：建立信息系学生的视图。\n1 2 3 4 5 CREATE VIEW IS_Student AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=\u0026#39;IS\u0026#39;; 本例中省略了视图IS_Student的列名，隐含了由子查询中SELECT子句中的三个列名组成。\n关系数据库管理系统执行CREATE VIEW语句的结果只是把视图的定义存入数据字典，并不执行其中的SELECT语句。只是在对视图查询时，才按视图的定义从基本表中将数据查出。\n例85：建立信息系学生的视图，并要求进行修改和插入操作时仍需保证该视图只有信息系的学生。\n1 2 3 4 5 6 CREATE VIEW IS_Student AS SELECT Sno,Sname,Sage FROM Student WHERE Sdept=\u0026#39;IS\u0026#39; WITH CHECK OPTION; 由于在定义IS_Student视图时加上了WITH CHECK OPTION子句，以后对该视图进行插入、修改和删除操作时，关系数据库管理系统会自动加上Sdept=IS的条件。\n若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图。IS_Student视图就是一个行列子集视图。\n视图不仅可以建立在单个基本表上，也可以建立在多个基本表上。\n例86：建立信息系选修了1号课程的学生的视图（包括学号、姓名、成绩）。\n1 2 3 4 5 6 7 CREATE VIEW IS_S1(Sno,Sname,Grade) AS SELECT Student.Sno,Sname,Grade FROM Student,SC WHERE Sdept=\u0026#39;IS\u0026#39; AND Student.Sno=SC.Sno AND SC.Cno=\u0026#39;1\u0026#39;; 由于视图IS_S1的属性列中包含了Student表与SC表的同名列Sno，所以必须在视图名后面明确说明视图的各个属性列名。\n视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个己定义好的视图上，或建立在基本表与视图上。\n例87：建立信息系选修了1号课程且成绩在90分以上的学生的视图。\n1 2 3 4 5 CREATE VIEW IS_S2 AS SELECT Sno,Sname,Grade FROM IS_S1 WHERE Grade\u0026gt;=90; 这里的视图IS_S2就是建立在视图IS_S1之上的。\n定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生出的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要设置一些派生属性列。这些派生属性由于在基本表中并不实际存在，也称它们为虚拟列。带虚拟列的视图也称为带表达式的视图。\n例88：定义一个反映学生出生年份的视图。\n1 2 3 CREATE VIEW BT_S(Sno,Sname,Sbirth) SELECT Sno,Sname,2014-Sage FROM Student; 这里视图BT_S是一个带表达式的视图。视图中的出生年份值是通过计算得到的。\n还可以用带有聚集函数和GROUP BY子句的查询来定义视图，这种视图称为分组视图。\n例89：将学生的学号及平均成绩定义为一个视图。\n1 2 3 4 5 CREATE VIEW S_G(Sno,Gavg) AS SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno; 由于AS子句中SELECT语句的目标列平均成绩是通过作用聚集函数得到的，所以CREATE VIEW中必须明确定义组成S_G视图的各个属性列名。S_G是一个分组视图。\n例90：将Student表中所有女生记录定义为一个视图。\n1 2 3 4 5 CREATE VIEW F_Student(F_sno,name,sex,age,dept) AS SELECT * FROM Student WHERE Ssex=\u0026#39;女\u0026#39;; 这里视图F_Student是由子查询“SELECT *”建立的。F_Student视图的属性列与Student表的属性列一一对应。如果以后修改了基本表Student的结构，则Student表与F_Student视图的映像关系就会被破坏，该视图就不能正常工作了。为避免出现这类问题，最好在修改基本表之后删除由该基本表导出的视图，然后重建这个视图。\n删除视图 该语句的格式为\n1 DROP VIEW \u0026lt;视图名\u0026gt; [CASCADE]; 视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用CASCADE级联删除语句把该视图和由它导出的所有视图一起删除。\n基本表删除后，由该基本表导出的所有视图均无法使用了，但是视图的定义没有从字典中清除。删除这些视图定义需要显式地使用DROP VIEW语句。\n例91：删除视图BT_S和视图IS_SI。\n1 2 DROP VIEW BT_S; /*成功执行*/ DROP VIEW IS_S1; /*拒绝执行*/ 执行此语句时由于1S_S1视图上还导出了IS_S2视图，所以该语句被拒绝执行。如果确定要删除，则使用级联删除语句：\n1 DROPVIEWIS_S1 CASCADE; /*删除了视图IS_S1和由它导出的所有视图*/ 查询视图 视图定义后，用户就可以像对基本表一样对视图进行查询了。\n例92：在信息系学生的视图中找出年龄小于20岁的学生。\n1 2 3 SELECT Sno,Sage FROM IS_Student WHERE Sage\u0026lt;20; 关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解(view resolution)。\n本例转换后的查询语句为\n1 2 3 SELECT Sno,Sage FROM Student WHERE Sdept=\u0026#39;IS\u0026#39; AND Sage\u0026lt;20; 例93：查询选修了 1号课程的信息系学生。\n1 2 3 SELECT IS_Student.Sno,Sname FROM IS_Student,SC WHERE IS_Student.Sno=SC.Sno AND SC.Cno=\u0026#39;1\u0026#39;; 本查询涉及视图IS_Student（虚表）和基本表SC，通过这两个表的连接来完成用户请求。在一般情况下，视图查询的转换是直截了当的。但有些情况下，这种转换不能直接进行，查询时就会出现问题，如例94。\n例94：在S_G视图（例89中定义的视图）中查询平均成绩在90分以上的学生学号和平均成绩，语句为\n1 2 3 SELECT * FROM S_G WHERE Gavg\u0026gt;=90; 例3.89中定义S_G视图的子查询为\n1 2 3 SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno; 将本例中的查询语句与定义S_G视图的子查询结合，形成下列查询语句：\n1 2 3 4 SELECT Sno,AVG(Grade) FROM SC WHERE AVG(Grade)\u0026gt;=90 GROUP BY Sno; 因为WHERE子句中是不能用聚集函数作为条件表达式的，因此执行此修正后的查询将会出现语法错误。正确转换的查询语句应该是\n1 2 3 4 SELECT Sno,AVG(Grade) FROM SC GROUP BY Sno HAVING AVG(Grade)\u0026gt;=90; 目前多数关系数据库系统对行列子集视图的查询均能进行正确转换。但对非行列子集视图的查询（如例94）就不一定能做转换了，因此这类查询应该直接对基本表进行。\n例94也可以用如下SQL语句完成：\n1 2 3 4 5 SELECT * FROM (SELECT Sno,AVG(Grade) /*子查询生成一个派生表 S_G*/ FROM SC GROUP BY Sno) AS S_G(Sno, Gavg) WHERE Gavg\u0026gt;=90; 但定义视图并查询视图与基于派生表的查询是有区别的。视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而派生表只是在语句执行时临时定义，语句执行后该定义即被删除。\n更新视图 更新视图是指通过视图来插入（INSERT）、删除（DELETE）和修改（UPDATE）数据。\n由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。为防止用户通过视图对数据进行增加、删除、修改时，有意无意地对不属于视图范围内的基本表数据进行操作，可在定义视图时加上WITH CHECK OPTION子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则 拒绝执行该操作。\n例95：将信息系学生视图IS_Student中学号为“201215122”的学生姓名改为\u0026quot;刘辰”。\n1 2 3 UPDATE IS_Student SET Sname=\u0026#39;刘辰\u0026#39; WHERE Sno=\u0026#39;201215122\u0026#39;; 转换后的更新语句为\n1 2 3 UPDATE Student SET Sname=\u0026#39;刘辰\u0026#39; WHERE Sno=\u0026#39;201215122\u0026#39; AND Sdept=\u0026#39;IS\u0026#39;; 例96向信息系学生视图IS_Student中插入一个新的学生记录，其中学号为 “201215129”，姓名为“赵新”，年龄为20岁。\n1 2 3 INSERT INTO IS_Student VALUES (\u0026#39;201215129\u0026#39;,\u0026#39;赵新\u0026#39;,\u0026#39;20\u0026#39;); 转换为对基本表的更新：\n1 2 3 INSERT INTO Student (Sno,Sname,Sage,Sdept) VALUES(\u0026#39;201215129\u0026#39;,\u0026#39;赵新\u0026#39;,20,\u0026#39;IS\u0026#39;); 这里系统自动将系名'IS'放入VALUES子句中。\n例97：删除信息系学生视图IS_Student中学号为\u0026quot;201215129\u0026quot;的记录。\n1 2 3 DELETE FROM IS Student WHERE Sno=\u0026#39;201215129\u0026#39;; 转换为对基本表的更新：\n1 2 3 DELETE FROM Student WHERE Sno=\u0026#39;201215129\u0026#39; AND Sdept=\u0026#39;IS\u0026#39;; 在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一地有意义地转换成对相应基本表的更新。\n例如，例89定义的视图S_G是由学号和平均成绩两个属性列组成的，其中平均成绩一项是由Student表中对元组分组后计算平均值得来的。\n1 2 3 4 5 CREATE VIEW S_G (Sno,Gavg) AS SELECT Sno,AVG (Grade) FROM SC GROUP BY Sno; 如果想把视图S_G中学号为“201215121”的学生的平均成绩改成90分，SQL语句如下：\n1 2 3 UPDATE S_G SET Gavg=90 WHERE Sno=\u0026#39;20121512\u0026#39;; 但这个对视图的更新是无法转换成对基本表SC的更新的，因为系统无法修改各科成绩，以使平均成绩成为90。所以S_G视图是不可更新的。\n一般地，行列子集视图是可更新的。除行列子集视图外，有些视图理论上是可更新的，但它们的确切特征还是尚待研究的课题。还有些视图从理论上就是不可更新的。\n目前，各个关系数据库管理系统一般都只允许对行列子集视图进行更新，而且各个系统对视图的更新还有更进一步的规定。由于各系统实现方法上的差异，这些规定也不尽相同。\n例如，DB2规定：\n(1)若视图是由两个以上基本表导出的，则此视图不允许更新。\n(2)若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。\n(3)若视图的字段来自聚集函数，则此视图不允许更新。\n(4)若视图定义中含有GROUP BY子句，则此视图不允许更新。\n(5)若视图定义中含有DISTINCT短语，则此视图不允许更新。\n(6)若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如，将SC表中成绩在平均成绩之上的元组定义成一个视图GOOD_SC：\n1 2 3 4 5 6 7 CREATE VIEW GOOD SC AS SELECT Sno,Cno,Grade FROM SC WHERE Grade \u0026gt; (SELECT AVG(Grade) FROM SC); 导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。\n(7)一个不允许更新的视图上定义的视图也不允许更新。 应该指出的是，不可更新的视图与不允许更新的视图是两个不同的概念。前者指理论上已证明其是不可更新的视图。后者指实际系统中不支持其更新，但它本身有可能是可更新的视图。\n视图的作用 视图最终是定义在基本表之上的，对视图的一切操作最终也要转换为对基本表的操作。而且对于非行列子集视图进行查询或更新时还有可能出现问题。既然如此，为什么还要定义视图呢？这是因为合理使用视图能够带来许多好处。\n视图能够简化用户的操作 视图机制使用户可以将注意力集中在所关心的数据上。如果这些数据不是直接来自基本表，则可以通过定义视图使数据库看起来结构简单、清晰，并且可以简化用户的数据查询操作。 例如，那些定义了若干张表连接的视图就将表与表之间的连接操作对用户隐蔽起来了。换句话说，用户所做的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无须了解。\n视图使用户能以多种角度看待同一数据 视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常重要的。\n视图对重构数据库提供了一定程度的逻辑独立性 在数据库系统概论中已经介绍过数据的物理独立性与逻辑独立性的概念。数据的物理独立性是指 用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时， 如增加新的关系或对原有关系增加新的字段等，用户的应用程序不会受影响。层次数据库 和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全地支持。在关系数据库中，数据库的重构往往是不可避免的。重构数据库最常见的是将一个基 本表\u0026quot;垂直\u0026quot;地分成多个基本表。例如：将学生关系\n1 Student(Sno,Sname,Ssex,Sage,Sdept) 分为SX(Sno, Sname, Sage)和SY(Sno, Ssex, Sdept)两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student：\n1 2 3 4 5 CREATE VIEW Student(Sno,Sname,Ssex,Sage,Sdept) AS SELECT SX.Sno,SX.Sname,SY.Ssex,SX.Sage,SY.Sdept FROM SX.SY WHERE SX.Sno=SY.Sno; 这样尽管数据库的逻辑结构改变了（变为SX和SY两个表），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。\n当然，视图只能在一定程度上提供数据的逻辑独立性，比如由于对视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因基本表结构的改变而需要做相应修改。\n视图能够对机密数据提供安全保护 有了视图机制，就可以在设计数据库应用系统时对不同的用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系的学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本院系的学生视图。\n适当利用视图可以更清晰地表达查询 例如，经常需要执行这样的查询“对每个同学找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩：\n1 2 3 4 5 CREATE VIEW VMGRADE AS SELECT Sno.MAX(Grade) Mgrade FROM SC GROUP BY Sno; 然后用如下的查询语句完成查询：\n1 2 3 SELECT SC.Sno,Cno FROM SC, VMGRADE WHERE SC.Sno=VMGRADE.Sno AND SC.Grade=VMGRADE.Mgrade; 不要温和地走进那个良夜。 ― 迪兰·托马斯 ","date":"2024-11-11T17:45:02+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/database_system/the_standard_language_for_relational_database_sql/","title":"数据库系统（三）：关系数据库标准语言SQL"},{"content":" 集合及其运算 在本篇里，首先非形式地讨论集合论的基本概念：集合及其元素，以及元素与集合间的属于关系，集合的表示方法。然后，利用这些基本概念定义集合的子集、幂集、集合相等。接着定义集合间的运算:并、交、差、对称差、集的余集、笛卡儿乘积，并讨论每种运算所满足的运算规律以及它们之间的联系。最后，介绍有穷集合的基数与基本的计数法则。\n集合的概念 \u0026ldquo;集合”是集合论中的一个原始概念，原始概念是不能被精确定义的，因为我们没有比它更原始的概念。因此，我们只给出集合这个概念的一种非形式的描述，说明这个概念的含义。这正如同欧几里德几何中的“点”不加定义，而作为原始概念之一一样。\n集合 通常把一些互不相同的东西放在一起所形成的整体就叫做一个集合，简称集。构成集合的每一个东西，称为这个集合的一个成员。构成集合的这些成员可以是具体的东西，也可以是抽象东西。例如，某教室里的所有学生形成的整体就是一个集合。全体自然数构成的整体也是一个集合。程序设计语言C的基本字符的全体也形成一个集合。集合的概念是如此的普遍和原始，以致于有许多同义语，如“全体”“汇集”等等。\n元素 当抽象讨论集合时，任何一个东西称为元素，元素是可区分的。构成集合的那些成员就是集的元素。于是，任一元素，对给定的集合,要么这个元素是该集合的一个（成员）元素，要么就不是该集合的一个成员，两者必有一个成立，但不能都成立。通常我们用大写的英文字母或大写的希腊字母代替该集合。如果给定一个集合 \\(A\\) 和一个元素 \\(a\\) ， \\(a\\) 是 \\(A\\) 的一个成员（元素），即 \\(a\\) 属于 \\(A\\) ，就记 \\(a \\in A\\) 。否则，若 \\(a\\) 不属 \\(A\\) ，就记为 \\(a \\notin A\\) 。 \\(a \\in A\\) 读成 “ \\(a\\) 属于 \\(A\\) ”，而 \\(a \\notin A\\) 读成“ \\(a\\) 不属于 \\(A\\) ”。\n例1：设 \\(N\\) 为全体自然数（正整数）之集，则\n\\[ 7 \\in N,2^7\\in N,1024 \\in N \\tag{1} \\] 而\n\\[ 0 \\notin N,\\frac{1}{2} \\notin N,\\sqrt{2} \\notin N,-3\\notin N \\tag{2} \\] 于是，是，集合是由一些东西（或事物、对象，统称为元素）构成的，构成集合的每个东西叫做集合的成员。集合的成员与集合间有属于关系“ \\(\\in\\) ”。这样，集合、元素、属于关系就是集合论中三个原始概念,它们不能精确地形式定义。集合论中的其他概念均可用这三个原始概念加以定义。\n集合的表示 有两种方法表示一个集合。最自然的方法是把构成集合的那些元素全列出来，元素之间用逗号\u0026rdquo;，”隔开，并用花括号“ \\(\\{\\) ”与“ \\(\\}\\) ”在两边括起来以表示这些元素构成整体。例如，由 \\(1,2,3\\) 三个自然数构成的集合就记成 \\(\\set{1,2,3}\\) 。花括号把 \\(1,2,3\\) 括在里面使它们组成一个整体。不过，在集合的概念里我们只要求构成集合的那些元素是互不相同的，而与它们在集合中出现的次序无关。因此，集合中的每个元素只能出现一次，至于先写出哪一个无关紧要。于是， \\(\\set{1,2,3}\\) 与 \\(\\set{3,1,2}\\) 表示了同一个集合。\n一般说来，仅由少数元素构成的集合才能用列出它的全部元素的方法表示该集合。对于有穷（也说有限）多个元素，原则上这个方法也是可行的，但元素的个数很大时，列出这些元素在实际上是不可行的。不过在具体问题中借助于其他知识，只列出其几个元素后就可知道组成集合的那些元素。例如，由26个小写英文字母 \\(a,b,c,\\cdots,x,y,z\\) 构成的集合就可记为\n\\[ \\set{a,b,c,\\cdots,x,y,z} \\tag{3} \\] 其中的“ \\(\\cdots\\) ”就表示了那些未列出的字母，而不是说\u0026quot;…”也是一个元素。在这里，我们利用小写字母在英文字母表中的顺序的知识，就知道了未列出的那些字母是什么。利用此方法有时甚至可以表示某些由无穷多个元素组成的集合。例如，全体自然数构成的集合 \\(N\\) 就可以写成\n\\[ \\set{1,2,3} \\tag{4} \\] 这里借用了人们的已有知识\u0026mdash;\u0026mdash;自然数的顺序，只列出了前三个自然数，其后的自然数用“…”代替。\n用上述方法表示集合很直观，哪些元素是集合的成员一望可知,但集合的这种表示方法的表达能力是有局限的。有些集合很难或不能用这种方法表示，例如，区间 \\((0,1)\\) 中的所有实数组成的集合就不能用这种方法表示。实际上，这个集合是“大于或等于零且小于或等于1”的一切实数构成的。而在实际应用中，往往把具有某种性质的一些对象集合在一起形成一个集合，为此引入集合的另一表示法，这种方法是用概括集合中各元素的属性来表示集合。设x为某类对象的一般表示， \\(P(x)\\) 为关于 \\(x\\) 的一命题，则我们用\n\\[ \\set{x|P(x)} \\tag{5} \\] 表示“使 \\(P(x)\\) 成立的对象 \\(x\\) 所组成的集合”。其中竖线“|”前写的是对象的一般表示，右边写出它应满足（具有）的属性。\n例2：所有偶自然数之集合 \\(E\\) 可记为\n\\[ \\set{m|2|m且m \\in N} \\tag{6} \\] 其中 \\(2|m\\) 表示 \\(2\\) 能整除 \\(m\\) 。\n例3： \\([0,1]\\) 上的所有连续函数之集 \\(C_{[0,1]}\\) 可记成\n\\[ \\set{f(x)|f(x)在(0,1)上连续} \\tag{7} \\] 易见，集合的第二种表示法较方便，它给出了组成集合的各元素所具有性质，因此它能告诉我们更多的信息。\n有穷集合和无穷集合 由有限个元素构成的集合叫做有限集合，或有穷集。由无穷多个元素组成的集合叫做无穷集合。有穷集的一个特例是仅由一个元素形成的集合,称为单元素集。例如，方程\n\\[ x^3-x^2+x-1=0 \\tag{8} \\] 的实根构成的集合就是单元素集。注意，不要把单元素集 \\(\\set{x}\\) 与 它的唯一元素 \\(x\\) 混为一谈，否则会引出矛盾。例如， \\(x \\in {x}\\) 有意义， 但 \\(x \\in x\\) 是无意义的。\n空集 在实际的具体问题中，常涉及具有某种性质的对象全体形成的集合，这样的集合也参加运算。但事先不知道是否存在这种性质的元素，如果后来发现这种元素不存在，那么具有这种性质的元素之集合中就不包含任何元素。于是，有必要引入一个不含任何元素的集合。不含任何元素的集合叫做空集，记为 \\(\\varnothing\\) 。我们假定空集是存在的，例如，方程\n\\[ x^2+1=0 \\tag{9} \\] 的实根之集是空集。空集的引入可以使许多问题的叙述得以简化。\n子集、集合的相等 “集合”、“元素”、元素与集合间的“属于”关系是三个没有精确定义的原始概念，对它们仅给出了直观的描述，以说明它们的各自含义。本节利用这三个概念定义集合的子集、集合间的包含关系、集合的相等、幕集、集族等概念。\n集合的包含 定义1：设 \\(A\\) 和 \\(B\\) 是两个集合，如果集合 \\(A\\) 中的每个元素都是 \\(B\\) 的元素，则称 \\(A\\) 是 \\(B\\) 的子集合。简称子集。这是我们说 \\(A\\) 包含在 \\(B\\) 里，或 \\(B\\) 包含着 \\(A\\) 。 \\(A\\) 是 \\(B\\) 的子集记为 \\(A \\sube B\\) 或 \\(B \\supe A\\) 。\n由定义可知， \\(A \\sube B\\) 当且仅当对 \\(A\\) 的每个元素 \\(x\\) 均有 \\(x \\in B\\) 。以后常用记号 \\(\\Harr\\) 表示“当且仅当”；用“ \\(\\forall x \\cdots\\) ”表示“对所有的 \\(x\\) ···”；“ \\(\\exist x \\cdots\\) ”表示“存在一个 \\(x\\) ···”。于是 \\(\\forall x \\in A\\) 就读做对 \\(A\\) 的所有元素 \\(x\\) 。于是\n\\[ A \\sube B \\Harr \\forall x \\in A,x \\in B \\tag{10} \\] 或等价地\n\\[ A \\sube B \\Harr 不在B的元素必不在A中 \\tag{11} \\] 例4：设 \\(N\\) 为所有自然数构成的集合， \\(Q\\) 为一切有理数组成的集合， \\(R\\) 为全体实数之集， \\(C\\) 为全体复数之集，则\n\\[ N \\sube Q \\sube R \\sube C \\tag{12} \\] \\[ \\set{1} \\sube N,\\set{1,1.2,9,9}\\sube Q,\\set{\\sqrt{2},\\pi}\\sube R \\tag{13} \\] 如果 \\(A\\) 不是 \\(B\\) 的子集，则记为 \\(A \\nsubseteq B\\) （读 \\(A\\) 不包含在 \\(B\\) 里），由定义得\n\\[ A \\nsubseteq B \\Harr \\exist x \\in A 使得 x \\notin B \\tag{14} \\] 若 \\(A,B,C\\) 都是集合，则由定义有 \\[ A \\sube A \\tag{15} \\] \\[ 若 A \\sube B 且 B \\sube C ，则 A \\sube C \\tag{16} \\]\n真子集 定义2：设 \\(A,B\\) 为集合。如果 \\(A \\sube B\\) 且 \\(\\exist x \\in B\\) 使得 \\(x \\notin A\\) ，则称 \\(A\\) 是 \\(B\\) 的真子集，记为 \\(A \\sub B\\) 。\n例如， \\(\\set{a,b}\\) 的真子集。 \\(N\\) 是 \\(Q\\) 的真子集， \\(Q\\) 是 \\(R\\) 的 真子集， \\(R\\) 是 \\(C\\) 的真子集。\n注意符号“ \\(\\in\\) ”与“ \\(\\sube\\) ”在概念上的区别。 \\(\\in\\) 为元素与集合间的属于关系，而 \\(\\sube\\) 为集合间的包含关系。\n集合的相等 定义3：设 \\(A,B\\) 是集合，如果 \\(A \\sube B\\) 且 \\(B \\sube A\\) ，则称 \\(B\\) 与 \\(A\\) 相等,并记成 \\(A=B\\) 。\n这就是说，如果 \\(A\\) 和 \\(B\\) 由完全相同的元素组成时，那么 \\(A\\) 与 \\(B\\) 就是相等的两个集合。两个相等的集合并不意味着它们是用同样的方法定义的。如果 \\(A\\) 与 \\(B\\) 是两个不相等的集合，那么就记为 \\(A \\ne B\\) 。显然，\n\\[ A\\ne B \\Harr A \\nsubseteq B 或 B \\nsubseteq A \\tag{17} \\] \\[ A \\sub B \\Harr A \\sube B 且 A \\ne B \\tag{18} \\] 例5：设 \\(A=\\set{2,3}\\) ， \\(B\\) 为方程\n\\[ x^2-5x+6=0 \\tag{19} \\] 的根形成的集合，则 \\(A=B\\) 。\n定义3指出了一个重要原则：要证明两个集合相等，唯一的方法是证明每一个集中的任一元素均是另一个集的元素。这种证明应是靠逻辑推理，而不是依靠直观。证明两个集合相等的方法是本文中必须掌握的方法，它贯穿在本部分的各篇中。\n空集是任一集的子集且唯一 定理1：空集是任一集的子集且空集是唯一的。\n证明（定理1）：设 \\(A\\) 是任一集。由于空集 \\(\\varnothing\\) 没有任何元素，所以断言“ \\(\\varnothing\\) 中每个元素均是 \\(A\\) 的元素。”成立。因此，按子集的定义有 \\(\\varnothing \\sube A\\) ，即 \\(\\varnothing\\) 是 \\(A\\) 的子集。\n设 \\(\\varnothing\\) 和 \\(\\varnothing'\\) 都是空集，则由上可知， \\(\\varnothing \\in \\varnothing'\\) 且 \\(\\varnothing' \\in \\varnothing\\) 。由定义3得到 \\(\\varnothing=\\varnothing'\\) ，从而空集是唯一的。证毕。\n由定理1，空集是唯一的，所以用 \\(\\varnothing\\) 表示空集是合理的。\n由定义1可知，判断 \\(A\\) 是否是集合 \\(B\\) 的子集等价于判断断言“对每个 \\(x\\) 若 \\(x \\in A\\) 则 \\(x \\in B\\) ”是否成立。如果这个断言成立，则 \\(A \\sube B\\) ；否则 \\(A \\nsubseteq B\\) 。而断言“对每个 \\(x\\) 若 \\(x \\in A\\) 则 \\(x \\in B\\) ”是一个复合语句（命题） \\(x \\in A\\) 是前题， \\(x \\in B\\) 是结论。前题和结论都是断言，它们之间用联接词“如果…，则…”联接成一个复合命题。在数学中，特别是在数理逻辑中，我们规定一个复合命题是假的，当且仅当前提是真的，结论是假的。利用此规定进行推理是安全的，不会推出假的复含命题。定理1的前半部分的证明就利用了这个规定。\n集族 在集合的概念中曾说过，集合是一些事物的总体,而这些东西可以是现实存在的，也可以是抽象的，并没有什么限制。于是，集合也是事物，也可以把一些集合构成一个整体形成一个新的集合。这种以集合为其元素的集合叫做集族。集族并不是一个新概念，只是提醒读者，这个集合的成员也是某些集合。于是，就有了层次。为了思考的清 晰起见，我们有\n定义4：以集合为元素的集合称为集族。\n在数学、计算机科学中，甚至在日常生活中常常会遇到集族。例 如，在学校中，每个班级的学生形成一个集合,而全校的各个班就形成了一个集族。\n设 \\(A_1,A_2,A_3\\) 为集合，则 \\(\\set{A_1,A_2,A_3}\\) 为一个集族。若令 \\(I=\\set{1,2,3}\\) ，则 \\(\\forall i \\in I\\) ， \\(i\\) 确定了一个唯一的集合 \\(A_i\\) 。于是，集族 \\(A_1,A_2,A_3\\) 又常写成 \\(\\set{A_i}_{i \\in I}\\) ，即 \\(I\\) 中元素 \\(i\\) 确定的那些集形成的集族。\n一般地，若 \\(J\\) 为任一集，对 \\(J\\) 中每个 \\(j\\) 有一个唯一的集与之对应, 这个集记为 \\(A_j\\) ，那么所有这些 \\(A_j\\) 形成的集族就用 \\(\\set{A_j}_{j \\in J}\\) 表示，其 \\(J\\) 称为标号集。\n定义5：集合 \\(S\\) 中的所有子集（包括空集 \\(\\varnothing\\) 及 \\(S\\) 本身）形成的集族称为 \\(S\\) 的幂集，并记为 \\(2^S\\) ，或 \\(\\mathscr{P}(s)\\) 。\n于是有 \\[ 2^S=\\set{A|A \\sube S} \\tag{20} \\]\n例6：设 \\(S={1,2,3}\\) ，则\n\\[ 2^S=\\set{\\varnothing,\\set{1},\\set{2},\\set{3},\\set{1,2},\\set{1,3},\\set{2,3},\\set{1,2,3}} \\tag{21} \\] \\(S\\) 有八个子集。\n一般说来，若 \\(S\\) 正好有 \\(n\\) 个元素，则 \\(S\\) 有 \\(2^n\\) 个子集，这就是我们为什么采用记号 \\(2^S\\) 的原因。\n注意， \\(2^{\\varnothing}=\\set{\\varnothing}\\) 。在这里要区分 \\(\\varnothing\\) 和 \\(\\set{\\varnothing}\\) ， \\(\\varnothing\\) 为空集，而 \\(\\set{\\varnothing}\\) 是个集族，这个集族仅有一个元素，就是空集。因此， \\(\\varnothing\\ne\\set{\\varnothing}\\) 。但 \\(\\varnothing\\in\\set{\\varnothing}\\) 且 \\(\\varnothing\\sube\\set{\\varnothing}\\) ，又集 \\(\\set{\\varnothing,\\set{\\varnothing}}\\) 含有两个元素。\n集合的基本运算 在任一数学系统中，总要引入若干种运算。引入运算的目的不仅在于由已知集合通过运算可以得新的集合，而且由于引入的运算往往服从某些熟知的规则，从而又能简化所得到的公式,而且在很多场合下，往往能简化科学结论的逻辑结构。本节介绍集合的并、交、差、对称差、补运算，并证明它们满足某些运算规律。\n并运算 并集的定义 定义6（并集）：设 \\(A,B\\) 是两个集合,至少属于集合 \\(A\\) 与集合 \\(B\\) 之一的那些元素构成的集合称为 \\(A\\) 与 \\(B\\) 的并集，并记为 \\(A \\cup B\\) 。符号 \\(\\cup\\) 称为并运算符。于是\n\\[ A \\cup B = \\set{x|x \\in A 或 x \\in B} \\tag{22} \\] 例7：设 \\(A=\\set{a,b,c,d},B=\\set{b,d,e,f}\\)，则 \\(A \\cup B=\\set{a,b,c,d,e,f}\\) 。注意在本例中， \\(b\\) 和 \\(d\\) 既是 \\(A\\) 的元素又是 \\(B\\) 的元素，在 \\(A \\cup B\\) 中， \\(b\\) 和 \\(d\\) 各写一次，不能重写，因为 \\(A \\cup B\\) 是由互不相同的元素组成的。\n例8：设 \\(A=\\set{1,3,5,\\cdots},B=\\set{2,4,6,\\cdots}\\) ，则 \\(A \\cup B = \\set{1,2,3,4,5,6,\\cdots}=N\\) 。\n对于 \\(x \\in A \\cup B\\) ，我们可以根据定义写成\n\\[ x \\in A 或 x \\in B \\tag{36} \\] 但是对于 \\(x \\notin A \\cup B\\) ，实际上我们得到的是\n\\[ x \\notin A 且 x \\notin B \\tag{37} \\] 的结论。\n并运算的性质 并运算有下面的一些性质。\n定理2：设 \\(A,B,C\\) 为任意的三个集合，则\n(1) 交换律成立。即\n\\[ A \\cup B = B \\cup A \\tag{25} \\] (2) 结合律成立。即\n\\[ (A \\cup B ) \\cup C = A \\cup (B \\cup C) \\tag{26} \\] (3) 幂等律成立。即\n\\[ A \\cup A = A \\tag{27} \\] (4)\n\\[ \\varnothing \\cup A = A \\tag{28} \\] (5)\n\\[ A \\cup B = B \\Harr A \\sube B \\tag{29} \\] (6)\n\\[ A \\sube A \\cup B,\\quad B \\sube A \\cup B \\tag{30} \\] (7)\n\\[ 若 A \\cup B \\sube C，则 A \\sube C,B \\sube C \\tag{31} \\] (8)\n\\[ 若A \\sube C,B \\sube C，则A \\cup B \\sube C \\tag{32} \\] 证明（定理2）：\n(1) 由式(22)可得 \\(A \\cup B = \\set{x|x \\in A 或 x \\in B}\\)，而\\(B \\cup A = \\set{x|x \\in B 或 x \\in A} = \\set{x|x \\in A 或 x \\in B}\\) ，故 \\(A \\cup B = B \\cup A\\) 。\n(2) 设 \\(x \\in (A \\cup B) \\cup C\\) ，则有 \\(x \\in A \\cup B\\) 或 \\(x \\in C\\) 。若 \\(x \\in A \\cup B\\) ，则又有 \\(x \\in A\\) 或 \\(x \\in B\\) ，由定义知 \\(B \\sube B \\cup C\\) ，因此对 \\(x\\) 有 \\(x \\in A\\) 或 \\(x \\in B \\cup C\\) ，即 \\(x \\in A \\cup (B \\cup C)\\) 。若 \\(x \\in C\\) ，由定义知 \\(C \\sube B \\cup C\\) ，则 \\(x \\in B \\cup C\\) ，又由定义知 \\(B \\cup C \\sube A \\cup (B \\cup C)\\) ，因此 \\(x \\in A \\cup (B \\cup C)\\) 。于是不论怎样， \\(x \\in A \\cup (B \\cup C)\\) ，因此 \\((A \\cup B) \\cup C \\sube A \\cup (B \\cup C)\\) 。\n反之，设 \\(x \\in A \\cup (B \\cup C)\\) ，则由定义知 \\(x \\in A\\) 或 \\(x \\in B \\cup C\\) 。若 \\(x \\in A\\) ，由定义知 \\(A \\sube A \\cup B \\sube (A \\cup B) \\cup C\\) ，故 \\(x \\in (A \\cup B) \\cup C\\) 。若 \\(x \\in B \\cup C\\) ，则 \\(x \\in B\\) 或 \\(x \\in C\\) ，又由定义知 \\(B \\sube A \\cup B\\) ，故 \\(x \\in A \\cup B\\) 或 \\(x \\in C\\) ，即 \\(x \\in (A \\cup B) \\cup C\\) 。于是不论怎样， \\(x \\in (A \\cup B) \\cup C\\) ，因此 \\(A \\cup (B \\cup C) \\sube (A \\cup B) \\cup C\\) 。\n综上所述，由定义3可知， \\(A \\cup (B \\cup C) = (A \\cup B) \\cup C\\) 。\n(3) 由式(15)知 \\(A \\sube A\\) ，因此由(5)可知 \\(A \\cup A = A\\) 。\n(4) 由定理1可知 \\(\\varnothing \\sube A\\) 。因此由(5)可知 \\(\\varnothing \\cup A = A\\) 。\n(5) 设 \\(A \\cup B = B\\) ，任取 \\(x \\in A\\) ，由(1)可知 \\(A \\sube A \\cup B\\) ，则 \\(x \\in A \\cup B = B\\) ，即 \\(x \\in B\\) ，故 \\(A \\sube B\\) 。反过来，设 \\(A \\sube B\\) 。对任意 \\(x \\in A \\cup B\\) ，即 \\(x \\in A\\) 或 \\(x \\in B\\) 。如果 \\(x \\in A\\) ，则由 \\(A \\sube B\\) 可得 \\(x \\in B\\) 。所以不管怎样都有 \\(x \\in B\\) ，所以 \\(A \\cup B \\sube B\\) 。而由(1)可得 \\(B \\sube A \\cup B\\) 。由定义3可知 \\(A \\cup B = B\\) 。\n(6) 可直接由并集的定义得出。\n(7) 若 \\(A \\cup B \\sube C\\) ，则对任意 \\(x \\in A \\cup B\\) ， \\(x \\in C\\) 。而由 \\(x \\in A \\cup B\\) 和并集的定义可得 \\(x \\in A\\) 或 \\(x \\in B\\) ，故对任意 \\(x \\in A, x \\in B\\) 都有 \\(x \\in C\\) ，即 \\(A \\sube C,B \\sube C\\) 。\n(8) 设 \\(A \\sube C,B \\sube C\\) 。对任意 \\(x \\in A \\cup B\\) ，有 \\(x \\in A\\) 或 \\(x \\in B\\) 。若 \\(x \\in A\\) ，由 \\(A \\sube C\\) 可知 \\(x \\in C\\) 。若 \\(x \\in B\\) ，由 \\(B \\sube C\\) 可知 \\(x \\in C\\) 。总之 \\(x \\in C\\) 。所以 \\(A \\cup B \\sube C\\) 。\n接下来是一些常用结论。\n结论1：对集合 \\(A,B,C,D\\) ，若 \\(A \\sube C, B \\sube D\\) ，则有 \\(A \\cup B \\sube C \\cup D\\) 。\n证明（结论1）：对任意 \\(x \\in A \\cup B\\) ，有 \\(x \\in A\\) 或 \\(x \\in B\\) 。由 \\(A \\sube C\\) 有 \\(x \\in C\\) ；由 \\(B \\sube D\\) 有 \\(x \\in D\\) 。故 \\(x \\in C\\) 或 \\(x \\in D\\) ，即 \\(x \\in C \\cup D\\) 。因此， \\(A \\cup B \\sube C \\cup D\\) 。\n无穷并集 由式(26)， \\((A \\cup B) \\cup C = A \\cup (B \\cup C)\\) ，因此 \\(A \\cup B \\cup C\\) 有意义。类似地，我们可以定义多个集合 \\(A_1,A_2,\\cdots,A_n\\) 的并集 \\(A_1 \\cup A_2 \\cup \\cdots \\cup A_n\\) 为至少属于 \\(A_1,A_2,\\cdots,A_n\\) 中之一的那些元素构成的集合。 \\(A_1 \\cup A_2 \\cup \\cdots \\cup A_n\\) 常缩写成 \\(\\displaystyle\\bigcup_{i=1}^{n}A_i\\) 。\n若 \\(A_1,A_2,\\cdots,A_n,\\cdots\\) 是一个无穷集合的无穷序列，则它们的并集记为 \\(A_1 \\cup A_2 \\cup \\cdots \\cup A_n \\cup \\cdots\\) ，常缩写为 \\(\\displaystyle\\bigcup_{i=1}^{\\infin}A_n\\) ，其定义为\n\\[ A_1 \\cup A_2 \\cup \\cdots \\cup A_n \\cup \\cdots = \\bigcup_{i=1}^{\\infin}A_n = \\set{x | \\exist\\space n \\in N 使得 x \\in A_n} \\tag{33} \\] 其中 \\(N\\) 是自然数之集。\n一般地，若 \\(\\set{A_l}_{l \\in I}\\) 是任一集族，则集族中那些集之并集记为 \\(\\displaystyle\\bigcup_{l \\in I}A_l\\) ，并且\n\\[ \\bigcup_{l \\in I}A_l=\\set{x | \\exist \\space l \\in I 使得 x \\in A_l} \\tag{34} \\] 交运算 集合的并运算，就是把给定集的那些元素放到一起合并成一个集合，在这个合并中，相同的元素只要一个。集合的另一个运算是交运算，它是由给定的集合的公共元素构成的集合。形式上，我们有如下的定义。\n交集的定义 定义7（交集）：设 \\(A\\) 和 \\(B\\) 是任意的两个集合，由既属于 \\(A\\) 又属于 \\(B\\) 的一切元素构成的集合称为 \\(A\\) 与 \\(B\\) 的交集，并记为 \\(A \\cap B\\) 。\n于是\n\\[ A \\cap B = \\set{x|x \\in A 且 x \\in B} \\tag{35} \\] 例9：设 \\(A=\\set{a,b,c,d,e},B=\\set{a,c,e,f}\\) ，则 \\(A \\cap B = \\set{a,c,e}\\) 。\n例10： \\(A\\) 为所有蓝眼睛的男人之集， \\(B\\) 为所有棕色头发男人之集，则 \\(A \\cap B\\) 就是一切蓝眼睛棕色头发男人之集。\n对于 \\(x \\in A \\cap B\\) ，我们可以根据定义写成\n\\[ x \\in A 且 x \\in B \\tag{36} \\] 但是对于 \\(x \\notin A \\cap B\\) ，实际上我们得到的是\n\\[ x \\notin A 或 x \\notin B \\tag{37} \\] 的结论。\n交运算的性质 交运算有以下性质。\n定理3：设 \\(A,B,C\\) 是任意三个集合，则\n(1) 交换律成立。即\n\\[ A \\cap B = B \\cap A \\tag{38} \\] (2) 结合律成立。即\n\\[ (A \\cap B) \\cap C = A \\cap (B \\cap C) \\tag{39} \\] (3) 幂等律成立，即\n\\[ A \\cap A = A \\tag{40} \\] (4)\n\\[ \\varnothing \\cap A = \\varnothing \\tag{41} \\] (5)\n\\[ A \\cap B = A \\Harr A \\sube B \\tag{42} \\] (6)\n\\[ A \\cap B \\sube A,\\quad A \\cap B \\sube B \\tag{43} \\] (7)\n\\[ 若 C \\sube A \\cap B，则 C \\sube A,C \\sube B \\tag{44} \\] (8)\n\\[ 若A \\sube C,B \\sube C，则A \\cap B \\sube C \\tag{45} \\] 证明（定理3）：\n(1) 由式(35)可得 \\(A \\cap B = \\set{x|x \\in A 且 x \\in B}\\)，而\\(B \\cap A = \\set{x|x \\in B 且 x \\in A} = \\set{x|x \\in A 且 x \\in B}\\) ，故 \\(A \\cap B = B \\cap A\\) 。\n(2) 设 \\(x \\in (A \\cap B) \\cap C\\) ，则有 \\(x \\in A \\cap B\\) 且 \\(x \\in C\\) 。而由 \\(x \\in A \\cap B\\) ，又有 \\(x \\in A\\) 且 \\(x \\in B\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\in C\\) ，即 \\(x \\in A\\) 且 \\(x \\in B \\cap C\\) ，即 \\(x \\in A \\cap (B \\cap C)\\) 。由此可得 \\((A \\cap B) \\cap C \\sube A \\cap (B \\cap C)\\) 。\n反之，设 \\(x \\in A \\cap (B \\cap C)\\) ，则由定义知 \\(x \\in A\\) 且 \\(x \\in B \\cup C\\) 。而由 \\(x \\in B \\cup C\\) ,又有 \\(x \\in B\\) 且 \\(x \\in C\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\in C\\) ，即 \\(x \\in A \\cap B\\) 且 \\(x \\in C\\) ，即 \\(x \\in (A \\cap B) \\cap C\\) 。由此可得 \\(A \\cap (B \\cap C) \\sube (A \\cap B) \\cap C\\) 。\n综上所述，由定义3可知， \\(A \\cup (B \\cup C) = (A \\cup B) \\cup C\\) 。\n(3) 由式(15)知 \\(A \\sube A\\) ，再由(5)得到 \\(A \\cap A = A\\) 。\n(4) 由定理1知 \\(\\varnothing \\sube A\\) 。再由(6)知 \\(\\varnothing \\cap A = \\varnothing\\) 。\n(5) 若 \\(A \\cap B = A\\) ，任取 \\(x \\in A\\) ， 由 \\(A \\cap B = A\\) 可知 \\(x \\in A \\cap B\\) 。而由(1)可得 \\(A \\cap B \\sube B\\) ，故 \\(x \\in B\\) ，因此 \\(A \\sube B\\) 。反过来，设 \\(A \\sube B\\) 。对任意 \\(x \\in A\\) ，因为 \\(A \\sube B\\) 有 \\(x \\in B\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) ，由交集定义可得 \\(x \\in A \\cap B\\) ，因此 \\(A \\sube A \\cap B\\) 。又由(1)得 \\(A \\cap B \\sube A\\) ，因此由定义3可知 \\(A \\cap B = A\\) 。\n(6) 可直接由交集的定义得到。\n(7) 若 \\(C \\sube A \\cap B\\) ，对任意 \\(x \\in C\\) ，有 \\(x \\in A \\cap B\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) 。因此可得 \\(C \\sube A\\) 和 \\(C \\sube B\\) 。\n(8) 设 \\(A \\sube C,B \\sube C\\) 。由(6)可得 \\(A \\cap B \\sube A\\) ，而 \\(A \\sube C\\) ，因此 \\(A \\cap B \\sube C\\) 。\n接下来是一些常用结论。\n结论2：对集合 \\(A,B,C,D\\) ，若 \\(A \\sube C, B \\sube D\\) ，则有 \\( A \\cap B \\sube C \\cap D\\) 。\n证明（结论2）：对任意 \\(x \\in A \\cap B\\) ，有 \\(x \\in A\\) 且 \\(x \\in B\\) 。由 \\(A \\sube C\\) 有 \\(x \\in C\\) ；由 \\(B \\sube D\\) 有 \\(x \\in D\\) 。故 \\(x \\in C\\) 且 \\(x \\in D\\) ，即 \\(x \\in C \\cap D\\) 。因此， \\(A \\cap B \\sube C \\cap D\\) 。\n无穷交集 同样可定义 \\(n\\) 个集合 \\(A_1,A_2,\\cdots,A_n\\) 的交集，也可定义集合序列 \\(A_1,A_2,\\cdots,A_n,\\cdots\\) 的那些集的交集，并分别记为或定义为\n\\[ A_1 \\cap A_2 \\cap \\cdots \\cap A_n = \\bigcap_{i=1}^{n}A_n=\\set{x|\\forall i \\in \\set{1,2,\\cdots,n},x\\in A_i} \\tag{46} \\] \\[ A_1 \\cap A_2 \\cap \\cdots \\cap A_n \\cap \\cdots = \\bigcap_{i=1}^{\\infin}A_n=\\set{x|\\forall b \\in N,x\\in A_n} \\tag{47} \\] 更一般地，集族 \\(\\set{A_l}_{l \\in I}\\) 中各集的交记成 \\(\\displaystyle\\bigcap_{l \\in I}A_l\\) ，其定义为\n\\[ \\bigcap_{l \\in I}A_l=\\set{x|\\forall \\xi \\in I, x \\in A_\\xi} \\tag{48} \\] 并运算与交运算的联系 并运算与交运算的分配律 定理2和定理3各性质是并运算与交运算各自的性质。下面的定理表明了并运算与交运算之间的联系。\n定理4：设 \\(A\\) 为任一集合， \\(\\set{B_l}_{l \\in I}\\) 为任一集族，则\n\\[ A \\cap \\left(\\bigcup_{l \\in I}B_l\\right)=\\bigcup_{l \\in I}\\left(A \\cap B_l \\right) \\tag{49} \\] \\[ A \\cup \\left(\\bigcap_{l \\in I}B_l\\right)=\\bigcap_{l \\in I}\\left(A \\cup B_l \\right) \\tag{50} \\] 其中 \\(I \\ne \\varnothing\\) 。\n证明（定理4）：先证式(49)。令 \\(\\displaystyle S = A \\cap \\left(\\bigcup_{l \\in I}B_l\\right),T=\\bigcup_{l \\in I}\\left(A \\cap B_l \\right)\\) 。\n首先证明 \\(S \\sube T\\) 。取任意 \\(x \\in S = \\displaystyle A \\cap \\left(\\bigcup_{l \\in I}B_l\\right)\\) ，由交集的定义有 \\(x \\in A\\) 且 \\(x \\in \\displaystyle\\bigcup_{l \\in I}B_l\\) ，由式(34)知存在一个 \\(\\xi_0 \\in I\\) 使得 \\(x \\in B_{\\xi_0}\\) 。于是 \\(x \\in A\\) 且 \\(x \\in B_{\\xi_0}\\) 。由交集的定义有 \\(x \\in A \\cap B_{\\xi_0}\\) 。由式(30)可得 \\(x \\in \\displaystyle\\bigcup_{\\xi \\in I}(A \\cap B_\\xi)\\) ，即 \\(x \\in T\\) 。因此， \\(S \\sube T\\) 。\n其次，我们来证明 \\(T \\sube S\\) 。取任意 \\(x \\in T = \\displaystyle\\bigcup_{l \\in I}\\left(A \\cap B_l \\right)\\) ，由式(34)知必有 \\(\\xi_0 \\in I\\) 使得 \\(x \\in A \\cap B_{\\xi_0}\\) 。因此由交集的定义有 \\(x \\in A\\) 且 \\(x \\in B_{\\xi_0}\\) 。由式(30)可得 \\(x \\in A\\) 且 \\(x \\in \\left(\\displaystyle\\bigcup_{\\xi \\in I}B_\\xi\\right)\\) ，因此由交集的定义有 \\(x \\in A \\cap \\left(\\displaystyle\\bigcup_{\\xi \\in I}B_\\xi\\right)\\) ，即 \\(T \\sube S\\) 。\n因此由定义3可知 \\(S=T\\) ，即 \\(\\displaystyle A \\cap \\left(\\bigcup_{l \\in I}B_l\\right)=\\bigcup_{l \\in I}\\left(A \\cap B_l \\right)\\) 。\n再证式(50)。令 \\(S=\\displaystyle A \\cup \\left(\\bigcap_{l \\in I}B_l\\right),T=\\bigcap_{l \\in I}\\left(A \\cup B_l \\right)\\) 。\n首先证明 \\(S \\sube T\\) 。设 \\(x \\in S=\\displaystyle A \\cup \\left(\\bigcap_{l \\in I}B_l\\right)\\) ，由并集的定义可得 \\(x \\in A\\) 或 \\(x \\in \\displaystyle\\bigcap_{l \\in I}B_l\\) 。如果 \\(x \\in A\\) ，则由式(30)可知对任意 \\(l\\) 都有 \\(x \\in A \\cup B_l\\) ，即 \\(x \\in \\displaystyle\\bigcap_{l \\in I}\\left(A \\cup B_l \\right)\\) 。如果 \\(x \\in \\displaystyle\\bigcap_{l \\in I}B_l\\) ，则由式(48)可得 \\(\\forall \\xi \\in I,x \\in B_\\xi\\) ，再由式(30)可知 \\(\\forall \\xi \\in I,x \\in A \\cup B_\\xi\\) ，由式(48)得 \\(x \\in \\displaystyle\\bigcap_{l \\in I}\\left(A \\cup B_l \\right)\\) 。总之不论如何都有 \\(x \\in \\displaystyle\\bigcap_{l \\in I}\\left(A \\cup B_l \\right)\\) ，即 \\(x \\in T\\) ，因此 \\(S \\sube T\\) 。\n再证明 \\(T \\sube S\\) 。设 \\(x \\in T\\) ，由式(48)可得 \\(\\forall \\xi \\in I,x \\in A \\cup B_\\xi\\) ，则由并集的定义可得 \\(\\forall \\xi \\in I\\)，\\(x \\in A\\) 或 \\(x \\in B_\\xi\\) 。假设 \\(x \\in A\\) ，则由式(30)可知 \\(x \\in \\displaystyle A \\cup \\left(\\bigcap_{l \\in I}B_l\\right) \\) 。假设 \\(x \\in B_\\xi\\) ，则 \\(\\forall \\in I,x \\in B_\\xi\\) ，即 \\(x \\in \\displaystyle\\bigcap_{l \\in I}B_l\\) ，由式(30)可知 \\(x \\in A \\cup \\displaystyle\\bigcap_{l \\in I}B_l\\) 。总之，不论如何都有 \\(x \\in A \\cup \\displaystyle\\bigcap_{l \\in I}B_l\\) ，即 \\(x \\in S\\) 。所以 \\(T \\sube S\\) 。\n综上所述，由定义3可知 \\(S=T\\) ，即 \\(\\displaystyle A \\cup \\left(\\bigcap_{l \\in I}B_l\\right)=\\bigcap_{l \\in I}\\left(A \\cup B_l \\right)\\) 。\n分配律的简单形式 定理5：设 \\(A,B,C\\) 为任意三个集合，则\n(1) 交运算对并运算满足分配律，即\n\\[ A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C) \\tag{51} \\] (2) 并运算对交运算满足分配律，即\n\\[ A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C) \\tag{52} \\] 证明（定理5）：这个定理是定理4的一个特例，因此无须证明。\n但是，我们可以证明该定理的结论(1)和结论(2)是可以互推的。我们先从(1)开始证(2)。利用并运算和交运算的交换、结合性质和式(51)、式(55)和式(56)可得\n\\[ \\begin{aligned} (A \\cup B) \\cap (A \\cup C)=\u0026(A \\cup C) \\cap (A \\cup B) \\\\[5pt] =\u0026((A \\cup C) \\cap A) \\cup ((A \\cup C) \\cap B)\\text{（式(51)）}\\\\[5pt] =\u0026(A \\cap (A \\cup C)) \\cup (B \\cap (A \\cup C))\\text{（交换律）}\\\\[5pt] =\u0026 A \\cup (B \\cap (A \\cup C))\\text{（式(55)）}\\\\[5pt] =\u0026 A \\cup ((B \\cap A) \\cup (B \\cap C))\\text{（式(51)）}\\\\[5pt] =\u0026 (A \\cup (B \\cap A)) \\cup (B \\cap C)\\text{（结合律）}\\\\[5pt] =\u0026 (A \\cup (A \\cap B)) \\cup (B \\cap C)\\text{（交换律）}\\\\[5pt] =\u0026 A \\cup (B \\cap C)\\text{（式(56)）} \\end{aligned} \\tag{53} \\] 我们再来从(2)推导(1)。利用并运算和交运算的交换、结合性质和式(52)、式(55)和式(56)可得\n\\[ \\begin{aligned} (A \\cap B) \\cup (A \\cap C)=\u0026(A \\cap C) \\cup (A \\cap B)\\\\[5pt] =\u0026((A \\cap C) \\cup A)\\cap((A \\cap C) \\cup B)\\text{（式(52)）}\\\\[5pt] =\u0026(A \\cup (A \\cap C)) \\cap (B \\cup (A \\cap C))\\\\[5pt] =\u0026A \\cap (B \\cup (A \\cap C))\\text{（式(56)）}\\\\[5pt] =\u0026A \\cap ((B \\cup A) \\cap (B \\cup C))\\text{（式(52)）}\\\\[5pt] =\u0026(A \\cap (B \\cup A))\\cap(B \\cup C)\\\\[5pt] =\u0026A \\cap (B \\cup C)\\text{（式(55)）} \\end{aligned} \\tag{54} \\] 吸收律 定理6：对任何集 \\(A,B\\) ，吸收律成立：\n(1)\n\\[ A \\cap (A \\cup B) = A \\tag{55} \\] (2)\n\\[ A \\cup (A \\cap B) = A \\tag{56} \\] 证明（定理6）：由式(30)可得 \\(A \\sube A \\cup B\\) ，又由式(42)可得 \\(A \\cap (A \\cup B) = A\\) 。同理，由式(43)可得 \\(A \\cap B \\sube A\\) ，又由式(29)可得 \\((A \\cap B) \\cup A = A \\cup (A \\cap B) = A\\) 。\n两两不相交的集序列 定义8：设 \\(A,B\\) 为任意集合，如果 \\(A \\cap B = \\varnothing\\) ，则称 \\(A\\) 与 \\(B\\) 不相交。若集序列 \\(A_1,A_2,\\cdots,A_n,\\cdots\\) 的任两集 \\(A_i\\) 和 \\(A_j\\) （ \\(i \\ne j\\) ）不相交，则称 \\(A_1,A_2,\\cdots,A_n,\\cdots\\) 是两两不相交的集序列。\n差运算 差集的定义 定义9（差集）：设 \\(A\\) 与 \\(B\\) 为任意集合，由属于 \\(A\\) 但不属于 \\(B\\) 的一切元素构成的集合称为 \\(A\\) 与 \\(B\\) 的差集，并记为 \\(A\\backslash B\\) 。于是\n\\[ A \\backslash B = \\set{x | x \\in A 且 x \\notin B} \\tag{57} \\] 例11：设 \\(A=\\set{1,2,3,4,5},B=\\set{3,4,5,6}\\) ，则 \\(A \\backslash B = \\set{1,2}\\) 。\n对任意 \\(x \\in A \\backslash B\\) ，可以写成\n\\[ x \\in A 且 x \\notin B \\tag{58} \\] 对于 \\(x \\notin A \\backslash B\\) ，则写成\n\\[ x \\notin A 或 x \\in B \\tag{59} \\] 差运算的性质 差运算有以下性质。\n定理7：设 \\(A,B,C\\) 是任意三个集合，则\n(1)\n\\[ A \\backslash A = \\varnothing \\tag{60} \\] (2)\n\\[ A \\backslash \\varnothing = A \\tag{61} \\] (3)\n\\[ \\varnothing \\backslash A = \\varnothing \\tag{62} \\] (4)\n\\[ A \\backslash B \\sube A \\tag{63} \\] 证明（定理7）：\n(1) 如果 \\(A \\backslash A\\) 不为空，假设 \\(x \\in A \\backslash A\\) ，则 \\(x \\in A\\) 且 \\(x \\notin A\\) ，这种元素是不存在的，因此 \\(A \\backslash A\\) 中不能有元素，即为空集。\n(2) 由空集的定义， \\(A \\backslash \\varnothing = \\set{x | x \\in A 且 x \\notin \\varnothing}= \\set{x | x \\in A} = A\\) 。\n(3) 不存在 \\(x\\) 满足 \\(x \\in \\varnothing\\) ，因此 \\(\\varnothing \\backslash A = \\set{x | x \\in \\varnothing 且 x \\in A}\\) 没有元素，即为空集。\n(4) 由定义知对任意 \\(x \\in A \\backslash B\\) 都有 \\(x \\in A\\) 且 \\(x \\in B\\) ，即都有 \\(x \\in A\\) ，所以 \\(A \\backslash B \\sube A\\) 。\n差运算与并运算 定理8：设 \\(A,B\\) 是任意两个集合，则\n(1)\n\\[ (A \\backslash B) \\cup B = A \\cup B \\tag{64} \\] (2)\n\\[ (A \\backslash B) \\cup B = A \\Harr B \\sube A \\tag{65} \\] (3)\n\\[ A \\backslash (B \\cup C) = (A \\backslash B) \\backslash C \\tag{66} \\] (4)\n\\[ (A \\cup B) \\backslash C = (A \\backslash C) \\cup (B \\backslash C) \\tag{67} \\] 证明（定理8）：\n(1) 设 \\(x \\in (A \\backslash B) \\cup B\\) ，则 \\(x \\in A \\backslash B\\) 或 \\(x \\in B\\) 。如果 \\(x \\in A \\backslash B\\) ，则由式(63)可知 \\(x \\in A\\) ，由式(30)可知 \\(A \\sube A \\cup B\\) ，即 \\(x \\in A \\cup B\\) 。如果 \\(x \\in B\\) ，则由式(30)可知 \\(B \\sube A \\cup B\\) ，即 \\(x \\in A \\cup B\\) 。综上所述， \\((A \\backslash B) \\cup B \\sube A \\cup B\\) 。\n另外，假设 \\(x \\in A \\cup B\\) ，则 \\(x \\in A\\) 或 \\(x \\in B\\) 。假设 \\(x \\in A\\) ，此时又分为两种情况： \\(x \\in B\\) 或 \\(x \\notin B\\) 。如果 \\(x \\in A\\) 且 \\(x \\in B\\) ，由式(30)可知 \\(B \\sube (A \\backslash B) \\cup B\\) ，即 \\(x \\in (A \\backslash B) \\cup B\\) 。如果 \\(x \\in A\\) 且 \\(x \\notin B\\) ，由差集的定义得 \\(x \\in A \\backslash B\\) ，又由式(30)得 \\(A \\backslash B \\sube (A \\backslash B) \\cup B\\) ，即 \\(x \\in (A \\backslash B) \\cup B\\) 。所以当 \\(x \\in A\\) 时总有 \\(x \\in (A \\backslash B) \\cup B\\) 。当 \\(x \\in B\\) 时，由式(30)可知 \\(B \\sube (A \\backslash B) \\cup B\\) ，即 \\(x \\in (A \\backslash B) \\cup B\\) 。总之， \\(x \\in A \\cup B\\) 时 \\(x \\in (A \\backslash B) \\cup B\\) ，即 \\(A \\cup B \\sube (A \\backslash B) \\cup B\\) 。\n因此由定义3可知 \\((A \\backslash B) \\cup B = A \\cup B\\) 。\n(2) 先假设 \\((A \\backslash B) \\cup B = A\\) 。由式(31)可直接得 \\(B \\sube A\\) 。再假设 \\(B \\sube A\\) 。由式(63)可得 \\(A \\backslash B \\sube A\\) 。和 \\(B \\sube A\\) 一起由式(32)可得 \\((A \\backslash B) \\cup B \\sube A\\) 。由式(64)可得 \\((A \\backslash B) \\cup B = A \\cup B\\) ，而由 \\(A \\sube A \\cup B\\) 可得 \\(A \\sube (A \\backslash B) \\cup B\\) 。因此 \\((A \\backslash B) \\cup B = A\\) 。因此结论成立。\n(3)设 \\(x \\in A \\backslash (B \\cup C)\\) ，则有 \\(x \\in A\\) 且 \\(x \\notin B \\cup C\\) ，即 \\(x \\in A\\) 且 \\(x \\notin B\\) 且 \\(x \\notin C\\) 。再设 \\(x \\in (A \\backslash B) \\backslash C\\) ，有 \\(x \\in A \\backslash B\\) 且 \\(x \\notin C\\) ，即 \\(x \\in A\\) 且 \\(x \\notin B\\) 且 \\(x \\notin C\\) 。两式的变量限制条件相等。因此 \\(A \\backslash (B \\cup C)=(A \\backslash B) \\backslash C\\) 。\n(4)设 \\(x \\in (A \\cup B) \\backslash C\\) ，则 \\(x \\in A \\cup B\\) 且 \\(x \\notin C\\) ，即 \\(x \\in A,x \\notin C\\) 或 \\(x \\in B, x \\notin C\\) 。同理设 \\(x \\in (A \\backslash C) \\cup (B \\backslash C)\\) ，则 \\(x \\in A,x \\notin C\\) 或 \\(x \\in B, x \\notin C\\) 。两式的变量限制条件相等，因此 \\((A \\cup B) \\backslash C = (A \\backslash C) \\cup (B \\backslash C)\\) 。\n差运算与交运算 定理9：设 \\(A,B,C\\) 为任意三个集合，则\n(1)\n\\[ A \\cap (B \\backslash C)=(A \\cap B) \\backslash (A \\cap C) \\tag{68} \\] 该式称为交运算对差运算满足分配律。\n(2)\n\\[ (A \\cap B) \\backslash C = (A \\backslash C) \\cap (B \\backslash C) \\tag{69} \\] 证明（定理9）：\n(1)设 \\(x \\in A \\cap (B \\backslash C)\\) ，则 \\(x \\in A\\) 且 \\(x \\in B \\backslash C\\) ，即 \\(x \\in B\\) 且 \\(x \\notin C\\) ，考虑 \\(x \\in A\\) 重复两次（在全是并运算的表达式中，由并运算的交换律和结合律可知可以这么做）即可得到 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\in A\\) 且 \\(x \\notin C\\) ，即 \\(x \\in A \\cap B\\) 且 \\(x \\notin A \\cap C\\) 。所以由差运算的定义， \\(x \\in (A \\cap B) \\backslash (A \\cap C)\\) ，从而 \\(A \\cap (B \\backslash C) \\sube (A \\cap B) \\backslash (A \\cap C)\\) 。\n反之，设 \\(x \\in (A \\cap B) \\backslash (A \\cap C)\\) 。则 \\(x \\in A \\cap B \\) 且 \\(x \\notin A \\cap C\\) 。因此， \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\notin A \\cap C\\) 。而 \\(x \\notin A \\cap C\\) 等价于 \\(x \\notin A\\) 或 \\(x \\notin C\\) （见式(37)），但是注意有条件 \\(x \\in A\\) ，因此 \\(x \\notin A \\cap C\\) 等价于 \\(x \\notin C\\) 。即 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\notin C\\) 。即 \\(x \\in A\\) 且 \\(x \\in B \\backslash C\\) 。 \\(x \\in A \\cap (B \\backslash C)\\) 。于是有 \\((A \\cap B) \\backslash (A \\cap C) \\sube A \\cap (B \\backslash C)\\) 。\n综上，由定义3， \\(A \\cap (B \\backslash C) = (A \\cap B) \\backslash (A \\cap C)\\) 。\n(2)设 \\(x \\in (A \\cap B) \\backslash C\\) ，即 \\(x \\in A \\cap B\\) 且 \\(x \\notin C\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\notin C\\) 。再设 \\(x \\in (A \\backslash C) \\cap (B \\backslash C)\\) ，有 \\(x \\in A \\backslash C\\) 且 \\(x \\in B \\backslash C\\) ，即 \\(x \\in A\\) 且 \\(x \\in B\\) 且 \\(x \\notin C\\) 。两式的变量限制条件相等，因此 \\((A \\cap B) \\backslash C = (A \\backslash C) \\cap (B \\backslash C)\\) 。\n例12： \\(A,B\\) 为例11中的 \\(A,B\\) ，则\n\\[ B \\backslash A = \\set{6} \\ne A \\backslash B \\tag{70} \\] 这表明差运算不满足交换律。若令 \\(C=\\set{3,4}\\) ，则 \\((A \\backslash B) \\backslash C = \\set{1,2} \\backslash C = \\set{1,2}\\) ，而 \\(A \\backslash (B \\backslash C) = A \\backslash \\set{5,6} = \\set{1,2,3,4}\\) 。于是 \\((A \\backslash B) \\backslash C \\ne A \\backslash (B \\backslash C)\\) 。这表明差运算也不满足结合律。\n对称差 对称差的定义 定义10：设 \\(A\\) 与 \\(B\\) 为任两个集合， \\(A \\backslash B\\) 与 \\(B \\backslash A\\) 的并集称为 \\(A\\) 与 \\(B\\) 的对称差，记为 \\(A \\triangle B\\) 。于是\n\\[ A \\triangle B = (A \\backslash B) \\cup (B \\backslash A) = \\set{x | (x \\in A 且x \\notin B)或(x \\in B且x \\notin A)} \\tag{71} \\] 对 \\(x \\in A \\triangle B\\) ，可以写成\n\\[ 若 x \\in A \\triangle B，则x \\in A,x \\notin B或x \\in B, x \\notin A \\tag{72} \\] 对 \\(x \\notin A \\triangle B\\) ，则要么 \\(x \\in A, x \\in B\\) ，要么 \\(x \\notin A,x \\notin B\\) 。因为一共就四种情况： \\(x \\in A, x \\in B\\) ； \\(x \\in A, x \\notin B\\) ； \\(x \\notin A, x \\in B\\) ； \\(x \\notin A, x \\notin B\\) 。因此可以写成\n\\[ 若 x \\notin A \\triangle B，则x \\in A, x \\in B 或 x \\notin A, x \\notin B \\tag{73} \\] 对称差的性质 对称差运算有如下性质。\n定理10：设 \\(A,B,C\\) 为任意三个集合，则\n(1)\n\\[ A \\triangle B = B \\triangle A \\tag{74} \\] (2)\n\\[ (A \\triangle B) \\triangle C = A \\triangle (B \\triangle C) \\tag{75} \\] (3)\n\\[ A \\triangle A = \\varnothing \\tag{76} \\] (4)\n\\[ A \\triangle \\varnothing = A \\tag{77} \\] 证明（定理10）：\n(1) \\(A \\triangle B = (A \\backslash B) \\cup (B \\backslash A)\\) ，由并运算的交换律式(25)可得 \\(B \\triangle A = (B \\backslash A) \\cup (A \\backslash B)=(A \\backslash B) \\cup (B \\backslash A)=A \\triangle B\\) 。\n(2) 对任意 \\(x \\in (A \\triangle B) \\triangle C\\) ，由式(72)知 \\(x \\in A \\triangle B, x \\notin C\\) 或 \\(x \\notin A \\triangle B, x \\in C\\) 。先看第一种可能 \\(x \\in A \\triangle B, x \\notin C\\) ，由式(72)知此时又可分为 \\(x \\in A, x \\notin B, x \\notin C\\) 和 \\(x \\notin A, x \\in B, x \\notin C\\) 两种情况。再看第二种可能 \\(x \\notin A \\triangle B, x \\in C\\) ，由式(73)知此时还有两种情况 \\(x \\notin A,x \\notin B, x \\in C\\) 和 \\(x \\in A,x \\in B,x \\in C\\) 。综上所述， \\(x \\in (A \\triangle B) \\triangle C\\) 一共有四种情况，分别是\n\\[ \\begin{aligned} x \\in A, x \\notin B, x \\notin C \\\\[5pt] x \\notin A, x \\in B, x \\notin C \\\\[5pt] x \\notin A, x \\notin B, x \\in C \\\\[5pt] x \\in A,x \\in B,x \\in C \\end{aligned} \\tag{78} \\] 再来看 \\(A \\triangle (B \\triangle C)\\) 。对任意 \\( x \\in A \\triangle (B \\triangle C)\\) ，由式(72)知 \\(x \\in A, x \\notin B \\triangle C\\) 或 \\(x \\notin A, x \\in B \\triangle C\\) 。先看第一种可能 \\(x \\in A, x \\notin B \\triangle C\\) ，由式(73)知此时又可分为 \\(x \\in A, x \\in B, x \\in C\\) 和 \\(x \\in A, x \\notin B, x \\notin C\\) 两种情况。再看第二种可能 \\(x \\notin A, x \\in B \\triangle C\\) ，由式(72)知此时还有两种情况 \\(x \\notin A, x \\in B, x \\notin C\\) 和 \\(x \\notin A, x \\notin B, x \\in C\\) 。综上所述， \\(A \\triangle (B \\triangle C)\\) 一共有四种情况，分别是\n\\[ \\begin{aligned} x \\in A, x \\in B, x \\in C \\\\[5pt] x \\in A, x \\notin B, x \\notin C \\\\[5pt] x \\notin A, x \\in B, x \\notin C \\\\[5pt] x \\notin A, x \\notin B, x \\in C \\end{aligned} \\tag{79} \\] 我们发现式(78)和 式(79)是完全一样的，因此证明了 \\((A \\triangle B) \\triangle C = A \\triangle (B \\triangle C)\\) 。\n(3) 由式(60)可知 \\(A \\backslash A = \\varnothing\\) 。因此， \\(A \\triangle A = (A \\backslash A) \\cup (A \\backslash A) = \\varnothing \\cup \\varnothing =\\varnothing\\) 。\n(4) 由式(61)、式(62)和式(28)可推导出 \\(A \\triangle \\varnothing = (A \\backslash \\varnothing) \\cup ( \\varnothing \\backslash A) = A \\cup \\varnothing \\ A\\) 。\n对称差与交运算 定理11：交运算关于对称差满足分配律，即\n\\[ A \\cap (B \\triangle C) = (A \\cap B) \\triangle (A \\cap C) \\tag{80} \\] 证明（定理11）：由式(51)、式(68)和式(71)得\n\\[ \\begin{aligned} A \\cap (B \\triangle C) =\u0026 A \\cap ((B \\backslash C) \\cup (C \\backslash B))\\quad\\text{（式(71)）}\\\\[5pt] =\u0026 (A \\cap (B \\backslash C)) \\cup (A \\cap (C \\backslash B))\\quad\\text{（式(51)）}\\\\[5pt] =\u0026((A \\cap B) \\backslash (A \\cap C)) \\cup ((A \\cap C) \\backslash (A \\cap B))\\quad\\text{（式(68)）}\\\\[5pt] =\u0026(A \\cap B) \\triangle (A \\cap C)\\quad\\text{（式(71)）} \\end{aligned} \\tag{81} \\] Venn图 在许多实际问题中，常以某个集合 \\(S\\) 为出发点，而所涉及的集合都是 \\(S\\) 的子集。这个包含所考虑的所有集的集合 \\(S\\) ，称为该问题的全集。这时，常用图示法的方法表示全集的各子集间的包含关系，以及并集、交集、差集和对称差集。在这种图示法中，用矩形中各点表示全集 \\(S\\) 的各个元素，矩形中的圆里的各点表示 \\(S\\) 的子集的各元素。于是，若 \\(A,B \\sube S\\) ，则 \\(A \\cup B,A\\cap B, A \\backslash B, A \\triangle B, A \\sube B\\) 可用下图表示，称为Venn图表示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图1\u0026emsp;Venn图\n余集、De Morgan公式 余集 余集的定义 定义11：设 \\(S\\) 是一个集合， \\(A \\sube S\\) ，差集 \\(S \\backslash A\\) 称为集 \\(A\\) 对集 \\(S\\) 的余集，记为 \\(A^c\\) ，即 \\(A^c=S \\backslash A\\) 。\n在数学的文献中，余集也称为补集，并且记号也未统一。有的作者用 \\(\\complement_SA\\) 表示 \\(A\\) 对 \\(S\\) 的余集，其优点是明确地指出是相对于 \\(S\\) 求 \\(A\\) 的余集，但不简洁。还有些作者使用 \\(\\bar{A}\\) 、 \\(A'\\) 表示 \\(A\\) 的余集。记号 \\(A^c,\\bar{A},A'\\) 的优点在于其简洁性，便于在公式中书写。但由于余集的概念是相对于某个集合而言，记号 \\(A^c,\\bar{A},A'\\) 没有指明对哪个集求余集。然而，在具体问题中所考虑的集合 \\(A\\) 都是某个集 \\(S\\) 的子集，根据上下文， \\(A\\) 对哪个集求余集是清楚的。于是，记号 \\(A^c,\\bar{A},A'\\) 的简洁性优点便突出来。因此，本文使用记号 \\(A^c\\) 表示 \\(A\\) 的余集，其中的 \\(c\\) 为 \\(\\text{complement}\\) 的第一个字母。在易发生误会时就用 \\(\\complement_SA\\) 注明。\n集 \\(A\\) 对 \\(S\\) 的余集用Venn图表示时如图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图2\u0026emsp;\\(A\\) 的余集的Venn图表示\n例13：设 \\(S=\\set{1,2,3,4}\\) ， \\(A = \\set{2,4}\\) ，则 \\(A^c = \\set{1,3}\\) 。可是 \\(A\\) 对自然数集 \\(N\\) 求余集时 \\(\\complement_NA=\\set{1,3,5,6,7,\\cdots}\\) 。\n余集的性质 余集具有以下性质。\n定理12：设 \\(S\\) 是任一集合， \\(A\\) 是 \\(S\\) 的子集，则有\n(1) \\(S\\) 对 \\(S\\) 的余集为空集，即\n\\[ \\complement_SS=S^c=\\varnothing \\tag{82} \\] (2)\n\\[ \\varnothing^c=S(\\complement_\\varnothing=S) \\tag{83} \\] (3)\n\\[ A \\cap A^c = \\varnothing，即\\complement_SA\\cap A = \\varnothing \\tag{84} \\] (4)\n\\[ A \\cup A^c = S，即 A \\cup \\complement_SA=S \\tag{85} \\] (5)\n\\[ (A^c)^c=A \\tag{86} \\] 证明（定理12）：\n(1) 由式(60)可得 \\(S^c=S \\backslash S = \\varnothing\\) 。\n(2) 由式(61)可得 \\(\\varnothing^c=S \\backslash \\varnothing = S\\) 。\n(3) 由式(68)、 \\(A \\sube S\\) 、 式(42)和式(40)可得 \\(A \\cap A^c = A \\cap ( S \\backslash A)=(A \\cap S) \\backslash (A \\cap A) = A \\backslash A = \\varnothing\\) 。\n(4) 由式(64)、 \\(A \\sube S\\) 、式(29)可得 \\(A \\cup A^c = A \\cup (S \\backslash A) = (S \\backslash A) \\cup A = S \\cup A = S\\) 。\n(5) 设 \\(x \\in (A^c)^c\\) ，由定义有 \\(x \\in S \\backslash A^c\\) ，即 \\(x \\in S\\) 且 \\(x \\notin A^c\\) 。而对 \\(x \\in A^c\\) 有 \\(A^c = S \\backslash A\\) ,因此 \\(x \\notin S \\backslash A\\) ，由式(59)可得 \\(x \\notin S 或 x \\in A\\) 。注意前面已经有了 \\(x \\in S\\) 的条件，因此只能有 \\(x \\in A\\) ，因此 \\(x \\in S \\cup A\\) 。又 \\(A \\sube S\\) ，因此由式(29)可得 \\(x \\in A\\) 。\nDe Morgan公式 定理13（De Morgan公式）：设 \\(S\\) 为任一集合， \\(I\\) 为标号集， \\(\\forall\\xi\\in I\\) 有 \\(A_\\xi \\sube S\\) ，则有\n(1) 并集的余集等于各余集的交集，即\n\\[ \\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c=\\bigcap_{\\xi \\in I}A_\\xi^c \\tag{87} \\] (2) 交集的余集等于各余集的并集，即\n\\[ \\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c=\\bigcup_{\\xi in I}A_\\xi^c \\tag{88} \\] 证明（定理13）：\n(1) 设 \\(x \\in \\displaystyle\\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c\\) ，则 \\(x \\in S\\) 且 \\(x \\notin \\displaystyle\\bigcup_{\\xi \\in I}A_\\xi\\) ，从而 \\(\\forall\\xi\\in I,x \\notin A_\\xi\\) 。于是， \\(\\forall\\xi\\in I,x \\in A_\\xi^c\\) 。因此， \\(x \\in \\displaystyle\\bigcap_{\\xi \\in I}A_\\xi^c\\) ，故 \\(\\displaystyle\\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c \\sube \\bigcap_{\\xi \\in I}A_\\xi^c\\) 。\n其次，设 \\(x \\in \\displaystyle\\bigcap_{\\xi \\in I}A_\\xi^c\\) ，则 \\(\\forall \\xi \\in I\\) 都有 \\(x \\in A_\\xi^c\\) 。因此， \\(\\forall \\xi \\in I\\) 都有 \\(x \\notin A_\\xi\\) ，且 \\(x \\in S\\) ，故 \\(x \\notin \\displaystyle\\bigcup_{\\xi \\in I}A_\\xi\\) 。于是， \\(x \\in \\displaystyle\\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c\\) 。所以， \\(\\displaystyle\\bigcap_{\\xi \\in I}A_\\xi^c \\sube \\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c\\) 。\n由定义3可得 \\(\\displaystyle\\left(\\bigcup_{\\xi \\in I}A_\\xi\\right)^c=\\bigcap_{\\xi \\in I}A_\\xi^c\\) 。\n(2) 设 \\(x \\in \\displaystyle\\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c\\) ，则 \\(x \\in S\\) 且 \\(x \\notin \\displaystyle\\bigcap_{\\xi \\in I}A_\\xi\\) ，从而 \\(\\exist\\xi\\in I,x \\notin A_\\xi\\) 。于是， \\(\\exist\\xi\\in I,x \\in A_\\xi^c\\) 。因此， \\(x \\in \\displaystyle\\bigcup_{\\xi \\in I}A_\\xi^c\\) ，故 \\(\\displaystyle\\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c \\sube \\bigcup_{\\xi \\in I}A_\\xi^c\\) 。\n其次，设 \\(x \\in \\displaystyle\\bigcup_{\\xi \\in I}A_\\xi^c\\) ，则 \\(\\exist \\xi \\in I\\) 都有 \\(x \\in A_\\xi^c\\) 。因此， \\(\\exist \\xi \\in I\\) 都有 \\(x \\notin A_\\xi\\) ，且 \\(x \\in S\\) ，故 \\(x \\notin \\displaystyle\\bigcap_{\\xi \\in I}A_\\xi\\) 。于是， \\(x \\in \\displaystyle\\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c\\) 。所以， \\(\\displaystyle\\bigcup_{\\xi \\in I}A_\\xi^c \\sube \\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c\\) 。\n由定义3可得 \\(\\displaystyle\\left(\\bigcap_{\\xi \\in I}A_\\xi\\right)^c=\\bigcup_{\\xi \\in I}A_\\xi^c\\) 。\n","date":"2024-11-07T22:25:27+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/discrete_mathematics/set_theory/sets_and_their_operations/","title":"集合论（一）：集合及其运算"},{"content":" 进程的描述与控制 在传统的操作系统中，为了提高资源利用率和系统吞吐量，通常采用多道程序技术，将多个程序同时装入内存，并使之并发运行，传统意义上的程序不再能独立运行。此时，作为资源分配和独立运行的基本单位都是进程。操作系统所具有的四大特征也都是基于进程而形成的，并从进程的角度对操作系统进行研究.可见，在操作系统中，进程是一个极其重要的概念。因此，本篇专门对进程进行详细阐述。\n前趋图和程序执行 在早期未配置OS的系统和单道批处理系统中，程序的执行方式是顺序执行，即在内存中仅装入一道用户程序：由它独占系统中的所有资源，只有在一个用户程序执行完成后，才允许装入另一个程序并执行。可见，这种方式浪费资源、系统运行效率低等缺点。而在多道程序系统中，由于内存中可以同时装入多个程序，使它们共享系统资源，并发执行，显然可以克服上述缺点。程序的这两种执行方式间有着显著的不同，尤其是考虑到程序并发执行时的特征，才导致了在操作系统中引入进程的概念。因此，这里有必要先对程序的顺序和并发执行方式做简单的描述。\n前趋图 为了能更好地描述程序的顺序和并发执行情况，我们先介绍用于描述程序执行先后顺序的前趋图。所谓前趋图(Precedence Graph)，是指一个有向无循环图，可记为DAG(Directed Acyclic Graph)，它用于描述进程之间执行的先后顺序。图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序(Partial Order)‌或前趋关系(Precedence Relation)。\n进程（或程序）之间的前趋关系可用“\\(\\to\\)”来表示，如果进程和号存在着前趋关系，可表示为 \\((P_i,P_j)\\in\\to\\) ，也可写成 \\(P_i\\to P_j\\) 表示在 \\(P_j\\) 开始执行之前 \\(P_i\\) 必须完成。此时称 \\(P_i\\) 是 \\(P_j\\) 的直接前趋，而称 \\(P_j\\) 是 \\(P_i\\) 的直接后继。在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)。此外，每个结点还具有一个重量(Weight)，用于表示该结点所含有的程序量或程序的执行时间。在图1(a)所示的前趋图中，存在着如下前趋关系：\n\\(P_1\\to P_2,P_1\\to P_3,P_1\\to P_4,P_2\\to P_5,P_3\\to P_5,P_4\\to P_6,P_4\\to P_7,P_5\\to P_8,P_6\\to P_8,P_7\\to P_9,P_8\\to P_9\\)\n或表示为：\n\\(P=\\set{P_1,P_2,P_3,P_4,P_5,P_6,P_7,P_8,P_9}\\)\n\\(=\\set{(P_1,P_2),(P_1,P_3),(P_1,P_4),(P_2,P_5),(P_3,P_5),(P_4,P_6),(P_4,P_7),(P_5,P_8),(P_6,P_8),(P_7,P_9),(P_8,P_9)}\\)\n应当注意，前趋图中是不允许有循环的，否则必然会产生不可能实现的前趋关系。如图1(b)所示的前趋关系中就存在着循环。它一方面要求在 \\(S_3\\) 开始执行之前， \\(S_2\\) 必须完成，另一方面又要求在 \\(S_2\\) 开始执行之前， \\(S_1\\) 必须完成。显然，这种关系是不可能实现的。\n\\(S_2\\to S_3,S_3\\to S_2\\)\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a)具有9个节点的前趋图 ( b )具有循环的前趋图 图1\u0026emsp;前趋图\n程序顺序执行 程序的顺序执行 通常，一个应用程序由若干个程序段组成，每一个程序段完成特定的功能，它们在执行时，都需要按照某种先后次序顺序执行，仅当前一程序段执行完后，才运行后一程序段。例如，在进行计算时，应先运行输入程序，用于输入用户的程序和数据；然后运行计算程序，对所输入的数据进行计算；最后才是运行打印程序，打印计算结果。我们用结点(Node)‌代表各程序段的操作（在图1中用圆圈表示），其中 \\(I\\) 代表输入操作， \\(C\\) 代表计算操作， \\(P\\) 为打印操作，用箭头指示操作的先后次序。这样，上述的三个程序段间就存在着这样的前趋关系： \\(I_i\\to C_i \\to P_i\\) ，其执行的顺序可用前趋图图2(a)描述。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a)程序的顺序执行 ( b )三条语句的顺序执行 图2\u0026emsp;程序顺序执行的前趋图\n即使是一个程序段，也可能存在着执行顺序问题，下面示出了一个包含了三条语句的程序段：\n\\(S_1\\): a :=x+y;\n\\(S_2\\): b :=a+5;\n\\(S_3\\): c :=b+1;\n其中，语句 \\(S_2\\) 必须在语句 \\(S_1\\) 后即（a被赋值）才能执行，语句 \\(S_3\\) 也只能在b被赋值后才能执行，因此，三条语句存在着这样的前趋关系： \\(S_1\\to S_2 \\to S_3\\) ，应按前趋图图2(b)所示的顺序执行。\n程序顺序执行时的特征 由上所述可以得知，在程序顺序执行时，具有这样三个特征：①顺序性：指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束；② 封闭性：指程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态（除初始状态外）只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；③可再现性：指只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都可获得相同的结果。程序顺序执行时的这种特性，为程序员检测和校正程序的错误带来了很大的方便。\n程序并发执行 程序顺序执行时，虽然可以给程序员带来方便，但系统资源的利用率却很低。为此，在系统中引入了多道程序技术，使程序或程序段间能并发执行。然而，并非所有的程序都能并发执行。事实上，只有在不存在前趋关系的程序之间才有可能并发执行，否则无法并发执行。\n程序的并发执行 我们通过一个常见的例子来说明程序的顺序执行和并发执行。图2中的输入程序、计算程序和打印程序三者之间，存在着 \\(I_i\\to C_i\\to P_i\\) 这样的前趋关系，以至对一个作业的输入、计算和打印三个程序段必须顺序执行。但若是对一批作业进行处理时，每道作业的输入、计算和打印程序段的执行情况如图3所示。输入程序 \\(I_1\\) 在输入第一次数据后，由计算程序 \\(C_1\\) 对该数据进行计算的同时，输入程序 \\(I_2\\) 可再输入第二次数据，从而使第一个计算程序 \\(C_1\\) 可与第二个输入程序 \\(I_2\\) 并发执行。事实上，正是由于 \\(C_1\\) 和 \\(I_2\\) 之间并不存在前趋关系，因此它们之间可以并发执行。一般来说，输入程序 \\(I_{i+1}\\) 在输入第 \\(i+1\\) 次数据时，计算程序 \\(C_i\\) 可能正在对程序 \\(I_i\\) 的第 \\(i\\) 次输入的数据进行计算，而打印程序 \\(P_{i-1}\\) 正在打印程序 \\(C{i-1}\\) 的计算结果。\n由图3可以看出，存在前趋关系 \\(I_i \\to C_i,I_i \\to I_{i+1},C_i \\to P_i, C_i \\to C_{i+1},P_i\\to P_{i+1}\\) 而 \\(I_{i+1}\\) 和 \\(C_i\\) 及 \\(P_{i-1}\\) 是重叠的，即在 \\(P_{i-1}\\) 和 \\(C_i\\) 以及 \\(I_{i+1}\\) 之间，不存在前趋关系，可以并发执行。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图3\u0026emsp;程序并发执行时的前趋图\n对于具有下述四条语句的程序段：\n\\(S_1\\) : a :=x+2\n\\(S_2\\) : b :=y+4\n\\(S_3\\) : c :=a+b\n\\(S_4\\) : d :=c+b\n可画出图4所示的前趋关系。可以看出： \\(S_3\\) 必须在a和b被赋值后方能执行； \\(S_4\\) 必须在 \\(S_3\\) 之后执行；但 \\(S_1\\) 和 \\(S_2\\) 则可以并发执行，因为它们彼此互不依赖。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图4\u0026emsp;四条语句的前趋关系\n程序并发执行时的特征 在引入了程序间的并发执行功能后，虽然提高了系统的吞吐量和资源利用率，但由于它们共享系统资源，以及它们为完成同一项任务而相互合作，致使在这些并发执行的程序之间必将形成相互制约的关系，由此会给程序并发执行带来新的特征。\n(1) 间断性。程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系。例如，图3中的 \\(I\\) 、 \\(C\\) 和 \\(P\\) 是三个相互合作的程序，当计算程序完成 \\(C_{i-1}\\) 的计算后，如果输入程序 \\(I_i\\) 尚未完成数据的输入，则计算程序 \\(C_i\\) 就无法进行数据处理，必须暂停运行。只有当使程序暂停的因素消失后（如 \\(I_i\\) 己完成数据输入），计算程序 \\(C_i\\) 便可恢复执行。由此可见，相互制约将导致并发程序具有\u0026quot;执行一暂停——执行”这种间断性的活动规律。\n(2) 失去封闭性。当系统中存在着多个可以并发执行的程序时，系统中的各种资源将为它们所共享，而这些资源的状态也由这些程序来改变，致使其中任一程序在运行时，其环境都必然会受到其它程序的影响。例如，当处理机已被分配给某个进程运行时，其它程序必须等待。显然，程序的运行已失去了封闭性。\n(3) 不可再现性。程序在并发执行时，由于失去了封闭性，也将导致其又失去可再现性。例如，有两个循环程序 \\(A\\) 和 \\(B\\) ，它们共享一个变量 \\(N\\) 。程序 \\(A\\) 每执行一次时，都要做 \\(N=N+1\\) 操作；程序 \\(B\\) 每执行一次时，都要执行 \\(\\text{Print}(N)\\) 操作，然后再将 \\(N\\) 置成“\\(0\\)”。程序 \\(A\\) 和 \\(B\\) 以不同的速度运行。这样，可能出现下述三种情况（假定某时刻变量 \\(N\\) 的值为 \\(n\\) ）：\n① \\(N=N+1\\) 在 \\(\\text{Print}(N)\\) 和 \\(N=0\\) 之前，此时得到的N值分别为 \\(n+1,n+1,0\\) 。\n② \\(N=N+1\\) 在 \\(\\text{Print}(N)\\) 和 \\(N=0\\) 之后，此时得到的 \\(N\\) 值分别为 \\(n,0,1\\) 。\n③ \\(N=N+1\\) 在 \\(\\text{Print}(N)\\) 和 \\(N=0\\) 之间，此时得到的 \\(N\\) 值分别为 \\(n,n+1,0\\) 。\n上述情况说明，程序在并发执行时，由于失去了封闭性，其计算结果必将与并发程序的执行速度有关，从而使程序的执行失去了可再现性。换而言之，程序经过多次执行后，虽然它们执行时的环境和初始条件相同，但得到的结果却各不相同。\n进程的描述 进程的定义和特征 进程的定义 在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性，以及其运行结果不可再现性的特征。由此，决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。\n为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block,PCB)。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。这样，由程序段、相关的数据段和PCB三部分便构成了进程实体（又称进程映像）。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实质上是创建进程实体中的PCB；而撤消进程，实质上是撤消进程的PCB，本教材中也是如此。\n对于进程的定义，从不同的角度可以有不同的定义，其中较典型的定义有：\n(1) 进程是程序的一次执行。\n(2) 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。\n(3) 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。\n在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”\n进程的特征 进程和程序是两个截然不同的概念，除了进程具有程序所没有的PCB结构外，还具有下面一些特征：\n(1) 动态性。进程的实质是进程实体的执行过程，因此，动态性就是进程的最基本的特征。动态性还表现在：“它由创建而产生，由调度而执行，由撤消而消亡。”可见，进程实体有一定的生命期，而程序则只是一组有序指令的集合，并存放于某种介质上，其本身并不具有活动的含义，因而是静态的。\n(2) 并发性。是指多个进程实体同存于内存中，且能在一段时间内同时运行。引入进程的目的也正是为了使其进程实体能和其它进程实体并发执行。因此，并发性是进程的另一重要特征，同时也成为OS的重要特征。而程序(没有建立PCB)是不能参与并发执行的。\n(3) 独立性。在传统的OS中，独立性是指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序都不能作为一个独立的单位参与运行。\n(4) 异步性，是指进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进。正是源于此因，才导致了传统意义上的程序若参与并发执行，会产生其结果的不可再现性。为使进程在并发运行时虽具有异步性，但仍能保证进程并发执行的结果是可再现的，在OS中引进了进程的概念，并且配置相应的进程同步机制。\n进程的基本状态及转换 进程的三种基本状态 由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。一般而言，每一个进程至少应处于以下三种基本状态之一：\n(1) 就绪(Ready)状态。这是指进程已处于准备好运行的状态，即进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。如果系统中有许多处于就绪状态的进程，通常将它们按一定的策略（如优先级策略）排成一个队列，称该队列为就绪队列。\n(2) 执行(Running)状态。这是指进程已获得CPU，其程序正在执行的状态。对任何一个时刻而言，在单处理机系统中，只有一个进程处于执行状态，而在多处理机系统中，则有多个进程处于执行状态。\n(3) 阻塞(Block)状态。这是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行时的状态，亦即进程的执行受到阻塞。此时引起进程调度，OS把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。通常系统将处于阻塞状态的进程也排成一个队列，称该队列为阻塞队列。实际上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因的不同，会设置多个阻塞队列。\n三种基本状态的转换 进程在运行过程中会经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理机之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程（当前进程）如果因分配给它的时间片己完而被剥夺处理机暂停执行时，其状态便由执行转为就绪：如果因发生某事件，致使当前进程的执行受阻（例如进程访问某临界资源，而该资源正被其它进程访问时），使之无法继续执行，则该进程状态将由执行转变为阻塞。图5示出了进程的三种基本状态，以及各状态之间的转换关系。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 阻塞 执行 就绪 I/O完成 时间片完 进程调度 I/O请求 终止 图5\u0026emsp;进程的三种基本状态及其转换\n创建状态和终止状态 为了满足进程控制块对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。\n1. 创建状态\n如前所述，进程是由创建而产生。创建一个进程是个很复杂的过程，一般要通过多个步骤才能完成：如首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息； 然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入就绪队列之中。\n但如果进程所需的资源尚不能得到满足，比如系统尚无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。引入创建状态是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性。同时，创建状态的引入也增加了管理的灵活性，OS可以根据系统性能或主存容量的限制推迟新进程的提交（创建状态）。对于处于创建状态的进程，当其获得了所需的资源以及对其PCB的初始化工作完成后，便可由创建状态转入就绪状态。\n2. 终止状态\n进程的终止也要通过两个步骤：首先，是等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将其PCB清零，并将该空白PCB返还系统。图6示出了增加了创建状态和终止状态后进程的五种状态及转换关系图。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 阻塞 执行 就绪 I/O完成 时间片完 进程调度 I/O请求 终止 创建 终止 图6\u0026emsp;进程的五种基本状态及转换\n挂起操作和进程状态的转换 在许多系统中，进程除了就绪、执行和阻塞三种最基本的状态外，为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作\u0026mdash;\u0026mdash;挂起操作。当该操作作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂不接受调度。与挂起操作对应的操作是激活操作。\n挂起操作的引入 引入挂起操作的原因，是基于系统和用户的如下需要：\n(1) 终端用户的需要。当终端用户在自己的程序运行期间发现有可疑问题，希望暂停自己的程序的运行，使之停止下来，以便用户研究其执行情况或对程序进行修改。\n(2) 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。\n(3) 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。\n(4) 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。\n引入挂起原语操作后三个进程状态的转换 在引入挂起原语Suspend和激活原语Active后，在它们的作用下，进程将可能发生以下几种状态的转换：\n(1) 活动就绪🠖静止就绪。当进程处于未被挂起的就绪状态时，称此为活动就绪状态，表示为Readya，此时进程可以接受调度。当用挂起原语Suspend将该进程挂起后，该进程便转变为静止就绪状态，表示为Readys，处于Readys状态的进程不再被调度执行。\n(2) 活动阻塞🠖静止阻塞。当进程处于未被挂起的阻塞状态时，称它是处于活动阻塞状态，表示为Blockeda。当用Suspend原语将它挂起后，进程便转变为静止阻塞状态，表示为Blockeds，处于该状态的进程在其所期待的事件出现后，它将从静止阻塞变为静止就绪Readys状态。\n(3) 静止就绪🠖活动就绪。处于Readys状态的进程若用激活原语Active激活后，该进程将转变为Readya状态。\n(4) 静止阻塞🠖活动阻塞。处于Blockeds状态的进程若用激活原语Active激活后，进程将转变为Blockeda状态。图7示出了具有挂起状态的进程状态图。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 活动 就绪 静止 就绪 执行 时间片完 挂起 挂起 调度 激活 活动 阻塞 释放 静止 阻塞 释放 挂起 激活 请求I/O 终止 图7\u0026emsp;具有挂起状态的进程状态图\n引入挂起操作后五个进程状态的转换 如图8示出了增加了创建状态和终止状态后具有挂起状态的进程状态及转换图。\n如图8所示，引进创建和终止状态后，在进程状态转换时，与图7所示的进程五状态转换相比较，要增加考虑下面的几种情况：\n(1) NULL🠖创建：一个新进程产生时，该进程处于创建状态。\n(2) 创建🠖活动就绪：在当前系统的性能和内存的容量均允许的情况下，完成对进程创建的必要操作后，相应的系统进程将进程的状态转换为活动就绪状态。\n(3) 创建🠖静止就绪：考虑到系统当前资源状况和性能的要求，不分配给新建进程所需资源，主要是主存，相应的系统将进程状态转为静止就绪状态，被安置在外存，不参与，调度，此时进程创建工作尚未完成。\n(4) 执行🠖终止：当一个进程已完成任务时，或是出现了无法克服的错误，或是被OS，或是被其他进程所终结，此时将进程的状态转换为终止状态。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 活动 就绪 静止 就绪 执行 时间片完 挂起 挂起 调度 激活 活动 阻塞 释放 静止 阻塞 释放 挂起 激活 请求I/O 释放 终止 创建 许可 许可 图8\u0026emsp;具有创建、终止和挂起状态的进程状态图\n进程管理中的数据结构 如操作系统概论-操作系统的目标和作用所述，一方面，为了便于对计算机中的各类资源（包括硬件和信息）的使用和管理，OS将它们抽象为相应的各种数据结构，以及提供一组对资源进行操作的命令，用户可利用这些数据结构及操作命令来执行相关的操作，而无需关心其实现的具体细节。另一方面，操作系统作为计算机资源的管理者，尤其是为了协调诸多用户对系统中共享资源的使用，它还必须记录和查询各种资源的使用及各类进程运行情况的信息。OS对于这些信息的组织和维护也是通过建立和维护各种数据结构的方式来实现的。\n操作系统中用于管理控制的数据结构 在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，我们称之为资源信息表或进程信息表，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。通过这些指针，可以将同类资源或进程的信息表，或者同一进程所占用的资源信息表分类链接成不同的队列，便于操作系统进行查找。如图9所示，OS管理的这些数据结构一般分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，通常进程表又被称为进程控制块PCB。本节着重介绍PCB，其它的表将在后面的篇章中陆续介绍。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 内存 设备 文件 进程 内存表 设备表 文件表 进程1 进程2 进程3 进程n 进程1 进程n 进程实体及作用资源列表 进程实体及作用资源列表 图9\u0026emsp;操作系统控制表一般结构\n进程控制块PCB的作用 为了便于系统描述和管理进程的运行，在OS的核心为每个进程专门定义了一个数据结构\u0026mdash;\u0026mdash;进程控制块PCB(Process Control Block)。PCB作为进程实体的一部分，记录了操作系统所需的，用于描述进程的当前情况以及管理进程运行的全部信息，是操作系统中最重要的记录型数据结构。\nPCB的作用是使一个在多道程序环境下不能独立运行的程序（含数据）成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。下面对PCB的具体作用作进一步的阐述：\n(1) 作为独立运行基本单位的标志。当一个程序（含数据）配置了PCB后，就表示它已是一个能在多道程序环境下独立运行的、合法的基本单位，也就具有取得OS服务的权利，如打开文件系统中的文件，请求获得系统中的I/O设备，以及与其它相关进程进行通信等。因此，当系统创建一个新进程时，就为它建立了一个PCB。进程结束时又回收其PCB，进程于是也随之消亡。系统是通过PCB感知进程的存在的。事实上，PCB已成为进程存在于系统中的唯一标志。\n(2) 能实现间断性运行方式。在多道程序环境下，程序是采用停停走走间断性的运行方式运行的。当进程因阻塞而暂停运行时，它必须保留自己运行时的CPU现场信息，再次被调度运行时，还需要恢复其CPU现场信息。在有了PCB后，系统就可将CPU现场信息保存在被中断进程的PCB中，供该进程再次被调度执行时恢复CPU现场时使用。由此， 可再次明确，在多道程序环境下，作为传统意义上的静态程序，因其并不具有保护或保存自己运行现场的手段，无法保证其运行结果的可再现性，从而失去运行的意义。\n(3) 提供进程管理所需要的信息。当调度程序调度到某进程运行时，只能根据该进程PCB中记录的程序和数据在内存或外存中的始址指针，找到相应的程序和数据；在进程运行过程中，当需要访问文件系统中的文件或I/O设备时，也都需要借助于PCB中的信息。另外，还可根据PCB中的资源清单了解到该进程所需的全部资源等。可见，在进程的整个生命期中，操作系统总是根据PCB实施对进程的控制和管理。\n(4) 提供进程调度所需要的信息。只有处于就绪状态的进程才能被调度执行，而在PCB中就提供了进程处于何种状态的信息。如果进程处于就绪状态，系统便将它插入到进程就绪队列中，等待着调度程序的调度；另外在进行调度时往往还需要了解进程的其他信息，如在优先级调度算法中，就需要知道进程的优先级。在有些较为公平的调度算法中，还需要知道进程的等待时间和已执行的时间等。\n(5) 实现与其它进程的同步与通信。进程同步机制是用于实现诸进程的协调运行的，在采用信号量机制时，它要求在每个进程中都设置有相应的用于同步的信号量。在PCB中还具有用于实现进程通信的区域或通信队列指针等。\n进程控制块中的信息 在进程控制块中，主要包括下述四个方面的信息。\n1. 进程标识符\n进程标识符用于唯一地标识一个进程。一个进程通常有两种标识符：\n(1) 外部标识符。为了方便用户（进程）对进程的访问，须为每一个进程设置一个外部标识符。它是由创建者提供的，通常由字母、数字组成。为了描述进程的家族关系，还应设置父进程标识及子进程标识。此外，还可设置用户标识，以指示拥有该进程的用户。\n(2) 内部标识符。为了方便系统对进程的使用，在OS中又为进程设置了内部标识符，即赋予每一个进程一个唯一的数字标识符，它通常是一个进程的序号。\n2. 处理机状态\n处理机状态信息也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的。这些寄存器包括：\n①通用寄存器，又称为用户可视寄存器，它们是用户程序可以访问的，用于暂存信息，在大多数处理机中，有8〜32个通用寄存器，在RISC结构的计算机中可超过100个；②指令计数器，其中存放了要访问的下一条指令的地址；③程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等；④用户栈指针，指每个用户进程都有一个或若干个与之相关的系统栈，用于存放过程和系统调用参数及调用地址。栈指针指向该栈的栈顶。处理机处于执行状态时，正在处理的许多信息都是放在寄存器中。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时能再从断点继续执行。\n3. 进程调度信息\n在OS进行调度时，必须了解进程的状态及有关进程调度的信息，这些信息包括：①进程状态，指明进程的当前状态，它是作为进程调度和对换时的依据；②进程优先级，是用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；③进程调度所需的其它信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等；④事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。\n4. 进程控制信息\n是指用于进程控制所必须的信息，它包括：①程序和数据的地址，进程实体中的程序和数据的内存或外存地（首）址，以便再调度到该进程执行时，能从PCB中找到其程序和数据；②进程同步和通信机制，这是实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中：③资源清单，在该清单中列出了进程在运行期间所需的全部资源（除CPU以外），另外还有一张已分配到该进程的资源的清单；④链接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。\n进程控制块的组织方式 在一个系统中，通常可拥有数十个、数百个乃至数千个PCB。为了能对它们加以有效的管理，应该用适当的方式将这些PCB组织起来。目前常用的组织方式有以下三种。\n(1) 线性方式，即将系统中所有的PCB都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。图10示出了线性表的PCB组织方式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e PCB1 PCB2 PCB3 PCBn 图10\u0026emsp;PCB线性表示意图\n(2) 链接方式，即把具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。对就绪队列而言，往往按进程的优先级将PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。同样，也可把处于阻塞状态进程的PCB根据其阻塞原因的不同，排成多个阻塞队列，如等待I/O操作完成的队列和等待分配内存的队列等。图11示出了一种链接队列的组织方式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 就绪队列指针 阻塞队列指针 空闲队列指针 执行指针 PCB1 PCB2 PCB1 PCB1 PCB1 PCB3 PCB4 PCB5 PCB6 PCB7 PCB8 PCB9 4 3 8 7 9 0 1 0 图11\u0026emsp;PCB连接队列示意图\n(3) 索引方式，即系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。图12示出了索引方式的PCB组织。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 执行指针 就绪表指针 阻塞表指针 PCB1 PCB2 PCB3 PCB5 PCB6 PCB7 PCB4 ··· 就绪索引表 阻塞索引表 图12\u0026emsp;按索引方式组织PCB\n进程控制 进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。如当一个正在执行的进程因等待某事件而暂时不能继续执行时，将其转变为阻塞状态，而在该进程所期待的事件出现后，又将该进程转换为就绪状态等。进程控制一般是由OS的内核中的原语来实现的。\n操作系统内核 现代操作系统一般将OS划分为若干层次，再将OS的不同功能分别设置在不同的层次中。通常将一些与硬件紧密相关的模块（如中断处理程序等）、各种常用设备的驱动程序以及运行频率较高的模块（如时钟管理、进程调度和许多模块所公用的一些基本操作），都安排在紧靠硬件的软件层次中，将它们常驻内存，即通常被称为的OS内核。这种安排方式的目的在于两方面：一是便于对这些软件进行保护，防止遭受其他应用程序的破坏；二是可以提高OS的运行效率。\n相对应的是，为了防止OS本身及关键数据（如PCB等）遭受到应用程序有意或无意的破坏，通常也将处理机的执行状态分成系统态和用户态两种：①系统态：又称为管态，也称为内核态。它具有较高的特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。②用户态：又称为目态。它是具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般情况下，应用程序只能在用户态运行，不能去执行OS指令及访问OS区域，这样可以防止应用程序对OS的破坏。\n总体而言，不同类型和规模的OS，它们的内核所包含的功能间存在着一定的差异，但大多数OS内核都包含了以下两大方面的功能：\n支撑功能 该功能是提供给OS其它众多模块所需要的一些基本功能，以便支撑这些模块工作。其中三种最基本的支撑功能是：中断处理、时钟管理和原语操作。\n(1) 中断处理。中断处理是内核最基本的功能，是整个操作系统赖以活动的基础，OS中许多重要的活动，如各种类型的系统调用、键盘命令的输入、进程调度、设备驱动等，无不依赖于中断。通常，为减少处理机中断的时间，提高程序执行的并发性，内核在对中断进行“有限处理”后，便转入相关的进程，由这些进程继续完成后续的处理工作。\n(2) 时钟管理。时钟管理是内核的一项基本功能，在OS中的许多活动都需要得到它的支撑，如在时间片轮转调度中，每当时间片用完时，便由时钟管理产生一个中断信号，促使调度程序重新进行调度。同样，在实时系统中的截止时间控制、批处理系统中的最长运行时间控制等，也无不依赖于时钟管理功能。\n(3) 原语操作。所谓原语(Primitive)，就是由若干条指令组成的，用于完成一定功能的一个过程。它与一般过程的区别在于：它们是“原子操作(Action Operation)”。所谓原子操作是指，一个操作中的所有动作要么全做，要么全不做。换言之，它是一个不可分割的基本单位。因此，原语在执行过程中不允许被中断。原子操作在系统态下执行，常驻内存。在内核中可能有许多原语，如用于对链表进行操作的原语、用于实现进程同步的原语等。\n资源管理功能 (1) 进程管理。在进程管理中，或者由于各个功能模块的运行频率较高，如进程的调度与分派、进程的创建与撤消等；或者由于它们为多种功能模块所需要，如用于实现进程同步的原语、常用的进程通信原语等。通常都将它们放在内核中，以提高OS的性能。\n(2) 存储器管理。存储器管理软件的运行频率也比较高，如用于实现将用户空间的逻辑地址变换为内存空间的物理地址的地址转换机构、内存分配与回收的功能模块以及实现内存保护和对换功能的模块等。通常也将它们放在内核中，以保证存储器管理具有较高的运行速度。\n(3) 设备管理。由于设备管理与硬件（设备）紧密相关，因此其中很大部分也都设置在内核中。如各类设备的驱动程序、用于缓和CPU与I/O速度不匹配矛盾的缓冲管理、用于实现设备分配和设备独立性功能的模块等。\n进程的创建 进程的层次结构 在OS中，允许一个进程创建另一个进程，通常把创建进程的进程称为父进程，而把被创建的进程称为子进程。子进程可继续创建更多的孙进程，由此便形成了一个进程的层次结构。如在UNIX中，进程与其子孙进程共同组成一个进程家族（组）。\n了解进程间的这种关系是十分重要的。因为子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，继承父进程所分配到的缓冲区等。当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。此外，在撤消父进程时，也必须同时撤消其所有的子进程。为了标识进程之间的家族关系，在PCB中设置了家族关系表项，以标明自己的父进程及所有的子进程。进程不能拒绝其子进程的继承权。\n值得注意的是，在Windows中不存在任何进程层次结构的概念，所有的进程都具有相同的地位。如果一个进程创建另外的进程时创建进程获得了一个句柄，其作用相当于一个令牌，可以用来控制被创建的进程。但是，这个句柄是可以进行传递的，也就是说，获得了句柄的进程就拥有控制其它进程的权力，因此，进程之间的关系不再是层次关系了，而是获得句柄与否、控制与被控制的简单关系。\n进程图 为了形象地描述一个进程的家族关系而引入了进程图(Process Graph)。所谓进程图就是用于描述进程间关系的一棵有向树，如图13所示。图中的结点代表进程。在进程 \\(P_i\\) 创建了进程 \\(P_j\\) 之后，称 \\(P_i\\) 是 \\(P_j\\) 的父进程(Parent Process)， \\(P_j\\) 是 \\(P_i\\) 的子进程(Progeny Process)。这里可用一条由进程 \\(P_i\\) 指向进程 \\(P_j\\) 的有向边来描述它们之间的父子关系。创建父进程的进程称为祖先进程，这样便形成了一棵进程树，把树的根结点作为进程家族的祖先(Ancestor)。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图13\u0026emsp;进程树\n引起创建进程的事件 为使程序之间能并发运行，应先为它们分别创建进程。导致一个进程去创建另一个进 程的典型事件有四类：\n(1) 用户登录。在分时系统中，用户在终端键入登录命令后，若登录成功，系统将为该用户建立一个进程，并把它插入就绪队列中。\n(2) 作业调度。在多道批处理系统中，当作业调度程序按一定的算法调度到某个（些）作业时，便将它（们）装入内存，为它（们）创建进程，并把它（们）插入就绪队列中。\n(3)提供服务。当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户所需要的服务，例如，用户程序要求进行文件打印，操作系统将为它创建一个打印进程，这样不仅可使打印进程与该用户进程并发执行，而且还便于计算为完成打印任务所花费的时间。\n(4)应用请求。在上述三种情况下，都是由系统内核为用户创建一个新进程；而这类事件则是由用户进程自己创建新进程，以便使新进程以同创建者进程并发运行的方式完成特定任务。例如，某用户程序需要不断地先从键盘终端读入数据，继而再对输入数据进行相应的处理，然后，再将处理结果以表格形式在屏幕上显示。该应用进程为使这几个操作能并发执行，以加速任务的完成，可以分别建立键盘输入进程、表格输出进程。\n进程的创建(Create of Process) 在系统中每当出现了创建新进程的请求后，OS便调用进程创建原语Create按下述步骤创建一个新进程：\n(1) 申请空白PCB，为新进程申请获得唯一的数字标识符，并从PCB集合中索取一个空白PCB。\n(2) 为新进程分配其运行所需的资源，包括各种物理和逻辑资源，如内存、文件、I/O设备和CPU时间等。这些资源或从操作系统或仅从其父进程获得。新进程对这些资源的需求详情一般也要提前告知操作系统或其父进程。例如，为新进程的程序和数据以及用户栈分配必要的内存空间时，操作系统必须知道新进程所需内存的大小：①对于批处理作业，其大小可在用户提出创建进程要求时提供；②若是为应用进程创建子进程，也应是在该进程提出创建进程的请求中给出所需内存的大小；③对于交互型作业，用户可以不给出内存要求而由系统分配一定的空间；如果新进程要共享某个己在内存的地址空间（即已装入内存的共享段），则必须建立相应的链接。\n(3) 初始化进程控制块(PCB)。PCB的初始化包括：①初始化标识信息，将系统分配的标识符和父进程标识符填入新PCB中；②初始化处理机状态信息，使程序计数器指向程序的入口地址，使栈指针指向栈顶；③初始化处理机控制信息，将进程的状态设置为就绪状态或静止就绪状态，对于优先级，通常是将它设置为最低优先级，除非用户以显式方式提出高优先级要求。\n(4) 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。\n进程的终止 引起进程终止(Termination of Process)的事件 (1) 正常结束，表示进程的任务已经完成，准备退出运行。在任何系统中，都应有一个用于表示进程已经运行完成的指示。在批处理系统中，通常会在程序的最后安排一条Holt指令，用于向OS表示运行已结束。当程序运行到Holt指令时，将产生一个中断，去通知OS本进程已经完成；在分时系统中，用户可利用Logs off去表示进程运行完毕，此时同样可产生一个中断，去通知OS进程已运行完毕。\n(2) 异常结束，是指进程在运行时发生了某种异常事件，使程序无法继续运行。常见的异常事件有：①越界错，这是指程序所访问的存储区，已越出该进程的区域；②保护错，指进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件；③非法指令，指程序试图去执行一条不存在的指令。出现该错误的原因可能是程序错误地转移到数据区，把数据当成了指令：④特权指令错，指用户进程试图去执行一条只允许OS执行的指令；⑤运行超时，指进程的执行时间超过了指定的最大值；⑥等待超时，指进程等待某事件的时间超过了规定的最大值；⑦算术运算错，指进程试图去执行一个被禁止的运算，例如，被0除；⑧I/O故障，这是指在I/O过程中发生了错误等。\n(3) 外界干预，是指进程应外界的请求而终止运行。这些干预有：①操作员或操作系统干预，指如果系统中发生了某事件，例如，发生了系统死锁，由操作员或操作系统采取终止某些进程的方式使系统从死锁状态中解救出来；②父进程请求，指当子进程已完成父进程所要求的任务时，父进程可以提出请求结束该子进程；③因父进程终止，指当父进程终止时，它的所有子进程也都应当结束，因此，OS在终止父进程的同时，也将它的所有子孙进程终止。\n进程终止的过程 如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：\n(1) 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态。\n(2) 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。\n(3) 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程。\n(4) 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统。\n(5) 将被终止进程(PCB)从所在队列（或链表）中移出，等待其它程序来搜集信息。\n进程的阻塞与唤醒 引起进程阻塞和唤醒的事件 有下述几类事件会引起进程阻塞或被唤醒：\n(1) 向系统请求共享资源失败。进程在向系统请求共享资源时，由于系统已无足够的资源分配给它，此时进程因不能继续运行而转变为阻塞状态。例如，一进程请求使用打印机，由于系统已将打印机分配给其它进程，已无可以再可分配的打印机，这时请求者进程只能被阻塞，仅在其它进程释放出打印机时，请求进程才被唤醒。\n(2) 等待某种操作的完成。当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则应先将该进程阻塞起来，以等待操作完成。例如，进程启动了某I/O设备，如果只有在I/O设备完成了指定的I/O操作任务后进程才能继续执行，则该进程在启动了I/O设备后便应自动进入阻塞状态去等待。在I/O操作完成后，再由中断处理程序将该进程唤醒。\n(3) 新数据尚未到达。对于相互合作的进程，如果一个进程需要先获得另一进程提供的数据后才能对该数据进行处理，只要其所需数据尚未到达，进程便只有阻塞。例如，有两个进程，进程A用于输入数据，进程B对输入数据进行加工。假如A尚未将数据输入完毕，则进程B将因没有所需处理的数据而阻塞；一旦进程A把数据输入完毕，便可去唤醒进程B。\n(4) 等待新任务的到达。在某些系统中，特别是在网络环境下的OS，往往设置一些特定的系统进程，每当这种进程完成任务后便把自己阻塞起来，等待新任务的到来。例如，在网络环境中的发送进程，其主要任务是发送数据包，若已有的数据包已全部发送完成，而又无新的数据包发送，这时发送进程将把自己阻塞起来；仅当有新的数据包到达时，才将发送进程唤醒。\n进程阻塞过程 正在执行的进程，如果发生了上述某事件，进程便通过调用阻塞原语block将自己阻塞。可见，阻塞是进程自身的一种主动行为。进入block过程后，由于该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞队列。最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换，亦即，保留被阻塞进程的处理机状态，按新进程的PCB中的处理机状态设置CPU的环境。\n进程唤醒过程 当被阻塞进程所期待的事件发生时，比如它所启动的I/O操作已完成，或其所期待的OS，数据已经到达，则由有关进程（比如提供数据的进程）调用唤醒原语wakeup，将等待该事件OS，的进程唤醒。wakeup执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出OS，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。应当指出，block原语和wakeup原语是一对作用刚好相反的原语。在使用它们时，必须成对使用，即如果在某进程中调用了阻塞原语，则必须在与之相合作的、或其它相关的OS，进程中安排一条相应的唤醒原语，以便能唤醒被阻塞进程；否则，阻塞进程将会因不能被OS，唤醒而永久地处于阻塞状态，再无机会继续运行。\n进程的挂起与激活 进程的挂起 当系统中出现了引起进程挂起的事件时，OS将利用挂起原语suspend将指定进程或处于阻塞状态的进程挂起。suspend的执行过程是：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪：对于活动阻塞状态的进程，则将之改为静止阻塞；为了方便用户或父进程考查该进程的运行情况，而把该进程的PCB复制到某指定的内存区域；最后，若被挂起的进程正在执行，则转向调度程序重新调度。\n进程的激活过程 当系统中发生激活进程的事件时，OS将利用激活原语active，将指定进程激活。激活原语先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。假如采用的是抢占调度策略，则每当有静止就绪进程被激活而插入就绪队列时，便应检查是否要进行重新调度，即由调度程序将被激活的进程与当前进程两者的优先级进行比较，如果被激活进程的优先级低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分配给刚刚被激活的进程。\n进程同步 在OS中引入进程后，一方面可以使系统中的多道程序并发执行，这不仅能有效地改善资源利用率，还可显著地提高系统的吞吐量，但另一方面却使系统变得更加复杂。如果不能采取有效的措施，对多个进程的运行进行妥善的管理，必然会因为这些进程对系统资源的无序争夺给系统造成混乱。致使每次处理的结果存在着不确定性，即显现出其不可再现性。\n为保证多个进程能有条不紊地运行，在多道程序系统中，必须引入进程同步机制。在本文中，将详细介绍在单处理机系统中的进程同步机制\u0026mdash;\u0026mdash;硬件同步机制、信号量机制、管程机制等，利用它们来保证程序执行的可再现性。\n进程同步的基本概念 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性。\n两种形式的制约关系 在多道程序环境下，对于同处于一个系统中的多个进程，由于它们共享系统中的资源，或为完成某一任务而相互合作，它们之间可能存在着以下两种形式的制约关系：\n1. 间接相互制约关系\n多个程序在并发执行时，由于共享系统资源，如CPU、I/O设备等，致使在这些并发执行的程序之间形成相互制约的关系。对于像打印机、磁带机这样的临界资源，必须保证多个进程对之只能互斥地访问，由此，在这些进程间形成了源于对该类资源共享的所谓间接相互制约关系。为了保证这些进程能有序地运行，对于系统中的这类资源，必须由系统实施统一分配，即用户在要使用之前，应先提出申请，而不允许用户进程直接使用。\n2. 直接相互制约关系\n某些应用程序，为了完成某任务而建立了两个或多个进程。这些进程将为完成同一项任务而相互合作。进程间的直接制约关系就是源于它们之间的相互合作。例如，有两个相互合作的进程\u0026mdash;\u0026mdash;输入进程A和计算进程B，它们之间共享一个缓冲区。进程A通过缓冲向进程B提供数据。进程B从缓冲中取出数据，并对数据进行处理。但如果该缓冲空时，计算进程因不能获得所需数据而被阻塞。一旦进程A把数据输入缓冲区后便将进程B唤醒；反之，当缓冲区已满时，进程A因不能再向缓冲区投放数据而被阻塞，当进程B将缓冲区数据取走后便可唤醒A。\n在多道程序环境下，由于存在着上述两类相互制约关系，进程在运行过程中是否能获得处理机运行与以怎样的速度运行，并不能由进程自身所控制，此即进程的异步性。由此会产生对共享变量或数据结构等资源不正确的访问次序，从而造成进程每次执行结果的不一致。这种差错往往与时间有关，故称为“与时间有关的错误”。为了杜绝这种差错，必须对进程的执行次序进行协调，保证诸进程能按序执行。\n临界资源(Critical Resource) 在第一篇中我们曾经介绍过，许多硬件资源如打印机、磁带机等，都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享。下面我们将通过一个简单的例子来说明这一过程。\n生产者\u0026mdash;消费者（producer-consumer）问题是一个著名的进程同步问题。它描述的是：有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程将其所生产的产品放入一个缓冲区中:消费者进程可从一个缓冲区中取走产品去消费。尽管所有的生产者进程和消费者进程都是以异步方式运行的，但它们之间必须保持同步，既不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未被取走的缓冲区中投放产品。\n我们可利用一个数组buffer来表示上述的具有n个缓冲区的缓冲池。每投入（或取出）一个产品时,缓冲池buffer中暂存产品（或已取走产品的空闲单元）的数组单元指针in（或out）加1。由于这里由buffer组成的缓冲池是被组织成循环缓冲的，故应把输入指针in（或输出指针out）加1，表示成in=(in+1)%n（或out=(out+1)%n）。当(in+1)%n=out时表示缓冲池满；而in=out则表示缓冲池空。此外，还引入了一个整型变量counter，其初始值为0。每当生产者进程向缓冲池中投放（或取走）一个产品后，使counter加1(或减1)。生产者和消费者两进程共享下面的变量：\n1 2 int in=0, out=0, count=0; item buffer[n]; 指针in和out初始化为0。在生产者进程中使用一局部变量nextp，用于暂时存放每次刚刚生产出来的产品；而在消费者进程中，则使用一个局部变量nextc，用于存放每次要消费的产品。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void producer() { item nextp; do { nextp = produce_item(); // 假设有函数produce_item()用于生成产品 while (counter == n); // 忙等待 buffer[in] = nextp; in = (in + 1) % n; counter++; } while (true); } void consumer() { item nextc; do { while (counter == 0); // 忙等待 nextc = buffer[out]; out = (out + 1) % n; counter--; consume_item(nextc); // 假设有函数consume_item()用于消费产品 } while (true); } void main() { create(producer); create(consumer); } 虽然上面的生产者程序和消费者程序在分别看时都是正确的，而且两者在顺序执行时其结果也会是正确的，但若并发执行时就会出现差错，问题就在于这两个进程共享变量counter。生产者对它做加1操作，消费者对它做减1操作，这两个操作在用机器语言实现时，常可用下面的形式描述：\n1 2 3 4 // 生产者进程 register1 = counter; register1 = register1 + 1; counter = register1; 1 2 3 4 // 消费者进程 register2 = counter; register2 = register2 - 1; counter = register2; 假设counter当前值是5。如果生产者进程先执行左列的三条机器语言语句，然后消费者进程再执行右列的三条语句，则最后共享变量counter的值仍为5。反之，如果让消费者进程先执行右列的三条语句，然后再让生产者进程执行左列的三条语句，counter值也还是5，但是，如果按下述顺序执行：\n1 2 3 4 5 6 register1 = counter; // (register1 = 5) register1 = register1 + 1; // (register1 = 6) register2 = counter; // (register2 = 5) register2 = register2 - 1; // (register2 = 4) counter = register1; // (counter = 6) counter = register2; // (counter = 4) 正确的counter值应当是5，但现在是4。读者可以自己试试，倘若再将两段程序中各语句交叉执行的顺序改变，将可看到又可能得到counter=6的答案，这表明程序的执行已经失去了再现性。为了预防产生这种错误，解决此问题的关键是应把变量counter作为临界资源处理，亦即，令生产者进程和消费者进程互斥地访问变量counter。\n临界区(critical section) 由前所述可知，不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问。人们把在每个进程中访问临界资源的那段代码称为临界区(critical section)。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资源的互斥访问。为此,每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看它是否正被访问。如果此刻临界资源未被访问，进程便可进入临界区对该资源进行访问，并设置它正被访问的标志；如果此刻该临界资源正被某进程访问，则本进程不能进入临界区。因此，必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区(entry section)。相应地，在临界区后面也要加上一段称为退出区(exitsection)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。进程中除上述进入区、临界区及退出区之外的其它部分的代码在这里都称为剩余区。这样，可把一个访问临界资源的循环进程描述如下：\n1 2 3 4 5 6 7 8 void process() { do{ enter_critical_section(); //进入区 critical_section(); //临界区 exit_critical_section(); //退出区 remainder_section(); //剩余区 } while (true); } 同步机制应遵循的规则 为实现进程互斥地进入自己的临界区，可用软件方法，更多的是在系统中设置专门的同步机构来协调各进程间的运行。所有同步机制都应遵循下述四条准则：\n(1) 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。\n(2) 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。\n(3) 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入\u0026quot;死等”状态。\n(4) 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。\n硬件同步机制 虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。实际上，在对临界区进行管理时，可以将标志看做一个锁，“锁开”进入，“锁关”等待，初始时锁是打开的。每个要进入临界区的进程必须先对锁进行测试，当锁未开时，则必须等待，直至锁被打开。反之，当锁是打开的时候，则应立即把其锁上，以阻止其它进程进入临界区。显然，为防止多个进程同时测试到锁为打开的情况，测试和关锁操作必须是连续的，不允许分开进行。\n关中断 关中断是实现互斥的最简单的方法之一。在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。这样，进程在临界区执行期间，计算机系统不响应中断，从而不会引发调度，也就不会发生进程或线程切换。由此，保证了对锁的测试和关锁操作的连续性和完整性，有效地保证了互斥。但是，关中断的方法存在许多缺点：①滥用关中断权力可能导致严重后果；②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；③关中断方法也不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。\n利用Test-and-Set指令实现互斥 这是一种借助一条硬件指令——“测试并建立”指令TS（Test-and-Set）‌以实现互斥的方法。在许多计算机中都提供了这种指令。TS指令的一般性描述如下：\n1 2 3 4 5 6 7 #include \u0026lt;stdbool.h\u0026gt; bool TS(bool *lock) { bool old; old = *lock; *lock = true; return old; } 这条指令可以看作为一个函数过程，其执行过程是不可分割的，即是一条原语。其中，lock有两种状态：当lock=false时，表示该资源空闲；当lock=true时，表示该资源正在被使用。\n用TS指令管理临界区时，为每个临界资源设置一个布尔变量lock，由于变量lock代表了该资源的状态，故可把它看成一把锁。lock初值为false，表示该临界资源空闲。进程在进入临界区之前，首先用TS指令测试lock，如果其值为false，则表示没有进程在临界区内，可以进入，并将true值赋予lock，这等效于关闭了临界资源，使任何进程都不能进入临界区，否则必须循环测试直到TS(s)为true。利用TS指令实现互斥的循环进程结构可描述如下：\n1 2 3 4 5 6 7 8 void process() { do { while(TS(\u0026amp;lock)); //进入区 ... //临界区 lock = false; //退出区 ... //剩余区 } while (true); } 利用Swap指令实现互斥 该指令称为对换指令，在Intel 80x86中又称为XCHG指令，用于交换两个字的内容。其处理过程描述如下：\n1 2 3 4 5 6 void swap(bool *a, bool *b) { bool temp; temp = *a; *a = *b; *b = temp; } 用对换指令可以简单有效地实现互斥，方法是为每个临界资源设置一个全局的布尔变量lock,其初值为false，在每个进程中再利用一个局部布尔变量key。利用Swap指令实现进程互斥的循环进程可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 bool lock = false; void process() { bool key; do { key = true; do { swap(\u0026amp;lock, \u0026amp;key); } while (key != false); //进入区 ... //临界区 lock = false; //退出区 ... //剩余区 } while (true); } 利用上述硬件指令能有效地实现进程互斥，但当临界资源忙碌时，其它访问进程必须不断地进行测试，处于一种\u0026quot;忙等”状态，不符合“让权等待”的原则，造成处理机时间的浪费，同时也很难将它们用于解决复杂的进程同步问题。\n信号量机制 1965年，荷兰学者Dijkstra提出的信号量(Semaphores)机制是一种卓有成效的进程同步工具。在长期且广泛的应用中，信号量机制又得到了很大的发展，它从整型信号量经记录型信号量，进而发展为‌“信号量集”机制。现在，信号量机制已被广泛地应用于单处理机和多处理机系统以及计算机网络中。\n整型信号量 最初由Dijkstra把整型信号量定义为一个用于表示资源数目的整型量S，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation)‌wait(\u0026amp;S)和signal(\u0026amp;S)来访问。很长时间以来，这两个操作一直被分别称为P、V操作。wait和signal操作可描述如下：\n1 2 3 4 5 6 7 void wait(int *S) { while (*S \u0026lt;= 0); (*S)--; } void signal(int *S) { (*S)++; } wait(\u0026amp;S)和signal(\u0026amp;S)是两个原子操作，因此，它们在执行时是不可中断的。亦即，当一个进程在修改某信号量时，没有其它进程可同时对该信号量进行修改。此外，在wait操作中，对S值的测试和做S=S-1操作时都不可中断。\n记录型信号量 在整型信号量机制中的wait操作，只要是信号量S⩽0，就会不断地测试。因此，该机制并未遵循“让权等待”的准则，而是使进程处于“忙等”的状态。记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现多个进程等待访问同一临界资源的情况。为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量value外，还应增加一个进程链表指针list，用于链接上述的所有等待进程。记录型信号量是由于它采用了记录型的数据结构而得名的。它所包含的上述两个数据项可描述如下：\n1 2 3 4 typedef struct { int value; struct process_control_block *list; }semaphore; 相应地，wait(\u0026amp;S)和signal(\u0026amp;S)操作可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void wait(semaphore *S) { S-\u0026gt;value--; if (S-\u0026gt;value \u0026lt; 0) { block(\u0026amp;(S-\u0026gt;list)); //阻塞进程 } } void signal(semaphore *S) { S-\u0026gt;value++; if (S-\u0026gt;value \u0026lt;= 0) { wakeup(\u0026amp;(S-\u0026gt;list)); //唤醒进程 } } 在记录型信号量机制中，S-\u0026gt;value的初值表示系统中某类资源的数目，因而又称为资源信号量，对它的每次wait操作，意味着进程请求一个单位的该类资源，使系统中可供分配的该类资源数减少一个，因此描述为S-\u0026gt;value--；当S.value\u0026lt;0时，表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞，放弃处理机，并插入到信号量链表S-\u0026gt;list中。可见，该机制遵循了“让权等待”准则。此时S-\u0026gt;value的绝对值表示在该信号量链表中已阻塞进程的数目。对信号量的每次signal操作表示执行进程释放一个单位资源，使系统中可供分配的该类资源数增加一个，故S-\u0026gt;value++操作表示资源数目加1。若加1后仍是S-\u0026gt;value⩽0,则表示在该信号量链表中仍有等待该资源的进程被阻塞，故还应调用wakeup原语，将S-\u0026gt;list链表中的第一个等待进程唤醒。如果S-\u0026gt;value的初值为1，表示只允许一个进程访问临界资源，此时的信号量转化为互斥信号量，用于进程互斥。\nAND型信号量 前面所述的进程互斥问题针对的是多个并发进程仅共享一个临界资源的情况。在有些应用场合，是一个进程往往需要获得两个或更多的共享资源后方能执行其任务。假定现有两个进程A和B，它们都要求访问共享数据D和E，当然，共享数据都应作为临界资源。为此，可为这两个数据分别设置用于互斥的信号量Dmutex和Emutex，并令它们的初值都是1。相应地，在两个进程中都要包含两个对Dmutex和Emutex的操作，即\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void processA() { do{ wait(\u0026amp;Dmutex); signal(\u0026amp;Dmutex); wait(\u0026amp;Emutex); signal(\u0026amp;Emutex); } while (true); } void processB() { do{ wait(\u0026amp;Dmutex); signal(\u0026amp;Dmutex); wait(\u0026amp;Emutex); signal(\u0026amp;Emutex); } while (true); } 若进程A和B按下述次序交替执行wait操作：\n1 2 3 4 processA(): wait(\u0026amp;Dmutex);//Dmutex=0 processB(): wait(\u0026amp;Emutex);//Emutex=0 processA(): wait(\u0026amp;Emutex);//Emutex=-1 A阻塞 prodessB(): wait(\u0026amp;Dmutex);//Dmutex=-1 B阻塞 最后，进程A和B就将处于僵持状态。在无外力作用下，两者都将无法从僵持状态中解脱出来。我们称此时的进程A和B已进入死锁状态。显然，当进程同时要求的共享资源愈多时，发生进程死锁的可能性也就愈大。\nAND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。亦即，对若干个临界资源的分配采取原子操作方式：要么把它所请求的资源全部分配到进程，要么一个也不分配。由死锁理论可知，这样就可避免上述死锁情况的发生。为此，在wait操作中增加了一个“AND”条件，故称为‌AND同步，或称为同时wait操作，Swait定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Swait：等待多个信号量满足条件 void Swait(int *S1, int *S2, ..., int *Sn) { int *S[n] = {S1,S2,...,Sn}; while (true) { bool all_ready = true; // 检查所有信号量是否满足条件 for (int i = 0; i \u0026lt; n; i++) { if (*S[i] \u0026lt; 1) { all_ready = false; // 将当前进程放入与第一个不足的Si相关联的等待队列中 // 并将程序计数器设置为Swait操作的开头 place_in_waiting_queue(S[i]); break; } } // 如果所有信号量都满足条件，减去它们的值并退出循环 if (all_ready) { for (int i = 0; i \u0026lt; n; i++) { (*S[i])--; } break; } } } // Ssignal：释放多个信号量 void Ssignal(int *S1, int *S2, ..., int *Sn) { int *S[n] = {S1,S2,...,Sn}; while (true) { for (int i = 0; i \u0026lt; n; i++) { (*S[i])++; // 将等待在与Si相关的等待队列中的所有进程移至就绪队列 move_waiting_to_ready_queue(S[i]); } break; // 退出循环以防止无限循环 } } 信号量集 在前面所述的记录型信号量机制中，wait(\u0026amp;S)或signal(\u0026amp;S)操作仅能对信号量施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait(\u0026amp;S)操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配之前，都必须测试资源的数量，判断是否大于可分配的下限值，决定是否予以分配。\n基于上述两点，可以对 AND 信号量机制加以扩充，对进程所申请的所有资源以及每类资源不同的资源需求量，在一次 Swait、Ssignal 原语操作中完成申请或释放。进程对信号量 *Si 的测试值不再是 1 ，而是该资源的分配下限值 ti ，即要求 *Si \u0026gt;= ti ，否则不予分配。一旦允许分配，进程对该资源的需求值为 di ，即表示资源占用量，进行 *Si = *Si - di 操作，而不是简单的 *Si = *Si - 1 。由此形成一般化的“信号量集”机制。对应的 Swait 和 Ssignal 格式为：\n1 2 Swait(int *S1, int t1, int d1, int *S2, int t2, int d2, ... ,int *Sn, int tn, int dn); Ssignal(int *S1, int d1, int S2, int d2, ..., int *Sn, int dn); 一般信号量集还有下面几种特殊情况：\n(1)Swait(\u0026amp;S,d,d)。此时在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。\n(2)Swait(\u0026amp;S,1,1)。此时的信号量集己退化为一般的记录型信号量（S\u0026gt;1时）或互斥信号量（S=1时）。\n(3)Swait(\u0026amp;S,1,0)。这是一种很特殊且很有用的信号量操作。当S\u0026gt;=1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。\n信号量的应用 利用信号量实现进程互斥 为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(\u0026amp;mutex)和signal(\u0026amp;mutex)操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被访问，本次wait操作必然成功，进程便可进入自己的临界区，这时若再有其它进程也欲进入自己的临界区，由于对mutex执行wait操作定会失败，因而此时该进程阻塞，从而保证了该临界资源能被互斥地访问。当访问临界资源的进程退出临界区后，又应对mutex执行signal操作，以便释放该临界资源。利用信号量实现两个进程互斥的描述如下：\n(1)设mutex为互斥信号量，其初值为1，取值范围为(-1,0,1)。当mutex=1时，表示两个进程皆未进入需要互斥的临界区；当mutex=0时，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列；当mutex=-1时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。\n(2)代码描述：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 semaphore mutex=1; void ProcessA() { while(true) { wait(\u0026amp;mutex); ...//临界区 signal(\u0026amp;mutex); ...//剩余区 } } void ProcessB() { while(true) { wait(\u0026amp;mutex); ...//临界区 signal(\u0026amp;mutex); ...//剩余区 } } 在利用信号量机制实现进程互斥时应该注意，wait(\u0026amp;mutex)和signal(\u0026amp;mutex)必须成对地出现。缺少wait(\u0026amp;mutex)将会导致系统混乱，不能保证对临界资源的互斥访问；而缺少signal(\u0026amp;mutex)将会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不能被唤醒。\n利用信号量实现前趋关系 还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程 \\(P_1\\) 和 \\(P_2\\) 。 \\(P_1\\) 中有语句 \\(S_1\\) ， \\(P_2\\) 中有语句 \\(S_2\\) 。我们希望在 \\(S_1\\) 执行后再执行 \\(S_2\\) 。为实现这种前趋关系，只需使进程 \\(P_1\\) 和 \\(P_2\\) 共享一个公用信号量 \\(S\\) ，并赋予其初值为0，将signal(\u0026amp;S)操作放在语句 \\(S_1\\) 后面，而在 \\(S_2\\) 语句前面插入wait(\u0026amp;S)操作，即\n在进程 \\(P_1\\) 中，用S1;signal(\u0026amp;S);\n在进程 \\(P_2\\) 中，用wait(\u0026amp;S);S2;\n由于S被初始化为0，这样，若 \\(P_2\\) 先执行必定阻塞，只有在进程 \\(P_1\\) 执行完S1;signal(\u0026amp;S);操作后使S增为1时， \\(P_2\\) 进程方能成功执行语句 \\(S_2\\) 。同样，我们可以利用信号量按照语句间的前趋关系（见图14），写出一个更为复杂的可并发执行的程序。图14中 \\(S_1,S_2,S_3,\\cdots,S_6\\) 是最简单的程序段（只有一条语句）。为使各程序段能正确执行，应设置若干个初始值为“0”的信号量。如为保证 \\(S_1\\to S_2\\) ， \\(S_1 \\to S_3\\) 的前趋关系,应分别设置信号量a和b,同样，为了保证 \\(S_2 \\to S_4,S_2 \\to S_5, S_3 \\to S_6,S_4 \\to S_6\\) 和 \\(S_5 \\to S_6\\) ，应设置信号量c、d、e、f、g。代码框架描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 void p1() { S1(); signal(\u0026amp;a); signal(\u0026amp;b);} void p2() { wait(\u0026amp;a); S2(); signal(\u0026amp;c); signal(\u0026amp;d);} void p3() { wait(\u0026amp;b); S3(); signal(\u0026amp;e);} void p4() { wait(\u0026amp;c); S4(); signal(\u0026amp;f);} void p5() { wait(\u0026amp;d); S5(); signal(\u0026amp;g);} void p6() { wait(\u0026amp;e); wait(f); wait(\u0026amp;g); S6();} void main() { semaphore a, b, c, d, e, f, g; a.value=0; b.value=0; c.vaIue=O; d.value=0; e.value=0; f.value=0; g.value=0; p1(); p2(); p3(); p4(); p5(); p6(); } ‌\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图14\u0026emsp;前趋图举例\n管程机制 虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作wait(\u0026amp;S)和signal(\u0026amp;S)。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。这样，在解决上述问题的过程中，便产生了一种新的进程同步工具\u0026mdash;\u0026mdash;管程(Monitors)。\n管程的定义 系统中的各种硬件资源和软件资源均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。因此，可以利用共享数据结构抽象地表示系统中的共享资源，并且将对该共享数据结构实施的特定操作定义为一组过程。进程对共享资源的申请、释放和其它操作必须通过这组过程，间接地对共享数据结构实现操作。对于请求访问共享资源的诸多并发进程，可以根据资源的情况接受或阻塞，确保每次仅有一个进程进入管程，执行这组过程，使用共享资源，达到对共享资源所有访问的统一管理，有效地实现进程互斥。\n代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，我们称之为管程。管程被请求和释放资源的进程所调用。Hansan为管程所下的定义是：\u0026ldquo;一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。\n由上述的定义可知，管程由四部分组成：①管程的名称；②局部于管程的共享数据结构说明；③对该数据结构进行操作的一组过程；④对局部于管程的共享数据设置初始值的语句。图15是一个管程的示意图。管程的语法描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MonitorName { public: // 共享变量 /* share variable declarations; */ // 条件变量 /* cond declarations; */ // 能被进程调用的方法 void P1(/* params */) { /* implementation */ } void P2(/* params */) { /* implementation */ } // 其他方法... // 构造函数，用于初始化 MonitorName() { // initialization code } }; ‌\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 共享数据 一组操作过程 ··· 初始化代码 条 件 （ 不 忙 ） 队列 进入队列 图15\u0026emsp;管程的示意图\n实际上，管程中包含了面向对象的思想，它将表征共享资源的数据结构及其对数据结构操作的一组过程，包括同步机制，都集中并封装在一个对象内部，隐藏了实现细节。封装于管程内部的数据结构仅能被封装于管程内部的过程所访问，任何管程外的过程都不能访问它：反之，封装于管程内部的过程也仅能访问管程内的数据结构。所有进程要访问临界资源时，都只能通过管程间接访问，而管程每次只准许一个进程进入管程，执行管程内的过程，从而实现了进程互斥。\n管程是一种程序设计语言的结构成分，它和信号量有同等的表达能力，从语言的角度看，管程主要有以下特性：①模块化，即管程是一个基本程序单位，可以单独编译；②抽象数据类型，指管程中不仅有数据，而且有对数据的操作；③信息掩蔽，指管程中的数据结构只能被管程中的过程访问，这些过程也是在管程内部定义的，供管程外的进程调用，而管程中的数据结构以及过程（函数）的具体实现外部不可见。\n管程和进程不同:①虽然二者都定义了数据结构，但进程定义的是私有数据结构PCB，管程定义的是公共数据结构，如消息队列等；②二者都存在对各自数据结构上的操作，但进程是由顺序程序执行有关操作，而管程主要是进行同步操作和初始化操作；③设置进程的目的在于实现系统的并发性，而管程的设置则是解决共享资源的互斥使用问题；④进程通过调用管程中的过程对共享数据结构实行操作，该过程就如通常的子程序一样被调用，因而管程为被动工作方式，进程则为主动工作方式；⑤进程之间能并发执行，而管程则不能与其调用者并发；⑥进程具有动态性，由“创建”而诞生，由“撤消”而消亡，而管程则是操作系统中的一个资源管理模块，供进程调用。\n条件变量 在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语wait和signal。当某进程通过管程请求获得临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上，如图15所示。仅当另一进程访问完成并释放该资源之后，管程才又调用signal原语，唤醒等待队列中的队首进程。\n但是仅仅有上述的同步工具是不够的，考虑一种情况：当一个进程调用了管程，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除，而在此期间，如果该进程不释放管程，则其它进程无法进入管程，被迫长时间的等待。为了解决这个问题，引入了条件变量condition。通常，一个进程被阻塞或挂起的条件（原因）可有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问只能在管程中进行。\n管程中对每个条件变量都须予以说明，其形式为：condition x,y；对条件变量的操作仅仅是wait和signal，因此条件变量也是一种抽象数据类型，每个条件变量保存了一个链表，用于记录因该条件变量而阻塞的所有进程，同时提供的两个操作即可表示为x.wait和x.signal，其含义为：\n①x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。\n②x.signal：正在调用管程的进程发现x条件发生了变化，则调用x.signal，重新启动一个因x条件而阻塞或挂起的进程，如果存在多个这样的进程，则选择其中的一个，如果没有，继续执行原进程，而不产生任何结果。这与信号量机制中的signal操作不同。因为，后者总是要执行s=s+1操作，因而总会改变信号量的状态。\n如果有进程Q因x条件处于阻塞状态，当正在调用管程的进程P执行了x.signal操作后，进程Q被重新启动，此时两个进程P和Q，如何确定哪个执行哪个等待，可采用下述两种方式之一进行处理：\n(1)P等待，直至Q离开管程或等待另一条件。\n(2)Q等待，直至P离开管程或等待另一条件。\n采用哪种处理方式，当然是各执一词。Hoare采用了第一种处理方式，而Hansan选择了两者的折中，他规定管程中的过程所执行的signal操作是过程体的最后一个操作，于是，进程P执行signal操作后立即退出管程，因而，进程Q马上被恢复执行。\n经典进程的同步问题 在多道程序环境下，进程同步问题十分重要，也是相当有趣的问题，因而吸引了不少学者对它进行研究，由此而产生了一系列经典的进程同步问题，其中较有代表性的是“生产者\u0026mdash;消费者”问题、\u0026ldquo;读者\u0026mdash;写者问题”、\u0026ldquo;哲学家进餐问题\u0026quot;等等。通过对这些问题的研究和学习，可以帮助我们更好地理解进程同步的概念及实现方法。\n生产者\u0026mdash;消费者问题 前面我们已经对生产者\u0026mdash;消费者问题（The proceducer-consumer problem）‌做了一些描述，但未考虑进程的互斥与同步问题，因而造成了数据counter的不定性。由于生产者\u0026mdash;消费者问题是相互合作的进程关系的一种抽象，例如，在输入时，输入进程是生产者，计算进程是消费者；而在输出时，则计算进程是生产者，而打印进程是消费者，因此，该问题有很大的代表性及实用价值。本小节将利用信号量机制来解决生产者\u0026mdash;消费者问题。\n利用记录型信号量解决生产者\u0026mdash;消费者问题 假定在生产者和消费者之间的公用缓冲池中具有n个缓冲区，这时可利用互斥信号量mutex实现诸进程对缓冲池的互斥使用；利用信号量empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。对生产者\u0026mdash;消费者问题可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int in=0, out=0; item buffer[n]; int mutex=l, empty=n, full=0; void producer() { item nextp; do { nextp = produce_item(); wait(\u0026amp;empty); wait(\u0026amp;mutex); buffer[in] = nextp; in = (in + 1) % n; signal(\u0026amp;mutex); signal(\u0026amp;full); } while (true); } void consumer() { item nextc; do { wait(\u0026amp;full); wait(\u0026amp;mutex); nextc = buffer[out]; out = (out + 1) % n; signal(\u0026amp;mutex); signal(\u0026amp;empty); consume_item(nextc); } while (true); } void main() { create(producer); create(consumer); } 在生产者-消费者问题中应注意：首先，在每个程序中用于实现互斥的wait(\u0026amp;mutex)和signal(\u0026amp;mutex)必须成对地出现；其次，对资源信号量empty和full的wait和signal操作，同样需要成对地出现，但它们分别处于不同的程序中。例如，wait(\u0026amp;empty)在计算进程中，而signal(\u0026amp;empty)则在打印进程中，计算进程若因执行wait(\u0026amp;empty)而阻塞，则以后将由打印进程将它唤醒；最后，在每个程序中的多个wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。\n利用AND型信号量解决生产者\u0026mdash;消费者问题 对于生产者\u0026mdash;消费者问题，也可利用AND信号量来解决，即用Swait(\u0026amp;empty, \u0026amp;mutex)来代替wait(\u0026amp;empty)和wait(\u0026amp;mutex)；用Ssignal(\u0026amp;mutex, \u0026amp;full)来代替signal(\u0026amp;mutex)和signal(\u0026amp;full)；用Swait(\u0026amp;full, \u0026amp;mutex)代替wait(\u0026amp;full)和wait(\u0026amp;mutex)，以及用Ssignal(\u0026amp;mutex, \u0026amp;empty)代替Signal(\u0026amp;mutex)和Signal(\u0026amp;empty)。利用AND信号量来解决生产者\u0026mdash;消费者问题的算法中的生产者和消费者可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int in=0, out=0; item buffer[n]; int mutex=l, empty=n, full=0; void producer() { item nextp; do { nextp = produce_item(); Swait(\u0026amp;empty, \u0026amp;mutex); buffer[in] = nextp; in = (in + 1) % n; Ssignal(\u0026amp;empty, \u0026amp;mutex); } while (true); } void consumer() { item nextc; do { Swait(\u0026amp;full, \u0026amp;mutex); nextc = buffer[out]; out = (out + 1) % n; Ssignal(\u0026amp;full, \u0026amp;mutex); consume_item(nextc); } while (true); } void main() { create(producer); create(consumer); } 利用管程解决生产者\u0026mdash;消费者问题 在利用管程方法来解决生产者\u0026mdash;消费者问题时，首先便是为它们建立一个管程，并命名为ProducerConsumer，或简称为PC。其中包括两个过程：\n(1) put(\u0026amp;x)过程。生产者利用该过程将自己生产的产品投放到缓冲池中，并用整型变量count来表示在缓冲池中己有的产品数目，当count\u0026gt;=N时，表示缓冲池己满，生产者须等待。\n(2) get(\u0026amp;x)过程。消费者利用该过程从缓冲池中取出一个产品，当count\u0026lt;=0时，表示缓冲池中已无可取用的产品，消费者应等待。\n对于条件变量notfull和notempty，分别有两个过程cwait和csignal对它们进行操作：\n(1) cwait(\u0026amp;condition)过程：当管程被一个进程占用时，其他进程调用该过程时阻塞，并挂在条件condition的队列上。\n(2) csignal(\u0026amp;condition)过程：唤醒在cwait执行后阻塞在条件condition队列上的进程，如果这样的进程不止一个，则选择其中一个实施唤醒操作；如果队列为空，则无操作而返回。PC管程可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ProducerConsumer { public: item *buffer[N];//共享变量，缓冲区 int in,out; //共享变量，缓冲区队列首尾指针 condition notfull, notempty; //条件变量，缓冲区是否空或是否满 int count; //条件变量，缓冲区内物品数量 //Producer放入物品 void put(item *x) { //如果满了，则阻塞notfull下的队列（即Producer放入物品的队列） if(count \u0026gt;= N) cwait(\u0026amp;notfull); *buffer[in] = *x; in = (in + 1) % N; count++; csignal(\u0026amp;notempty); } //Consumer取出物品 void get(item *x) { //如果空了，则阻塞notempty下的队列（即Consumer取出物品的队列） if(count \u0026lt;= 0) cwait(\u0026amp;notempty); *x = *buffer[out]; out = (out + 1) % N; count--; csignal(\u0026amp; notfull); } // 构造函数 ProducerConsumer() { in = 0; out = 0; count = 0; } }; typedef ProducerConsumer PC; 在利用管程解决生产者\u0026mdash;消费者问题时，其中的生产者和消费者可描述为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void producer() { item x; do { x = produce_item(); PC.put(\u0026amp;x) } while (true); } void consumer() { item x; do { PC.get(\u0026amp;x); consume_item(x); } while (true); } void main() { create(producer); create(consumer); } 哲学家进餐问题 由Dijkstra提出并解决的哲学家进餐问题(The Dinning Philosophers Problem)‌是典型的同步问题。该问题是描述有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。\n利用记录型信号量解决哲学家进餐问题 经分析可知，放在桌子上的筷子是临界资源，在一段时间内只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组。其描述如下：\n1 int chopstick[5]={1, 1, 1, 1, 1}; 所有信号量均被初始化为1，第i位哲学家的活动可描述为：\n1 2 3 4 5 6 7 8 do { wait(\u0026amp;chopstick[i]); wait(\u0026amp;chopstick[(i+1)%5]); ...//eat signal(\u0026amp;chopstick[i]); signal(\u0026amp;chopstick[(i+l)%5]); ...//think }while (true); 在以上描述中，当哲学家饥饿时，总是先去拿他左边的筷子，即执行wait(\u0026amp;chopstick[i])。成功后，再去拿他右边的筷子，即执行wait(\u0026amp;chopstick[(i+l)%5])。又成功后便可进餐。进餐毕，又先放下他左边的筷子，然后再放他右边的筷子。虽然，上述解法可保证不会有两个相邻的哲学家同时进餐，但却有可能引起死锁。假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0；当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期地等待。对于这样的死锁问题，可采取以下几种解决方法：\n(1 )至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐。\n(2) 仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进餐。\n(3) 规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。\n利用AND信号量机制解决哲学家进餐问题 在哲学家进餐问题中，要求每个哲学家先获得两个临界资源（筷子）后方能进餐，这在 本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法。\n1 2 3 4 5 6 7 int chopstick[5]={1, 1, 1, 1, 1}； do { ...//think Sswait(\u0026amp;chopstick[(i+1)%5], \u0026amp;chopstick[i]); ...//eat Ssignal(\u0026amp;chopstick[(i+1)%5], \u0026amp;chopstick[i]); } while (true); 读者\u0026mdash;写者问题 一个数据文件或记录可被多个进程共享，我们把只要求读该文件的进程称为\u0026rdquo;reader进程”，其他进程则称为\u0026rdquo;writer进程”。允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱。但不允许一个writer进程和其他reader进程或writer进程同时访问共享对象。因为这种访问将会引起混乱。所谓“读者\u0026mdash;写者（reader-writer Problem）问题”是指保证一个writer进程必须与其他进程互斥地访问共享对象的同步问题。读者\u0026mdash;写者问常被用来测试新同步原语。\n利用记录型信号量解决读者\u0026mdash;写者问题 为实现reader与writer进程间在读或写时的互斥而设置了一个互斥信号量wmutex。另外，再设置一个整型变量readcount表示正在读的进程数目。由于只要有一个reader进程在读，便不允许writer进程去写。因此，仅当readcount=0，表示尚无reader进程在读时，reader进程才需要执行Wait(\u0026amp;wmutex)操作。若wait(\u0026amp;wmutex)操作成功，reader进程便可去读，相应地，做readcount+1操作。同理，仅当reader进程在执行了readcount-1操作后其值为0时，才须执行signal(\u0026amp;wmutex)操作，以便让writer进程写操作。又因为readcount是一个可被多个reader进程访问的临界资源，因此，也应该为它设置一个互斥信号量rmutex。\n读者-写者问题可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int rmutex=1, wmutex=1; int readcount=0; void reader() { do { wait(\u0026amp;rmutex); if (readcount==0) wait(\u0026amp;wmutex); readcount++; signal(\u0026amp;rmutex); ...//读操作 wait(\u0026amp;rmutex); readcount--; if (readcount==0) signal(\u0026amp;wmutex); signal(\u0026amp;rmutex); }while(TRUE); } void writer() { do { wait(\u0026amp;wmutex); ...//写操作 signal(\u0026amp;wmutex); } while (true); } void main() { create(reader); create(writer); } 利用信号量集机制解决读者\u0026mdash;写者问题 这里的读者一写者问题，与前面的略有不同，它增加了一个限制，即最多只允许RN个读者同时读。为此，又引入了一个信号量L，并赋予其初值为RN，通过执行wait(\u0026amp;L,1,1)操作来控制读者的数目，每当有一个读者进入时，就要先执行wait(\u0026amp;L,1,1)操作，使L的值减1。当有RN个读者进入读后，L便减为0，第RN+1个读者要进入读时，必然会因wait(\u0026amp;L,1,1)操作失败而阻塞。对利用信号量集来解决读者\u0026mdash;写者问题的描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int RN; int L=RN, mx=1; void reader() { do { Swait(\u0026amp;L, 1, 1, \u0026amp;mx, 1, 0); ...//读操作 Ssignal(\u0026amp;L, 1); } while (true); } void writer() { do { Swait(\u0026amp;L, RN, 0, \u0026amp;mx, 1, 1); ...//写操作 Ssignal(\u0026amp;mx, 1); } while (TRUE); } void main() { create(reader); create(writer); } 进程通信 进程通信是指进程之间的信息交换。由于进程的互斥与同步，需要在进程间交换一定的信息，故不少学者将它们也归为进程通信，但只能把它们称为低级进程通信。我们以信号量机制为例来说明，它们之所以低级的原因在于：①效率低，生产者每次只能向缓冲池投放一个产品（消息），消费者每次只能从缓冲区中取得一个消息；②通信对用户不透明，os只为进程之间的通信提供了共享存储器。而关于进程之间通信所需之共享数据结构的设置、数据的传送、进程的互斥与同步，都必须由程序员去实现，显然，对于用户而言，这是非常不方便的。\n在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，该工具最主要的特点是：\n(1) 使用方便。OS隐藏了实现进程通信的具体细节，向用户提供了一组用于实现高级通信的命令（原语），用户可方便地直接利用它实现进程之间的通信。或者说，通信过程对用户是透明的。这样就大大减少了通信程序编制上的复杂性。\n(2) 高效地传送大量数据。用户可直接利用高级通信命令（原语）高效地传送大量的数据。\n进程通信的类型 随着OS的发展，用于进程之间实现通信的机制也在发展，并已由早期的低级进程通信机制发展为能传送大量数据的高级通信工具机制。目前，高级通信机制可归结为四大类：共享存储器系统、管道通信系统、消息传递系统以及客户机\u0026mdash;服务器系统。\n共享存储器系统（Shared-Memory System） 在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。据此，又可把它们分成以下两种类型：\n(1) 基于共享数据结构的通信方式。在这种通信方式中，要求诸进程公用某些数据结构，借以实现诸进程间的信息交换，如在生产者\u0026mdash;消费者问题中的有界缓冲区。操作系统仅提供共享存储器，由程序员负责对公用数据结构的设置及对进程间同步的处理。这种通信方式仅适于传递相对少量的数据，通信效率低下，属于低级通信。\n(2)基于共享存储区的通信方式。为了传输大量数据，在内存中划出了一块共享存储区域，诸进程可通过对该共享区的读或写交换信息，实现通信，数据的形式和位置甚至访问控制都是由进程负责，而不是OS。这种通信方式属于高级通信。需要通信的进程在通信前，先向系统申请获得共享存储区中的一个分区，并将其附加到自己的地址空间中，便可对其中的数据进行正常读、写，读写完成或不再需要时，将其归还给共享存储区。\n管道(pipe)通信系统 所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道；而接受管道输出的接收进程（即读进程）则从管道中接收（读）数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。\n为了协调双方的通信，管道机制必须提供以下三方面的协调能力：①互斥，即当一个进程正在对pipe执行读/写操作时，其它（另一）进程必须等待。②同步，指当写（输入）进程把一定数量（如4KB）的数据写入pipe，便去睡眠等待，直到读（输出）进程取走数据后再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后才将之唤醒。③确定对方是否存在，只有确定了对方已存在时才能进行通信。\n消息传递系统(Message Passing System) 在该机制中，进程不必借助任何共享存储区或数据结构，而是以格式化的消息(message)为单位，将通信的数据封装在消息中，并利用操作系统提供的一组通信命令（原语），在进程间进行消息传递，完成进程间的数据交换。\n该方式隐藏了通信实现细节，使通信过程对用户透明化，降低了通信程序设计的复杂性和错误率，成为当前应用最为广泛的一类进程间通信的机制。例如：在计算机网络中，消息(message)又称为报文；在微内核操作系统中，微内核与服务器之间的通信无一例外都是采用了消息传递机制；由于该机制能很好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具。\n基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可进一步分成两类：\n(1)直接通信方式，是指发送进程利用OS所提供的发送原语，直接把消息发送给目标进程。\n(2)间接通信方式，是指发送和接收进程，都通过共享中间实体（称为邮箱）的方式进行消息的发送和接收，完成进程间的通信。\n客户机\u0026mdash;服务器系统（Client-Server System） 前面所述的共享内存、消息传递等技术，虽然也可以用于实现不同计算机间进程的双向通信，但客户机\u0026mdash;服务器系统的通信机制，在网络环境的各种应用领域已成为当前主流的通信实现机制，其主要的实现方法分为三类：套接字、远程过程调用和远程方法调用。\n1. 套接字\n套接字起源于20世纪70年代加州大学伯克利分校版本的UNIX（即BSDUnix），是UNIX操作系统下的网络通信接口。一开始，套接字被设计用在同一台主机上多个应用程序之间的通信（即进程间的通信），主要是为了解决多对进程同时通信时端口和物理线路的多路复用问题。随着计算机网络技术的发展以及UNIX操作系统的广泛使用，套接字已逐渐成为最流行的网络通信程序接口之一。\n一个套接字就是一个通信标识类型的数据结构，包含了通信目的的地址、通信使用的端口号、通信网络的传输层协议、进程所在的网络地址，以及针对客户或服务器程序提供的不同系统调用（或API函数）等，是进程通信和网络通信的基本构件。套接字是为客户/服务器模型而设计的，通常，套接字包括两类：\n(1)基于文件型：通信进程都运行在同一台机器的环境中，套接字是基于本地文件系统支持的，一个套接字关联到一个特殊的文件，通信双方通过对这个特殊文件的读写实现通信，其原理类似于前面所讲的管道。\n(2)基于网络型：该类型通常采用的是非对称方式通信，即发送者需要提供接收者命名。通信双方的进程运行在不同主机的网络环境下，被分配了一对套接字，一个属于接收进程（或服务器端），一个属于发送进程（或客户端）。一般地，发送进程（或客户端）发出连接请求时，随机申请一个套接字，主机为之分配一个端口，与该套接字绑定，不再分配给其它进程。接收进程（或服务器端）拥有全局公认的套接字和指定的端口（如ftp服务器监听端口为21,Web或http服务器监听端口为80）,并通过监听端口等待客户请求。因此，任何进程都可以向它发出连接请求和信息请求，以方便进程之间通信连接的建立。接收进程（或服务器端）一旦收到请求，就接受来自发送进程（或客户端）的连接，完成连接，即在主机间传输的数据可以准确地发送到通信进程，实现进程间的通信：当通信结束时，系统通过关闭接收进程（或服务器端）的套接字撤销连接。\n套接字的优势在于，它不仅适用于同一台计算机内部的进程通信，也适用于网络环境中不同计算机间的进程通信。由于每个套接字拥有唯一的套接字号（也称套接字标识符），这样系统中所有的连接都持有唯一的一对套接字及端口连接，对于来自不同应用程序进程或网络连接的通信，能够方便地加以区分，确保了通信双方之间逻辑链路的唯一性，便于实现数据传输的并发服务，而且隐藏了通信设施及实现细节，采用统一的接口进行处理。\n2. 远程过程调用和远程方法调用\n远程过程（函数）调用RPC(Remote Procedure Call)，是一个通信协议，用于通过网络连接的系统。该协议允许运行于一台主机（本地）系统上的进程调用另一台主机（远程）系统上的进程，而对程序员表现为常规的过程调用，无需额外地为此编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称做远程方法调用。\n负责处理远程过程调用的进程有两个，一个是本地客户进程，另一个是远程服务器进程，这两个进程通常也被称为网络守护进程，主要负责在网络间的消息传递，一般情况下，这两个进程都是处于阻塞状态，等待消息。\n为了使远程过程调用看上去与本地过程调用一样，即希望实现RPC的透明性，使得调用者感觉不到此次调用的过程是在其他主机（远程）上执行的，RPC引入一个存根(stub)‌的概念：在本地客户端，每个能够独立运行的远程过程都拥有一个客户存根(client stubborn)，本地进程调用远程过程实际是调用该过程关联的存根；与此类似，在每个远程进程所在的服务器端，其所对应的实际可执行进程也存在一个服务器存根(stub)‌与其关联。本地客户存根与对应的远程服务器存根一般也是处于阻塞状态，等待消息。\n实际上，远程过程调用的主要步骤是：\n(1) 本地过程调用者以一般方式调用远程过程在本地关联的客户存根，传递相应的参数，然后将控制权转移给客户存根。\n(2)客户存根执行，完成包括过程名和调用参数等信息的消息建立，将控制权转移给本地客户进程。\n(3)本地客户进程完成与服务器的消息传递，将消息发送到远程服务器进程。\n(4)远程服务器进程接收消息后转入执行，并根据其中的远程过程名找到对应的服务器存根，将消息转给该存根。\n(5)该服务器存根接到消息后，由阻塞状态转入执行状态，拆开消息从中取出过程调用的参数，然后以一般方式调用服务器上关联的过程。\n(6)在服务器端的远程过程运行完毕后，将结果返回给与之关联的服务器存根。\n(7)该服务器存根获得控制权运行，将结果打包为消息，并将控制权转移给远程服务器进程：\n(8)远程服务器进程将消息发送回客户端。\n(9)本地客户进程接收到消息后，根据其中的过程名将消息存入关联的客户存根，再将控制权转移给客户存根。\n(10)客户存根从消息中取出结果，返回给本地调用者进程，并完成控制权的转移。\n这样，本地调用者再次获得控制权，并且得到了所需的数据，得以继续运行。显然，上述步骤的主要作用在于：将客户过程的本地调用转化为客户存根，再转化为服务器过程的本地调用，对客户与服务器来说，它们的中间步骤是不可见的，因此，调用者在整个过程中并不知道该过程的执行是在远程，而不是在本地。\n消息传递通信的实现方式 在进程之间通信时，源进程可以直接或间接地将消息传送给目标进程，因此可将进程通信分为直接和间接两种通信方式。常见的直接消息传递系统和信箱通信就是分别采用这两种通信方式。\n直接消息传递系统 在直接消息传递系统中采用直接通信方式，即发送进程利用OS所提供的发送命令（原语），直接把消息发送给目标进程。\n1. 直接通信原语\n(1)对称寻址方式。该方式要求发送进程和接收进程都必须以显式方式提供对方的标识符。通常，系统提供下述两条通信命令（原语）：\nsend(receiver,message); 发送一个消息给接收进程\nreceive(sender,message); 接收Sender发来的消息\n例如，原语Send(P2,m1)表示将消息m1发送给接收进程P2；而原语Receive(P1,m1)则表示接受由P1发来的消息m1。\n对称寻址方式的不足在于，一旦改变进程的名称，则可能需要检查所有其它进程的定义，有关对该进程旧名称的所有引用都必须查找到，以便将其修改为新名称，显然，这样的方式不利于实现进程定义的模块化。\n(2)非对称寻址方式。在某些情况下，接收进程可能需要与多个发送进程通信，无法事先指定发送进程。例如，用于提供打印服务的进程，它可以接收来自任何一个进程的“打印请求”消息。对于这样的应用，在接收进程的原语中，不需要命名发送进程，只填写表示源进程的参数，即完成通信后的返回值，而发送进程仍需要命名接收进程。该方式的发送和接收原语可表示为：\nsend(P, message); 发送一个消息给进程P\nreceive(id, message); 接收来自任何进程的消息，id变量可设置为进行通信的发送方进程id或名字。\n2. 消息的格式\n在消息传递系统中所传递的消息，必须具有一定的消息格式。在单机系统环境中，由于发送进程和接收进程处于同一台机器中，有着相同的环境，所以消息的格式比较简单，可采用比较短的定长消息格式，以减少对消息的处理和存储开销。该方式可用于办公自动化系统中，为用户提供快速的便笺式通信。但这种方式对于需要发送较长消息的用户是不方便的。为此，可采用变长的消息格式，即进程所发送消息的长度是可变的。对于变长消息，系统无论在处理方面还是存储方面，都可能会付出更多的开销，但其优点在于方便了用户。\n3. 进程的同步方式\n在进程之间进行通信时，同样需要有进程同步机制，以使诸进程间能协调通信。不论是发送进程还是接收进程，在完成消息的发送或接收后，都存在两种可能性，即进程或者继续发送（或接收）或者阻塞。由此，我们可得到三种情况：①发送进程阻塞，接收进程阻塞。这种情况主要用于进程之间紧密同步，发送进程和接收进程之间无缓冲时。②发送进程不阻塞、接收进程阻塞。这是一种应用最广的进程同步方式。平时，发送进程不阻塞，因而它可以尽快地把一个或多个消息发送给多个目标；而接收进程平时则处于阻塞状态，直到发送进程发来消息时才被唤醒。③发送进程和接收进程均不阻塞。这也是一种较常见的进程同步形式。平时，发送进程和接收进程都在忙于自己的事情，仅当发生某事件使它无法继续运行时，才把自己阻塞起来等待。\n4. 通信链路\n为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。第一种方式是：由发送进程在通信之前用显式的“建立连接”命令（原语）请求系统为之建立一条通信链路，在链路使用完后拆除链路。这种方式主要用于计算机网络中。第二种方式是：发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令（原语），系统会自动地为之建立一条链路。这种方式主要用于单机系统中。而根据通信方式的不同，则又可把链路分成两种：①单向通信链路，只允许发送进程向接收进程发送消息，或者相反；②双向通信链路，既允许由进程A向进程B发送消息，也允许进程B同时向进程A发送消息。\n信箱通信 信箱通信属于间接通信方式，即进程之间的通信，需要通过某种中间实体（如共享数据结构等）来完成。该实体建立在随机存储器的公用缓冲区上，用来暂存发送进程发送给目标进程的消息；接收进程可以从该实体中取出发送进程发送给自己的消息，通常把这种中间实体称为邮箱（或信箱），每个邮箱都有一个唯一的标识符。消息在邮箱中可以安全地保存，只允许核准的目标用户随时读取。因此，利用邮箱通信方式既可实现实时通信，又可实现非实时通信。\n1. 信箱的结构\n信箱定义为一种数据结构。在逻辑上，可以将其分为两个部分：\n(1)信箱头，用以存放有关信箱的描述信息，如信箱标识符、信箱的拥有者、信箱口令、信箱的空格数等。\n(2)信箱体，由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目以及每格的大小是在创建信箱时确定的。\n在消息传递方式上，最简单的情况是单向传递。消息的传递也可以是双向的。图16示出了双向通信链路的通信方式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 进程A 进程B 信箱头 格 子 1 格 子 2 格 子 3 格 子 … 接收 发送 接收 发送 图16\u0026emsp;双向信箱示意图\n*2. 信箱通信原语\n系统为邮箱通信提供了若干条原语，分别用于：\n(1)邮箱的创建和撤消。进程可利用邮箱创建原语来建立一个新邮箱，创建者进程应给出邮箱名字、邮箱属性（公用、私用或共享）；对于共享邮箱，还应给出共享者的名字。当进程不再需要读邮箱时，可用邮箱撤消原语将之撤消。\n(2)消息的发送和接收。当进程之间要利用邮箱进行通信时，必须使用共享邮箱，并利用系统提供的下述通信原语进行通信。\nSend(mailbox, message); 将一消息发送到指定邮箱\nReceive(mailbox, message); 从指定邮箱中接收一个消息\n3. 信箱的类型\n邮箱可由操作系统创建，也可由用户进程创建，创建者是邮箱的拥有者。据此，可把邮箱分为以下三类：\n(1)私用邮箱。用户进程可为自己建立一个新邮箱，并作为该进程的一部分。邮箱的拥有者有权从邮箱中读取消息，其他用户则只能将自己构成的消息发送到该邮箱中。这种私用邮箱可采用单向通信链路的邮箱来实现。当拥有该邮箱的进程结束时，邮箱也随之消失。\n(2)公用邮箱。由操作系统创建，并提供给系统中的所有核准进程使用。核准进程既可把消息发送到该邮箱中，也可从邮箱中读取发送给自己的消息。显然，公用邮箱应采用双向通信链路的邮箱来实现。通常，公用邮箱在系统运行期间始终存在。\n(3)共享邮箱。由某进程创建，在创建时或创建后指明它是可共享的，同时须指出共享进程（用户）的名字。邮箱的拥有者和共享者都有权从邮箱中取走发送给自己的消息。在利用邮箱通信时，在发送进程和接收进程之间，存在以下四种关系：①一对一关系。发送进程和接收进程可以建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰。②多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为客户/服务器交互(client/server interaction)。③一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式向接收者（多个）发送消息。④多对多关系。允许建立一个公用邮箱，让多个进程都能向邮箱中投递消息；也可从邮箱中取走属于自己的消息。\n直接消息传递系统实例 消息缓冲队列通信机制首先由美国的Hansan提出，并在RC4000系统上实现，后来被广泛应用于本地进程之间的通信中。在这种通信机制中，发送进程利用Send原语将消息直接发送给接收进程；接收进程则利用Receive原语接收消息。\n消息缓冲队列通信机制中的数据结构 (1)消息缓冲区。在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区。它可描述如下：\n1 2 3 4 5 6 typedef struct message_buffer { int sender; //发送者进程标识符 int size; //消息长度 char *text; //消息正文 struct message_buffer *next; //指向下一个消息缓冲区的指针 }MesBuf; (2)PCB中有关通信的数据项。在操作系统中采用了消息缓冲队列通信机制时，除了需要为进程设置消息缓冲队列外，还应在进程的PCB中增加消息队列队首指针，用于对消息队列进行操作，以及用于实现同步的互斥信号量mutex和资源信号量sm。在PCB中应增加的数据项可描述如下：\n1 2 3 4 5 6 7 typedef struct processcontrol_block { ... struct message_buffer *mq; //消息队列队首指针 semaphore mutex; //消息队列互斥信号量 semaphore sm; //消息队列资源信号量 ... }PCB; 发送原语 发送进程在利用发送原语发送消息之前，应先在自己的内存空间设置一发送区a，如图17所示，把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标（接收）进程。发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着，把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在j.mq上。由于该队列属于临界资源，故在执行insert操作的前后都要执行wait和signal操作。最后，释放信号量sm表示消息发送完毕。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 进程A send( B , a) mq mutex sm size=5 tex t - \u0026gt; “ h e ll o ” nex t -\u0026gt; N U L L sender=A 第一消息缓冲区 size=5 tex t - \u0026gt; “ h e ll o ” sender=A a 发 送 区 a 进程B r ece i v e( b ) size=5 tex t - \u0026gt; “ h e ll o ” sender=A 接 收 区 b b PCB( b ) 图17\u0026emsp;消息缓冲通信\n发送原语可描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void send(Process *receiver, Message *a) { //receive为接收进程标识符，a为发送区首地址 MesBuf *i = getbuf(a-\u0026gt;size); //根据a.size申请缓冲区 /* 将发送区a中的信息复制到消息缓冲区i中 */ i-\u0026gt;sender=a-\u0026gt;sender; i-\u0026gt;size=a-\u0026gt;size; copy(i-\u0026gt;text, a-\u0026gt;text); i-\u0026gt;next=NULL; PCB *j = get_pcb(receiver); //获取接收进程内部的标识符 wait(\u0026amp;(j-\u0026gt;mutex)) insert(\u0026amp;(j-\u0026gt;mq), i); //将消息缓冲区插入消息队列 signal(\u0026amp;(j-\u0026gt;mutex)); signal(\u0026amp;(j-\u0026gt;sm)); //发送完毕 } 接收原语 从自己的消息缓冲队列mq中摘下第一个消息缓冲 并将其中的数据复制到以b为首址的指定消息接收区内。接收原语描述如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void receive(b) { PCB* j = get_pid(b); //j为接收进程b内部的标识符 wait(\u0026amp;(j-\u0026gt;sm)); wait(\u0026amp;(j-\u0026gt;mutex)); MesBuf* i = remove(\u0026amp;(j-\u0026gt;mq)); //将消息队列中的第一个消息移出 signal(\u0026amp;(j.mutex)); /* 将消息缓冲区i中的信息复制到接收区b */ b-\u0026gt;sender = i-\u0026gt;sender; b-\u0026gt;size = i-\u0026gt;size; copy(b-\u0026gt;text, i-\u0026gt;text); releasebuf(i); //释放消息缓冲区 } 线程(Threads)的基本概念 在20世纪60年代中期，人们在设计多道程序OS时，引入了进程的概念，从而解决了在单处理机环境下的程序并发执行问题。此后在长达20年的时间里，在多道程序OS中一直是以进程作为能拥有资源和独立调度（运行）的基本单位的。直到80年代中期，人们又提出了比进程更小的基本单位\u0026mdash;\u0026mdash;线程的概念，试图用它来提高程序并发执行的程度，以进一步改善系统的服务质量。特别是在进入20世纪90年代后，多处理机系统得到迅速发展，由于线程能更好地提高程序的并行执行程度，因而近几年推出的多处理机OS无一例外地都引入了线程，用以改善OS的性能。\n线程的引入 如果说，在OS中引入进程的目的是为了使多个程序能并发执行，以提高资源利用率和系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。\n进程的两个基本属性 首先让我们来回顾进程的两个基本属性：①进程是一个可拥有资源的独立单位，一个进程要能独立运行，它必须拥有一定的资源，包括用于存放程序正文、数据的磁盘和内存地址空间，以及它在运行时所需要的I/O设备、已打开的文件、信号量等；②进程同时又是一个可独立调度和分派的基本单位，一个进程要能独立运行，它还必须是一个可独立调度和分派的基本单位。每个进程在系统中有唯一的PCB,系统可根据其PCB感知进程的存在，也可以根据其PCB中的信息，对进程进行调度，还可将断点信息保存在其PCB中。反之，再利用进程PCB中的信息来恢复进程运行的现场。正是由于进程有这两个基本属性，才使进程成为一个能独立运行的基本单位，从而也就构成了进程并发执行的基础。\n程序并发执行所需付出的时空开销 为使程序能并发执行，系统必须进行以下的一系列操作：\n(1)创建进程，系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB。\n(2)撤消进程，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB。\n(3)进程切换，对进程进行上下文切换时，需要保留当前进程的CPU环境，设置新选中进程的CPU环境，因而须花费不少的处理机时间。\n据此可知，由于进程是一个资源的拥有者，因而在创建、撤消和切换中，系统必须为之付出较大的时空开销。这就限制了系统中所设置进程的数目，而且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高。\n线程\u0026mdash;\u0026mdash;作为调度和分派的基本单位 如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，已成为近年来设计操作系统时所追求的重要目标。有不少研究操作系统的学者们想到，要设法将进程的上述两个属性分开，由OS分开处理，亦即并不把作为调度和分派的基本单位也同时作为拥有资源的单位，以做到\u0026quot;轻装上阵”；而对于拥有资源的基本单位，又不对之施以频繁的切换。正是在这种思想的指导下，形成了线程的概念。\n随着VLSI技术和计算机体系结构的发展，出现了对称多处理机(SMP)计算机系统。它为提高计算机的运行速度和系统吞吐量提供了良好的硬件基础。但要使多个CPU很好地协调运行，充分发挥它们的并行处理能力，以提高系统性能，还必须配置性能良好的多处理机OS。但利用传统的进程概念和设计方法已难以设计出适合于SMP结构计算机系统的OS。其最根本的原因是进程“太重”，致使为实现多处理机环境下的进程的创建、调度、分派，都需花费较大的时间和空间开销。如果在OS中引入线程，以线程作为调度和分派的基本单位，则可以有效地改善多处理机系统的性能。因此，一些主要的OS（UNIX、Windows）厂家又进一步对线程技术做了开发，使之适用于SMP的计算机系统。\n线程与进程的比较 由于线程具有许多传统进程所具有的特征，所以又称之为轻型进程（Light-Weight Process）‌或进程元，相应地，把传统进程称为重型进程（Heavy-Weight Process）。它相当于只有一个线程的任务。下面我们从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。\n调度的基本单位 在传统的OS中，进程是作为独立调度和分派的基本单位，因而进程是能独立运行的基本单位。在每次被调度时，都需要进行上下文切换，开销较大。而在引入线程的OS中，已把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位。当线程切换时，仅需保存和设置少量寄存器内容，切换代价远低于进程。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，必然就会引起进程的切换。\n并发性 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，甚至还允许在一个进程中的所有线程都能并发执行。同样，不同进程中的线程也能并发执行。这使得OS具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。例如，在文字处理器中可以设置三个线程：第一个线程用于显示文字和图形，第二个线程从键盘读入数据，第三个线程在后台进行拼写和语法检查。又如，在网页浏览器中，可以设置一个线程来显示图像或文本，再设置一个线程用于从网络中接收数据。\n此外，有的应用程序需要执行多个相似的任务。例如，一个网络服务器经常会接到许多客户的请求，如果仍采用传统的单线程的进程来执行该任务，则每次只能为一个客户服务。但如果在一个进程中可以设置多个线程，将其中的一个专用于监听客户的请求，则每当有一个客户请求时，便立即创建一个线程来处理该客户的请求。\n拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位。然而，线程本身并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源。比如，在每个线程中都应具有一个用于控制线程运行的线程控制块TCB、用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。\n线程除了拥有自己的少量资源外，还允许多个线程共享该进程所拥有的资源，这首先表现在：属于同一进程的所有线程都具有相同的地址空间，这意味着，线程可以访问该地址空间中的每一个虚地址；此外，还可以访问进程所拥有的资源，如已打开的文件、定时器、信号量机构等的内存空间和它所申请到的I/O设备等。\n独立性 在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为，为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。由一个线程打开的文件可以供其它线程读、写。\n系统开销 在创建或撤消进程时，系统都要为之分配和回收进程控制块、分配或回收其它资源，如内存空间和I/O设备等。OS为此所付出的开销，明显大于线程创建或撤消时所付出的开销。类似地，在进程切换时，涉及到进程上下文的切换，而线程的切换代价也远低于进程的。例如，在Solaris 2 OS中，线程的创建要比进程的创建快30倍，而线程上下文切换要比进程上下文的切换快5倍。此外，由于一个进程中的多个线程具有相同的地址空间，线程之间的同步和通信也比进程的简单。因此，在一些OS中，线程的切换、同步和通信都无需操作系统内核的干预。\n支持多处理机系统 在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代多处理机OS都无一例外地引入了多线程。\n线程的状态和线程控制块 线程运行的三个状态 与传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线 程在运行时也具有间断性。相应地，线程在运行时也具有下述三种基本状态：\n(1)执行状态，表示线程已获得处理机而正在运行。\n(2)就绪状态，指线程已具备了各种执行条件，只须再获得CPU便可立即执行。\n(3)阻塞状态，指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞。 线程状态之间的转换和进程状态之间的转换是一样的，如图5所示。\n线程控制块TCB 如同每个进程有一个进程控制块一样,系统也为每个线程配置了一个线程控制块TCB,将所有用于控制和管理线程的信息记录在线程控制块中。线程控制块通常有这样几项：①线程标识符，为每个线程赋予一个唯一的线程标识符；②一组寄存器，包括程序计数器PC、状态寄存器和通用寄存器的内容；③线程运行状态，用于描述线程正处于何种运行状态；④优先级，描述线程执行的优先程度：⑤线程专有存储区，用于线程切换时存放现场保护信息，和与该线程相关的统计信息等；⑥信号屏蔽，即对某些信号加以屏蔽：⑦堆栈指针，在线程运行时，经常会进行过程调用，而过程的调用通常会出现多重嵌套的情况，这样，就必须将每次过程调用中所使用的局部变量以及返回地址保存起来。为此，应为每个线程设置一个堆栈，用它来保存局部变量和返回地址。相应地，在TCB中，也须设置两个指向堆栈的指针：指向用户自己堆栈的指针和指向核心栈的指针。前者是指当线程运行在用户态时，使用用户自己的用户栈来保存局部变量和返回地址，后者是指当线程运行在核心态时使用系统的核心栈。\n多线程OS中的进程属性 通常在多线程OS中的进程都包含了多个线程，并为它们提供资源。OS支持在一个进程中的多个线程能并发执行，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：\n(1)进程是一个可拥有资源的基本单位。在多线程OS中，进程仍是作为系统资源分配的基本单位，任一进程所拥有的资源都包括：用户的地址空间、实现进程（线程）间同步和通信的机制、已打开的文件和已申请到的I/O设备，以及一张由核心进程维护的地址映射表，该表用于实现用户程序的逻辑地址到其内存物理地址的映射。\n(2)多个线程可并发执行。通常一个进程都含有若干个相对独立的线程，其数目可多可少，但至少要有一个线程。由进程为这些（个）线程提供资源及运行环境，使它们能并发执行。在OS中的所有线程都只能属于某一个特定进程。实际上，现在把传统进程的执行方法称为单线程方法。如传统的UNIX系统能支持多用户进程，但只支持单线程方法。反之，将每个进程支持多个线程执行的方法称为多线程方法。如Java的运行环境是单进程多线程的，Windows 2000、Solaris、Mach等采用的则是多进程多线程的方法。\n(3)进程已不是可执行的实体。在多线程OS中，是把线程作为独立运行（或称调度）的基本单位。此时的进程已不再是一个基本的可执行实体。虽然如此，进程仍具有与执行相关的状态。例如，所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。此外，对进程所施加的与进程状态有关的操作也对其线程起作用。例如，在把某个进程挂起时，该进程中的所有线程也都将被挂起；又如，在把某进程激活时，属于该进程的所有线程也都将被激活。\n线程的实现 线程的实现方式 线程已在许多系统中实现，但各系统的实现方式并不完全相同。在有的系统中，特别是一些数据库管理系统，如infomix所实现的是用户级线程；而另一些系统（如Macintosh和OS/2操作系统）所实现的是内核支持线程；还有一些系统如Solaris操作系统，则同时实现了这两种类型的线程。\n内核支持线程KST(Kernel Supported Threads) 在OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程KST同样也是在内核的支持下运行的，它们的创建、阻塞、撤消和切换等，也都是在内核空间实现的。为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。当前大多数OS都支持内核支持线程。\n这种线程实现方式主要有四个主要优点：\n(1)在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行。\n(2)如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程。\n(3)内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小。\n(4)内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。 内核支持线程的主要缺点是：对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。\n用户级线程ULT(User Level Threads) 用户级线程是在用户空间中实现的。对线程的创建、撤消、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。在一个系统中的用户级线程的数目可以达到数百个至数千个。由于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。\n值得说明的是，对于设置了用户级线程的系统，其调度仍是以进程为单位进行的。在采用轮转调度算法时，各个进程轮流执行一个时间片，这对诸进程而言貌似是公平的。但假如在进程A中包含了一个用户级线程，而在另一个进程B中含有100个用户级线程，这样，进程A中线程的运行时间将是进程B中各线程运行时间的100倍：相应地，其速度要快上100倍，因此说实质上并不公平。\n假如系统中设置的是内核支持线程，则调度便是以线程为单位进行的。在采用轮转法调度时，是各个线程轮流执行一个时间片。同样假定进程A中只有一个内核支持线程，而在进程B中有100个内核支持线程。此时进程B可以获得的CPU时间是进程A的100倍,且进程B可使100个系统调用并发工作。\n使用用户级线程方式有许多优点：\n(1)线程切换不需要转换到内核空间。对一个进程而言，其所有线程的管理数据结构均在该进程的用户空间中，管理线程切换的线程库也在用户地址空间运行，因此进程不必切换到内核方式来做线程管理，从而节省了模式切换的开销。\n(2)调度算法可以是进程专用的。在不干扰OS调度的情况下，不同的进程可以根据自身需要选择不同的调度算法，对自己的线程进行管理和调度，而与OS的低级调度算法是无关的。\n(3)用户级线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。因此，用户级线程甚至可以在不支持线程机制的操作系统平台上实现。\n而用户级线程方式的主要缺点则在于：\n(1)系统调用的阻塞问题。在基于进程机制的OS中，大多数系统调用将使进程阻塞，因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且，进程内的所有线程会被阻塞。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。\n(2)在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU。因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其它线程只能等待。\n组合方式 有些OS把用户级线程和内核支持线程两种方式进行组合，提供了组合方式ULT/KST线程。在组合方式线程系统中，内核支持多个内核支持线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。一些内核支持线程对应多个用户级线程，这是用户级线程通过时分多路复用内核支持线程来实现的。即将用户级线程对部分或全部内核支持线程进行多路复用，程序员可按应用需要和机器配置，对内核支持线程数目进行调整，以达到较好效果。组合方式线程中，同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时并不需要将整个进程阻塞。所以，组合方式多线程机制能够结合KST和ULT两者的优点，并克服了其各自的不足。由于用户级线程和内核支持线程连接方式的不同，从而形成了三种不同的模型：多对一模型、一对一模型和多对多模型：\n(1)多对一模型，即将用户线程映射到一个内核控制线程。如图18(a)所示，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。仅当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进行映射。该模型的主要优点是线程管理的开销小，效率高；其主要缺点在于，如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；此外，在任一时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。\n(2)一对一模型，即将每一个用户级线程映射到一个内核支持线程。如图18(b)所示，为每一个用户线程都设置一个内核控制线程与之连接。该模型的主要优点是：当一个线程阻塞时，允许调度另一个线程运行，所以它提供了比多对一模型更好的并发功能。此外，在多处理机系统中，它允许多个线程并行地运行在多处理机系统上。该模型的唯一缺点是:每创建一个用户线程，相应地就需要创建一个内核线程，开销较大，因此需要限制整个系统的线程数。Windows2000、WindowsNT、OS/2等系统上都实现了该模型。\n(3)多对多模型，即将许多用户线程映射到同样数量或更少数量的内核线程上。如图18(c)所示，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。该模型结合上述两种模型的优点，它可以像一对一模型那样，使一个进程的多个线程并行地运行在多处理机系统上，也可像多对一模型那样，减少线程的管理开销和提高效率。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户空间 内核空间 用户线程 核心线程 用户空间 内核空间 用户线程 核心线程 用户空间 内核空间 用户线程 核心线程 （a ） 多对一模型 （b ） 一对一模型 （c ） 多对多模型 图18\u0026emsp;多线程模型\n线程的实现 不论是进程还是线程，都必须直接或间接地取得内核的支持。由于内核支持线程可以直接利用系统调用为它服务，故线程的控制相当简单；而用户级线程必须借助于某种形式的中间系统的帮助方能取得内核的服务，故在对线程的控制上要稍复杂些。\n内核支持线程的实现 在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB空间，如图19所示。在每一个TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息。虽然这些信息与用户级线程TCB中的信息相同，但现在却是被保存在内核空间中。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e P T D A 进程资源 T CB #1 T CB #2 T CB #3 图19\u0026emsp;任务数据区空间\n每当进程要创建一个线程时，便为新线程分配一个TCB，将有关信息填入该TCB中，并为之分配必要的资源，如为线程分配数百至数千个字节的栈空间和局部存储区，于是新创建的线程便有条件立即执行。当PTDA中的所有TCB空间已用完，而进程又要创建新的线程时，只要其所创建的线程数目未超过系统的允许值（通常为数十至数百个），系统可再为之分配新的TCB空间；在撤消一个线程时，也应回收该线程的所有资源和TCB。可见，内核支持线程的创建、撤消均与进程的相类似。在有的系统中为了减少在创建和撤消一个线程时的开销，在撤消一个线程时并不立即回收该线程的资源和TCB，这样，当以后再要创建一个新线程时，便可直接利用已被撤消但仍保持有资源的TCB作为新线程的TCB。\n内核支持线程的调度和切换与进程的调度和切换十分相似，也分抢占式方式和非抢占方式两种。在线程的调度算法上，同样可采用时间片轮转法、优先权算法等。当线程调度选中一个线程后，便将处理机分配给它。当然，线程在调度和切换上所花费的开销要比进程的小得多。\n用户级线程的实现 用户级线程是在用户空间实现的。所有的用户级线程都具有相同的结构，它们都运行在一个中间系统上。当前有两种方式实现中间系统，即运行时系统和内核控制线程。\n1. 运行时系统(Runtime System)\n所谓“运行时系统”，实质上是用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤消线程的函数、线程同步和通信的函数，以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。\n在传统的OS中，进程在切换时必须先由用户态转为核心态，再由核心来执行切换任务；而用户级线程在切换时则不须转入核心态，而是由运行时系统中的线程切换过程（函数），来执行切换任务，该过程将线程的CPU状态保存在该线程的堆栈中，然后按照一定的算法，选择一个处于就绪状态的新线程运行，将新线程堆栈中的CPU状态装入到CPU相应的寄存器中，一旦将栈指针和程序计数器切换后，便开始了新线程的运行。由于用户级线程的切换无须进入内核，且切换操作简单，因而使用户级线程的切换速度非常快。\n不论在传统的OS中，还是在多线程OS中，系统资源都是由内核管理的。在传统的OS中，进程是利用OS提供的系统调用来请求系统资源的，系统调用通过软中断（如trap）机制进入OS内核，由内核来完成相应资源的分配。用户级线程是不能利用系统调用的。当线程需要系统资源时，是将该要求传送给运行时系统，由后者通过相应的系统调用来获得系统资源。\n2. 内核控制线程\n这种线程又称为轻型进程（LWP，Light Weight Process）。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构（如TCB）,其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。LWP也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只须将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是组合方式。\n在一个系统中的用户级线程数量可能很大，为了节省系统开销，不可能设置太多的LWP，而是把这些LWP做成一个缓冲池，称为“线程池”。用户进程中的任一用户线程都可以连接到LWP池中的任何一个LWP上。为使每一用户级线程都能利用LWP与内核通信,可以使多个用户级线程多路复用一个LWP,但只有当前连接到LWP上的线程才能与内核通信，其余进程或者阻塞，或者等待LWP。而每一个LWP都要连接到一个内核级线程上,这样，通过LWP可把用户级线程与内核线程连接起来，用户级线程可通过LWP来访问内核，但内核所看到的总是多个LWP而看不到用户级线程。亦即，由LWP实现了内核与用户级线程之间的隔离，从而使用户级线程与内核无关。图20示出了利用轻型进程作为中 间系统时用户级线程的实现方法。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e C P U 内核 内核线程 用户级线程 轻型线程 任务1 任务2 任务3 图20\u0026emsp;利用轻型线程作为中间系统\n当用户级线程不需要与内核通信时，并不需要LWP；而当要通信时，便须借助于LWP,而且每个要通信的用户级线程都需要一个LWP。例如，在一个任务中，如果同时有5个用户级线程发出了对文件的读、写请求，这就需要有5个LWP来予以帮助，即由LWP将对文件的读、写请求发送给相应的内核级线程，再由后者执行具体的读、写操作。如果一个任务中只有4个LWP，则只能有4个用户级线程的读、写请求被传送给内核线程，余下的一个用户级线程必须等待。\n在内核级线程执行操作时，如果发生阻塞，则与之相连接的多个LWP也将随之阻塞，进而使连接到LWP上的用户级线程也被阻塞。如果进程中只包含了一个LWP，此时进程也应阻塞。这种情况与前述的传统OS一样，在进程执行系统调用时，该进程实际上是阻塞的。但如果在一个进程中含有多个LWP，则当一个LWP阻塞时，进程中的另一个LWP可继续执行；即使进程中的所有LWP全部阻塞，进程中的线程也仍然能继续执行，只是不能再去访问内核。\n线程的创建和终止 如同进程一样，线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应的，在OS中也就有用于创建线程的函数（或系统调用）和用于终止线程的函数（或系统调用）。\n线程的创建 应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。\n线程的终止 当一个线程完成了自己的任务（工作）后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数（或系统调用）对它执行终止操作。但有些线程（主要是系统线程），它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。\n虽已被终止但尚未释放资源的线程仍可以被需要它的线程所调用，以使被终止线程重新恢复运行。为此，调用线程须调用一条被称为“等待线程终止”的连接命令来与该线程进行连接。如果在一个调用者线程调用“等待线程终止”的连接命令，试图与指定线程相连接时，若指定线程尚未被终止，则调用连接命令的线程将会阻塞，直至指定线程被终止后，才能实现它与调用者线程的连接并继续执行：若指定线程已被终止，则调用者线程不会被阻塞而是继续执行。\n人生只若如初见，何事秋风悲画扇。 ― 纳兰性德, 《木兰花·拟古决绝词柬友》 ","date":"2024-11-06T15:37:29+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/operating_system/process_description_and_control/","title":"操作系统（二）：进程的描述与控制"},{"content":" 关系数据库 关系数据库应用数学方法来处理数据库中的数据。最早将这类方法用于数据处理的是1962年CODASYL发表的“信息代数”，之后有1968年David Child在IBM7090机上实现的集合论数据结构，但系统、严格地提出关系模型的是美国IBM公司的E.F.Codd。\n1970年，E.F.Codd在美国计算机学会会刊《Communications of the ACM》上发表了题为“A Relational Model of Data for Shared Data Banks”的论文，开创了数据库系统的新纪元。ACM1983年把这篇论文列为从1958年以来的四分之一世纪中具有里程碑意义的25篇研究论文之一。此后，E.F.Codd连续发表了多篇论文，奠定了关系数据库的理论基础。\n20世纪70年代末，关系方法的理论研究和软件系统的研制均取得了丰硕的成果，IBM公司的San Jose实验室在IBM 370系列机上研制的关系数据库实验系统System R历时6年获得成功。1981年，IBM公司又宣布了具有System R全部特征的新的数据库软件产品SQL/DS问世。\n与System R同期，美国加州大学伯克利分校也研制了INGRES关系数据库实验系统，并由INGRES公司发展成为INGRES数据库产品。\n40多年来，关系数据库系统的研究和开发取得了辉煌的成就。关系数据库系统从实验室走向了社会，成为最重要、应用最广泛的数据库系统，大大促进了数据库应用领域的扩大和深入。因此，关系数据模型的原理、技术和应用十分重要。\n关系数据结构及形式化定义 关系 关系模型的数据结构非常简单，只包含单一的数据结构\u0026mdash;\u0026mdash;关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。\n关系模型的数据结构虽然简单却能够表达丰富的语义，描述出现实世界的实体以及实体间的各种联系。也就是说，在关系模型中，现实世界的实体以及实体间的各种联系均用单一的结构类型，即关系来表示。\n前面已经非形式化地介绍了关系模型及有关的基本概念。关系模型是建立在集合代数的基础上的，这里从集合论角度给出关系数据结构的形式化定义。\n域(domain) 定义1（域）：域是一组具有相同数据类型的值的集合。例如，自然数、整数、实数、长度小于25字节的字符串集合、 {0,1} 、 {男,女} 、大于等于0且小于等于100的正整数等，都可以是域。\nCartesian乘积(cartesian product) 定义2（Cartesian乘积）：给定一组域 \\(D_1,D_2,\\cdots,D_n\\) ，允许其中某些域是相同的， \\(D_1,D_2,\\cdots,D_n\\)的Cartesian乘积为\n\\[ D_1\\times D_2 \\times \\cdots \\times D_n=\\set{(d_1,d_2,\\cdots,d_n)|d_i\\in D_i,i=1,2,\\cdots,n} \\tag{1} \\] 其中，每一个元素 \\((d_1,d_2,\\cdots,d_n)\\) 叫作一个n元组(tuple)，或简称元组(tuple)。元素中的每一个值 \\(d_i\\) 叫做一个分量(component)。\n一个域允许的不同取值个数称为这个域的基数(cardinal number)。若 \\(D_i(i=1,2,\\cdots,n)\\) 为有限集，其计数为 \\(m_i(i=1,2,\\cdots,n)\\) ，则 \\((D_1,D_2,\\cdots,D_n)\\) 的基数 \\(M\\) 为\n\\[ M=\\prod_{i=1}^{n}m_i \\tag{2} \\] Cartesian乘积可表示为一张二维表，表中的每行对应一个元组，表中的每一列来自一个域，例如给出三个域\n\\[ \\begin{aligned} D_1=\u0026\\text{导师集合(SUPERVISOR)}=\\set{张清玫,刘逸}\\\\[5pt] D_2=\u0026\\text{专业集合(SPECIALITY)}=\\set{计算机专业,信息专业}\\\\[5pt] D_3=\u0026\\text{研究生集合(POSTGRADUATE)}=\\set{李勇,刘晨,王敏} \\end{aligned} \\tag{3} \\] 则 \\(D_1,D_2,D_3\\) 的Cartesian乘积为\n\\[ \\begin{aligned} D1\\times D2\\times D3=｛\u0026(张清玫,计算机专业,李勇),(张清玫,目算机专业,刘晨),\\\\[5pt] \u0026(张清玫,计算机专业,王敏),(张清玫,信息专业,李勇),\\\\[5pt] \u0026(张清玫,信息专业,刘晨),(张清玫,信息专业,王敏), \\\\[5pt] \u0026(刘逸,计算机专业,李勇),(刘逸,计算机专业,刘晨), \\\\[5pt] \u0026(刘逸,计算机专业,王敏),(刘逸,信息专业,李勇),\\\\[5pt] \u0026(刘逸,信息专业,刘晨),(刘逸,信息专业,王敏)｝ \\end{aligned} \\tag{4} \\] 其中，(张清玫,计算机专业,李勇)、(张清玫,计算机专业,刘晨)等都是元组。张清玫、计算机专业、李勇、刘晨等都是分量。该Cartesian乘积的基数为 \\(2\\times 2\\times 3=12\\) ，也就是说， \\(D_1\\times D_2\\times D_3\\) 一共有 \\(2\\times 2 \\times 3 = 12\\) 个元组。这12个元组可列成一张二维表，如表1所示\nSUPERVISOR SPECIALITY POSTGRADUATE 张清攻 计算机专业 李勇 张清攻 计算机专业 刘宸 张清攻 计算机专业 王敏 张清攻 信息专业 李勇 张清攻 信息专业 刘宸 张清攻 信息专业 王敏 刘逸 计算机专业 李勇 刘逸 计算机专业 刘宸 刘逸 计算机专业 王敏 刘逸 信息专业 李勇 刘逸 信息专业 刘宸 刘逸 信息专业 王敏 表1\u0026emsp;\\(D_1,D_2,D_3\\) 的Cartesian乘积\n。\n关系 定义3（关系） \\(D_1\\times D_2 \\times \\cdots\\times D_n\\) 的子集叫做在域 \\(D_1,D_2,\\times,D_n\\) 以上的关系，表示为\n\\[ R(D_1,D_2,\\times,D_n) \\tag{5} \\] 这里 \\(R\\) 表示关系的名字， \\(n\\) 是关系的目或度(degree)。\n关系中的每个元素是关系中的元组，通常用 \\(t\\) 表示。\n当 \\(n=1\\) 时，称该关系为单元关系(unary relation)，或一元关系。\n当 \\(n=2\\) 时，称该关系为二元关系(binary relation)。\n关系是Cartesian乘积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性(attribute)。n目关系必有n个属性。\n若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码(candidate key)。若一个关系有多个候选码，则选定其中一个为主码(primary key)。\n候选码的属性称为主属性(prime attribute)。不包含在任何候选码中的属性称为非主属性（non-prime attribute）‌或‌非码属性（non-key attribute）。\n在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为全码（all-key）。\n一般来说， \\(D_1,D_2,\\cdots,D_n\\) 的Cartesian乘积是没有实际语义的，只有它的某个真子集才有实际含义。例如，可以发现表1的Cartesian乘积中许多元组是没有意义的。因为在学校中一个专业方向有多个导师，而一个导师只在一个专业方向带研究生；一个导师可以带多名研究生，而一名研究生只有一个导师，学习某一个专业。因此，表1中的一个子集才是有意义的，才可以表示导师与研究生的关系，把该关系取名为 \\(\\text{SAP}\\) ，如表2所示。李勇和刘晨是计算机专业张清玫老师的研究生；王敏是信息专业刘逸老师的研究生。\n\\(\\text{SUPERVISOR}\\) \\(\\text{SPECIALITY}\\) \\(\\text{POSTGRADUATE}\\) 张清攻 计算机专业 李勇 张清攻 计算机专业 刘宸 刘逸 信息专业 王敏 表2\u0026emsp;SAP关系\n把关系 \\(\\text{SAP}\\) 的属性名取为域名，即 \\(\\text{SUPERVISOR}\\) , \\(\\text{SPECIALITY}\\) , \\(\\text{POSTGRADUATE}\\) 则这个关系可以表示为\n\\[ \\text{SAP}(\\text{SUPERVISOR},\\text{SPECIALITY},\\text{POSTGRADUATE}) \\tag{6} \\] 假设研究生不会重名（这在实际生活中是不合适的，这里只是为了举例方便），则 \\(\\text{POSTGRADUATE}\\) 属性的每一个值都唯一地标识了一个元组，因此可以作为SAP关系的主码。\n关系可以有三种类型：基本关系（通常又称为基本表或基表）、查询表和视图表。其中，基本表是实际存在的表，它是实际存储数据的逻辑表示：查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。\n按照定义2，关系可以是一个无限集合。由于组成Cartesian乘积的域不满足交换律，所以按照数学定义， \\((d_1,d_2,\\cdots,d_n)\\ne(d_2,d_1,\\cdots,d_n)\\) 。当关系作为关系数据模型的数据结构时，需要给予如下的限定和扩充。\n(1) 无限关系在数据库系统中是无意义的。因此，限定关系数据模型中的关系必须是有限集合。\n(2) 通过为关系的每个列附加一个属性名的方法取消关系属性的有序性，即 \\((d_1,d_2,\\cdots,d_i,d_j,\\cdots,d_n)=(d_1,d_2,\\cdots,d_j,d_i,\\cdots,d_n)\\quad(i,j=1,2,\\cdots,n)\\)\n因此，基本关系具有以下6条性质。\n(1) 列是同质的(homogeneous),即每一列中的分量是同一类型的数据，来自同一个域。\n(2) 不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。例如，在上面的例子中，也可以只给出两个域： \\[ \\begin{aligned} \u0026\\text{人(PERSON)}=\\set{张清玫，刘逸，李勇，刘晨，王敏}\\\\[5pt] \u0026\\text{专业(SPECIALITY)}=\\set{计算机专业，信息专业} \\end{aligned} \\tag{7} \\] \\(\\text{SAP}\\) 关系的导师属性和研究生属性都从 \\(\\text{PERSON}\\) 域中取值。为了避免混淆，必须给这两个属性取不同的属性名，而不能直接使用域名。例如，定义导师属性名为 \\(\\text{SUPERVISOR-PERSON}\\) （或 \\(\\text{SUPERVISOR}\\) ）研究生属性名为 \\(\\text{POSTGRADUATE-PERSON}\\) （或 \\(\\text{POSTGRADUATE}\\) ）\n(3) 列的顺序无所谓，即列的次序可以任意交换。由于列顺序是无关紧要的，因此在许多实际关系数据库产品中增加新属性时，永远是插至最后一列。\n(4) 任意两个元组的候选码不能取相同的值。\n(5) 行的顺序无所谓，即行的次序可以任意交换。\n(6) 分量必须取原子值，即每一个分量都必须是不可分的数据项。\n关系模型要求关系必须是规范化(normalization)‌的，即要求关系必须满足一定的规范条件。这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式（Normal Form，NF）。范式的概念将在第6篇关系数据理论中做进一步讲解。 例如，表3虽然很好地表达了导师与研究生之间的一对多关系，但由于属性 \\(\\text{POSTGRADUATE}\\) 中分量取了两个值，不符合规范化的要求，因此这样的关系在数据库中是不允许的。通俗地讲，关系表中不允许还有表，简言之不允许“表中有表”。直观地描述，表3中还有一个小表。\n\\(\\text{SUPERVISOR}\\) \\(\\text{SPECIALITY}\\) \\(\\text{POSTGRADUATE}\\) \\(\\text{PG1}\\) \\(\\text{PG2}\\) 张清攻 计算机专业 李勇 刘晨 刘逸 信息专业 王敏 表3\u0026emsp;非规范关系\n关系模式 在数据库中要区分型和值。关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述，那么一个关系需要描述哪些方面呢？\n关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性与域之间的映像关系。\n现实世界随着时间在不断地变化，因而在不同的时刻关系模式的关系也会有所变化。但是，现实世界的许多己有事实和规则限定了关系模式所有可能的关系必须满足一定的完整性约束条件。这些约束或者通过对属性取值范围的限定，例如职工年龄小于60岁（60岁以后退休），或者通过属性值间的相互关联反映出来。例如，如果2个元组的主码相等，那么元组的其他值也一定相等，因为主码唯一标识一个元组，主码相等就表示这是同一个元组。关系模式应当刻划出这些完整性约束条件。\n定义4（关系模式）：关系的描述称为关系模式(relation schema)。它可以形式化地表示为\n\\[ R(U,D,\\text{DOM},F) \\tag{8} \\] 其中 \\(R\\) 为关系名， \\(U\\) 为组成该关系的属性名集合， \\(D\\) 为 \\(U\\) 中属性所来自的域， \\(\\text{DOM}\\) 为属性向域的映像集合， \\(F\\) 为属性间数据的依赖关系集合。\n属性间的数据依赖将在后篇讨论，本章中关系模式仅涉及关系名、各属性名、域名、属性向域的映像四部分，即 \\(R(U,D,\\text{DOM})\\) 。\n例如，在上面例子中，由于导师和研究生出自同一个域\u0026mdash;\u0026mdash;人，所以要取不同的属性名，并在模式中定义属性向域的映像，即说明它们分别出自哪个域，如：\n\\[ \\text{DOM(SUPERVISOR)=DOM(POSTGRADUATE)=PERSON} \\tag{9} \\] 关系模式通常可以简记为\n\\[ R(U) \\tag{10} \\] 或\n\\[ R(A_1,A_2,\\cdots,A_n) \\tag{11} \\] 其中 \\(R\\) 为关系名， \\(A_1,A_2,\\cdots,A_n\\) 为属性名。而域名及属性向域的映像常常直接说明为属性的类型、长度。\n关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。例如，学生关系模式在不同的学年，学生关系是不同的。在实际工作中，人们常常把关系模式和关系都笼统地称为关系，这不难从上下文中加以区别，希望读者注意。\n关系数据库 在关系模型中，实体以及实体间的联系都是用关系来表示的。例如导师实体、研究生实体、导师与研究生之间的一对多联系都可以分别用一个关系来表示。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。\n关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。\n关系模型的存储结构 我们已经知道，在关系数据模型中实体及实体间的联系都用表来表示，但表是关系数据的逻辑模型.在关系数据库的物理组织中，有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。\n关系操作 关系模型给出了关系操作的能力的说明，但不对关系数据库管理系统语言给出具体的语法要求，也就是说不同的关系数据库管理系统可以定义和开发不同的语言来实现这些操作。\n基本的关系操作 关系模型中常用的关系操作包括查询(query)操作和插入(insert)、删除(delete)、修改(update)操作两大部分。关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为选择(select)、投影(project)、连接(join)、除(divide)、并(union)、差(except)、交(intersection)、Cartesian乘积等。其中选择、投影、并、差、Cartesian乘积是5种基本操作，其他操作可以用基本操作来定义和导出，就像乘法可以用加法来定义和导出一样。\n关系数据语言的分类 早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数(relational algebra)‌和关系演算(relational calculus)‌关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算三种语言在表达能力上是等价的，都具有完备的表达能力。\n关系代数、元组关系演算和域关系演算均是抽象的查询语言，这些抽象的语言与具体的关系数据库管理系统中实现的实际语言并不完全一样。但它们能用作评估实际系统中查询语言能力的标准或基础。实际的查询语言除了提供关系代数或关系演算的功能外，还提供了许多附加功能，例如聚集函数(aggregation function)。关系赋值、算术运算等，使得目前实际查询语言的功能十分强大。\n另外，还有一种介于关系代数和关系演算之间的结构化查询语言(Structured Query Language,SQL)。SQL不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言(Data Control Language,DCL)于一体的关系数据语言。它充分体现了关系数据语言的特点和优点，是关系数据库的标准语言。因此，关系数据语言可以分为三类：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 关系数据语言 关系代数语 言 （ 例如I S B L ） 关系演算语言 具有关系代数和关系演算双重特性的语言(例如 S Q L ) 元组关系演算语 言 （ 例如 A L P H A 、 Q U E L ） 域关系演算语 言 （ 例如 Q B E ） 图1\u0026emsp;关系数据语言\n特别地，SQL语言是一种高度非过程化的语言，用户不必请求数据库管理员为其建立特殊的存取路径，存取路径的选择由关系数据库管理系统的优化机制来完成。例如，在一个存储有几百万条记录的关系中查找符合条件的某一个或某一些记录，从原理上讲可以有多种查找方法。例如，可以顺序扫描这个关系，也可以通过某一种索引来查找。不同的查找路径（或者称为存取路径）的效率是不同的，有的完成某一个查询可能很快，有的可能极慢。关系数据库管理系统中研究和开发了查询优化方法，系统可以自动选择较优的存取路径，提高查询效率。\n关系的完整性 关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时应该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。\n关系模型中有三类完整性约束：实体完整性(entity integrity)、参照完整性(referential integrity)和用户定义的完整性（user-defined integrity）。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。\n实体完整性 关系数据库中每个元组应该是可区分的，是唯一的。这样的约束条件用实体完整性来保证。\n实体完整性规则：若属性（指一个或一组属性） \\(A\\) 是基本关系 \\(R\\) 的主属性,则 \\(A\\) 不能取空值(null value)。所谓空值就是\u0026quot;不知道”或\u0026quot;不存在”或“无意义”的值。\n按照实体完整性规则的规定，如果主码由若干属性组成，则所有这些主属性都不能取空值。例如选修（学号，课程号,成绩）关系中，“学号、课程号”为主码，则“学号”和“课程号”两个属性都不能取空值。\n对于实体完整性规则说明如下：\n(1) 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。\n(2) 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。\n(3) 相应地，关系模型中以主码作为唯一性标识。\n(4) 主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与(2)相矛盾，因此这个规则称为实体完整性。\n参照完整性 现实世界中的实体之间往往存在某种联系，在关系模型中实体及实体间的联系都是用关系来描述的，这样就自然存在着关系与关系间的引用。先来看三个例子。\n例1：学生实体和专业实体可以用下面的关系来表示，其中主码用下划线标识。\n\\[ \\begin{aligned} \u0026学生(\\underline{学号},姓名,性别,专业号,年龄)\\\\[5pt] \u0026专业(\\underline{专业号},专业名) \\end{aligned} \\tag{12} \\] 这两个关系之间存在着属性的引用，即学生关系引用了专业关系的主码“专业号”显然，学生关系中的“专业号”值必须是确实存在的专业的专业号，即专业关系中有该专业的记录。也就是说，学生关系中的某个属性的取值需要参照专业关系的属性取值。\n例2：学生、课程、学生与课程之间的多对多联系可以如下三个关系表示：\n\\[ \\begin{aligned} \u0026学生(\\underline{学号},姓名,性别,专业号,年龄)\\\\[5pt] \u0026课程(\\underline{课程号},课程名,学分)\\\\[5pt] \u0026选修(\\underline{学号,课程号},成绩) \\end{aligned} \\tag{13} \\] 这三个关系之间也存在着属性的引用，即选修关系引用了学生关系的主码“学号”和课程关系的主码“课程号”。同样，选修关系中的“学号”值必须是确实存在的学生的学号,即学生关系中有该学生的记录；选修关系中的“课程号”值也必须是确实存在的课程的课程号，即课程关系中有该课程的记录。换句话说，选修关系中某些属性的取值需要参照其他关系的属性取值。\n不仅两个或两个以上的关系间可以存在引用关系，同一关系内部属性间也可能存在引用关系。\n例3：在 \\(学生（\\underline{学号}，姓名，性别，专业号，年龄，班长）\\) 关系中，“学号”属性是主码，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系“学号”属性, 即“班长”必须是确实存在的学生的学号。\n这三个例子说明关系与关系之间存在着相互引用、相互约束的情况。下面先引入外码 的概念，然后给出表达关系之间相互引用约束的参照完整性的定义。\n定义5（参照关系）：设 \\(F\\) 是基本关系 \\(R\\) 的一个或一组属性，但不是关系 \\(R\\) 的码， \\(K_s\\) 是基本关系 \\(S\\) 的主码。如果 \\(F\\) 与 \\(K_s\\) 相对应，则称 \\(F\\) 是 \\(R\\) 的外码(foreign key)，并称基本关系 \\(R\\) 为参照关系(referencing relation)，基本关系 \\(S\\) 为被参照关系(referenced relation)‌或目标关系(target relation)，关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 参照关系 被参照关系(目标关系) 图2\u0026emsp;参照关系与被参照关系\n显然，目标关系 \\(S\\) 的主码 \\(K_s\\) 和参照关系 \\(S\\) 的外码 \\(F\\) 必须定义在同一个（或同一组） 域上。\n在例1中，学生关系的“专业号”属性与专业关系的主码“专业号”相对应，因此“专业号”属性是学生关系的外码。这里专业关系是被参照关系，学生关系为参照关系。如图3(a)所示。\n在例2中，选修关系的“学号”属性与学生关系的主码“学号”相对应：选修关系的“课程号”属性与课程关系的主码“课程号”相对应，因此“学号”和“课程号”属性 是选修关系的外码。这里学生关系和课程关系均为被参照关系，选修关系为参照关系。如图3(b)所示。\n在例3中，“班长”属性与本身的主码“学号”属性相对应，因此“班长”是外码。这里，学生关系既是参照关系也是被参照关系。如图3(c)所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学生关系 专业关系 专业号 ( a) 学生关系 选修关系 学号 课程关系 课程号 ( b ) 学生关系 学号 ( c) 图3\u0026emsp;关系的参照图\n需要指出的是，外码并不一定要与相应的主码同名，如例2.3中学生关系的主码为学号，外码为班长。不过，在实际应用中为了便于识别，当外码与相应的主码属于不同关系时，往往给它们取相同的名字。\n参照完整性规则就是定义外码与主码之间的引用规则。\n参照完整性规则：若属性（或属性组） \\(F\\) 是基本关系 \\(R\\) 的外码，它与基本关系 \\(S\\) 的主码 \\(K_s\\) 相对应（基本关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系），则对于 \\(R\\) 中每个元组在 \\(F\\) 上的值必须： ◦或者取空值（ \\(F\\) 的每个属性值均为空值）。\n◦或者等于 \\(S\\) 中某个元组的主码值。\n例如，对于例1，学生关系中每个元组的“专业号”属性只能取下面两类值：\n◦空值，表示尚未给该学生分配专业。\n◦非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配到一个不存在的专业中。即被参照关系“专业”中一定存在一个元组，它的主码值等于该参照关系\u0026quot;学生\u0026quot;中的外码值。\n对于例2，按照参照完整性规则，“学号”和“课程号”属性也可以取两类值：空值或目标关系中已经存在的值。但由于“学号\u0026quot;和\u0026quot;课程号”是选修关系中的主属性，按照实体完整性规则，它们均不能取空值，所以选修关系中的\u0026quot;学号”和“课程号”属性实际上只能取相应被参照关系中已经存在的主码值。\n参照完整性规则中， \\(R\\) 与 \\(S\\) 可以是同一个关系。例如对于例3按照参照完整性规则，“班长”属性值可以取两类值：\n◦空值，表示该学生所在班级尚未选出班长。\n◦非空值，这时该值必须是本关系中某个元组的学号值。\n用户定义的完整性 任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取唯一值、某个非主属性不能取空值等。例如，在例1的学生关系中，若按照应用的要求学生不能没有姓名，则可以定义学生姓名不能取空值；某个属性（如学生的成绩），的取值范围可以定义在0〜100之间等。\n关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能。\n在早期的关系数据库管理系统中没有提供定义和检验这些完整性的机制，因此需要应用开发人员在应用系统的程序中进行检查。例如在例2的选修关系中，每插入一条记录,必须在应用程序中写一段程序来检查其中的学号是否等于学生关系中的某个学号，并检查其中的课程号是否等于课程关系中的某个课程号。如果等于，则插入这一条选修记录，否则就拒绝插入，并给出错误信息。\n关系代数 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括两类：集合运算符和专门的关系运算符，如表4所示。关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。其中，传统的集合运算将关系看成元组的集合，其运算是从关系的“水平”方向，即行的角度来进行：而专门的关系运算不仅涉及行，而且涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。\n运算符 含义 集合运算符 \\(\\cup\\) 并 \\(-\\) 差 \\(\\cap\\) 交 \\(\\times\\) Cartesian乘积 专门的关系运算符 \\(\\sigma\\) 选择 \\(\\pi\\) 投影 \\(\\Join\\) 连接 \\(\\div\\) 除 表4\u0026emsp;关系代数运算符\n传统的集合运算 传统的集合运算是二目运算，包括并、差、交、Cartesian乘积4种运算。\n设关系 \\(R\\) 和关系 \\(S\\) 具有相同的目 \\(n\\) （即两个关系都有 \\(n\\) 个属性），且相应的属性取自同一个域， \\(t\\) 是元组变量， \\(t \\in R\\) 表示 \\(t\\) 是 \\(R\\) 的一个元组。\n可以定义并、差、交、Cartesian乘积运算如下。\n并(union) 关系 \\(R\\) 与关系 \\(S\\) 的并记作\n\\[ R\\cup S=\\set{t|t \\in R \\lor t \\in S} \\tag{14} \\] 其中 \\(\\lor\\) 是或运算符。其结果仍为 \\(n\\) 目关系，由属于 \\(R\\) 或属于 \\(S\\) 的元组组成。\n差(except) 关系 \\(R\\) 与关系 \\(S\\) 的差记作\n\\[ R-S=\\set{t|t \\in R \\land t \\notin S} \\tag{15} \\] 其中 \\(\\land\\) 是与运算符。其结果关系仍为 \\(n\\) 目关系，由属于 \\(R\\) 而不属于 \\(S\\) 的所有元组组成。\n交(intersection) 关系 \\(R\\) 与关系 \\(S\\) 的交记作\n\\[ R\\cap S = \\set{t|t\\in R \\land t \\in S} \\tag{16} \\] 其结果关系仍为 \\(n\\) 目关系，由既属于 \\(R\\) 及又属于 \\(S\\) 的元组组成。关系的交可以用差来表示，即\n\\[ R \\cap S = R-(R-S) \\tag{17} \\] Cartesian乘积(cartesian product) 这里的Cartesian乘积严格地讲应该是广义的Cartesian乘积(extended cartesian product)，因为这里Cartesian乘积的元素是元组。\n两个分别为 \\(n\\) 目和 \\(m\\) 目的关系 \\(R\\) 和 \\(S\\) 的Cartesian乘积是一个 \\((n+m)\\) 列的元组的集合。元组的前 \\(n\\) 列是关系 \\(R\\) 的一个元组，后所列是关系 \\(S\\) 的一个元组。若 \\(R\\) 有 \\(k_1\\) 个元组，S有 \\(k_2\\) 个元组，则关系 \\(R\\) 和关系 \\(S\\) 的Cartesian乘积有 \\(k_1\\times k_2\\) 个元组。记作\n\\[ R\\times S=\\set{\\overgroup{t_rt_s}|t_r \\in R \\land t_s \\in S} \\tag{18} \\] 图4(a)、图4(b)分别为具有三个属性列的关系 \\(R\\) 、 \\(S\\) 。图4(c)为关系 \\(R\\) 与 \\(S\\) 的并。图4(d)为关系 \\(R\\) 与 \\(S\\) 的交。图4(e)为关系 \\(R\\) 和 \\(S\\) 的差。图4(f)为关系 \\(R\\) 和 \\(S\\) 的Cartesian乘积。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a) ( b ) ( c) ( d ) ( e ) ( f ) 图4\u0026emsp;传统集合运算举例\n专门的关系运算 专门的关系运算包括选择、投影、连接、除运算等。为了叙述上的方便，先引入几个记号。\n(1) 设关系模式为 \\(R(A_1,A_2,\\cdots,A_n)\\)，它的一个关系设为 \\(R\\) 。 \\(t \\in R\\) 表示 \\(t\\) 是 \\(R\\) 的一个元组。 \\(t[A_i]\\) 则表示元组 \\(t\\) 中相应于属性 \\(i\\) 的一个分量。\n(2) 若 \\(A=\\set{A_{i1},A_{i2},\\cdots,A_{ik}}\\) ，其 \\(A_{i1},A_{i2},\\cdots,A_{ik}\\) 是 \\(A_1,A_2,\\cdots,A_n\\) 中的一部分,则 \\(A\\) 称为属性列或属性组。 \\(t[A]=(t[A_{i1}],t[A_{i2}],\\cdots,t[A_{ik}])\\) 表示元组 \\(t\\) 在属性列 \\(A\\) 上诸分量的集合， \\(\\bar{A}\\) 则表示 \\(\\set{A_1,A_2,\\cdots,A_n}\\) 中去掉 \\(\\set{A_{i1},A_{i2},\\cdots,A_{ik}}\\) 后剩余的属性组。\n(3) \\(R\\) 为 \\(n\\) 目关系， \\(S\\) 为 \\(m\\) 目关系。 \\(t_r\\in R,t_s \\in S\\) ， \\(\\overgroup{t_rt_s}\\) 称为元组的连接(concatenation)‌或元组的串接。它是一个 \\(n+m\\) 列的元组，前 \\(n\\) 个分量为 \\(R\\) 中的一个 \\(n\\) 元组，后 \\(m\\) 个分量为 \\(S\\) 中的一个 \\(m\\) 元组。\n(4) 给定一个关系 \\(R(X,Z)\\) ， \\(X\\) 和 \\(Z\\) 为属性组。当 \\(t[X]=x\\) 时， \\(x\\) 在 \\(R\\) 中的象集(images set)‌定义为 \\[ Z_x=\\set{t[Z]|t \\in R, t[X]=x} \\tag{19} \\] 它表示 \\(R\\) 中属性组 \\(X\\) 上值为 \\(x\\) 的诸元组在 \\(Z\\) 上分量的集合。\n例如，图5中， \\(x_1\\) 在 \\(R\\) 中的象集为 \\(Z_{x_1}=\\set{{Z_1,Z_2,Z_3}}\\) ， \\(x_2\\) 在 \\(R\\) 中的象集为 \\(Z_{x_2}=\\set{Z_2,Z_3}\\) ， \\(x_3\\) 在 \\(R\\) 中的象集为 \\(Z_{x_3}=\\set{Z_1,Z_3}\\) 。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图5\u0026emsp;象集举例\n下面给出这些专门的关系运算的定义。\n选择 选择又称为限制(restriction)。它是在关系 \\(R\\) 中选择满足给定条件的诸元组，记作\n\\[ \\sigma_F(R)=\\set{t|t \\in R \\land F(t)=\\text{'真'}} \\tag{20} \\] 其中 \\(F\\) 表示一个选择条件，它是一个逻辑表达式，取逻辑“真”或“假”。\n逻辑表达式 \\(F\\) 的基本形式为\n\\[ X_1\\theta Y_1 \\tag{21} \\] 其中 \\(\\theta\\) 表示比较运算符，它可以是 \\(\u003e,\\ge,\u003c,\\le,=\\) 或 \\(\u003c\u003e\\) 。 \\(X_1,Y_1\\) 是属性名，或为常量，或为简单常数；属性名也可以用它的序号来代替，在基本的选择条件上可以进一步进行逻辑运算，即进行求非（ \\(\\lnot\\) ）、与（ \\(\\land\\) ）、或（ \\(\\lor\\) ）运算。条件表达式中的运算符如20241026141516CST所示。\n运算符 含义 比较运算符 \\(\u003e\\) 大于 \\(\\ge\\) 大于等于 \\(\u003c\\) 小于 \\(\\le\\) 小于等于 \\(=\\) 等于 \\(\u003c\u003e\\) 不等于 逻辑运算符 \\(\\lnot\\) 非 \\(\\land\\) 与 \\(\\lor\\) 或 表5\n选择运算实际上是从关系火中选取使逻辑表达式 \\(F\\) 为真的元组。这是从行的角度进行的运算。\n设有一个学生—课程数据库，包括学生关系Student，课程关系Course和选修关系SC。如图6所示。下面的多个例子将对这三个关系进行运算。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 201215121 学号 Sno 姓名 Sname 李勇 性别 Ssex 年龄 S ag e 所在系 Sd e p t 男 20 CS 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS S t u dent C o u r se ( a) 1 课程号 Cno 课程名 Cname 数据库 先行课 C pno 学分 C r edit 5 4 数学 2 信息系统 4 操作系统 3 2 3 4 5 6 7 数据结构 数据处理 P A S C A L语言 1 6 7 6 4 2 4 ( b ) 学号 Sno 课程号 Cno 成绩 G r ade 92 88 90 80 85 201215121 201215121 201215121 201215122 201215122 1 2 3 2 3 S C ( c) 图6\u0026emsp;学生—课程数据库\n例4：查询信息系（IS系）全体学生。\n\\[ \\sigma_{\\text{Sdept}=\\text{'IS'}}(\\text{Student}) \\tag{22} \\] 结果如图7(a)所示。\n例5：查询年龄小于20岁的学生。\n\\[ \\sigma_{\\text{Sage\u003c20}}(\\text{Student}) \\tag{23} \\] 结果如图7(b)所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学号 Sno 姓名 Sname 性别 Ssex 年龄 S ag e 所在系 Sd e p t 201215125 张立 男 19 IS S t u dent ( a) 学号 Sno 姓名 Sname 性别 Ssex 年龄 S ag e 所在系 Sd e p t 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS S t u dent ( b ) 图7\u0026emsp;选择运算举例\n投影(projection) 关系 \\(R\\) 上的投影是从 \\(R\\) 中选择出若干属性列组成新的关系。记作\n\\[ \\Pi_A(R)=\\set{t[A]|t \\in R} \\tag{24} \\] 其中 \\(A\\) 为 \\(R\\) 的属性列。\n投影操作就是从列的角度进行运算。\n例6：查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性上的投影。\n\\[ \\Pi_{\\text{Sname,Sdept}}(\\text{Student}) \\tag{25} \\] 结果如图8(a)所示。\n投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行。\n例7：查询学生关系Student中都有哪些系，即查询关系Student上所在系属性上的投影。\n\\[ \\Pi_{\\text{Sdept}}(\\text{Student}) \\tag{26} \\] 结果如图8(b)所示。Student关系原来有4个元组，而投影结果取消了重复的CS元组，因此只有三个元组。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Sname Sd e p t 李勇 刘晨 王敏 张立 CS CS MA IS Sd e p t CS IS MA （a） （b） 图8\u0026emsp;投影运算举例\n连接(join) 连接也称为 \\(\\theta\\) 连接。它是从两个关系的Cartesian乘积中选取属性间满足一定条件的元组。记作\n\\[ R \\underset{A\\theta B}{\\Join} S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[A]\\theta t_s[B])} \\tag{27} \\] 其中， \\(A\\) 和 \\(B\\) 分别为 \\(R\\) 和 \\(S\\) 上列数相等且可比的属性组， \\(\\theta\\) 是比较运算符。连接运算从 \\(R\\) 和 \\(S\\) 的Cartesian乘积 \\(R\\times S\\) 中选取R关系在 \\(A\\) 属性组上的值与 \\(S\\) 关系在 \\(B\\) 属性组上的值满足比较关系 \\(\\theta\\) 的元组。\n连接运算中有两种最为重要也最为常用的连接，一种是等值连接(equijoin)，另一种是自然连接(natural join)。\n\\(\\theta\\) 为“ \\(=\\) ”的连接运算称为等值连接。它是从关系 \\(R\\) 与 \\(S\\) 的广义Cartesian乘积中选取 \\(A\\) 、 \\(B\\) 属性值相等的那些元组，即等值连接为\n\\[ R \\underset{A=B}{\\Join} S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[A]=t_s[B])} \\tag{28} \\] 自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若 \\(R\\) 和 \\(S\\) 中具有相同的属性组 \\(B\\) ， \\(U\\) 为 \\(R\\) 和 \\(S\\) 的全体属性集合，则自然连接可记作\n\\[ R \\Join S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[B]=t_s[B])} \\tag{29} \\] 一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。\n例8：设图9(a)和(b)分别为关系 \\(R\\) 和关系 \\(S\\) ，图图9(c)为非等值连接及 \\( R \\underset{C\\lt E}{\\Join} S \\) 的结果，图9(d)为等值连接 \\( R \\underset{R.B=S.B}{\\Join} S \\) 的结果，图9(e)为自然连接 \\( R \\Join S \\) 的结果。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a)关系 ( b )关系 ( c)非等值连接 ( d )等值连接 ( e )自然连接 图9\u0026emsp;连接运算举例\n两个关系 \\(R\\) 和 \\(S\\) 在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系 \\(R\\) 中某些元组有可能在 \\(S\\) 中不存在公共属性上值相等的元组，从而造成 \\(R\\) 中这些元组在操作时被舍弃了，同样， \\(S\\) 中某些元组也可能被舍弃。这些被舍弃的元组称为悬浮元组(dangling tuple)，例如，在图9(e)的自然连接中， \\(R\\) 中的第 \\(4\\) 个元组， \\(S\\) 中的第 \\(5\\) 个元组都是被舍弃掉的悬浮元组。\n如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接(outer join)，记作 \\(R⟗S\\) ；如果只保留左边关系 \\(R\\) 中的悬浮元组就叫做左外连接（left outer join或left join），记作 \\(R⟕S\\) ；如果只保留右边关系 \\(S\\) 中的悬浮元组就叫做右外连接（right outer join或right join），记作 \\(R⟖S\\) 。在图10中，(a)是图9中的关系 \\(R\\) 和关系 \\(S\\) 的外连接，(b)是左外连接，(c)是右外连接。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a)外连接 ( b )左外连接 ( c)右外连接 图10\u0026emsp;外连接运算举例\n除运算 设关系 \\(R\\) 除以关系 \\(S\\) 的结果为关系 \\(T\\) ，则 \\(T\\) 包含所有在 \\(R\\) 但不在 \\(S\\) 中的属性及其值，且 \\(T\\) 的元组与 \\(S\\) 的元组的所有组合都在 \\(R\\) 中。\n下面用象集来定义除法：\n给定关系 \\(R(X,Y)\\) 和 \\(S(Y,Z)\\) ，其中 \\(X,Y,Z\\) 为属性组。 \\(R\\) 中的 \\(Y\\) 与 \\(S\\) 中的 \\(Y\\) 可以有不同的属性名，但必须出自相同的域集。\n\\(R\\) 与 \\(S\\) 的除运算得到一个新的关系 \\(P(X)\\) ， \\(P\\) 是 \\(R\\) 中满足下列条件的元组在 \\(X\\) 属性列上的投影：元组在 \\(X\\) 上分量值 \\(x\\) 的象集 \\(Y_x\\) 包含 \\(S\\) 在 \\(Y\\) 上投影的集合。记作\n\\[ R\\div S=\\set{t_r[X]|(t_r\\in R)\\land(\\Pi_Y (S)\\sube Y_x)} \\tag{30} \\] 其中 \\(Y_x\\) 为 \\(x\\) 在 \\(R\\) 中的象集， \\(x=t_r[X]\\) 。\n除操作是同时从行和列角度进行运算。\n例9：设关系 \\(R\\) 、 \\(S\\) 分别为图11中的(a)和(b)， \\(R \\div S\\) 的结果为图11(c)。\n在关系 \\(R\\) 中， \\(A\\) 可以取 \\(4\\) 个值 \\(\\set{a_1,a_2,a_3,a_4}\\) 。其中：\n\\(a_1\\) 的象集为 \\(\\set{(b_1,c_2),(b_2,c_3),(b_2,c_1)}\\) 。\n\\(a_2\\) 的象集为 \\(\\set{(b_3,c_7),(b_2,c_3)}\\) 。\n\\(a_3\\) 的象集为 \\(\\set{(b_4,c_6)}\\) 。\n\\(a_4\\) 的象集为 \\(\\set{(b_6,c_6)}\\) 。\n\\(S\\) 在 \\((B,C)\\) 上的投影为 \\(\\set{(b_1,c_2),(b_2,c_1),(b_2,c_3)}\\) 。\n显然只有 \\(a_1\\) 的象集 \\((B,C)_{a_1}\\) 包含了 \\(S\\) 在 \\((B,C)\\) 属性组上的投影，所以\n\\[ R \\div S = \\set{a_1} \\tag{31} \\] \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a) ( b ) ( c) 图11\u0026emsp;除运算举例\n下面再以学生—课程数据库（图6）为例，给出几个综合应用多种关系代数运算进行查询的例子。\n例10：查询1号课程和3号课程都选秀了的学生的号码。\n首先建立一个临时关系 \\(K\\) ：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Cno 1 3 K 图12\u0026emsp;临时关系 \\(\\text{K}\\)\n然后求\n\\[ \\Pi_{\\text{Sno},\\text{Cno}}(\\text{SC})\\div \\text{K} \\tag{32} \\] 结果为 \\(\\set{201215121}\\) 。\n求解过程与例9类似，先对 \\(\\text{SC}\\) 关系在 \\((\\text{Sno},\\text{Cno})\\) 属性上投影，然后逐一求出每 一学生（ \\(\\text{Sno}\\) ）的象集，并依次检查这些象集是否包含 \\(\\text{K}\\) 。\n例11：查询选修了 \\(2\\) 号课程的学生的学号。\n\\[ \\Pi_{\\text{Sno}}(\\sigma_{\\text{Cno}=\\text{'2'}}(\\text{SC}))=\\set{201215121,201215122} \\tag{33} \\] 例12：查询至少选修了一门其直接先行课为5号课程的学生姓名。\n\\[ \\Pi_{\\text{Sname}}(\\sigma_{\\text{Cpno}=\\text{'5'}}(\\text{Course})\\Join\\text{SC}\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student})) \\tag{34} \\] 或\n\\[ \\Pi_{\\text{Sname}}(\\Pi_{\\text{Sno}}(\\sigma_{\\text{Cpno}=\\text{'5'}}(\\text{Course})\\Join\\text{SC})\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student})) \\tag{35} \\] 例13：查询选修了全部课程的学生号码和姓名。\n\\[ \\Pi_{\\text{Sno},\\text{Cno}}(\\text{SC})\\div\\Pi_{\\text{Cno}}(\\text{Course})\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student}) \\tag{36} \\] 本节介绍了8种关系代数运算，其中并、差、Cartesian乘积、选择和投影这5种运算为基本的运算。其他三种运算，即交、连接和除，均可以用这5种基本运算来表达。引进它们并不增加语言的能力，但可以简化表达。\n关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。\n关系演算 关系演算是以数理逻辑中的谓词演算为基础的。按谓词变元的不同，关系演算可分为元组关系演算和域关系演算。本节先介绍元组关系演算，然后简单介绍域关系演算。\n元组关系演算语言ALPHA 元组关系演算以元组变量作为谓词变元的基本对象。一种典型的元组关系演算语言是E.F.Codd提出的ALPHA语言。这一语言虽然没有实际实现，但关系数据库管理系统INGRES最初所用的QUEL语言是参照ALPHA语言研制的，与ALPHA十分类似。ALPHA 语言主要有GET、PUT、HOLD、UPDATE、DELETE、DROP6条语句，语句的基本格式为\n1 操作语句 工作空间名 (表达式)：操作条件 其中表达式用于指定语句的操作对象，它可以是关系名或（和）属性名，一条语句可以同时操作多个关系或多个属性。操作条件是一个逻辑表达式，用于将操作结果限定在满足条件的元组中，操作条件可以为空。除此之外，还可以在基本格式的基础上加上排序要求以及指定返回元组的条数等。\n检索操作 检索操作用GET语句实现。\n1. 简单检索（即不带条件的检索）\n例14：查询所有被选修的课程号码。\n1 GET W (SC.Cno) W为工作空间名。这里条件为空，表示没有限定条件。\n例15：查询所有学生的数据。\n1 GET W (Student) 2. 限定的检索（即带条件的检索）\n例16：查询信息系(IS)中年龄小于20岁的学生的学号和年龄。\n1 GET W (Student.Sno,Student.Sage): Student.Sdept=\u0026#39;IS\u0026#39;∧Student.Sage\u0026lt;20 3. 带排序的检索\n例17：查询计算机科学系(CS)学生的学号、年龄，结果按年龄降序排序。\n1 GET W (Student.Sno,Student.Sage): Student.Sdept=\u0026#39;CS\u0026#39; DOWN Student.Sage DOWN表示降序排序。\n4. 指定返回元组的条数的检索\n例18：取出一个信息系学生的学号。\n1 GET W (1) (Student.Sno): Student.Sdept=\u0026#39;IS\u0026#39; 在W后括号中的数量就是指定的返回元组的个数。\n例19：查询信息系年龄最大的三个学生的学号及其年龄，结果按年龄降序排序。\n1 GET W (3) (Student.Sno,Student.Sage): Student.Sdept=\u0026#39;IS\u0026#39; DOWN Student.Sage 5. 用元组变量的检索\n前面已讲到，元组关系演算是以元组变量作为谓词变元的基本对象。元组变量是在某一关系范围内变化的，所以也称为范围变量(range variable)，一个关系可以设多个元组变量。\n元组变量主要有两方面的用途：\n(1) 简化关系名。如果关系的名字很长，使用起来就会感到不方便，这时可以设一个较短名字的元组变量来代替关系名。如例20。\n(2) 操作条件中使用量词时必须用元组变量。如例21至例23。\n例20：查询信息系学生的名字。\n1 2 RANGE Student X GET W (X.Sname): X.Sdept=\u0026#39;IS\u0026#39; ALPHA语言用RANGE来说明元组变量。本例中X是关系Student上的元组变量，用途是简化关系名，即用X代表Student。\n6. 用存在量词(existential qualifier)检索\n例21：查询选修2号课程的学生的名字。\n1 2 RANGE SC X GET W (Student.Sname): ∃X(X.Sno=Student.Sno∧X.Cno=\u0026#39;2\u0026#39;) 例22：查询选修了这样课程的学生学号，其直接先行课是6号课程。\n1 2 RANGE Course CX GET W (SC.Sno): ∃CX(CX.Cno=SC.Cno∧CX.Pcno=\u0026#39;6\u0026#39;) 例23：查询至少选修一门其先行课为6号课程的学生名字。\n1 2 3 4 RANGE Course CX SC SCX GET W (Student.Sname): ∃SCX(SCX.Sno=Student.Sno∧ ∃CX(CX.Cno=SCX.Cno∧CX.Pcno=\u0026#39;6\u0026#39;)) 在本例中的元组关系演算公式可以变换为前束范式(prenex normal form)‌的形式：\n1 2 GET W (StudentSname): ∃SCX∃CX(SCX.Sno=Student.Sno∧ CX.Cno=SCX.Cno∧CX.Pcno=\u0026#39;6\u0026#39;) 例21、例22、例23中的元组变量都是为存在量词而设的。其中例2.23需要对两个关系使用存在量词，所以设了两个元组变量。\n7. 带有多个关系表达式的检索\n上面所举的各个例子中，虽然查询时可能会涉及多个关系，即公式中可能涉及多个关系，但查询结果表达式中只有一个关系。实际上表达式中是可以有多个关系的。\n例24：查询成绩为90分以上的学生名字与课程名字。\n本查询所要求的结果是学生名字和课程名字，分别在Student和Course两个关系中。\n1 2 3 RANGE SC SCX GET W (Student.Sname,Course.Cname): ∃SCX(SCX.Grade⩾90∧ SCX.Sno=Student.Sno∧Course.Cno=SCX.Cno) 8. 用全称量词(generality quantifier)的检索\n例25：查询不选1号课程的学生名字。\n1 2 RANGE SC SCX GET W (Student.Sname): ∀SCX(SCX.Sno≠Student.Sno∨SCX.Cno≠\u0026#39;1\u0026#39;) 也可以用存在量词表示。\n1 2 RANGE SC SCX GET W (Student.Sname): ¬∃SCX(SCX.Sno=Student.Sno∧SCX.Cno=\u0026#39;1\u0026#39;) 9. 用两种量词的检索\n例26：查询选修了全部课程的学生姓名。\n1 2 3 RANGE Course CX SC SCX GET W (Student.Sname): ∀CX∃SCX(SCX.Sno=Student.Sno∧SCX.Cno=CX.Cno) 10. 用蕴涵(implication)的检索\n例27：查询最少选修了 201215122学生所选课程的学生学号。\n本例题的求解思路是，对Course中的所有课程依次检查每一门课程，看201215122是否选修了该课程，如果选修了，则再看某一个学生是否也选修了该门课。如果对于201215122所选的每门课程该学生都选修了，则该学生为满足要求的学生。把所有这样的学生全都找出来即完成了本题。\n1 2 3 4 5 RANGE Course CX SC SCX SC SCY GET W (Student.Sno): ∀CX(∃SCX(SCX.Sno=\u0026#39;201215122\u0026#39;∧SCX.Cno=CX.Cno) ⇒∃SCY(SCY.Sno=Student.Sno∧SCY.Cno=CX.Cno)) 蕴涵（⇒）见命题逻辑。\n11. 聚集函数\n用户在使用查询语言时经常要作一些简单的计算，例如要求符合某一查询要求的元组数，求某个关系中所有元组在某属性上的值的总和或平均值等。为了方便用户，关系数据语言中建立了有关这类运算的标准函数库供用户选用。这类函数通常称为聚集函数或内置函数（built-in function），关系演算中提供了COUNT、TOTAL、MAX、MIN、AVG等聚集函数，其含义如表6所示。\n函数名 功能 COUNT 对数据项计数 TOTAL 计算总和 MAX 查找最大值 MIN 查找最小值 AVG 计算平均值 表6\u0026emsp;关系演算中的聚集函数\n例28：查询学生所在系的数目。\n1 GET W (COUNT(Student.Sdept)) 例29：查询信息系学生的平均年龄。\n1 GET W (AVG(Student.Sage): Student.Sdept=\u0026#39;IS\u0026#39;) 更新操作 1. 修改操作\n(1) 首先用HOLD语句将要修改的元组从数据库中读到工作空间中： (2) 然后用宿主语言修改工作空间中元组的属性值。\n(3) 最后用UPDATE语句将修改后的元组送回数据库中。\n例30：把201215127学生从计算机科学系转到信息系。\n1 2 3 4 HOLD W (Student.Sno,Student Sdept): Student.Sno=\u0026#39;201215127\u0026#39; (从Student关系中读出201215127学生的数据) MOVE \u0026#39;IS\u0026#39; TO W.Sdept (用宿主语言进行修改) UPDATE W (把修改后的元组送回Student关系) 在该例中用HOLD语句来读201215127的数据，而不是用GET语句。如果修改操作涉及两个关系的话，就要执行两次HOLD-MOVE-UPDATE操作序列。\n在ALPHA语言中，修改关系主码的操作是不允许的，例如不能用UPDATE语句将学 号201215121改为201215122。如果需要修改主码值，只能先用删除操作删除该元组，然后再把具有新主码值的元组插入到关系中。\n2. 插入操作\n插入操作用PUT语句实现。其步骤是：\n(1) 首先用宿主语言在工作空间中建立新元组。\n(2) 然后用PUT语句把该元组存入指定的关系中。\n例31：学校新开设了一门2学分的课程\u0026quot;计算机组织与结构”，其课程号为8,直 接先行课为6号课程。插入该课程元组。\n1 2 3 4 5 MOVE \u0026#39;8\u0026#39; TO W.Cno MOVE \u0026#39;计算机组织与结构\u0026#39; TO W.Cname MOVE \u0026#39;6\u0026#39; TO W.Cpno MOVE \u0026#39;2\u0026#39; TO W.Ccredit PUT W (Course) (把W中的元组插入指定关系Course中) PUT语句只对一个关系操作，也就是说表达式必须为单个关系名。\n3. 删除操作\n删除操作用DELETE语句实现。其步骤为：\n(1) 用HOLD语句把要删除的元组从数据库中读到工作空间中。 (2) 用DELETE语句删除该元组。\n例32：201215230学生因故退学，删除该学生元组。\n1 2 HOLD W (Student): Student.Sno=\u0026#39;201215230\u0026#39; DELETE W 例33：将学号201215121改为 201215122。\n1 2 3 4 5 6 7 8 HOLD W (Student): Student.Sno=\u0026#39;201215121\u0026#39; DELETE W MOVE \u0026#39;201215122\u0026#39; TO W.Sno MOVE \u0026#39;李勇\u0026#39; TO W.Sname MOVE \u0026#39;男\u0026#39; TO W.Ssex MOVE \u0026#39;20\u0026#39; TO W.Sage MOVE \u0026#39;CS\u0026#39; TO W.Sdept PUT W (Student) 例34：删除全部学生。\n1 2 HOLD W (Student) DELETE W 由于SC关系与Student关系之间具有参照关系，为保证参照完整性，删除Student中元组时相应地要删除SC中的元组（手工删除或由数据库管理系统自动执行）：\n1 2 HOLD W (SC) DELETE W 元组关系演算 为了讨论方便，先允许关系（的基数）是无限的，然后再对这种情况下定义的演算做适当的修改，保证关系演算中各个公式表示的是有限关系。\n在元组关系演算系统中，称 \\(\\set{t|\\phi(t)}\\) 为元组演算表达式。其中， \\(t\\) 是元组变量， \\(\\phi(t)\\) 为元组关系演算公式，简称公式，它由原子公式和运算符组成。\n原子公式有以下三类：\n(1) \\(R(t)\\) 。 \\(R\\) 是关系名， \\(t\\) 是元组变量。 \\(R(t)\\) 表示 \\(t\\) 是 \\(R\\) 中的元组。于是，关系 \\(R\\) 可表示为 \\(\\set{t|R(t)}\\) 。\n(2) \\(t[i]\\theta u[j]\\) 。 \\(t\\) 和 \\(u\\) 是元组变量， \\(\\theta\\) 是算数比较运算符。 \\(t[i]\\theta u[j]\\) 表示断言“元组 \\(t\\) 的第 \\(i\\) 个分量与元组 \\(u\\) 的第 \\(j\\) 个分量满足比较关系 \\(\\theta\\) ”。例如， \\(t[2] \u003c u[3] \\) 表示元组 \\(t\\) 的第 \\(2\\) 个分量小于元组 \\(u\\) 的第 \\(3\\) 个分量。\n(3) \\(t[i]\\theta c\\) 或 \\(c\\theta t[i]\\) 。这里 \\(c\\) 是常量，该公式表示“ \\(t\\) 的第 \\(i\\) 个分量与常量 \\(c\\) 满足比较关系 \\(\\theta\\) ”。例如， \\(t[4]=3\\) 表示元组 \\(t\\) 的第 \\(4\\) 个分量等于 \\(3\\) 。\n在关系演算中定义了\u0026quot;自由元组变量”和\u0026quot;约束元组变量”的概念。这些概念和谓词演算中的概念完全一样。若公式中的一个元组变量前有“全称量词”或“存在量词\u0026quot;，则称该变量为约束元组变量，否则称自由元组变量。\n公式可以递归定义如下：\n(1) 每个原子公式是公式。\n(2) 如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 是公式，则 \\(\\phi_1\\land\\phi_2\\) 、 \\(\\phi_1\\lor\\phi_2\\) 、 \\(\\lnot\\phi_1\\) 是公式。\n①如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 同时为真，则 \\(\\phi_1\\land\\phi_2\\) 才为真，否则为假。\n②如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 中一个或同时为真，则 \\(\\phi_1\\lor\\phi_2\\) 为真，仅当 \\(\\phi_1\\) 和 \\(\\phi_2\\) 同时为假时， \\(\\phi_1\\lor\\phi_2\\) 才为假。\n③若 \\(\\phi_1\\) 为真，则 \\(\\lnot\\phi_1\\) 为假。\n(3) 若 \\(\\phi\\) 是公式，则 \\(\\exist t(\\phi)\\) 是公式，其中符号 \\(\\exist\\) 是全称量词符号， \\(\\exist t(\\phi)\\) 表示，如果对所有 \\(t\\) 都使 \\(\\phi\\) 为真，则 \\(\\exist t(\\phi)\\) 为真，否则 \\(\\exist t(\\phi)\\) 为假。\n(4) 若 \\(\\phi\\) 是公式，则 \\(\\forall t(\\phi)\\) 是公式，其中符号 \\(\\forall\\) 是全称量词符号， \\(\\forall t(\\phi)\\) 表示，如果对所有 \\(t\\) 都使 \\(\\phi\\) 为真，则 \\(\\forall t(\\phi)\\) 为真，否则 \\(\\forall t(\\phi)\\) 为假。\n(5) 在元组演算公式中，各种运算符的优先次序为：\n①算术比较运算符最高。\n②量词次之，且 \\(\\exist\\) 的优先级高于 \\(\\forall\\) 的优先级。\n③逻辑运算符最低，且 \\(\\lnot\\) 的优先级高于 \\(\\land\\) 的优先级， \\(\\land\\) 的优先级高于 \\(\\lor\\) 的优先级。\n④加括号时，括号中的运算符优先，同一括号内的运算符之优先级遵循①、②、③各项。\n(6) 有限次地使用上述5条规则得到的公式是元组关系演算公式，其他公式不是元组关系演算公式。\n一个元组演算表达式 \\(\\set{t|\\phi(t)}\\) 表示了使 \\(\\phi(t)\\) 真的元组集合。\n关系代数的运算均可以用关系演算表达式来表示（反之亦然）。下面用关系演算表达式来表示5种基本运算。\n(1) 并 \\[ R \\cup S = \\set{t|R(t) \\lor S(t)} \\tag{37} \\]\n(2) 差 \\[ R-S=\\set{t|R(t) \\land \\lnot S(t)} \\tag{38} \\]\n(3) Cartesian积 \\[ R\\times S=\\set{t^{(n+m)}|(\\exist u^{(n)})(\\exist v^{(m)})(R(u)\\land S(v) \\land (t[1]=u[1]) \\land \\cdots \\land (t[n]=u[n])\\\\[5pt] \\land (t[n+1]=v[1])\\land\\cdots\\land(t[n+m]\\land v[m]))} \\tag{39} \\] 这里 \\(t^{(n+m)}\\) 表示 \\(t\\) 的目数是 \\((n+m)\\) 。\n(4) 投影\n\\[ \\Pi_{i_1i_2\\cdots i_k}(R)=\\set{t^{(k)}|(\\exist u)(R(u)\\land(t[1]=u[i_1])\\land\\cdots\\land(t[k]=u[i_k]))} \\tag{40} \\] (5) 选择 \\[ \\sigma_F(R)=\\set{t|R(t)\\land F'} \\tag{41} \\] \\(F'\\) 是公式 \\(F\\) 用 \\(t[i]\\) 代替运算对象 \\(i\\) 得到的等价公式。\n下面用关系演算来对图6中的学生—课程数据库进行查询。\n例35：查询信息(IS)系全体学生。 \\[ S_{IS}=\\set{t|\\text{Student}(t)\\land (t[5]=\\text{'IS'})} \\tag{42} \\]\n例36：查询年龄小于 \\(20\\) 岁的学生。 \\[ S_{20}=\\set{t|\\text{Student}(t)\\land (t[4]\u003c20)} \\tag{43} \\]\n例37：查询学生的姓名和所在系。 \\[ S_1=\\set{t^{(2)}|(\\exist u)(\\text{Student}(u)\\land(t[1]=u[2])\\land(t[2]=u[5]))} \\tag{44} \\]\n上面的定义的关系演算允许出现无限关系。例如， \\(\\set{t|\\lnot R(t)}\\) 表示所有不属于 \\(R\\) 的元组（元组的目数等于 \\(R\\) 的目数）。要求出这些可能的元组是做不到的，所以必须排除这类无意义的表达式。把不产生无限关系的表达式称为安全表达式，所采取的措施称为安全限制。安全限制通常是定义一个有限的符号集 \\(\\text{dom}(\\phi)\\) ， \\(\\text{dom}(\\phi)\\) 一定包括出现在 \\(\\phi\\) 以及中间结果和最后结果的关系中的所有符号（实际上是各列中值的汇集）。 \\(\\text{dom}(\\phi)\\) 不必是最小集。\n当满足下列条件时，元组演算表达式 \\(\\set{t|\\phi(t)}\\) 是安全的：\n(1) 如果 \\(t\\) 使 \\(\\phi(t)\\) 为真，则 \\(t\\) 的每个分量是 \\(\\text{dom}(\\phi)\\) 中的元素。\n(2) 对于 \\(\\phi\\) 中每一个形如 \\((\\exist u)(W(u))\\) 的子表达式，若 \\(u\\) 使 \\(W(u)\\) 为真，则 \\(u\\) 的每个分量是 \\(\\text{dom}(\\phi)\\) 中的元素。\n(3) 对于 \\(\\phi\\) 中每一个形如 \\((\\forall u)(W(u))\\) 的子表达式，若 \\(u\\) 使 \\(W(u)\\) 为假，则 \\(u\\) 的每个分量必属于 \\(\\text{dom}(\\phi)\\) 。换言之，若 \\(u\\) 某一分量不属于 \\(\\text{dom}(\\phi)\\) ，则 \\(W(u)\\) 为真。\n例38：设有关系 \\(R\\) 如图13(a)所示， \\(S=\\set{t|\\lnot R(t)}\\) ，若不进行安全限制，则可能是一个无限关系。所以定义\n\\[ \\text{dom}(\\phi)=\\Pi_A(R)\\cup\\Pi_B(R)\\cup\\Pi_C(R)=\\set{\\set{a_1,a_2},\\set{b_1,b_2},\\set{c_1,c_2}} \\tag{45} \\] 则 \\(S\\) 是 \\(\\text{dom}(\\phi)\\) 中各阈值中元素的Cartesian积与 \\(R\\) 的差集。结果如图13(b)所示。注意，在做Cartesian积时各个域中的元素不能搞混。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a) ( b ) 图13\u0026emsp;关系演算安全限制示例\n域关系演算语言QBE 关系演算的另一种形式是域关系演算。域关系演算以元组变量的分量（即域变量）作为谓词变元的基本对象。1975年由M.M.Zloof提出的QBE就是一个很有特色的域关系演算语言，该语言于1978年在IBM370上得以实现。\nQBE是Query By Example（即通过例子进行查询）的简称，它最突出的特点是操作方式。它是一种高度非过程化的基于屏幕表格的查询语言，用户通过终端屏幕编辑程序，以填写表格的方式构造查询要求，而查询结果也是以表格形式显示，因此非常直观、易学易用。\nQBE中用示例元素来表示查询结果可能的情况，示例元素实质上就是域变量。QBE操作框架如图14所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 关系名 属性名 操作命令 元组属性值或查询条件 图14\u0026emsp;QBE操作框架\n下面以学生—课程数据库为例，说明QBE的用法。\n检索操作 1. 简单查询\n例39：求信息系全体学生的姓名。\n操作步骤为：\n①用户提出要求。\n②平面显示空白空格。\n\u0026zwnj; \u0026zwnj; ③用户在最左边一栏输入关系名Student。\nStudent \u0026zwnj; ④系统显示该关系的属性名。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; ⑤用户在上面构造查询要求\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; P.T IS 这里 \\(T\\) 是示例元素，即域变量。QBE要求示例元素下面一定要加下划线。IS是查询条件，不用加下划线。P.是操作符，表示打印(Print)，实际上是显示。\n查询条件中可以使用比较运算符 \\(\u003e\\)，\\(\\ge\\)，\\(\u003c\\)，\\(\\le\\)，\\(=\\) 和 \\(\\ne\\) ，其中 \\(=\\) 可以省略。\n示例元素是这个域中可能的一个值，它不必是查询结果中的元素。比如要求信息系的学生，只要给出任意的一个学生名即可，而不必真是信息系的某个学生名。\n对于例39，可如下构造查询要求：\nStudent Sno Sname Ssex Sage Sdept P.李勇 IS 这里的查询条件是 \\(\\text{Sdept}=\\text{'IS'}\\) ，其中“\\(=\\)”被省略。\n⑥屏幕显示查询结果。\nStudent Sno Sname Ssex Sage Sdept 张立 IS 即根据用户的查询要求求出了信息系的学生姓名。\n例40：查询全体学生的全部数据。\nStudent Sno Sname Ssex Sage Sdept P.201215121 P.李勇 P.男 P.20 P.CS 显示全部数据也可以简单地把P.操作符作用在关系名上。因此本查询也可以简单地表示如下：\nStudent Sno Sname Ssex Sage Sdept P. IS 2. 条件查询\n例41：求年龄大于19岁的学生的学号。\nStudent Sno Sname Ssex Sage Sdept P.201215121 \u003e19 例42：求计算机科学系年龄大于19岁的学生的学号。\n本查询的条件是 \\(\\text{Sdept}=\\text{'CS'}\\) ，和 \\(\\text{Sage\u003e19}\\) 两个条件的“与”。在QBE中，表示两个条件的“与”有两种方法：\n①把两个条件写在同一行上\nStudent Sno Sname Ssex Sage Sdept P.201215121 \u003e19 CS ②把两个条件写在不同行上，但是用相同的示例元素值。\nStudent Sno Sname Ssex Sage Sdept P.201215121 CS P.201215121 \u003e19 例43：查询计算机科学系或者年龄大于19岁的学生的学号。\n本查询的条件是 \\(\\text{Sdept}=\\text{'CS'}\\) ，和 \\(\\text{Sage\u003e19}\\) 两个条件的“或”。在QBE中把两个条件写在不同行上，并且使用不同的示例元素值，即表示条件的“或”。\nStudent Sno Sname Ssex Sage Sdept P.201215121 CS P.201215122 \u003e19 对于多行条件的查询，例42②和例43，先输入哪一行是任意的，不影响查询结果，这就允许用户以不同的思考方式进行查询，十分灵活、自由。\n例44：查询既选修了1号课程又选修了2号课程的学生的学号。\n本查询条件是在一个属性中的“与”关系，它只能用“与”条件的第②种方法表示，即写两行，但示例元素相同。\nSC Sno Cno Grade P.201215121 1 P.201215121 2 例45：查询选修1号课程的学生姓名。\n本查询涉及两个关系：SC和Student。在QBE中实现这种查询的方法是通过相同的连接属性值把多个关系连接起来。\nStudent Sno Sname Ssex Sage Sdept 201215121 P.李勇 SC Sno Cno Grade 201215121 1 这里示例元素 \\(\\text{Sno}\\) 是连接属性，其值在两个表中要相同。\n例46：查询未选修1号课程的学生姓名。\n这里的查询条件中用到逻辑非。在QBE中表示逻辑非的方法是将逻辑非写在关系名下面。\nStudent Sno Sname Ssex Sage Sdept 201215121 P.李勇 201215122 P.王勇 SC Sno Cno Grade \\(\\lnot\\) 201215121 1 \\(\\lnot\\) 201215122 注意除了该学生选的课程里没有1号课程，还有一种可能就是该学生什么课程都没有选修，因此还需要加上下面那一行查询条件。\n例47：查询有两个人以上选修的课程号。\n本查询是在一个表内连接。这个查询就是要显示这样的课程1，它不仅被201215121选修，而且也被另一个不是201215121学生（\\(\\lnot\\)201215121）选修了。\nSC Sno Cno Grade 201215121 P.1 \\(\\lnot\\)201215121 1 3. 聚集函数\n为了方便用户，QBE提供了一些聚集函数，主要包括CNT、SUM、AVG、MAX、MIN 等，其含义如表7所示。\n：查询信息系嘘声的平均年龄\n函数名 功能 CNT 对元组计数 SUM 求总和 AVG 求平均值 MAX 求最大值 MIN 求最小值 表7\n例48：查询信息系学生的平均年龄。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; P.AVG.ALL. IS 4. 对查询结果进行排序\n对查询结果按某个属性值的升序排序，只需在相应列中填入“AO.”，按降序排序则填“DO.”。如果按多列排序，用AO(i).或DO(i).表示，其中i为排序的优先级，i值越小，优先级越高。\n例49：查全体男生的姓名，要求查询结果按所在系升序排序，对相同系的学生按年龄降序排序。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; P.李勇 男 DO(2). AO(1). 更新操作 1. 修改操作\n修改操作符为“U.”。在QBE中关系的主码不允许修改，如需修改某个元组的主码，只能先删除该元组，然后再插入新的主码的元组。\n例50：把201215121学生的年龄改为18岁。\n这是一个简单修改操作，不包含算术表达式，因此可以有两种表示方法：\n①将操作符“U.”放在值上。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; 201215121 U.18 ②将操作符“U.”放在关系上。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj;U. 201215121 18 这里，码201215121标明要修改的元组。\u0026ldquo;U.\u0026ldquo;标明所在的行是修改后的新值。由于主码是不能修改的，所以即使在第二种写法中，系统也不会混淆要修改的属性。\n例51：把201215121学生的年龄增加1岁。\n这个修改操作涉及表达式，所以只能将操作符\u0026quot;U.\u0026ldquo;放在关系上。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; 201215121 17 U.\u0026zwnj; 201215121 17+1 例52将计算机科学系所有学生的年龄都增加一岁。\nStudent Sno Sname Ssex Sage Sdept \u0026zwnj; 201215128 18 CS U.\u0026zwnj; 201215128 18+1 2. 插入操作\n插入操作符为\u0026quot;I\u0026rdquo;。新插入的元组必须具有码值，其他属性值可以为空。\n例53：把信息系女生201215801，姓名张三，年龄17岁存入数据库中。\nStudent Sno Sname Ssex Sage Sdept I. 201215801 张三 女 17 IS 3. 删除操作\n删除操作符为“D.”。\n例54：删除学生201215189。\nStudent Sno Sname Ssex Sage Sdept D. 201215189 由于SC关系与Student关系之间具有参照关系，为保证参照完整性，删除201215189学生后，通常还应删除201215189学生选修的全部课程。\nSC Sno Cno Grade D. 201215189 无言是最大的轻蔑。 ― 刘慈欣, 《三体Ⅲ：死神永生》 ","date":"2024-10-24T15:31:25+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/database_system/relational_database_system/","title":"数据库系统（二）：关系数据库"},{"content":" 自然语言处理概论 本篇首先介绍了自然语言以及自然语言处理的基本概念，并总结了自然语言处理所面临的8个难点，即语言的抽象性、组合性、歧义性、进化性、非规范性、主观性、知识性及难移植性。正是由于这些难点的存在，导致自然语言处理任务纷繁复杂，并产生了多种划分方式，如按照任务层级，可以分为资源建设、基础任务、应用任务及应用系统四个层级；按照任务类型，可以分为回归、分类、匹配、解析及生成五大问题；按照研究对象的不同，可以分为形式、语义、推理及语用分析四个等级。从历史上看，自然语言处理经过了将近60年的发展，期间经历了理性主义和经验主义两大发展阶段。其中，经验主义又被分成了基于统计模型、深度学习模型及最新的预训练模型三个阶段，尤其是\u0026quot;预训练+精调\u0026quot;的方式，已成为自然语言处理的最新范式。\n自然语言处理的概念 自然语言通常指的是人类语言（本书特指文本符号，而非语音信号），是人类思维的载体和交流的基本工具，也是人类区别于动物的根本标志，更是人类智能发展的外在体现形式之一。自然语言处理（Natural Language Processing，简称NLP）‌主要研究用计算机理解和生成自然语言的各种理论和方法，属于人工智能领域的一个重要甚至核心分支，是计算机科学与语言学的交叉学科，又常被称为计算语言学(Computational Linguistics，简称CL）。随着互联网的快速发展，网络文本呈爆炸性增长，为自然语言处理提出了巨大的应用需求。同时，自然语言处理研究也为人们更深刻地理解语言的机理和社会的机制提供了一条重要的途径，因此具有重要的科学意义。\n目前，人们普遍认为人工智能的发展经历了从运算智能到感知智能，再到认知智能三个发展阶段。运算智能关注的是机器的基础运算和存储能力，在这方面，机器已经完胜人类。感知智能则强调机器的模式识别能力，如语音的识别以及图像的识别，目前机器在感知智能上的水平基本达到甚至超过了人类的水平。然而,在涉及自然语言处理以及常识建模和推理等研究的认知智能上，机器与人类还有很大的差距。\n自然语言处理的难点 为什么计算机在处理自然语言时会如此困难呢？这主要是因为自然语言具有高度的抽象性、近乎无穷变化的语义组合性、无处不在的歧义性和进化性，以及理解语言通常需要背景知识和推理能力等，下面分别进行具体的介绍。\n抽象性 语言是由抽象符号构成的，每个符号背后都对应着现实世界或人们头脑中的复杂概念，如\u0026quot;车”表示各种交通工具\u0026mdash;\u0026mdash;汽车、火车、自行车等，它们都具有共同的属性，有轮子、能载人或物等。\n组合性 每种语言的基本符号单元都是有限的，如英文仅有26个字母，中国国家标准GB2312《信息交换用汉字编码字符集•基本集》共收录6763个汉字，即便是常用的单词，英文和中文也不过各几十万个。然而，这些有限的符号却可以组合成无限的语义，即使是相同的词汇，由于顺序不同，组合的语义也是不相同的，因此无法使用穷举的方法实现对自然语言的理解。\n歧义性 歧义性主要是由于语言的形式和语义之间存在多对多的对应关系导致的，如:“苹果”一词，既可以指水果，也可以指一家公司或手机、电脑等电子设备，这就是典型的一词多义现象。另外，对于两个句子，如“曹雪芹写了红楼梦”和\u0026quot;红楼梦的作者是曹雪芹\u0026quot;，虽然它们的形式不同，但是语义是相同的。\n进化性 任何一种“活着\u0026quot;的语言都是在不断发展变化的，即语言具有明显的进化性，也称创造性。这主要体现在两方面：一方面是新词汇层出不穷，如\u0026quot;超女”“非典”\u0026ldquo;新冠\u0026quot;等；另一方面则体现在旧词汇被赋予新的含义，如\u0026quot;腐败\u0026rdquo;“杯具”等。除了词汇，语言的语法等也在不断变化，新的用法层出不穷。\n非规范性 在互联网上，尤其是在用户产生的内容中，经常有一些有意或无意造成的非规范文本，为自然语言处理带来了不小的挑战，如音近词（\u0026ldquo;为什么” \\(\\to\\) “为森么\u0026rdquo;，\u0026ldquo;怎么了” \\(\\to\\) \u0026ldquo;肿么了\u0026rdquo;）、单词的简写或变形（please \\(\\to\\) pls、cool \\(\\to\\) coooooooool）、新造词（“喜大普奔”“不明觉厉”）和错别字等。\n主观性 和感知智能问题不同，属于认知智能的自然语言处理问题往往具有一定的主观性，这不但提高了数据标注的难度，还为准确评价系统的表现带来了一定的困难。如在分词这一最基本的中文自然语言处理任务中，关于什么是\u0026quot;词”的定义都尚不明确，比如\u0026quot;打篮球\u0026quot;是一个词还是两个词呢？所以，在标注自然语言处理任务的数据时，往往需要对标注人员进行一定的培训，使得很难通过众包的方式招募大量的标注人员，导致自然语言处理任务的标注数据规模往往比图像识别、语音识别的标注数据规模要小得多。此外，由于不同的分词系统往往标准都不尽相同，所以通过准确率等客观指标对比不同的分词系统本身就是不客观的。难以评价的问题在人机对话等任务中体现得更为明显，由于对话回复的主观性，很难有一个所谓的标准回复，所以如何自动评价人机对话系统仍然是一个开放的问题。\n知识性 理解语言通常需要背景知识以及基于这些知识的推理能力。例如，针对句子\u0026quot;张三打了李四，然后他倒了\u0026rdquo;，问其中的\u0026quot;他\u0026quot;指代的是\u0026quot;张三\u0026quot;还是\u0026quot;李四”？只有具备了“被打的人更容易倒”这一知识，才能推出\u0026quot;他”很可能指代的是“李四”。而如果将\u0026quot;倒”替换为\u0026quot;笑”，则\u0026quot;他”很可能指代的是“张三”，因为“被打的人不太容易笑\u0026quot;。但是，如何表示、获取并利用这些知识呢？目前的自然语言处理技术并没有提供很好的答案。\n难移植性 由于自然语言处理涉及的任务和领域众多，并且它们之间的差异较大，造成了难移植性的问题。如下一节将要介绍的，自然语言处理任务根据层级可以分为分词、词性标注、句法分析和语义分析等基础任务，以及信息抽取、问答系统和对话系统等应用任务，由于这些任务的目标和数据各不相同，很难使用统一的技术或模型加以解决，因此不得不针对不同的任务设计不同的算法或训练不同的模型。另外，由于不同领域的用词以及表达方式不尽相同，因此在一个领域上学习的模型也很难应用于其他领域，这也给提高自然语言处理系统的可移植性带来了极大的困难。\n综上所述，由于自然语言处理面临的众多问题，使其成为目前制约人工智能取得更大突破和更广泛应用的瓶颈之一。因此自然语言处理又被誉为\u0026quot;人工智能皇冠上的明珠”，并吸引了越来越多的人工智能研究者加入。\n自然语言处理任务体系 任务层级 如前所述，自然语言处理的一大特点是涉及的任务众多。按照从低层到高层的方式，可以划分为资源建设、基础任务、应用任务和应用系统四大类。其中，资源建设主要包括两大类任务，即语言学知识库建设和语料库资源建设。所谓语言学知识库，一般包括词典、规则库等。词典(Dictionary)‌也称辞典(Thesaurus)，除了可以为词语提供音韵、句法或者语义解释以及示例等信息，还可以提供词语之间的关系信息，如上下位、同义反义关系等。语料库资源指的是面向某一自然语言处理任务所标注的数据。无论是语言学资源，还是语料库资源的建设，都是上层各种自然语言处理技术的基础，需要花费大量的人力和物力构建。基础任务包括分词、词性标注、句法分析和语义分析等，这些任务往往不直接面向终端用户，除了语言学上的研究价值，它们主要为上层应用任务提供所需的特征。应用任务包括信息抽取、情感分析、问答系统、机器翻译和对话系统等，它们往往可以作为产品直接被终端用户使用。本部分第2篇将对这些任务进行更详细的介绍。\n应用系统特指自然语言处理技术在某一领域的综合应用，又被称为NLP+，即自然语言处理技术加上特定的应用领域。如在智能教育领域，可以使用文本分类、回归等技术，实现主观试题的智能评阅，帮助教师减轻工作量，提高工作效率；在智慧医疗领域，自然语言处理技术可以帮助医生跟踪最新的医疗文献，帮助患者进行简单的自我诊断等；在智能司法领域，可以使用阅读理解、文本匹配等技术，实现自动量刑、类案检索和法条推荐等。总之，凡是涉及文本理解和生成的领域，自然语言处理技术都可以发挥巨大的作用。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用系 统 教 育 、 医 疗 、 司 法 、 金 融 、 机器人等 应用任务 信息抽 取 、 情感分 析 、 问答系 统 、 机器翻译和对话系统等 基础任务 分 词 、 词性标 注 、 句法分析和语义 分析等 资源建设 语言学知识库建设和语料资源建设 图1\u0026emsp;自然语言处理任务层级\n任务类别 虽然自然语言处理任务多种多样，刚涉足该领域的人可能会觉得眼花缭乱、 无从下手，但是这些复杂的任务基本上都可以归纳为回归、分类、匹配、解析或 生成五类问题中的一种。下面分别加以介绍：\n回归问题 即将输入文本映射为一个连续的数值，如对作文的打分，对案件刑期或罚款 金额的预测等。\n分类问题 又称为文本分类，即判断一个输入的文本所属的类别，如：在垃圾邮件识别任务中，可以将一封邮件分为正常和垃圾两类；在情感分析中，可以将用户的情感分为褒义、贬义或中性三类。\n匹配问题 判断两个输入文本之间的关系，如：它们之间是复述或非复述两类关系；或 者蕴含、矛盾和无关三类关系。另外，识别两个输入文本之间的相似性（0到1的数值）也属于匹配问题。\n解析问题 特指对文本中的词语进行标注或识别词语之间的关系，典型的解析问题包括 词性标注、句法分析等，另外还有很多问题，如分词、命名实体识别等也可以转化为解析问题。\n生成问题 特指根据输入（可以是文本，也可以是图片、表格等其他类型数据）生成一段自然语言，如机器翻译、文本摘要、图像描述生成等都是典型的文本生成类任务。\n研究对象与层次 此外此外，也可以通过对研究对象的区分，将自然语言处理研究分成多个层次的任务。自然语言处理主要涉及“名”“实”“知”“境”之间的关系，如图2所示。其中\u0026quot;名\u0026quot;指的是语言符号；“实”表示客观世界中存在的事实或人的主观世界中的概念；\u0026ldquo;知”是指知识，包括常识知识、世界知识和领域知识等；“境”则是指语言所处的环境。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 知 名 实 境 推理 （3） （2） 语义 （2） 语用 （1）形式 名：语言符号实：客观事实、主观意见知：知识境：语言所处的环境 (1)形式：名(2)语义：名+实(3)推理：名+实+知(4)语用：名+实+知+境 图2\u0026emsp;自然语言处理涉及的研究对象\n随着涉及的研究对象越来越多，自然语言处理的研究由浅入深，可以分为形式、语义、推理和语用四个层次。形式方面主要研究语言符号层面的处理，研究的是“名”与“名”之间的关系，如通过编辑距离等计算文本之间的相似度。语义方面主要研究语言符号和其背后所要表达的含义之间的关系，即“名\u0026quot;和\u0026quot;实”之间的关系，如“手机余额不足”和“电话欠费了”两个句子的表达方式完全不同,但是背后阐述的事实是相同的。语义问题也是自然语言处理领域目前主要关注的问题。推理是在语义研究的基础之上，进一步引入知识的运用，因此涉及“名”“实”和“知”之间关系，这一点正体现了自然语言的知识性。而语用则最为复杂,由于引入了语言所处的环境因素，通常表达的是“言外之意”和“弦外之音”，同时涉及了“名“”实”“知”“境”四个方面。例如，同样的一句话“你真讨厌”，从字面意义上明显是贬义，而如果是情侣之间的对话，则含义可能就不一样了。另外，语气、语调以及说话人的表情和动作也会影响其要表达的含义。\n自然语言处理技术发展历史 自然语言处理自诞生之日起经历了两大研究范式的转换，即理性主义和经验主义，如图3所示。受到语料规模以及计算能力的限制，早期的自然语言处理主要采用基于理性主义的规则方法，通过专家总结的符号逻辑知识处理通用的自然语言现象。然而，由于自然语言的复杂性，基于理性主义的规则方法在面对实际应用场景中的问题时显得力不从心。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 小规模专家知识（理性主义）20世纪50年代—20世纪90年代 大规模语料库统计模型（经验主义）20世纪50年代—21世纪初 大规模语料库深度学习（经验主义）2010年-2017年 大规模预训练语言模型（经验主义）2018年至今 图3\u0026emsp;自然语言处理技术发展阶段\n从20世纪90年代开始，随着计算机运算速度和存储容量的快速增加，以及 统计学习方法的愈发成熟，使得以语料库为核心的统计学习方法在自然语言处理领域得以大规模应用。由于大规模的语料库中包含了大量关于语言的知识，使得基于语料库的统计自然语言处理方法能够更加客观、准确和细致地捕获语言规律。在这一时期，词法分析、句法分析、信息抽取、机器翻译和自动问答等领域的研究均取得了一定程度的成功。\n尽管基于统计学习的自然语言处理取得了一定程度的成功，但它也有明显的局限性，也就是需要事先利用经验性规则将原始的自然语言输入转化为机器能够处理的向量形式。这一转化过程（也称为特征提取）需要细致的人工操作和一定的专业知识，因此也被称为特征工程。\n2010年之后，随着基于深度神经网络的表示学习方法（也称深度学习）的兴起，该方法直接端到端地学习各种自然语言处理任务，不再依赖人工设计的特征。所谓表示学习，是指机器能根据输入自动地发现可以用于识别或分类等任务的表示。具体地，深度学习模型在结构上通常包含多层的处理层。底层的处理层接收原始输入，然后对其进行抽象处理，其后的每一层都在前一层的结果上进行更深层次的抽象，最后一层的抽象结果即为输入的一个表示，用于最终的目标任务。其中的抽象处理，是由模型内部的参数进行控制的，而参数的更新值则是根据训练数据上模型的表现，使用反向传播算法学习得到的。由此可以看出，深度学习可以有效地避免统计学习方法中的人工特征提取操作，自动地发现对于目标任务有效的表示。在语音识别、计算机视觉等领域，深度学习已经取得了目前最好的效果，在自然语言处理领域，深度学习同样引发了一系列的变革。\n除了可以自动地发现有效特征，表示学习方法的另一个好处是打通了不同任 务之间的壁垒。传统统计学习方法需要针对不同的任务设计不同的特征，这些特征往往是无法通用的。而表示学习能够将不同任务在相同的向量空间内进行表示,从而具备跨任务迁移的能力。除了可以跨任务，还可以实现跨语言甚至跨模态的迁移。综合利用多项任务、多种语言和多个模态的数据，使得人工智能向更通用的方向迈进了一步。\n同样，得益于深度学习技术的快速发展，自然语言处理的另一个主要研究方 向——自然语言生成也取得了长足进步。长期以来，自然语言生成的研究几乎处于停滞状态，除了使用模板生成一些简单的语句，并没有什么太有效的解决办法。随着基于深度学习的序列到序列生成框架的提出，这种逐词的文本生成方法全面提升了生成技术的灵活性和实用性，完全革新了机器翻译、文本摘要和人机对话等任务的技术范式。\n虽然深度学习技术大幅提高了自然语言处理系统的准确率，但是基于深度学 习的算法有一个致命的缺点，就是过度依赖于大规模有标注数据。对于语音识别、图像处理等感知类任务，标注数据相对容易获得，如：在图像处理领域，人们已经为上百万幅的图像标注了相应的类别（如Image Net数据集）；用于语音识别的“语音—文本”平行语料库也有几十万小时。然而，由于自然语言处理这一认知类任务所具有的\u0026quot;主观性”特点，以及其所面对的任务和领域众多，使得标注大规模语料库的时间过长，人力成本过于高昂，因此自然语言处理的标注数据往往不够充足，很难满足深度学习模型训练的需要。\n早期的静态词向量预训练模型，以及后来的动态词向量预训练模型，特别是 2018年以来，以BERT、GPT为代表的超大规模预训练语言模型恰好弥补了自然语言处理标注数据不足的缺点，帮助自然语言处理取得了一系列的突破，使得包括阅读理解在内的所有自然语言处理任务的性能都得到了大幅提高，在有些数据 集上达到或甚至超过了人类水平。\n所谓模型预训练（Pre-train），即首先在一个原任务上预先训练一个初始模型，然后在下游任务（也称目标任务）上继续对该模型进行精调（Fine-tune），从而达到提高下游任务准确率的目的。在本质上，这也是迁移学习(Transfer Learning)‌思想的一种应用。然而，由于同样需要人工标注，导致原任务标注数据的规模往往也非常有限。那么，如何获得更大规模的标注数据呢？\n其实，文本自身的顺序性就是一种天然的标注数据，通过若干连续出现的词 语预测下一个词语（又称语言模型）就可以构成一项原任务。由于图书、网页等文本数据规模近乎无限，所以，可以非常容易地获得超大规模的预训练数据。有人将这种不需要人工标注数据的预训练学习方法称为无监督学习(Unsupervised Learning)，其实这并不准确，因为学习的过程仍然是有监督的(Supervised)，更准确的叫法应该是自监督学习（Self-supervised Learning）。\n为了能够刻画大规模数据中复杂的语言现象，还要求所使用的深度学习模型 容量足够大。基于自注意力的Transformer模型显著地提升了对于自然语言的建模能力，是近年来具有里程碑意义的进展之一。要想在可容忍的时间内，在如此大规模的数据上训练一个超大规模的Transformer模型，也离不开以GPU、TPU为代表的现代并行计算硬件。可以说，超大规模预训练语言模型完全依赖“蛮力”，在大数据、大模型和大算力的加持下，使自然语言处理取得了长足的进步。如OpenAI推出的GPT-3，是一个具有1750亿个参数的巨大规模，无须接受任何特定任务的训练，便可以通过小样本学习完成十余种文本生成任务，如问答、风格迁移、网页生成和自动编曲等。目前，预训练模型已经成为自然语言处理的新范式。\n\u0026emsp;\u0026emsp;你们要努力进窄门，因为宽门和阔路引向沉沦，进去的人很多；然而窄门和狭道却通向永生，只有少数人能找到。 ― 安德烈·纪德, 《窄门》 ","date":"2024-10-15T19:05:40+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/artificial_intelligence/natural_language_processing/introduction_to_natural_language_processing/","title":"自然语言处理（一）：自然语言处理概论"},{"content":" 数据库系统概论 数据库是数据管理的有效技术，是计算机科学的重要分支。今天，信息资源已成为各个部门的重要财富和资源。建立一个满足各级部门信息处理要求的行，之有效的信息系统也成为一个企业或组织生存和发展的重要条件。因此，作为信息系统核心和基础的数据库技术得到越来越广泛的应用，从小型单项事务处理系统到大型信息系统，从联机事务处理（On-Line Transaction Processing，OLTP）到联机分析处理（On-Line Analysis Processing，OLAP），从一般企业管理到计算机辅助设计与制造（CAD/CAM）、计算机集成制造系统(CIMS)、电子政务（e-Government）、电子商务（e-Commerce）、地理信息系统(GIS)等，越来越多的应用领域采用数据库技术来存储和处理信息资源。特别是随着互联网的发展，广大用户可以直接访问并使用数据库，例如通过网上订购图书、日用品、机票、火车票，通过网上银行转账存款取款、检索和管理赈户，等等。数据库已经成为每个人生活中不可缺少的部分。\n数据库系统概述 在系统地介绍数据库的基本概念之前，这里首先介绍一些数据库最常用的术语和基本概念。\n数据库的四个基本概念 数据、数据库、数据库管理系统和数据库系统是与数据库技术密切相关的4个基本概念。\n数据(Data) 数据是数据库中存储的基本对象。数据在大多数人头脑中的第一个反应就是数字，例如93、1000、99.5、-330.86、¥6880、$726等。其实数字只是最简单的一种数据，是数据的一种传统和狭义的理解。广义的理解认为数据的种类很多，例如文本(text)、图形(graph)、图像(image)、音频(audio)、视频(video)、学生的档案记录、货物的运输情况等，这些都是数据。\n可以对数据做如下定义：描述事物的符号记录称为数据。描述事物的符号可以是数字，也可以是文字、图形、图像、音频、视频等。数据有多种表现形式，它们都可以经过数字化后存入计算机。\n在现代计算机系统中数据的概念是广义的。早期的计算机系统主要用于科学计算，处理的数据是数值型数据，如整数、实数、浮点数等。现在计算机存储和处理的对象十分广泛，表示这些对象的数据也随之变得越来越复杂。\n数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的。例如，93是一个数据，可以是一个同学某门课的成绩，也可以是某个人的体重，还可以是计算机系2013级的学生人数。数据的解释是指对数据含义的说明，数据的含义称为数据的语义，数据与其语义是不可分的。\n在日常生活中，人们可以直接用自然语言（如汉语）来描述事物。例如，可以这样来描述某校计算机系一位同学的基本情况：李明同学，男，1995年5月生，江苏省南京市人，2013年入学。在计算机中常常这样来描述：\n（李明，男，199505，江苏省南京市，计算机系，2013）\n即把学生的姓名、性别、出生年月、出生地、所在院系、入学时间等组织在一起，构成一个记录。这里的学生记录就是描述学生的数据。这样的数据是有结构的。记录是计算机中表示和存储数据的一种格式或一种方法。\n数据库(DataBase,DB) 数据库，顾名思义，是存放数据的仓库。只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的。\n人们收集并抽取出一个应用所需要的大量数据之后，应将其保存起来，以供进一步加工处理，抽取有用信息。在科学技术飞速发展的今天，人们的视野越来越广，数据量急剧增加。过去人们把数据存放在文件柜里，现在人们借助计算机和数据库技术科学地保存和管理大量复杂的数据，以便能方便而充分地利用这些宝贵的信息资源。\n严格地讲，数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度(redundancy)、较高的数据独立性(data independency)和易扩展性(scalability)，并可为各种用户共享。\n概括地讲，数据库数据具有永久存储、有组织和可共享三个基本特点。\n数据库管理系统(DataBase Management System,DBMS) 了解了数据和数据库的概念，下一个问题就是如何科学地组织和存储数据，如何高效地获取和维护数据。完成这个任务的是一个系统软件\u0026mdash;\u0026mdash;数据库管理系统。数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面：\n1. 数据定义功能\n数据库管理系统提供数据定义语言(Data Definition Language,DDL)，用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。\n2. 数据组织、存储和管理\n数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、hash查找、顺序查找等）来提高存取效率。\n3. 数据操纵功能\n数据库管理系统还提供数据操纵语言(Data Manipulation Language,DML)，用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。\n4. 数据库的事务管理和运行管理\n数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。\n5. 数据库的建立和维护功能\n数据库的建立和维护功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。这些功能通常是由一些实用程序或管理工具完成的。\n6. 其他功能\n其他功能包括数据库管理系统与网络中其他软件系统的通信功能，一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能，异构数据库之间的互访和互操作功能等。\n数据库系统 数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员(DataBase Administrator,DBA)组成的存储、管理、处理和维护数据的系统。应当指出的是，数据库的建立、使用和维护等工作只靠一个数据库管理系统远远不够，还要有专门的人员来完成，这些人被称为数据库管理员。\n数据库系统可以用图1表示。其中数据库提供数据的存储功能，数据库管理系统提供数据的组织、存取、管理和维护等基础功能，数据库应用系统根据应用需求使用数据库，数据库管理员负责全面管理数据库系统。图2是引入数据库后计算机系统的层次结构。\n在一般不引起混淆的情况下，人们常常把数据库系统简称为数据库。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 用户 ··· 用户 用户 用户 ··· 用户 数据库管理系统 数据库管理系统 应用开发工具 应用开发工具 应用系统 应用系统 操作系统 操作系统 数据库 数据库 数据库管理员 数据库管理员 图1\u0026emsp;数据库系统\n‌\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 操 作 系 统 硬件 数 据 库 管 理 系 统 应 用 开 发 工 具 应 用 系 统 图2\u0026emsp;引入数据库后计算机系统的层次结构\n数据管理技术的产生和发展 数据库技术是应数据管理任务的需要而产生的。数据管理是指对数据进行分类、组织、编码、存储、检索和维护，它是数据处理的中心问题。而数据的处理是指对各种数据进行收集、存储、加工和传播的一系列活动的总和。\n在应用需求的推动下，在计算机硬件、软件发展的基础上，数据管理技术经历了人工管理、文件系统、数据库系统三个阶段。这三个阶段的特点及其比较如下表所示。\n人工管理阶段 文件系统阶段 数据库系统阶段 背景 应用背景 科学计算 科学计算、数据管理 大规模数据管理 硬件背景 无直接存储设备 磁盘、磁鼓 大容量磁盘、磁盘阵列 软件背景 没有操作系统 有文件系统 有数据库管理系统 处理方式 批处理 联机实时处理、批处理 联机实时处理、分布处理、批处理 特点 数据的管理者 用户（程序员） 文件系统 数据库管理系统 数据面向的对象 某一应用程序 某一应用 现实世界（一个部门、企业、跨国组织等） 数据的共享程度 无共享，冗余度极大 共享性差，冗余度大 共享性高，冗余度小 数据的独立性 不独立，完全依赖于程序 独立性差 具有高度的物理独立性和一定的逻辑独立性 数据的结构化 无结构 记录内有结构，整体无结构 整体结构化，用数据模型描述 数据控制能力 应用程序自己控制 应用程序自己控制 由数据库管理系统提供数据安全性、完整性，并发控制和恢复能力 表1\u0026emsp;数据管理三个阶段的比较\n人工管理阶段 20世纪50年代中期以前，计算机主要用于科学计算。当时的硬件状况是，外存只有纸带、卡片、磁带，没有磁盘等直接存取的存储设备；软件状况是，没有操作系统，没有管理数据的专门软件；数据处理方式是批处理。人工管理数据具有如下特点：\n1. 数据不保存\n由于当时计算机主要用于科学计算，一般不需要将数据长期保存，只是在计算某一课题时将数据输入，用完就撤走。不仅对用户数据如此处置，对系统软件有时也是这样。\n2. 应用程序管理数据\n数据需要由应用程序自己设计、说明（定义）和管理，没有相应的软件系统负责数据的管理工作。应用程序中不仅要规定数据的逻辑结构，而且要设计物理结构，包括存储结构、存取方法、输入方式等。因此程序员负担很重。\n3. 数据不共享\n数据是面向应用程序的，一组数据只能对应一个程序。当多个应用程序涉及某些相同的数据时必须各自定义，无法互相利用、互相参照，因此程序与程序之间有大量的冗余数据。\n4. 数据不具有独立性\n数据的逻辑结构或物理结构发生变化后，必须对应用程序做相应的修改，数据完全依赖于应用程序，称之为数据缺乏独立性，这就加重了程序员的负担。\n在人工管理阶段，应用程序与数据之间的一一对应关系可用下图表示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用程序1 数据集1 应用程序2 数据集2 应用程序n 数据集n 图3\u0026emsp;人工管理阶段应用程序与数据之间的一一对应关系\n文件系统阶段 20世纪50年代后期到60年代中期，这时硬件方面已有了磁盘、磁鼓等直接存取存储设备：软件方面，操作系统中已经有了专门的数据管理软件，一般称为文件系统；处理方式上不仅有了批处理，而且能够联机实时处理。\n用文件系统管理数据具有如下特点：\n1. 数据可以长期保存\n由于计算机大量用于数据处理，数据需要长期保留在外存上反复进行查询、修改、插入和删除等操作。\n2. 由文件系统管理数据\n由专门的软件即文件系统进行数据管理，文件系统把数据组织成相互独立的数据文件，利用“按文件名访问，按记录进行存取”的管理技术，提供了对文件进行打开与关闭、对记录读取和写入等存取方式。文件系统实现了记录内的结构性。但是，文件系统仍存在以下缺点：\n(1) 数据共享性差，冗余度大。在文件系统中，一个(或一组)文件基本上对应于一个应用程序，即文件仍然是面向应用的。当不同的应用程序具有部分相同的数据时，也必须建立各自的文件，而不能共享相同的数据，因此数据的冗余度大，浪费存储空间。同时由于相同数据的重复存储、各自管理，容易造成数据的不一致性，给数据的修改和维护带来了困难。\n(2) 数据独立性差。文件系统中的文件是为某一特定应用服务的，文件的逻辑结构是针对具体的应用来设计和优化的，因此要想对文件中的数据再增加一些新的应用会很困难。而且，当数据的逻辑结构改变时，应用程序中文件结构的定义必须修改，应用程序中对数据的使用也要改变，因此数据依赖于应用程序，缺乏独立性。可见，文件系统仍然是一个不具有弹性的无整体结构的数据集合，即文件之间是孤立的，不能反映现实世界事物之间的内在联系。\n文件系统阶段应用程序与数据之间的关系如下图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用程序1 应用程序2 应用程序n 文件组1 文件组2 文件组n 存取 方法 图4\u0026emsp;文件系统阶段应用程序与数据之间的对应关系\n数据库系统阶段 20世纪60年代后期以来，计算机管理的对象规模越来越大，应用范围越来越广泛，数据量急剧增长，同时多种应用、多种语言互相覆盖地共享数据集合的要求越来越强烈。\n这时硬件已有大容量磁盘，硬件价格下降；软件则价格上升，为编制和维护系统软件及应用程序所需的成本相对增加；在处理方式上，联机实时处理要求更多，并开始提出和考虑分布处理。在这种背景下，以文件系统作为数据管理手段已经不能满足应用的需求，于是为解决多用户、多应用共享数据的需求，使数据为尽可能多的应用服务，数据库技术便应运而生，出现了统一管理数据的专门软件系统\u0026mdash;\u0026mdash;数据库管理系统。\n用数据库系统来管理数据比文件系统具有明显的优点，从文件系统到数据库系统标志着数据管理技术的飞跃。\n数据库系统的特点 下面首先通过一个简单的例子\u0026mdash;\u0026ndash;学生学籍管理系统来比较文件系统和数据库系统的差异，从而阐述数据库系统的特点。\n例1：设一个学生的信息包括学号、姓名、性别、年龄、专业和奖励。部分学生的情况如表2所示。假设该学籍管理系统具有录入学生信息、根据学号可以找到一个学生信息等功能。\n学号 姓名 性别 年龄 专业 奖励 20100001 史玉明 女 20 计算机 2011校奖学金，2012国家奖学金 20100100 李明虎 男 21 机械 2012校优秀学生 20100234 张翔 男 21 化工 ··· ··· ··· ··· ··· ··· 表2\u0026emsp;学生一览表\n1. 采用文件系统实现学籍管理\n首先是如何存储学生数据。计算机操作系统实现了文件系统，可以把每个学生都具备的信息采用定长记录方式存放在一个“学生基本信息”文件中。有关奖励的数据有的学生较多，有的学生没有，因此采用变长记录方式把它存放在另外一个“奖励”文件中。“学生基本信息”文件的记录包括学号、姓名、性别、年龄、专业、位置和长度等字段，如表3所示。其中位置和长度描述的是另一个奖励文件（表4所示）中记录的开始位置和长度。文件系统管理的文件是流式文件，或者说只是一些字节流。因此，表3和表4是为了方便程序员理解的结构。程序员必须把它们在应用程序中加以说明和描述。\n学号 姓名 性别 年龄 专业 位置 长度 20100001 史玉明 女 20 计算机 0 30 20100100 李明虎 男 21 机械 30 15 20100234 张翔 男 21 化工 45 0 ··· ··· ··· ··· ··· ··· ··· 表3\u0026emsp;“学生基本信息”文件的结构和内容\n奖励 2011 校奖学金，2012 国家奖学金 2012 校优秀学生 ··· 表4\u0026emsp;“奖励”文件的结构内容\n确定了学生数据的存储方式后，需要编写程序来实现数据的录入功能和查询功能。录入功能的基本过程包括从键盘读入学生信息，把基本信息写到\u0026quot;学生基本信息”文件中，把奖励情况写到“奖励”文件中。特别要注意的是，为了能正确地表达“学生基本信息”文件中一条记录和“奖励”文件中记录的对应关系，在程序中要把奖励情况在文件中的开始位置和长度再写回\u0026quot;学生基本信息”文件中。\n查询功能采用顺序查找方法。首先从“学生基本信息”文件中读入第1条记录，然后比较学号字段的值是否和要查找的学号相同。如果相同，读出该学生的信息，并根据位置字段和长度字段的值到“奖励”文件中读出该学生的奖励信息，查找过程结束；如果不相同，则从“学生基本信息”文件中读入下一条记录，直到找到该学号的记录，或者读到文件末尾也没有该学号的学生为止。\n2. 采用数据库系统实现学籍管理\n首先在数据库中建立两张表：STUDENT存放学生的基本信息，AWARD存放学生的奖励情况。这可以用数据库管理系统的两条CREATE语句来实现：\n1 2 3 4 5 6 7 CREATE TABLE STUDENT( Sno CHAR(8), Sname CHAR(10), Ssex CHAR(2), Sage SMALLINT, Major CHAR(20)); CREATE TABLE AWARD( Sno CHAR(8), Details VARCHAR(2000)); 建立好表结构后，向数据库管理系统提交下面的两条插入命令就可以把学生的基本信 息和奖励情况保存到STUDENT和AWARD表中，完成录入功能。\n1 2 3 4 INSERT INTO STUDENT(Sno, Sname, Ssex,Sage, Major) VALUES(\u0026#39;2O1OOOO1\u0026#39;,\u0026#39;史玉明\u0026#39;,\u0026#39;女\u0026#39;,20,\u0026#39;计算机\u0026#39;) /*插入学生的基本信息*/ INSERT INTO AWARD(Sno, Deteils) VALUES(\u0026#39;20100001\u0026#39;,\u0026#39;2011校奖学金，2012国家奖学金\u0026#39;) /*插入学生获得的奖励*/ 查询功能可用一条查询语句实现：\n1 2 3 SELECT A.Sno, Sname, Ssex, Sage, Major, Details /*查询学号为20100001 学生的信息*/ FROM STUDENT A LEFT JOIN AWARD B ON A.Sno=B.Sno WHERE A.Sno = \u0026#39;20100001\u0026#39; 可以看出，无论采用文件系统还是数据库系统都可以实现本例中学籍管理的功能。但是，使用文件系统时，程序员要关注记录的结构和不同文件中记录之间的联系，使用文件系统提供的fopen（打开）、fread（读）、fwrite（写）、fseek（移动读写位置）、fclose（关闭）等操作来编程，工作量大、编程复杂，且开发速度慢；而数据库系统提供了功能强大的操作，如查询操作只需要写一条语句就可以实现，程序员的开发效率大大提高。\n与人工管理和文件系统相比，数据库系统的特点主要有一下几个方面。\n数据结构化 数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。\n在文件系统中，文件中的记录内部具有结构，但是记录的结构和记录之间的联系被固化在程序中，需要由程序员加以维护。这种工作模式既加重了程序员的负担，又不利于结构的变动。\n所谓“整体”结构化是指数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业：不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。也就是说，不仅要考虑某个应用的数据结构，还要考虑整个组织的数据结构。例如，一个学校的信息系统中不仅要考虑教务处的课程管理、学生选课管理、成绩管理，还要考虑学生处的学生学籍管理，同时还要考虑研究生院的研究生管理、人事处的教员人事管理、科研处的科研管理等。因此，学校信息系统中的学生数据就要面向各个处室的应用，而不仅仅是教务处的一个学生选课应用。可以参照下图为该校的信息系统组织其中的学生数据。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 日期 奖惩条目 姓名 与本人关系 详细情况 课程号 课程名称 家庭出身 籍贯 政治面貌 日期 学校 学历名 学号 课程号 学期 成绩 学号 姓名 性别 年龄 系 学生人事记录 奖惩情况记录 家庭成员记录 课程记录 学生学籍记录 学生选课记录 图5\u0026emsp;某学校信息系统中的学生数据\n图5的数据组织方式为各部门的应用提供了必要的记录，使整体数据结构化了。这就要求在描述数据时不仅要描述数据本身，还要描述数据之间的联系。在数据库系统中，记录的结构和记录之间的联系由数据库管理系统维护，从而减轻了程序员的工作量，提高了工作效率。\n在数据库系统中，不仅数据是整体结构化的，而且存取数据的方式也很灵活，可以存取数据库中的某一个或一组数据项、一个记录或一组记录；而在文件系统中，数据的存取单位是记录，粒度不能细到数据项。\n数据的共享性高、冗余度低且易扩充 数据库系统从整体角度看待和描述数据，数据不再面向某个应用而是面向整个系统，因此数据可以被多个用户、多个应用共享使用。数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。\n所谓数据的不一致性是指同一数据不同副本的值不一样。采用人工管理或文件系统管理时，由于数据被重复存储，当不同的应用使用和修改不同的副本时就很容易造成数据的不一致。在数据库中数据共享减少了由于数据冗余造成的不一致现象。\n由于数据面向整个系统，是有结构的数据，不仅可以被多个应用共享使用，而且容易增加新的应用，这就使得数据库系统弹性大，易于扩充，可以适应各种用户的要求。可以选取整体数据的各种子集用于不同的应用系统，当应用需求改变或增加时，只要重新选取不同的子集或加上一部分数据便可以满足新的需求。\n数据独立性高 数据独立性是借助数据库管理数据的一个显著优点，它已成为数据库领域中一个常用术语和重要概念，包括数据的物理独立性和逻辑独立性。\n物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是说，数据在数据库中怎样存储是由数据库管理系统管理的，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变时应用程序不用改变。\n逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。也就是说，数据的逻辑结构改变时用户程序也可以不变。\n数据独立性是由数据库管理系统提供的二级映像功能来保证的，将在后面的内容中进行讨论。\n数据与程序的独立把数据的定义从程序中分离出去，加上存取数据的方法又由数据库管理系统负责提供，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n数据由数据库管理系统统一管理和控制 数据库的共享将会带来数据库的安全隐患，而数据库的共享是并发的(concurrency)‌共享，即多个用户可以同时存取数据库中的数据，甚至可以同时存取数据库中同一个数据，这又会带来不同用户间相互干扰的隐患。另外，数据库中数据的正确与一致也必须得到保障。为此，数据库管理系统还必须提供以下几方面的数据控制功能。\n(1) 数据的安全性(security)保护。数据的安全性是指保护数据以防止不合法使用造成的数据泄密和破坏。每个用户只能按规定对某些数据以某些方式进行使用和处理。\n(2) 数据的完整性(integrity)检查。数据的完整性指数据的正确性、有效性和相容性。完整性检查将数据控制在有效的范围内，并保证数据之间满足一定的关系。\n(3) 并发(concurrency)控制。当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果或使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。\n(4) 数据库恢复(recovery)。计算机系统的硬件故障、软件故障、操作员的失误以及故意破坏也会影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失。数据库管理系统必须具有将数据库从错误状态恢复到某一己知的正确状态（亦称为完整状态或一致状态）的功能，这就是数据库的恢复功能。\n数据库系统阶段应用程序与数据之间的对应关系可用图6表示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据库 管理系统 数据库 管理系统 应用程序1 应用程序1 应用程序2 应用程序2 数据库 数据库 图6\u0026emsp;数据库系统阶段应用程序与数据之间的对应关系\n综上所述，数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。\n数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段。这样既便于数据的集中管理，又能简化应用程序的研制和维护，提高了数据的利用率和相容性，提高了决策的可靠性。\n目前，数据库已经成为现代信息系统的重要组成部分。具有数百G、数百T、甚至数百P字节的数据库已经普遍存在于科学技术、工业、农业、商业、服务业和政府部门的信息系统中。\n数据模型 数据库技术是计算机领域中发展最快的技术之一。数据库技术的发展是沿着数据模型的主线推进的。模型，特别是具体模型对人们来说并不陌生。一张地图、一组建筑设计沙盘、一架精致的航模飞机都是具体的模型，一眼望去就会使人联想到真实生活中的事物。模型是对现实世界中某个对象特征的模拟和抽象。例如，航模飞机是对生活中飞机的一种模拟和抽象，它可以模拟飞机的起飞、飞行和降落，它抽象了飞机的基本特征——机头、机身、机翼、机尾。\n数据模型(data model)‌也是一种模型，它是对现实世界数据特征的抽象。也就是说数据模型是用来描述数据、组织数据和对数据进行操作的。由于计算机不可能直接处理现实世界中的具体事物，所以人们必须事先把具体事物转换成计算机能够处理的数据，也就是首先要数字化，把现实世界中具体的人、物、活动、概念用数据模型这个工具来抽象、表示和处理。通俗地讲，数据模型就是现实世界的模拟。\n现有的数据库系统均是基于某种数据模型的。数据模型是数据库系统的核心和基础。因此，了解数据模型的基本概念是学习数据库的基础。\n两类数据模型 数据模型应满足三方面要求：一是能比较真实地模拟现实世界，二是容易为人所理解，三是便于在计算机上实现。一种数据模型要很好地、全面地满足这三方面的要求在目前尚很困难。因此，在数据库系统中针对不同的使用对象和应用目的，采用不同的数据模型。\n如同在建筑设计和施工的不同阶段需要不同的图纸一样，在开发实施数据库应用系统中也需要使用不同的数据模型：概念模型、逻辑模型和物理模型。\n根据模型应用的不同目的，可以将这些模型划分为两大类，它们分别属于两个不同的层次。第一类是概念模型，第二类是逻辑模型和物理模型。 第一类概念模型(conceptual model)，也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。\n第二类中的逻辑模型主要包括层次模型(hierarchical model)、网状模型(network model)、关系模型(relational model)、面向对象数据模型(object oriented data model)和对象关系数据模型（object relational data model)、半结构化数据模型(semistructured data model)等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。\n第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不必考虑物理级的细节。\n数据模型是数据库系统的核心和基础。各种机器上实现的数据库管理系统软件都是基于某种数据模型或者说是支持某种数据模型的。\n为了把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型，人们常常首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。也就是说，首先把现实世界中的客观对象抽象为某一种信息结构，这种信息结构并不依赖于具体的计算机系统，不是某一个数据库管理系统支持的数据模型，而是概念级的模型；然后再把概念模型转换为计算机上某一数据库管理系统支持的数据模型，这一过程如图7所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 现实世界 认识 抽象 概念模型 数据库管理系统支持的数据模型 信息世界 机器世界 图7\u0026emsp;现实世界中客观对象的抽象过程\n从现实世界到概念模型的转换是由数据库设计人员完成的；从概念模型到逻辑模型的转换可以由数据库设计人员完成，也可以用数据库设计工具协助设计人员完成；从逻辑模型到物理模型的转换主要是由数据库管理系统完成的。\n下面首先介绍概念模型，数据模型的组成要素，然后介绍三个常用的数据模型。\n概念模型 由图7可以看出，概念模型实际上是现实世界到机器世界的一个中间层次。\n概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言，因此概念模型一方面应该具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，另一方面它还应该简单、清晰、易于用户理解。\n信息世界中的基本概念 信息世界主要涉及以下一些概念。\n(1) 实体(entity)。客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系，例如，一个职工、一个学生、一个部门、一门课、学生的一次选课、部门的一次订货、教师与院系的工作关系（即某位教师在某院系工作）等都是实体。\n(2) 属性(attribute)。实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。例如，学生实体可以由学号、姓名、性别、出生年月、所在院系、入学时间等属性组成，属性组合(201315121，张山，男，199505，计算机系，2013)即表征了一个学生。\n(3) 码(key)。唯一标识实体的属性集称为码。例如学号是学生实体的码。 (4) 实体型(entitytype)。具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如，学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。\n(5) 实体集(entityset)。同一类型实体的集合称为实体集。例如，全体学生就是一个实体集。\n(6) 联系(relationship)。在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系，实体之间的联系通常是指不同实体集之间的联系。\n实体之间的联系有一对一、一对多和多对多等多种类型。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集 \\(A\\) 与实体集 \\(B\\) 具有一对一联系。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中有 \\(n\\) 个实体（ \\(n \\ge 0\\) ）与之联系，反之，对于实体集 \\(B\\) 中的每一个实体，实体集 \\(A\\) 中至多只有一个实体与之联系，则称实体集 \\(A\\) 与实体集 \\(B\\) 有一对多联系。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中有 \\(n\\) 个实体（ \\(n \\ge 0\\) ）与之联系，反之，对于实体集 \\(B\\) 中的每一个实体，实体集 \\(A\\) 中也有 \\(m\\) 个实体（ \\(m \\ge 0\\) ）与之联系，则称实体集 \\(A\\) 与实体集 \\(B\\) 具有多对多联系。例如一门课程可以同时有若干名学生选修，而一个学生可以同时选修多门课程，则课程实体与学生实体具有多对多联系。\n概念模型的一种表示方法：实体-联系方法 概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。概念模型的表示方法很多，其中最为常用的是P.P.S.Chen于1976年提出的实体-联系方法（Entity-Relationship approach）。该方法用E-R图（E-R diagram）‌来描述现实世界的概念模型，E-R方法也称为E-R模型。\n数据模型的组成要素 一般地讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件(integrity constraints)。因此数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。\n数据结构 数据结构描述数据库的组成对象以及对象之间的联系。也就是说，数据结构描述的内容有两类：一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等；一类是与数据之间联系有关的对象，如网状模型中的系型(set type)。\n数据结构是刻画一个数据模型性质最重要的方面。因此在数据库系统中，人们通常按照其数据结构的类型来命名数据模型。例如层次结构、网状结构和关系结构的数据模型分别命名为层次模型、网状模型和关系模型。\n总之，数据结构是所描述的对象类型的集合，是对系统静态特性的描述。\n数据操作 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括（操作及有关的操作规则。\n数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特性的描述。\n数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。\n数据模型应该反映和规定其必须遵守的基本的和通用的完整性约束条件。例如，在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。\n此外，数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。例如，在某大学的数据库中规定学生成绩如果有6门以上不及格将不能授予学士学位，教授的退休年龄是65周岁，男职工的退休年龄是60周岁，女职工的退休年龄是55周岁等。\n常用数据模型 数据库领域中主要的逻辑数据模型有：\n◦层次模型(hierarchical model)\n◦网状模型(network model)\n◦关系模型(relational model)\n◦面向对象数据模型(object oriented data model)\n◦对象关系数据模型(object relational data model)\n◦半结构化数据模型(semistructure data model)\n其中层次模型和网状模型统称为格式化模型。\n格式化模型的数据库系统在20世纪70年代至80年代初非常流行，在数据库系统产品中占据了主导地位。层次数据库系统和网状数据库系统在使用和实现上都要涉及数据库物理层的复杂结构，现在已逐渐被关系模型的数据库系统取代。但在美国及欧洲的一些国家里，由于早期开发的应用系统都是基于层次数据库或网状数据库系统的，因此目前仍有一些层次数据库系统或网状数据库系统在继续使用。\n20世纪80年代以来，面向对象的方法和技术在计算机各个领域，包括程序设计语言、软件工程、信息系统设计、计算机硬件设计等方面都产生了深远的影响，也促进数据库中面向对象数据模型的研究和发展。许多关系数据库厂商为了支持面向对象模型，对关系模型做了扩展，从而产生了对象关系数据模型。\n随着Internet的迅速发展，Web上各种半结构化、非结构化数据源已经成为重要的信息来源，产生了以XML为代表的半结构化数据模型和非结构化数据模型。\n本篇简要介绍层次模型、网状模型和关系模型。其他新型的数据模型将在后续介绍。\n数据结构、数据操作和数据完整性约束条件这三个方面的内容完整地描述了一个数据模型，其中数据结构是刻画模型性质的最基本的方面。为了使读者对数据模型有一个基本认识，下面着重介绍三种模型的数据结构。\n注：这里讲的数据模型都是逻辑上的，也就是说是用户眼中看到的数据范围。同时它们又都是能用某种语言描述，使计算机系统能够理解，被数据库管理系统支持的数据视图。这些数据模型将以一定的方式存储于数据库系统中，这是数据库管理系统的功能，是数据库管理系统中的物理存储模型。\n在格式化模型中实体用记录表示，实体的属性对应记录的数据项（或字段）。实体之间的联系在格式化模型中转换成记录之间的两两联系。在格式化模型中数据结构的单位是基本层次联系。所谓基本层次联系是指两个记录以及它们之间的一对多（包括一对一）的联系，如图8所示。图中 \\(R_i\\) 位于联系 \\(L_{ij}\\) 的始点，称为双亲结点(parent)， \\(R_j\\) 位于联系 \\(L_{ij}\\) 的终点，称为子女结点(child)。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 双亲节点 子女节点 一对多（包括一对一）联系名 图8\u0026emsp;基本层次联系\n层次模型 层次模型是数据库系统中最早出现的数据模型，层次数据库系统采用层次模型作为数据的组织方式。层次数据库系统的典型代表是IBM公司的IMS(Information Management System)，这是1968年IBM公司推出的第一个大型商用数据库管理系统，曾经得到广泛的使用。\n层次模型用树形结构来表示各类实体以及实体间的联系。现实世界中许多实体之间的联系本来就呈现出一种很自然的层次关系，如行政机构、家族关系等。\n1. 层次模型的数据结构\n在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：\n(1) 有且只有一个结点没有双亲结点，这个结点称为根结点。\n(2) 根以外的其他结点有且只有一个双亲结点。\n在层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。这就使得层次数据库系统只能处理一对多的实体联系。\n每个记录类型可包含若干个字段，这里记录类型描述的是实体，字段描述实体的属性。各个记录类型及其字段都必须命名。各个记录类型、同一记录类型中各个字段不能同名。每个记录类型可以定义一个排序字段，也称为码字段，如果定义该排序字段的值是唯一的，则它能唯一地标识一个记录值。\n一个层次模型在理论上可以包含任意有限个记录类型和字段，但任何实际的系统都会因为存储容量或实现复杂度而限制层次模型中包含的记录类型个数和字段的个数。\n在层次模型中，同一双亲的子女结点称为兄弟结点（twin或sibling），没有子女结点的结点称为叶结点。图9给出了一个层次模型的例子。其中， \\(R_1\\) 为根结点； \\(R_2\\) 和 \\(R_3\\) 为兄弟结点，是 \\(R_1\\) 的子女结点； \\(R_4\\) 和 \\(R_5\\) 为兄弟结点，是 \\(R_2\\) 的子女结点； \\(R_3\\) 、 \\(R_4\\) 和 \\(R_5\\) 为叶结点。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 根结点 兄弟结点 兄弟结点 叶节点 叶节点 叶节点 图9\u0026emsp;一个层次模型的示例\n从图9上可以看出层次模型像一棵倒立的树，结点的双亲是唯一的。\n层次模型的一个基本的特点是，任何一个给定的记录值只能按其层次路径查看，没有一个子女记录值能够脱离双亲记录值而独立存在。\n图10是一个教员学生层次模型。该层次模型有4个记录类型。记录类型系是根结点,由系编号、系名、办公地点三个字段组成。它有两个子女结点教研室和学生。记录类型教研室是系的子女结点，同时又是教员的双亲结点，它由教研室编号、教研室名两个字段组成。记录类型学生由学号、姓名、成绩三个字段组成。记录类型教员由职工号、姓名、研究方向三个字段组成。学生与教员是叶结点，它们没有子女结点。由系到教研室、由教研室到教员、由系到学生均是一对多的联系。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 系编号 系名 办公地点 系 教研室编号 教研室名 教研室 学号 姓名 成绩 学生 职工号 姓名 研究方向 教员 图10\u0026emsp;教员学生层次数据库模型\n图11是图10数据模型对应的一个值。该值是D02系（计算机科学系）记录值及其所有后代记录值组成的一棵树。D02系有三个教研室子女记录值R01、R02、R03和三个学生记录值S63871、S63874,S63876。教研室R01有三个教员记录值E2101、E1709,E3501；教研室R03有两个教员记录值E1101、E3102。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e D02 计算机 办公地点 系 教研室 S63871 文晓静 A 学生 E2101 王大明 数据库 教员 R02 信息系统 R01 数据库 R03 网络 S63874 刘华 C S63876 张君 A E1709 冯灵 数据仓库 E3501 孟勇 并行数据库 E1101 陈芝 网络安全 E3102 张豪 网络管理 图11\u0026emsp;教员学生层次数据库的一个值\n2. 层次模型的数据操纵和完整性约束\n层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。\n进行插入操作时，如果没有相应的双亲结点值就不能插入它的子女结点值。例如在图11的层次数据库中，若新调入一名教员，但尚未分配到某个教研室，这时就不能将新教员插入到数据库中。\n进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。例如在图10的层次数据库中，若删除网络教研室，则该教研室所有教员的数据将全部丢失。\n3. 层次模型的优缺点\n层次模型的优点主要有：\n(1) 层次模型的数据结构比较简单清晰。\n(2) 层次数据库的查询效率高。因为层次模型中记录之间的联系用有向边表示，这种联系在DBMS中常常用指针来实现。因此这种联系也就是记录之间的存取路径。当要存取某个结点的记录值，DBMS就沿着这一条路径很快找到该记录值，所以层次数据库的性能优于关系数据库，不低于网状数据库。\n(3) 层次数据模型提供了良好的完整性支持。\n层次模型的缺点主要有：\n(1) 现实世界中很多联系是非层次性的，如结点之间具有多对多联系，不适合用层次模型表示。\n(2) 如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。 (3) 查询子女结点必须通过双亲结点。\n(4) 由于结构严密，层次命令趋于程序化。\n可见，用层次模型对具有一对多的层次联系的部门描述非常自然、直观，容易理解。这是层次数据库的突出优点。\n网状模型 在现实世界中事物之间的联系更多的是非层次关系的，用层次模型表示非树形结构是很不直接的，网状模型则可以克服这一弊病。\n网状数据库系统采用网状模型作为数据的组织方式。网状数据模型的典型代表是DBTG系统，亦称CODASYL系统。这是20世纪70年代数据系统语言研究会(Conference On Data System Language,CODASYL)下属的数据库任务组(Data Base Task Group,DBTG)提出的一个系统方案。DBTG系统虽然不是实际的数据库系统软件，但是它的基本概念、方法和技术具有普遍意义，对于网状数据库系统的研制和发展起了重大的影响。后来不少系统都采用DBTG模型或者简化的DBTG模型，如Cullinet Software公司的IDMS、Univac公司的DMS1100、Honeywell公司的IDS/2、HP公司的IMAGE等。\n1. 网状模型的数据结构\n在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：\n(1) 允许一个以上的结点无双亲。\n(2) 一个结点可以有多于一个的双亲。\n网状模型是一种比层次模型更具普遍性的结构。它去掉了层次模型的两个限制，允许多个结点没有双亲结点，允许结点有多个双亲结点；此外它还允许两个结点之间有多种联系（称之为复合联系）。因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。\n与层次模型一样，网状模型中每个结点表示一个记录类型（实体），每个记录类型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）之间一对多的父子联系。\n从定义可以看出，层次模型中子女结点与双亲结点的联系是唯一的，而在网状模型中这种联系可以不唯一。因此要为每个联系命名，并指出与该联系有关的双亲记录和子女记录。例如图12(a)中 \\(R_3\\) 有两个双亲记录 \\(R_1\\) 和 \\(R_2\\) ，因此把 \\(R_1\\) 与 \\(R_3\\) 之间的联系命名为 \\(L_1\\) ， \\(R_2\\) 与 \\(R_3\\) 之间的联系命名为 \\(L_2\\) 。图12(a)、(b)、(c)都是网状模型的例子。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e ( a ) ( b ) ( c ) 图12\u0026emsp;网状模型的例子\n下面以学生选课为例，看一看网状数据库是怎样来组织数据的。\n按照常规语义，一个学生可以选修若干门课程，某一课程可以被多个学生选修，因此学生与课程之间是多对多联系。因为DBTG模型中不能表示记录之间多对多的联系，为此引进一个学生选课的连接记录，它由三个数据项组成，即学号、课程号、成绩，表示某个学生选修某一门课程及其成绩。这样，学生选课数据库包括三个记录：学生、课程和选课。\n每个学生可以选修多门课程，显然对学生记录中的一个值，选课记录中可以有多个值与之联系，而选课记录中的一个值，只能与学生记录中的一个值联系。学生与选课之间的联系是一对多的联系，联系名为S-SC。同样，课程与选课之间的联系也是一对多的联系，联系名为C-SC。图13所示为学生选课数据库的网状数据模型。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学号 姓名 系别 学生 课程号 课程名 学分 课程 学号 课程号 成绩 选课 S - S C C - S C 图13\u0026emsp;学生选课数据库的网状数据模型\n2. 网状模型的数据操纵与完整性约束\n网状模型一般来说没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。\n例如，DBTG在模式数据定义语言中提供了定义DBTG数据库完整性的若干概念和语句，主要有：\n(1) 支持记录码的概念，码即唯一标识记录的数据项的集合。例如，学生记录（如图13）中学号是码，因此数据库中不允许学生记录中学号出现重复值。\n(2) 保证一个联系中双亲记录和子女记录之间是一对多的联系。\n(3) 可以支持双亲记录和子女记录之间的某些约束条件。例如，有些子女记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。例如图13中选课记录就应该满足这种约束条件，学生选课记录值必须是数据库中存在的某一学生选修存在的某一门课的记录。DBTG提供了\u0026quot;属籍类别”的概念来描述这类约束条件。\n3. 网状模型的主要优点\n网状模型的优点主要有：\n(1) 能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多 种联系。\n(2) 具有良好的性能，存取效率较高。\n网状模型的缺点主要有：\n(1) 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不 利于最终用户掌握。\n(2) 网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C）中。用户不容易掌握，不容易使用。\n(3) 由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，加重了编写应用程序的负担。\n关系模型 关系模型是最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式。\n1970年，美国IBM公司SanJose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型，开创了数据库关系方法和关系数据理论的研究，为数据库技术奠定了理论基础。由于E.F.Codd的杰出工作，他于1981年获得ACM图灵奖。\n20世纪80年代以来，计算机厂商新推出的数据库管理系统几乎都支持关系模型，非关系系统的产品也大都加上了关系接口。数据库领域当前的研究工作也都是以关系方法为基础。因此本书的重点也将放在关系数据库上，后面各篇将详细介绍关系数据库。\n1. 关系模型的数据结构\n关系模型与以往的模型不同，它是建立在严格的数学概念的基础上的。严格的定义将在第二篇“关系数据库”中给出。这里只简单勾画一下关系模型。从用户观点看，关系模型由一组关系组成。每个关系的数据结构是一张规范化的二维表。下面以学生登记表（如表5所示）为例，介绍关系模型中的一些术语。\n学生登记表\n学号 姓名 年龄 性别 系名 年级 2013004 王小明 19 女 社会学 2013 2013006 黄大鹏 20 男 商品学 2013 2013008 张文斌 18 女 法律 2013 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 表5\u0026emsp;关系模型的数据结构\n◦ 关系(relation)： 一个关系对应通常说的一张表，例如表5中的这张学生登记表。\n◦ 元组(tuple)：表中的一行即为一个元组。\n◦属性(attribute)：表中的一列即为一个属性，给每一个属性起一个名称即属性名。 如表5所示的表有6列，对应6个属性（学号，姓名，年龄，性别，系名和年级）。\n◦码(key)：也称为码键。表中的某个属性组，它可以唯一确定一个元组，如表5中的学号可以唯一确定一个学生，也就成为本关系的码。\n◦域(domain)：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。 如人的年龄一般在1〜120岁之间，大学生年龄属性的域是（15〜45岁），性别的域是（男，女），系名的域是一个学校所有系名的集合。\n◦分量：元组中的一个属性值。\n◦关系模式：对关系的描述，一般表示为\n\\[ 关系名（属性1、属性2、···、属性n） \\tag{1} \\] 例如，上面的关系可描述为\n\\[ 学生（堂号，姓名，年龄，性别，系名，年级） \\tag{2} \\] 关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项，也就是说，不允许表中还有表。例如，表6中工资和扣除是可分的数据项，工资又分为基本工资、岗位津贴和业绩津贴，扣除又分为三险和个人所得税。因此，表6的表就不符合关系模型要求。\n职工号 姓名 职称 工资 扣除 实发 基本工资 岗位津贴 业绩津贴 三险 个人所得税 86051 陈平 讲师 1305 1200 2850 160 112 4083 表6\u0026emsp;一个工资表（表中有表）示例\n可以把关系和现实生活中的表格所使用的术语做一个粗略的对比，如表L5所示。\n关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 表7\u0026emsp;术语对比\n2. 关系模型的数据操纵与完整性约束\n关系模型的数据操纵主要包括查询、插入、删除和更新数据。这些操作必须满足关系的完整性约束条件。关系的完整性约束条件包括三大类：实体完整性、参照完整性和用户定义的完整性。其具体含义将在后续内容中介绍。\n关系模型中的数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集 合，而不像格式化模型中那样是单记录的操作方式。另一方面，关系模型把存取路径向用 户隐蔽起来，用户只要指出“干什么”或\u0026quot;找什么”，不必详细说明\u0026quot;怎么干”或\u0026quot;怎么找”, 从而大大地提高了数据的独立性，提高了用户生产率。\n3. 关系模型的优缺点\n关系模型具有下列优点：\n(1) 关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。\n(2) 关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。\n(3) 关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。\n所以关系模型诞生以后发展迅速，深受用户的喜爱。\n当然，关系模型也有缺点，例如，由于存取路径对用户是隐蔽的，查询效率往往不如 格式化数据模型。为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。不过用户不必考虑这些系统内部的优化技术细节。\n数据库系统的结构 考察数据库系统的结构可以有多种不同的层次或不同的角度。从数据库应用开发人员角度看，数据库系统通常采用三级模式结构，这是数据库系统内部的系统结构。从数据库 最终用户角度看，数据库系统的结构分为单用户结构、主从式结构、分布式结构、客户\u0026mdash;服务器、浏览器\u0026mdash;应用服务器/数据库服务器多层结构等。这是数据库系统外部的体系结构。\n本篇介绍数据库系统的模式结构。\n数据库模式的概念 在数据模型中有“型”(type)和“值”(value)的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如，学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（201315130,李明，男，计算机系，19,江苏南京市）则是该记录型的一个记录值。\n模式(schema)是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述,不涉及具体的值。模式的一个具体值称为模式的一个实例(instance)。同一个模式可以有很多实例。\n例如，在学生选课数据库模式中包含学生记录、课程记录和学生选课记录，现有一个具体的学生选课数据库实例，该实例包含了2013年学校中所有学生的记录（如果某校有10000个学生，则有10000个学生记录）、学校开设的所有课程的记录和所有学生选课的记录。2012年度学生选课数据库模式对应的实例与2013年度学生选课数据库模式对应的实例是不同的。实际上2013年度学生选课数据库的实例也会随时间变化，因为在该年度有的学生可能退学，有的学生可能转系。各个时刻学生选课数据库的实例是不同的、在变化的，不变的是学生选课数据库模式。\n模式是相对稳定的，而实例是相对变动的，因为数据库中的数据是在不断更新的。模式反映的是数据的结构及其联系，而实例反映的是数据库某一时刻的状态。 虽然实际的数据库管理系统产品种类很多，它们支持不同的数据模型，使用不同的数据库语言，建立在不同的操作系统之上，数据的存储结构也各不相同，但它们在体系结构上通常都具有相同的特征，即采用三级模式结构（早期微机上的小型数据库系统除外）并提供两级映像功能。\n数据库的三级模式模式结构 数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成，如图14所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用A 应用B 应用C 应用D 应用E 外模式1 外模式3 外模式2 内模式 模式 数据库 外模式/模式映像 内模式/模式映像 图14\u0026emsp;数据库系统的三级模式结构\n模式(shema) 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。\n模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等；而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。\n外模式(external schema) 外模式也称子模式(subschema)或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。\n外模式通常是模式的子集。一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。\n外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。\n数据库管理系统提供外模式数据定义语言（外模式DDL）‌来严格地定义外模式。\n内模式(internal schema) 内模式也称存储模式(storageschema),一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是按照某个（些）属性值的升（降）序存储，或按照属性值聚簇(cluster)存储：索引按照什么方式组织，是B+树索引还是hash索引；数据是否压缩存储，是否加密；数据的存储记录结构有何规定，如定长结构或变长结构，一个记录不能跨物理页存储；等等。\n数据库的二级映像功能与数据独立性 数据库系统的三级模式是数据的三个抽象级别，它把数据的具体组织留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式与存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。\n外模式/模式映像 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映像，它定义了该外模式与模式之间的对应关系。这些映像定义通常包含在各自外模式的描述中。\n当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n模式/内模式映像 数据库中只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。该映像定义通常包含在模式描述中。当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。\n在数据库的三级模式结构中，数据库模式即全局逻辑结构是数据库的中心与关键，它独立于数据库的其他层次。因此设计数据库模式结构时应首先确定数据库的逻辑模式。\n数据库的内模式依赖于它的全局逻辑结构，但独立于数据库的用户视图，即外模式，也独立于具体的存储设备。它是将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。\n数据库的外模式面向具体的应用程序，它定义在逻辑模式之上，但独立于存储模式和存储设备。当应用需求发生较大变化，相应的外模式不能满足其视图要求时，该外模式就得做相应改动，所以设计外模式时应充分考虑到应用的扩充性。\n特定的应用程序是在外模式描述的数据结构上编制的，它依赖于特定的外模式，与数据库的模式和存储结构独立。不同的应用程序有时可以共用同一个外模式。数据库的二级映像保证了数据库外模式的稳定性，从而从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n数据库系统的组成 在本章一开始介绍了数据库系统一般由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员构成。下面分别介绍这几个部分的内容。\n硬件平台数据库 由于数据库系统的数据量都很大，加之数据库管理系统丰富的功能使得其自身的规模也很大，因此整个数据库系统对硬件资源提出了较高的要求，这些要求是：\n(1) 要有足够大的内存，存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序。\n(2) 有足够大的磁盘或磁盘阵列等设备存放数据库，有足够大的磁带（或光盘）作数据备份。\n(3) 要求系统有较高的通道能力，以提高数据传送率。\n软件 数据库系统的软件主要包括：\n(1) 数据库管理系统。数据库管理系统是为数据库的建立、使用和维护配置的系统软件。\n(2) 支持数据库管理系统运行的操作系统。\n(3) 具有与数据库接口的高级语言及其编译系统，便于开发应用程序。\n(4) 以数据库管理系统为核心的应用开发工具。应用开发工具是系统为应用开发人员和最终用户提供的高效率、多功能的应用生成器、第四代语言等各种软件工具。它们为数据库系统的开发和应用提供了良好的环境。\n(5) 为特定应用环境开发的数据库应用系统。\n人员 开发、管理和使用数据库系统的人员主要包括数据库管理员、系统分析员和数据库设计人员、应用程序员和最终用户。不同的人员涉及不同的数据抽象级别，具有不同的数据视图，如图15所示。这些人员分别包括如下职责。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 外模式 模式 内模式 数据库 客户端 应用系统 数据库 管理系统 操作 系统 用户 应用程序员 数据库管理员 系统分析员 图15\u0026emsp;各种人员的数据视图\n1. 数据库管理员(Database Administrator,DBA)\n在数据库系统环境下有两类共享资源，一类是数据库，另一类是数据库管理系统软件。因此需要有专门的管理机构来监督和管理数据库系统。数据库管理员则是这个机构的一个（组）人员，负责全面管理和控制数据库系统。具体包括如下职责。\n(1) 决定数据库中的信息内容和结构。数据库中要存放哪些信息，数据库管理员要参与决策。因此，数据库管理员必须参加数据库设计的全过程，并与用户、应用程序员、系统分析员密切合作、共同协商，做好数据库设计。\n(2) 决定数据库的存储结构和存取策略。数据库管理员要综合各用户的应用要求，和数据库设计人员共同决定数据的存储结构和存取策略，以求获得较高的存取效率和存储空间利用率。\n(3) 定义数据的安全性要求和完整性约束条件。数据库管理员的重要职责是保证数据库的安全性和完整性。因此，数据库管理员负责确定各个用户对数据库的存取权限、数据的保密级别和完整性约束条件。\n(4) 监控数据库的使用和运行。数据库管理员还有一个重要职责就是监视数据库系统的运行情况，及时处理运行过程中出现的问题。比如系统发生各种故障时，数据库会因此遭到不同程度的破坏，数据库管理员必须在最短时间内将数据库恢复到正确状态，并尽可能不影响或少影响计算机系统其他部分的正常运行。为此，数据库管理员要定义和实施适当的后备和恢复策略，如周期性的转储数据、维护日志文件等。\n(5) 数据库的改进和重组、重构。数据库管理员还负责在系统运行期间监视系统的空间利用率、处理效率等性能指标，对运行情况进行记录、统计分析，依靠工作实践并根据实际应用环境不断改进数据库设计。不少数据库产品都提供了对数据库运行状况进行监视和分析的工具，数据库管理员可以使用这些软件完成这项工作。\n另外，在数据运行过程中，大量数据不断插入、删除、修改，时间一长，数据的组织结构会受到严重影响，从而降低系统性能。因此，数据库管理员要定期对数据库进行重组织，以改善系统性能。当用户的需求增加和改变时，数据库管理员还要对数据库进行较大的改造，包括修改部分设计，即数据库的重构。\n2. 系统分析员和数据库设计人员\n系统分析员负责应用系统的需求分析和规范说明，要和用户及数据库管理员相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计。\n数据库设计人员负责数据库中数据的确定及数据库各级模式的设计。数据库设计人员必须参加用户需求调查和系统分析，然后进行数据库设计。在很多情况下，数据库设计人员就由数据库管理员担任。\n3. 应用程序员\n应用程序员负责设计和编写应用系统的程序模块，并进行调试和安装。\n4. 用户\n这里用户是指最终用户(end user)。最终用户通过应用系统的用户接口使用数据库。常用的接口方式有浏览器、菜单驱动、表格操作、图形显示、报表书写等。\n最终用户可以分为如下三类。\n(1) 偶然用户。这类用户不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息，这类用户一般是企业或组织机构的高中级管理人员。\n(2) 简单用户。数据库的多数最终用户都是简单用户，其主要工作是查询和更新数据库，一般都是通过应用程序员精心设计并具有友好界面的应用程序存取数据库。银行的职员、航空公司的机票预订工作人员、宾馆总台服务员等都属于这类用户。\n(3) 复杂用户。复杂用户包括工程师、科学家、经济学家、科学技术工作者等具有较高科学技术背景的人员。这类用户一般都比较熟悉数据库管理系统的各种功能，能够直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序。\n我们都是阴沟里的虫子，但总还是得有人仰望星空。 ― 刘慈欣, 《三体Ⅰ：地球往事》 ","date":"2024-10-15T16:49:13+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/database_system/introduction_to_database_system/","title":"数据库系统（一）：数据库系统概论"},{"content":" 拓扑空间 拓扑空间 拓扑空间的定义 拓扑空间与拓扑公理 定义1（拓扑空间）：设 \\(X\\) 是一非空集合， \\(X\\) 的一个子集族 \\(\\tau\\) 称为 \\(X\\) 的一个拓扑，如果它满足\n(1) \\(X,\\varnothing\\) 都包含在 \\(\\tau\\) 中。\n(2) \\(\\tau\\) 中任意多个成员的并集仍在 \\(\\tau\\) 中。\n(3) \\(\\tau\\) 中有限多个成员的交集仍在 \\(\\tau\\) 中。\n集合 \\(X\\) 和它的一个拓扑 \\(\\tau\\) 一起称为一个拓扑空间，记作 \\((X,\\tau)\\) 。称 \\(\\tau\\) 中的成员为这个拓扑空间的开集。\n定义中的三个条件称为拓扑公理。(3)可等价地换为\n(3′) \\(\\tau\\) 中两个成员的交集仍在 \\(\\tau\\) 中。\n(3) 蕴含(3′)，另一方面易用归纳法从(3′)推出(3)。\n离散拓扑和平凡拓扑 从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。这种规定不是任意的，必须满足三条拓扑公理。但一般来说一个集合上可以规定许多不相同的拓扑，因此说到一个拓扑空间时，要同时指明集合及所规定的拓扑，以后在不会引起误解的情况下，也常常只用集合来称呼一个拓扑空间，如拓扑空间 \\(X\\) ，拓扑空间 \\(Y\\) 等。\n设 \\(X\\) 是一非空集合，显然 \\(2^X\\) 满足三个拓扑公理（见幂集），构成 \\(X\\) 上的拓扑，称为 \\(X\\) 上的离散拓扑；\\(\\set{X,\\varnothing}\\) 也是 \\(X\\) 上的拓扑，称为 \\(X\\) 上的平凡拓扑。当 \\(X\\) 中包含多余一个点时，这两个拓扑不相同，并且 \\(X\\) 还有许多别的拓扑。例如设 \\(X=\\set{a,b,c}\\) ，则 \\(\\set{X,\\varnothing,\\set{a}}\\) 、 \\(\\set{X,\\varnothing,\\set{a,b}}\\) 、 \\(\\set{X,\\varnothing,\\set{a},\\set{a,b}}\\) 都是 \\(X\\) 上的拓扑；但 \\(\\set{X,\\varnothing,\\set{a},\\set{b}}\\) 不是拓扑，因为条件(2)不满足。\n设 \\(\\tau_1,\\tau_2\\) 是集合 \\(X\\) 上的两个拓扑，如果 \\(\\tau_1 \\subset \\tau_2\\) ，则说 \\(\\tau_2\\) 比 \\(\\tau_1\\) 大（或者说 \\(\\tau_2\\) 比 \\(\\tau_1\\) 精细）。离散拓扑比任何别的拓扑都大，而平凡拓扑比任何拓扑都小。\n几个拓扑例子 下面给出几个拓扑的例子。\n例1：设 \\(X\\) 是无穷集合， \\(\\tau_f=\\set{A^c|A是X的有限子集}\\bigcup\\set{\\varnothing}\\) ，则不难验证 \\(\\tau_f\\) 是 \\(X\\) 上的一个拓扑，成为 \\(X\\) 上的余有限拓扑。\n例2：设 \\(X\\) 是不可数无穷集合， \\(\\tau_c=\\set{A^c|A是X的可数子集}\\bigcup\\set{\\varnothing}\\) ，则 \\(\\tau_c\\) 也是 \\(X\\) 的拓扑，成为余可数拓扑。\n例3：设 \\(\\bm{R}\\) 是全体实数的几何，规定 \\(\\tau_e=\\set{U|U是若干个区间的并集}\\) ，这里“若干”可以是无穷、有限，也可以是零，因此 \\(\\varnothing\\in\\tau_e\\) 。则 \\(\\tau_e\\) 是 \\(R\\) 上的拓扑，称为 \\(R\\) 上的Euclid拓扑，记 \\(\\bm{E}^1=(\\bm{R},\\tau_e)\\) 。\n现在，对 \\(R\\) 已规定了五个拓扑：平凡拓扑 \\(\\tau_t\\) ，离散拓扑 \\(\\tau_s\\) ，余有限拓扑 \\(\\tau_f\\) ，余可数拓扑 \\(\\tau_c\\) 和Euclid拓扑 \\(\\tau_e\\) 。 \\(\\tau_f\\) 小于 \\(\\tau_c\\) 和 \\(\\tau_e\\) ，而 \\(\\tau_c\\) 和 \\(\\tau_e\\) 不能比较大小。\n度量拓扑 度量与度量空间 集合 \\(X\\) 上的一个度量 \\(d\\) 是一个映射 \\(d:X\\times X \\to R\\) ，它满足\n(1) 正定性。\n\\[ \\begin{cases} d(x,x)=0,\\forall x \\in X\\\\[5pt] d(x,y)\u003e0,当x\\ne y \\end{cases} \\tag{1} \\] (2) 对称性。\n\\[ d(x,y)=d(y,x),\\quad\\forall x,y \\in x \\tag{2} \\] (3) 三角不等式。\n\\[ d(x,z)\\le d(x,y)+d(y,z),\\space\\forall x,y,z \\in X \\tag{3} \\] 当集合 \\(X\\) 上规定了一个度量 \\(d\\) 后，称为度量空间，记作 \\((X,d)\\) 。\nEuclid空间 例4：记 \\(\\bm{R}^n=\\set{(x_1,x_2,\\cdots,x_n)|x_i\\in\\bm{R},i=1,\\cdots,n}\\) ，规定 \\(R\\) 上的度量 \\(d\\) 为\n\\[ d((x_1,x_2,\\cdots,x_n),(y_1,y_2,\\cdots,y_n))=\\sqrt{\\sum_{i=1}^{n}(x_i-y_i)^2} \\tag{4} \\] 直接代入可得 \\(d\\) 满足度量的性质度量条件(1)和度量条件(2)。对于度量条件(3)，使用Cauchy-Schwartz不等式可得\n\\[ \\begin{aligned} \\left(d(\\bm{x},\\bm{y})+d(\\bm{y},\\bm{z})\\right)^2\u0026=d(\\bm{x},\\bm{y})^2+d(\\bm{y},\\bm{z})^2+2d(\\bm{x},\\bm{y})d(\\bm{y},\\bm{z})\\\\[5pt] =\u0026\\sum_{i=1}^{n}(x_i-y_i)^2+\\sum_{i=1}^{n}(y_i-z_i)^2+2\\sqrt{\\left(\\sum_{i=1}^{n}(x_i-y_i)^2\\right)\\left(\\sum_{i=1}^{n}(y_i-z_i)^2\\right)}\\\\[15pt] \\ge\u0026\\sum_{i=1}^{n}(x_i-y_i)^2+\\sum_{i=1}^{n}(y_i-z_i)^2+2\\sqrt{\\left(\\sum_{i=1}^{n}(x_i-y_i)(y_i-z_i)\\right)^2}\\text{（Cauchy-Schwartz不等式）}\\\\[15pt] =\u0026\\sum_{i=1}^{n}(x_i-y_i)^2+\\sum_{i=1}^{n}(y_i-z_i)^2+2\\left|\\sum_{i=1}^{n}(x_i-y_i)(y_i-z_i)\\right|\\\\[15pt] \\ge\u0026\\sum_{i=1}^{n}(x_i-y_i)^2+\\sum_{i=1}^{n}(y_i-z_i)^2+2\\sum_{i=1}^{n}(x_i-y_i)(y_i-z_i)\\\\[15pt] =\u0026\\sum_{i=1}^{n}\\bigg((x_i-y_i)^2+2(x_i-y_i)(y_i-z_i)+(y_i-z_i)^2\\bigg)\\\\[15pt] =\u0026\\sum_{i=1}^{n}(x_i-y_i+y_i-z_i)^2=\\sum_{i=1}^{n}(x_i-z_i)^2=d(\\bm{x},\\bm{z})^2 \\end{aligned} \\tag{5} \\] 注意 \\(d(\\bm{x},\\bm{y}),d(\\bm{y},\\bm{z}),d(\\bm{x},\\bm{z})\\) 都大于 \\(0\\) ，故 \\(d(\\bm{x},\\bm{z}) \\le d(\\bm{x},\\bm{y})+d(\\bm{y},\\bm{z})\\) 。度量条件(3)满足。\n记 \\(\\bm{E}^n=(\\bm{R}^n,d)\\) ，称为n维Euclid空间。\n设 \\((X,d)\\) 是一个度量空间，我们来规定 \\(X\\) 的一个拓扑。\n球形邻域 定义2（球形邻域）设 \\(x_0 \\in X,\\varepsilon\\) 是一正数，称 \\(X\\) 的子集\n\\[ B(x_0,\\varepsilon)=\\set{x \\in X | d(x_0,x)\u003c\\varepsilon} \\tag{6} \\] 为以 \\(x_0\\) 为中心， \\(\\varepsilon\\) 为半径的球形邻域。\n引理1： \\((X,d)\\) 的任意两个球形邻域的交集是若干球形邻域的并集。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图1\u0026emsp;球形邻域的交集\n证明（引理1）：设 \\(U=B(x_1,\\varepsilon_1)\\cap B(x_2,\\varepsilon_2)\\) 。 \\(\\forall x \\in U\\) ，则由球形邻域定义知 \\(\\varepsilon_i-d(x,x_i)\u003e0(i=1,2)\\) 。记 \\(\\varepsilon_x=\\min\\set{\\varepsilon_1-d(x,x_1),\\varepsilon_2-d(x,x_2)}\\) 。我们考虑任意 \\(x' \\in B(x,\\varepsilon_x)\\) ，由球形邻域定义知 \\(d(x',x)\u003c\\varepsilon_x\\) 。又知 \\(\\varepsilon_x=\\min\\set{\\varepsilon_1-d(x,x_1),\\varepsilon_2-d(x,x_2)}\u003c\\varepsilon_1-d(x,x_1)\\) ，有 \\(d(x',x)\u003c\\varepsilon_1-d(x,x_1)\\) ，即 \\(d(x',x)+d(x,x_1)\u003c\\varepsilon_1\\) 。由三角不等式可知 \\(d(x',x_1) \u003c d(x',x)+d(x,x_1) \u003c \\varepsilon_1\\) ，所以由球形邻域定义可知 \\(x' \\in B(x_1,\\varepsilon_1)\\) ，同理可证 \\(x' \\in B(x_2,\\varepsilon_2)\\) ，即 \\(x' \\in B(x_1,\\varepsilon_1)\\cap B(x_2,\\varepsilon_2) = U\\) ，故 \\(B(x,\\varepsilon_x) \\subseteq U\\) ，对所有 \\(x\\) 求并集有 \\(\\displaystyle\\bigcup_{x\\in U}B(x,\\varepsilon_x) \\subseteq U\\) 。但是由球形邻域定义又有 \\(\\forall x \\in U,x \\in B(x,\\varepsilon_x) \\subseteq \\displaystyle\\bigcup_{x\\in U}B(x,\\varepsilon_x)\\) ，即 \\(U \\subseteq \\displaystyle\\bigcup_{x\\in U}B(x,\\varepsilon_x)\\) ，最后我们得到\n\\[ U=\\bigcup_{x\\in U}B(x,\\varepsilon_x) \\tag{7} \\] 度量拓扑 命题1：规定 \\(X\\) 的子集族 \\(\\tau_d=\\set{U|U是若干个球形邻域的并集}\\) 。则 \\(\\tau_d\\) 是 \\(X\\) 上的一个拓扑（若干可以是无穷、可以是有限、也可以是零）。\n证明（命题1）：对拓扑公理(1)，取 \\(\\displaystyle\\left(\\bigcup_{x \\in X}B(x,\\varepsilon_x)\\right)\\bigcap X\\) 即可得到 \\(X\\) ，而取 \\(x=\\varnothing\\) 即可得到 \\(\\varnothing\\) ，所以满足。对拓扑公理(2)，由 \\(U\\) 的定义容易知道满足。对拓扑公理(3)，设 \\(U,U' \\in \\tau_d\\) ，记 \\(U=\\displaystyle\\bigcup_{\\alpha}B(x_\\alpha,\\varepsilon_\\alpha),U'=\\displaystyle\\bigcup_{\\beta}B(x'_\\beta,\\varepsilon'_\\beta)\\) ，由集合及其运算-式(49)\n\\[ \\begin{aligned} U \\cup U' =\u0026 \\left(\\bigcup_{\\alpha}B(x_\\alpha,\\varepsilon_\\alpha)\\right)\\cap\\left(\\bigcup_{\\beta}B(x'_\\beta,\\varepsilon'_\\beta)\\right)\\\\[15pt] =\u0026\\bigcup_{\\beta}\\left(\\left(\\bigcup_{\\alpha}B(x_\\alpha,\\varepsilon_\\alpha)\\right)\\cap B(x'_\\beta,\\varepsilon'_\\beta)\\right)\\text{（集合及其运算-式(49)）}\\\\[15pt] =\u0026\\bigcup_{\\beta}\\left(B(x'_\\beta,\\varepsilon'_\\beta)\\cap\\left(\\bigcup_{\\alpha}B(x_\\alpha,\\varepsilon_\\alpha)\\right)\\right)\\\\[15pt] =\u0026\\bigcup_{\\beta}\\left(\\bigcup_{\\alpha}(B(x'_\\beta,\\varepsilon'_\\beta)\\cap B(x_\\alpha,\\varepsilon_\\alpha))\\right)\\text{（集合及其运算-式(49)）}\\\\[15pt] =\u0026\\bigcup_{\\alpha,\\beta}(B(x_\\alpha,\\varepsilon_\\alpha)\\cap B(x'_\\beta,\\varepsilon'_\\beta))\\\\[15pt] \\end{aligned} \\tag{8} \\] 根据引理1，对任何 \\(\\alpha,\\beta\\) ， \\(B(x_\\alpha,\\varepsilon_\\alpha)\\cap B(x'_\\beta,\\varepsilon'_\\beta) \\in \\tau_d\\) 。再由拓扑公理(2)，得出 \\(U \\cap U' \\in \\tau_d\\) 。\n称 \\(\\tau_d\\) 为 \\(X\\) 上由度量 \\(d\\) 决定的度量拓扑。每个度量空间都自然地看成具有度量拓扑的拓扑空间，从而Euclid空间 \\(\\bm{E}^n\\) 也是拓扑空间（其度量拓扑称为Euclid拓扑）。从这个意义上讲，拓扑空间是Euclid空间和度量空间的推广。三条拓扑公理也正是从度量空间的开集所具有的最基本的性质中抽象出来的。\n拓扑空间中的几个基本概念 下面要讲的几个基本的拓扑概念在欧氏空间和度量空间中都已出现过，但现在用开集概念来规定它们。\n闭集 定义3：拓扑空间 \\(X\\) 的一个子集 \\(A\\) 称为闭集，如果 \\(A^c\\) 是开集（见定义1）。\n也就是说，闭集就是开集的余集，反过来开集一定是一个闭集的余集。例如在离散拓扑空间中，任何子集都是开集，从而任何子集也都是闭集；平凡拓扑空间 \\(X\\) 中，只有两个闭集： \\(X=\\varnothing^c\\) 和 \\(\\varnothing = X^c\\) 。在 \\((\\bm{R},\\tau_f)\\) 中，闭集或是 \\(X\\) ，或为有限集；而 \\((\\bm{R},\\tau_c)\\) 中的闭集是X或可数集。\n命题2：拓扑空间的闭集满足：\n(1) \\(X\\) 与 \\(\\varnothing\\) 都是闭集。\n(2) 任意多个闭集的交集是闭集。\n(3) 有限个闭集的并集是闭集。\n证明（命题2）：\n(1) 由定义1的定义可知 \\(X,\\varnothing\\) 一定是某个拓扑 \\(\\tau\\) 的子集，也就是 \\(X,\\varnothing\\) 一定是开集。而 \\(X^c=\\varnothing,\\varnothing^c = X\\) ，因此 \\(X,\\varnothing\\) 也是闭集。\n(2) 设有任意多个闭集 \\(A_1,A_2,\\cdots,A_i,\\cdots\\) 。由 \\(A_i\\) 是闭集可得 \\(A_i^c\\) 是开集，而由拓扑公理(2)，任意多个 \\(A_i^c\\) 的并集 \\(\\displaystyle\\bigcup_{i=1}^{\\infin} A_i^c\\) 也在拓扑空间 \\(\\tau\\) 内，即也是开集。因此由定义3， \\(\\displaystyle\\left(\\bigcup_{i=1}^{\\infin} A_i^c\\right)^c\\) 是闭集，再由集合及其运算-定理13可得 \\(\\displaystyle\\left(\\bigcup_{i=1}^{\\infin} A_i^c\\right)^c=\\bigcap_{i=1}^{\\infin} (A_i^c)^c=\\bigcap_{i=1}^{\\infin} A_i\\) 是闭集。因此任意多个闭集的交集是闭集。\n(3) 设有有限个闭集 \\(A_1,A_2,\\cdots,A_i,\\cdots,A_n\\) 。由 \\(A_i\\) 是闭集可得 \\(A_i^c\\) 是开集，而由拓扑公理(3)，有限个 \\(A_i^c\\) 的交集 \\(\\displaystyle\\bigcap_{i=1}^{n} A_i^c\\) 也在拓扑空间 \\(\\tau\\) 内，即也是开集。因此由定义3， \\(\\displaystyle\\left(\\bigcap_{i=1}^{n} A_i^c\\right)^c\\) 是闭集，再由集合及其运算-定理13可得 \\(\\displaystyle\\left(\\bigcap_{i=1}^{n} A_i^c\\right)^c=\\bigcup_{i=1}^{n} (A_i^c)^c=\\bigcup_{i=1}^{n} A_i\\) 是闭集。因此有限个闭集的交集是闭集。\n邻域，点和内部 定义4：设 \\(A\\) 是拓扑空间 \\(X\\) 的一个子集，点 \\(x \\in A\\) 。如果存在开集 \\(U\\) ，使得 \\(x \\in U \\sube A\\) ，则称 \\(x\\) 是 \\(A\\) 的一个内点， \\(A\\) 是 \\(x\\) 的一个邻域。 \\(A\\) 的所有内点的集合称为 \\(A\\) 的内部，记作 \\(\\mathring{A}\\) （或 \\(A\\degree\\) ）。\n命题3：\n(1) 若 \\(A \\sube B\\) ，则 \\(\\mathring{A} \\sube \\mathring{B}\\) 。\n(2) \\(\\mathring{A}\\) 是包含在 \\(A\\) 中的所有开集的并集，因此是包含在 \\(A\\) 中的最大开集。\n(3) \\(\\mathring{A}=A\\) \\(\\Harr\\) \\(A\\) 是开集。\n(4) \\((A \\cap B)\\degree = \\mathring{A} \\cap \\mathring{B}\\) 。\n(5) \\((A \\cup B)\\degree \\supseteq \\mathring{A} \\cup \\mathring{B}\\) 。\n证明（命题3）：\n(1) 若 \\(x\\) 是 \\(A\\) 的内点，则存在开集 \\(U\\) 使得 \\(x \\in U \\sube A\\) 。因为 \\(A \\sube B\\) ，所以 \\(U \\sube B\\) ，于是 \\(x\\) 也是 \\(B\\) 的内点，这样， \\(A\\) 的内点都是 \\(B\\) 的内点， \\(\\mathring{A} \\sube \\mathring{B}\\) 。\n(2) 记 \\(\\set{U_\\alpha | \\alpha \\in \\mathscr{A}}\\) 是包含在 \\(A\\) 中的所有开集构成的子集族（即 \\(\\forall \\alpha \\in \\mathscr{A},U_\\alpha \\sube A\\) ）。 \\(\\forall x \\in \\displaystyle\\bigcup_{\\alpha \\in \\mathscr{A}}U_\\alpha\\) ，必存在 \\(\\alpha_0\\) 使 \\(x \\in U_{\\alpha_0}\\) 。由 \\(U_\\alpha\\) 的定义知 \\(U_{\\alpha_0} \\in A\\) ，再由定义4中内点的定义可知 \\(x\\) 是 \\(A\\) 的一个内点，因此 \\(x \\in \\mathring{A}\\) 。所以， \\(\\displaystyle\\bigcup_{\\alpha \\in \\mathscr{A}}U_\\alpha \\sube \\mathring{A}\\) 。反之， \\(\\forall x \\in \\mathring{A}\\) ，由定义4中内点的定义可知存在开集 \\(U\\) 满足 \\(x \\in U \\sube A\\) ，而由集合 \\(\\set{U_\\alpha | \\alpha \\in \\mathscr{A}}\\) 的定义知必存在 \\(\\alpha_0\\) 使 \\(U=U_{\\alpha_0}\\) 。即 \\(x \\in \\displaystyle\\bigcup_{\\alpha \\in \\mathscr{A}}U_\\alpha\\) ，从而 \\(\\mathring{A} \\sube \\displaystyle\\bigcup_{\\alpha \\in \\mathscr{A}}U_\\alpha\\) 。综上所述，\\(\\mathring{A} = \\displaystyle\\bigcup_{\\alpha \\in \\mathscr{A}}U_\\alpha\\) ，因此 \\(\\mathring{A}\\) 是包含在 \\(A\\) 中的所有开集的并集。\n(3) 由(2)可知， \\(\\mathring{A}\\) 是开集，若 \\(\\mathring{A}=A\\) ，则 \\(A\\) 也是开集。反之，当 \\(A\\) 是开集时， \\(A\\) 就是包含在 \\(A\\) 中的最大开集。由(2)可直接得到 \\(\\mathring{A}=A\\) 。\n(4)由集合及其运算-式(43)可得 \\(A \\cap B \\sube A\\) ，再由(1)可得 \\((A \\cap B) \\degree \\sube \\mathring{A}\\) ，同理可得 \\((A \\cap B) \\degree \\sube \\mathring{B}\\) ，因此 \\((A \\cap B) \\degree \\sube \\mathring{A} \\cap \\mathring{B}\\) 。由 \\(\\mathring{A} \\sube A, \\mathring{B} \\sube B\\) 和集合及其运算-结论2可得 \\(\\mathring{A} \\cap \\mathring{B} \\sube A \\cap B\\) 。两边取邻域并由(1)可得 \\((\\mathring{A}\\cap\\mathring{B})\\degree\\sube (A \\cap B)\\degree\\) 。因此 \\((\\mathring{A}\\cap\\mathring{B})\\degree = (A \\cap B)\\degree\\) 。又由(2)可得 \\(\\mathring{A},\\mathring{B}\\) 都是开集，因此由拓扑公理(3)可知 \\(\\mathring{A}\\cap\\mathring{B}\\) 也是开集，所以由(3)可得 \\( (\\mathring{A}\\cap\\mathring{B})\\degree=\\mathring{A}\\cap\\mathring{B}\\) 。因此 \\((A \\cap B)\\degree = \\mathring{A} \\cap \\mathring{B}\\) 。\n(5)因为 \\(\\mathring{A}\\cup\\mathring{B}\\) 是包含在 \\(A \\cup B\\) 中的开集，根据(2)可知 \\((A \\cup B)\\degree \\supset \\mathring{A} \\cup \\mathring{B}\\) 。\n用归纳法可以从(4)推导出\n\\[ \\left(\\bigcap_{i=1}^{n}A_i\\right)\\degree=\\bigcap_{i=1}^{n}\\mathring{A}_i \\tag{9} \\] 但对无穷多个子集的交集相应结果不成立。一般地(5)不能把包含号改成等号。在这里举一个反例。\n例5：设 \\(A=[0,1],B=(1,2]\\) ，则 \\((A \\cup B)\\degree = [0,2]\\degree = (0,2)\\) ，而 \\(\\mathring{A}=(0,1),\\mathring{B}=(1,2)\\) ，因此 \\(\\mathring{A}\\cup \\mathring{B} = (0,1)\\cup(1,2)\\) ，因此 \\((A \\cup B)\\degree \\ne \\mathring{A} \\cup \\mathring{B}\\) 。\n聚点与闭包 定义5：设 \\(A\\) 是拓扑空间 \\(X\\) 的子集， \\(x \\in X\\) 。如果 \\(x\\) 的每个邻域都含有 \\(A \\backslash \\set{x}\\) 中的点，则称 \\(x\\) 为 \\(A\\) 的聚点。 \\(A\\) 的所有聚点的集合称为 \\(A\\) 的导集，记作 \\(A'\\) 。称集合 \\(\\bar{A}=A \\cup A'\\) 为 \\(A\\) 的闭包。\n结论1： \\(x \\in \\bar{A}\\) \\(\\Harr\\) \\(x\\) 的任一邻域与 \\(A\\) 都有交点。\n证明（结论1）：假设 \\(x \\in \\bar{A}\\) ，则 \\(x \\in A\\) 或 \\(x \\in A'\\) 。如果是 \\(x \\in A\\) ，则显然任意 \\(x\\) 的邻域与 \\(A\\) 都有至少有交点 \\(x\\) 。如果是 \\(x \\in A'\\) ，则由 \\(A'\\) 的定义可知 \\(x\\) 的每个邻域都含有 \\(A\\backslash\\set{x}\\) 中的点，即与 \\(A\\) 有交点。反过来，如果 \\(x\\) 的任一邻域都与 \\(A\\) 有交点。如果交点只是 \\(x\\) ，则可知 \\(x \\in A\\) ，如果交点不止是 \\(x\\) 或者没有 \\(x\\) ，也就是有 \\(A \\backslash \\set{x}\\) 中的点，则由导集的定义知 \\(x \\in A'\\) 。因此，结论成立。\n命题4：若拓扑空间 \\(X\\) 的子集 \\(A\\) 与 \\(B\\) 互为余集，则 \\(\\bar{A}\\) 与 \\(\\mathring{B}\\) 互为余集。\n证明（命题4）：由结论1和定义4可得如下等价关系\n\\[ \\begin{aligned} x \\in \\bar{A}^c \u0026 \\Harr x有邻域与 A 不相交\\\\[5pt] \u0026 \\Harr x有邻域包含在B中\\\\[5pt] \u0026 \\Harr x是B的内点 \\end{aligned} \\tag{10} \\] 因此 \\(\\bar{A}^c=\\mathring{B}\\) 。\n命题5：\n(1)若 \\(A \\sube B \\) ，则 \\(\\bar{A} \\sube \\bar{B}\\) 。\n(2) \\(\\bar{A}\\) 是所有包含 \\(A\\) 的闭集的交集，所以是包含 \\(A\\) 的最小闭集。\n(3) \\(\\bar{A}\\A\\) \\(\\Harr\\) \\(A\\) 是闭集。\n(4)\n\\[ \\overline{A \\cup B}=\\bar{A} \\cup \\bar{B} \\tag{11} \\] (5)\n\\[ \\overline{A \\cap B} = \\bar{A} \\cap \\bar{B} \\tag{12} \\] ","date":"2024-10-15T14:00:15+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/topology/point_set_topology/topological_space/","title":"点集拓扑学（一）：拓扑空间"},{"content":" 曲线论 在本篇，我们要给出在 \\(E^3\\) 中刻画曲线形状的几何不变量，即曲线的弧长、曲率和挠率，这些量可以用坐标来表示，但是它们与空间 \\(E^3\\) 中的Cartesian直角坐标系的选择是无关的，并且当曲线在空间萨中作刚体运动时这些量也是保持不变的。最后，我们要证明这三个量构成了空间曲线的完全不变量系统，即给出了曲率和挠率作为弧长的函数，则在空间 \\(E^3\\) 中除了位置以外唯一地确定了一条曲线以给定的函数为它的曲率和挠率，这就是所谓的曲线论基本定理。在方法上至为重要的是，在空间曲线的每一点依附了一个正交标架，称为Frenet标架．当点在曲线上运动时，Frenet标架跟着一起运动，而且它的运动状态正好刻画了曲线的形状特征。\n正则参数曲线 参数曲线 在本节我们要对所研究的曲线做一些假定。在直观上， \\(E^3\\) 中的一条曲线是指 \\(E^3\\) 中的一个点随时间的变化而运动时所描出的轨迹。换言之， \\(E^3\\) 中的一条曲线 \\(C\\) 是从区间 \\([a,b]\\) 到 \\(E^3\\) 中的一个连续映射，记为\n\\[ p:[a,b]\\to E^3 \\tag{1} \\] 称为参数曲线。在 \\(E^3\\) 中取定一个正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) ，则曲线 \\(C\\) 上的点 \\(p(t)(a\\le t \\le b)\\) 和向量 \\(\\overrightarrow{Op(t)}\\) 是等同的。命 \\(\\bm{r}(t)=\\overrightarrow{Op(t)}\\) ，则 \\(\\bm{r}(t)\\) 可以用标架向量 \\(\\bm{i},\\bm{j},\\bm{k}\\) 表示为\n\\[ \\bm{r}(t)=x(t)\\bm{i}+y(t)\\bm{j}+z(t)\\bm{k} \\tag{2} \\] 这样，式(1)的映射等价于三个实函数 \\(x(t),y(t),z(t)\\) 。因此，我们通常在固定的Cartesian直角坐标系 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 下把曲线 \\(C\\) 直接记成\n\\[ \\bm{r}(t)=(x(t),y(t),z(t))\\quad t \\in [a,b] \\tag{3} \\] 其中 \\(t\\) 是曲线参数，上式称为曲线 \\(C\\) 的参数方程。\n切线 由导数的定义可知\n\\[ \\bm{r}'(t)=\\lim\\limits_{\\Delta t \\to 0}\\frac{\\bm{r}(t+\\Delta t)-\\bm{r}(t)}{\\Delta t}=(x'(t),y'(t),z'(t)) \\tag{4} \\] 如果坐标函数 \\(x'(t),y'(t),z'(t)\\) 是连续可微的，则称曲线 \\(\\bm{r}(t)\\) 是连续可微的，并且与Cartesian坐标系无关（因为Cartesian坐标变换是线性变换）。\n导数 \\(\\bm{r}(t)\\) 有明显的几何意义。 \\(\\bm{r}(t+\\Delta t)-\\bm{r}(t)\\) 表示从点 \\(\\bm{r}(t)\\) 到点 \\(\\bm{r}(t+\\Delta t)\\) 的有向线段，因此\n\\[ \\frac{\\bm{r}(t+\\Delta t)-\\bm{r}(t)}{\\Delta t} \\tag{5} \\] 代表经过点 \\(\\bm{r}(t)\\) 和点 \\(\\bm{r}(t+\\Delta t)\\) 的割线 \\(l\\) 的方向向量。当 \\(\\Delta t \\to 0\\) 时，割线 \\(l\\) 的极限位置就是曲线在点 \\(\\bm{r}(t)\\) 的切线。如果 \\(\\bm{r}'(t)\\ne 0\\) ，则 \\(\\bm{r}'(t)\\) 是该曲线在点 \\(\\bm{r}(t)\\) 的切线的方向向量，称为该参数曲线的切向量。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图1\u0026emsp;曲线的切线\n正则参数曲线 此时，曲线在点 \\(\\bm{r}(t)\\) 的切线是完全确定的，这样的点称为曲线的正则点．曲线在正则点的切线方程是\n\\[ \\bm{X}(u)=\\bm{r}(t)+u\\bm{r}'(t) \\tag{6} \\] 其中 \\(t\\) 是固定的， \\(u\\) 是切线上点的参数， \\(\\bm{X}(u)\\) 是从原点 \\(O\\) 指向切线上参数为 \\(u\\) 的点的有向线段。\n这样，我们所研究的参数曲线 \\(\\bm{r}(t)\\) 要满足下面两个条件：\n(1) \\(\\bm{r}(t)\\) 至少是自变量 \\(t\\) 的三次以上连续可微的向量函数（因为曲线的几何不变量涉及 \\(\\bm{r}(t)\\) 的三次导数）。\n(2) 处处是正则点，即对于任意的 \\(t\\) 有 \\(\\bm{r}'(t) \\ne \\bm{0}\\) 。\n这样的参数曲线称为正则参数曲线。我们还把参数增大的方向称为该参数曲线的正向，因此 \\(\\bm{r}'(t)\\) 正好指向曲线的正向。\n当然，曲线的参数方程的表达式与空间 \\(E^3\\) 中Cartesian直角坐标系的选取有关。另外，在固定的Cartesian直角坐标系下，曲线的参数方程的参数还容许做一定的变换。为了保证正则参数曲线所满足的两个条件在参数变换下保持不变，则要求参数的变换 \\(t=t(u)\\) 满足下面两个条件：\n(1) \\(t(u)\\) 是 \\(u\\) 的三次以上连续可微函数。 (2) \\(t'(u)\\) 处处不为零。\n称满足上面条件的参数变换为容许参数变换。\n正则曲线 实际上，在参数变换 \\(t=t(u)\\) 下，曲线的参数方程成为 \\(\\bm{r}(t(u))\\) ，为简单起见仍然把它记为 \\(\\bm{r}(u)\\) ．当 \\(t(u)\\) 是 \\(u\\) 的三次以上的连续可微函数时， \\(\\bm{r}(t(u))\\) 自然是 \\(u\\) 的三次以上的连续可微函数。另外，根据求导的链式法则\n\\[ \\bm{r}'(u)=\\frac{\\mathrm{d}}{\\mathrm{d}u}\\bm{r}(t(u))=\\bm{r}'(t(u))\\cdot t'(u) \\tag{7} \\] 在 \\(\\bm{r}'(t)\\ne\\bm{0}\\) 的情况下， \\(\\bm{r}'(u)\\ne 0\\) 的充分必要条件是 \\(t'(u)\\ne 0\\) 。如上的参数变换在正则参数曲线之间建立了一种等价关系，等价的正则参数曲线被看作是同一条曲线。由全体等价的正则参数曲线构成的集合称为一条正则曲线。\n如果对于容许的参数变换还要求 \\(t'(u)\u003e0\\) ，则这种容许的参数变换保持曲线的定向不变，称这种参数变换为定向的容许参数变换。如果一条正则参数曲线只容许做保持定向的参数变换，则这样的正则参数曲线的等价类被称为是一条有向的正则曲线。\n曲线的坐标参数表示 用参数方程表示曲线是从Euler开始的。曲线还能够用坐标之间的函数关系来表示，例如\n\\[ y=y(x),\\quad z=z(x) \\tag{8} \\] 不过，这只是参数方程的一种特殊情形，即可以把 \\(x\\) 作为曲线的参数，记成\n\\[ \\bm{r}(x)=(x,y(x),z(x)) \\tag{9} \\] 如上表示的参数曲线必定是正则的，因为在此时有\n\\[ \\bm{r}'(x)=(1,y'(x),z'(x))\\ne\\bm{0} \\tag{10} \\] 正则参数曲线在每一点的附近都能够表示成如式(9)的形式．例如，在 \\(\\bm{r}'(t)=(x'(t),y'(t),z'(t))\\ne\\bm{0}\\) 时，不妨假定在点 \\(t_0\\) 有 \\(x'(t_0)\\ne 0\\) ,则存在 \\(\\varepsilon \u003e 0\\) 使得函数 \\(x(t)\\) 在区间 \\((t_0-\\varepsilon, t_0+\\varepsilon)\\) 上有反函数（见反函数存在定理），记为 \\(t=t(x)\\) ．于是参数方程 \\(\\bm{r}(t)=(x(t),y(t),z(t))\\) 经过参数变换 \\(t=t(x)\\) 成为\n\\[ \\bm{r}(t(x))=(x,y(t(x)),z(t(x))) \\tag{11} \\] 这正是如式(9)的表达式。\n曲线还能够用坐标的隐式方程来表示。例如，一条曲线是两个联立方程\n\\[ \\begin{cases} f(x,y,z)=0\\\\[5pt] g(x,y,z)=0 \\end{cases} \\tag{12} \\] 的解 \\((x,y,z)\\) 的集合，其中 \\(f(x,y,z)\\) 和 \\(g(x,y,z)\\) 是两个巳知的连续可微函数。在直观上，这两个方程分别代表两张曲面，而所考虑的曲线是这两张曲面的交线．如果这条曲线的参数方程是 \\(\\bm{r}(t)=(x(t),y(t),z(t))\\) ，将其代入式(12)得到恒等式\n\\[ \\begin{cases} f(x(t),y(t),z(t))\\equiv 0\\\\[5pt] g(x(t),y(t),z(t))\\equiv 0 \\end{cases} \\tag{13} \\] 将上面的方程对 \\(t\\) 求导，得到\n\\[ \\begin{cases} \\displaystyle\\frac{\\partial f}{\\partial x}\\cdot x'(t)+\\frac{\\partial f}{\\partial y}\\cdot y'(t)+\\frac{\\partial f}{\\partial z}\\cdot z'(t)=0\\\\[10pt] \\displaystyle\\frac{\\partial g}{\\partial x}\\cdot x'(t)+\\frac{\\partial g}{\\partial y}\\cdot y'(t)+\\frac{\\partial g}{\\partial z}\\cdot z'(t)=0 \\end{cases} \\tag{14} \\] 由上式和Euclid空间-公式2，这意味着\n\\[ \\begin{aligned} \u0026\\bm{r}'(t)\\times\\left(\\left(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}\\right)\\times\\left(\\frac{\\partial g}{\\partial x},\\frac{\\partial g}{\\partial y},\\frac{\\partial g}{\\partial z}\\right)\\right)\\\\[15pt] =\u0026\\left((x'(t),y'(t),z'(t))\\cdot\\left(\\frac{\\partial g}{\\partial x},\\frac{\\partial g}{\\partial y},\\frac{\\partial g}{\\partial z}\\right)\\right)\\left(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}\\right)-\\\\[15pt] \u0026\\left((x'(t),y'(t),z'(t))\\cdot\\left(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}\\right)\\right)\\left(\\frac{\\partial g}{\\partial x},\\frac{\\partial g}{\\partial y},\\frac{\\partial g}{\\partial z}\\right)\\text{（Euclid空间-公式2）}\\\\[15pt] =\u0026\\left(\\frac{\\partial g}{\\partial x}\\cdot x'(t)+\\frac{\\partial g}{\\partial y}\\cdot y'(t)+\\frac{\\partial g}{\\partial z}\\cdot z'(t)\\right)\\left(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}\\right)-\\\\[15pt] \u0026\\left(\\frac{\\partial f}{\\partial x}\\cdot x'(t)+\\frac{\\partial f}{\\partial y}\\cdot y'(t)+\\frac{\\partial f}{\\partial z}\\cdot z'(t)\\right)\\left(\\frac{\\partial g}{\\partial x},\\frac{\\partial g}{\\partial y},\\frac{\\partial g}{\\partial z}\\right)\\\\[15pt] =\u0026\\space \\bm{0} \\end{aligned} \\tag{15} \\] 由Euclid空间-式(21)，这意味着切向量 \\(\\bm{r}'(t)=(x'(t),y'(t),z'(t))\\) 平行于向量\n\\[ \\left(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z}\\right)\\times\\left(\\frac{\\partial g}{\\partial x},\\frac{\\partial g}{\\partial y},\\frac{\\partial g}{\\partial z}\\right) \\tag{16} \\] 上式向量不为零的条件可以等价于如下矩阵的秩为 \\(2\\) 。\n\\[ \\begin{pmatrix} \\displaystyle\\frac{\\partial f}{\\partial x} \u0026 \\displaystyle\\frac{\\partial f}{\\partial y} \u0026 \\displaystyle\\frac{\\partial f}{\\partial z} \\\\[15pt] \\displaystyle\\frac{\\partial g}{\\partial x} \u0026 \\displaystyle\\frac{\\partial g}{\\partial y} \u0026 \\displaystyle\\frac{\\partial g}{\\partial z} \\end{pmatrix} \\tag{17} \\] 见矩阵的秩和Euclid空间-式(53)，实际上，上式矩阵存在 \\(2\\) 阶子式不为 \\(0\\) 条件刚好就是Euclid空间-式(53)中的向量不为 \\(\\bm{0}\\) 的条件，因此等价于其秩为 \\(2\\) 。因此由隐函数存在定理，从式(12)的方程组中可以解出其中两个坐标作为第三个坐标的函数。例如，当\n\\[ \\begin{vmatrix} \\displaystyle\\frac{\\partial f}{\\partial y} \u0026 \\displaystyle\\frac{\\partial f}{\\partial z}\\\\[10pt] \\displaystyle\\frac{\\partial g}{\\partial y} \u0026 \\displaystyle\\frac{\\partial g}{\\partial z} \\end{vmatrix} \\ne 0 \\tag{18} \\] 时，可以解出\n\\[ y=y(x),\\quad z=z(x) \\tag{19} \\] 使得\n\\[ \\begin{cases} f(x,y(x),z(x))\\equiv 0\\\\[5pt] g(x,y(x),z(x))\\equiv 0 \\end{cases} \\tag{20} \\] 于是该曲线的参数方程是\n\\[ \\bm{r}(x)=(x,y(x),z(x)) \\tag{21} \\] 由此可见，如果 \\(f(x,y,z)\\) 和 \\(g(x,y,z)\\) 是连续可微函数， \\(p(x_0,y_0,z_0)\\) 是方程组式(12)的一个解，并且矩阵式(17)的秩是 \\(2\\) ，则方程组式(12)在点 \\(p\\) 的一个邻域内的解是经过点 \\(p\\) 的一条正则曲线。\n曲线的弧长 定义 设 \\(E^3\\) 中的一条正则曲线 \\(C\\) 的参数方程是 \\(\\bm{r}=\\bm{r}(t),\\space a \\le t \\le b\\) 。命\n\\[ s=\\int_{a}^{b}\\left|\\bm{r}'(t)\\right|\\mathrm{d}t \\tag{22} \\] 不变性 则 \\(s\\) 是该曲线的一个不变量，即它与空间 \\(E^3\\) 中的Cartesian直角坐标系的选取无关，也与该曲线的保持定向的容许参数变换无关。前者是因为Cartesian直角坐标变换是个等距变换（见Euclid空间-等距变换），切向量的长度 \\(\\left|\\bm{r}'(t)\\right|\\) 是不变的，故 \\(s\\) 不变。关于后者，不妨设参数变换是\n\\[ t=t(u),\\quad t'(u)\u003e0, \\quad \\alpha \\le u \\le \\beta \\tag{23} \\] 并且\n\\[ t(\\alpha)=a,\\quad t(\\beta)=b \\tag{24} \\] 因此\n\\[ \\begin{aligned} \\left|\\frac{\\mathrm{d}\\bm{r}(t(u))}{\\mathrm{d}u}\\right|=\u0026\\sqrt{\\left(\\frac{\\mathrm{d}x(t(u))}{\\mathrm{d}u}\\right)^2+\\left(\\frac{\\mathrm{d}y(t(u))}{\\mathrm{d}u}\\right)^2+\\left(\\frac{\\mathrm{d}z(t(u))}{\\mathrm{d}u}\\right)^2}\\\\[15pt] =\u0026\\sqrt{\\left(\\frac{\\mathrm{d}x(t(u))}{\\mathrm{d}t}\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\right)^2+\\left(\\frac{\\mathrm{d}y(t(u))}{\\mathrm{d}t}\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\right)^2+\\left(\\frac{\\mathrm{d}z(t(u))}{\\mathrm{d}t}\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\right)^2}\\\\[15pt] =\u0026\\sqrt{\\left(\\frac{\\mathrm{d}x(t(u))}{\\mathrm{d}t}\\right)^2+\\left(\\frac{\\mathrm{d}y(t(u))}{\\mathrm{d}t}\\right)^2+\\left(\\frac{\\mathrm{d}z(t(u))}{\\mathrm{d}t}\\right)^2}\\cdot\\left|\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\right|\\\\[15pt] =\u0026\\left|\\frac{\\mathrm{d}\\bm{r}(t(u))}{\\mathrm{d}t}\\right|\\cdot\\frac{\\mathrm{d}t}{\\mathrm{d}u} \\end{aligned} \\tag{25} \\] 根据积分的变量替换公式有\n\\[ \\int_a^b\\left|\\frac{\\mathrm{d}\\bm{r}(t)}{\\mathrm{d}t}\\right|\\mathrm{d}t=\\int_a^b\\left|\\frac{\\mathrm{d}\\bm{r}(t(u))}{\\mathrm{d}t}\\right|\\cdot\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\mathrm{d}u=\\int_a^b\\left|\\frac{\\mathrm{d}\\bm{r}(t(u))}{\\mathrm{d}u}\\right|\\mathrm{d}u \\tag{26} \\] 所以 \\(s\\) 与参数变换式(23)是无关的。\n实际上 \\(s\\) 的几何意义就是该曲线段的长度。实际上，根据定积分的定义可得\n\\[ \\begin{aligned} s=\u0026\\int_{a}^{b}\\left|\\bm{r}'(t)\\right|\\mathrm{d}t\\\\[10pt] =\u0026\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^{n}|\\bm{r}'(t_i)|\\Delta t_i \\end{aligned} \\tag{27} \\] 其中 \\(a= t_0 \u003c t_1 \u003c \\cdots \u003c t_n=b \\) 是区间 \\([a,b]\\) 的任意一个分割， \\(\\Delta t_i = t_i - t_{i-1}\\) ， \\(\\lambda = \\max\\{ |\\Delta t_i|; i=1,\\cdots,n \\}\\) 。注意 \\(\\lambda \\to 0\\) 时 \\(\\Delta t_i \\to 0\\) 。因此由向量函数的导数定义\n\\[ \\begin{aligned} s=\u0026\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^{n}|\\bm{r}'(t_i)|\\Delta t_i\\\\[15pt] =\u0026\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^{n}\\lim\\limits_{\\Delta t_i \\to 0}\\left|\\frac{ \\bm{r}(t_i+\\Delta t_i)-\\bm{r}(t_i)}{\\Delta t_i}\\right|\\Delta t_i\\\\[15pt] =\u0026\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^{n}\\left| \\bm{r}(t_i+\\Delta t_i)-\\bm{r}(t_i)\\right|\\\\[15pt] \\end{aligned} \\tag{28} \\] 上式的结果表达的是顶点依次为 \\(\\bm{r}(t_0),\\bm{r}(t_1),\\cdots,\\bm{r}(t_n)\\) 的折线长度，因此 \\(\\displaystyle\\int_a^b|\\bm{r}'(t)|dt\\) 是将曲线不断地细分所得的折线的长度的极限，也就是该曲线的长度，称为该曲线的弧长。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图2\u0026emsp;曲线的弧长\n弧长参数 现在对于任意的 \\(a \\le t \\le b\\) ，命\n\\[ s(t)=\\int_a^t|\\bm{r}'(t')|\\mathrm{d}t' \\tag{29} \\] 则 \\(s(t)\\) 是曲线 \\(C\\) 从 \\(a\\) 到 \\(t\\) 的弧长。\n注意到\n\\[ \\frac{\\mathrm{d}s(t)}{\\mathrm{d}t}=|\\bm{r}'(t)|\u003e0 \\tag{30} \\] 并且\n\\[ \\begin{aligned} \\frac{\\mathrm{d}^3s(t)}{\\mathrm{d}^3t}=\u0026\\frac{\\mathrm{d}^2}{\\mathrm{d}^2t}|\\bm{r}'(t)|\\\\[10pt] =\u0026\\frac{\\mathrm{d}^2}{\\mathrm{d}^2t}\\sqrt{(x'(t))^2+(y'(t))^2+(z'(t))^2} \\end{aligned} \\tag{31} \\] 是关于 \\(x(t),y(t),z(t)\\) 的三阶导数。而由正则参数曲线的定义可得 \\(x(t),y(t),z(t)\\) 是三次以上的连续可微函数，因此 \\(s(t)\\) 也是三次以上连续可微函数。故式(29)可以看成一个定向的容许参数变换。换句话说，我们总是可以把正则曲线的弧长作为它的参数，这种参数称为曲线的弧长参数。弧长参数由长参数由曲线本身确定，至多差一个常数（这反映了量度曲线长度的起点不同），与表示曲线的Cartesian直角坐标系的选取无关，与曲线原来的参数的取法也无关。由式(29)得到\n\\[ \\mathrm{d}s=|\\bm{r}'(t)|\\mathrm{d}t \\tag{32} \\] 由式(25)可知对于 \\(t=t(u)\\)\n\\[ \\mathrm{d}s=|\\bm{r}'(t(u))|\\mathrm{d}u=|\\bm{r}'(t)|\\frac{\\mathrm{d}t}{\\mathrm{d}u}\\mathrm{d}u=|\\bm{r}'(t)|\\mathrm{d}t \\tag{33} \\] 因此 \\(\\mathrm{d}s\\) 也是一个曲线不变量，称为曲线的弧长元素。\n判断弧长参数 注意到积分式(29)往往不能够用显式来表示，也就是说要显式地写出弧长函数的表达式往往是不可能的，因此判定已知参数 \\(t\\) 何时是弧长参数是十分重要的。下面给出判断方法。\n定理1：设 \\(\\bm{r}=\\bm{r}(t)(a \\le t \\le b)\\) 是 \\(E^3\\) 中的一条正则曲线，则 \\(t\\) 是它的弧长参数的充分必要条件是 \\(|\\bm{r}'(t)|\\equiv 1\\) 。\n证明（定理1）：因为 \\(\\displaystyle\\frac{\\mathrm{d}s}{\\mathrm{d}t}=|\\bm{r}'(t)|\\) ，当 \\(t\\) 是它的弧长参数 \\(s\\) 时， \\(\\mathrm{d}s=\\mathrm{d}t\\) ，所以由式(32)可知 \\(|\\bm{r}'(t)|\\equiv 1\\) ，反之亦然，证毕。\n上述定理的几何意义是：曲线以弧长为参数的充分必要条件是它的切向量场是单位切向量场。\n曲线的曲率和Frenet标架 切向量的转动 设曲线 \\(C\\) 的方程是 \\(\\bm{r}(s)\\) ，其中 \\(s\\) 是曲线的弧长参数。根据定理1可知 \\(\\bm{r}'(s)\\) 是曲线 \\(C\\) 的单位切向量场。命\n\\[ \\bm{\\alpha}(s)=\\bm{r}'(s) \\tag{34} \\] 下面我们要研究如何刻画曲线的弯曲程度。从直观上看， \\(\\bm{\\alpha}(s)\\) 是曲线 \\(C\\) 在 \\(s\\) 处的方向向量，因此当一点沿曲线以单位速率前进时，方向向量转动的快慢反映了曲线的弯曲程度，而方向向量 \\(\\bm{\\alpha}(s)\\) 转动的快慢恰好是用 \\(\\displaystyle\\left|\\frac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right|\\) 来衡量的。\n定理2：设 \\(\\bm{\\alpha}(s)\\) 是曲线 \\(\\bm{r}(s)\\) 的单位切向量场， \\(s\\) 是弧长参数，用 \\(\\Delta\\theta\\) 表示切向量 \\(\\bm{\\alpha}(s+\\Delta s)\\) 和 \\(\\bm{\\alpha}(s)\\) 之间的夹角，则\n\\[ \\lim\\limits_{\\Delta s \\to 0}\\left|\\frac{\\Delta\\theta}{\\Delta s}\\right|=\\left|\\frac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right| \\tag{35} \\] 证明（定理2）：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图3\u0026emsp;曲线方向向量的转动\n把曲线 \\(C\\) 上所有的单位切向量 \\(\\bm{\\alpha}(s)\\) 平行移动，使它们的起点都放在原点 \\(O\\) 处，则这些向量的端点便描出单位球面上的一条曲线，于是由弧长公式 \\(L=R\\theta\\) ，切向量 \\(\\bm{\\alpha}(s+\\Delta s)\\) 和 \\(\\bm{\\alpha}(s)\\) 之间的夹角 \\(\\Delta\\theta\\) 是在单位球面上从 \\(\\bm{\\alpha}(s+\\Delta s)\\) 和 \\(\\bm{\\alpha}(s)\\) 的大圆弧的弧长，而 \\(|\\bm{\\alpha}(s+\\Delta s)-\\bm{\\alpha}(s)|\\) 正好是该角所对的弦长，所以可推导出（注意由 \\(\\bm{\\alpha}(s)\\) 的定义可知其模长恒为 \\(1\\) ）\n\\[ \\begin{aligned} \\left|\\frac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right|=\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{|\\bm{\\alpha}(s+\\Delta s)-\\bm{\\alpha}(s)|}{|\\Delta s|}\\\\[15pt] =\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{2|\\bm{\\alpha}(s)|\\left|\\sin \\cfrac{\\Delta\\theta}{2}\\right|}{|\\Delta s|}\\\\[15pt] =\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{2\\left|\\sin \\cfrac{\\Delta\\theta}{2}\\right|}{|\\Delta s|}\\\\[15pt] =\u0026\\lim\\limits_{\\Delta s \\to 0}\\left|\\frac{\\Delta\\theta}{\\Delta s}\\right| \\end{aligned} \\tag{36} \\] 最后一步使用了 \\(\\sin x \\backsim x\\) （见等价无穷小）。证毕。\n曲率 定义1：设曲线 \\(C\\) 的方程是 \\(\\bm{r}(s)\\) ，其中 \\(s\\) 是曲线的弧长参数。命\n\\[ \\kappa(s)=\\left|\\frac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right|=\\left|\\bm{r}''(s)\\right| \\tag{37} \\] 称 \\(\\kappa(s)\\) 为曲线 \\(\\bm{r}(s)\\) 在 \\(s\\) 处的曲率，并且称 \\(\\left|\\cfrac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right|\\) 为该曲线的曲率向量。\n定理3：曲线 \\(C\\) 是一条直线当且仅当它的曲率 \\(\\kappa(s)\\equiv 0\\) 。\n证明（定理3）：设直线 \\(C\\) 的参数方程是 \\(\\bm{r}(s)=\\bm{r}_0+\\bm{\\alpha}_0s\\) ，其中 \\(\\bm{\\alpha}_0\\) 是该直线的方向向量。因此， \\(\\bm{r}'(s)=\\bm{\\alpha}_0,\\bm{r}''(s)=\\bm{0}\\) ，故 \\(\\kappa(s)=|\\bm{r}''(s)|\\equiv 0\\) 。上述推导也可以从后往前推，因此反过来也成立。证毕。\n把曲线 \\(C\\) 的单位切向量 \\(\\bm{\\alpha}(s)\\) 平行移动到原点 \\(O\\) ，其端点所描出的曲线称为曲线 \\(C\\) 的切线像，它的参数方程是\n\\[ \\bm{r}=\\bm{\\alpha}(s) \\tag{38} \\] 一般说来， \\(s\\) 不再是曲线的切线像的弧长，而由式(32)，切线像的弧长元素是\n\\[ \\mathrm{d}\\tilde{s}=\\left|\\frac{\\mathrm{d}\\bm{r}}{\\mathrm{d}s}\\right|ds=\\left|\\frac{\\mathrm{d}\\bm{\\alpha}}{\\mathrm{d}s}\\right|ds=\\kappa(s)\\mathrm{d}s \\tag{39} \\] 所以\n\\[ \\kappa(s)=\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s} \\tag{40} \\] 这就是说，曲线的曲率 \\(\\kappa(s)\\) 是曲线的切线像的弧长元素与曲线的弧长元素之比。\nFrenet标架 因为 \\(|\\bm{\\alpha}(s)|=1\\) ，根据Euclid空间-定理3的 (1) 有\n\\[ \\bm{\\alpha}(s)\\cdot\\bm{\\alpha}'(s)=0 \\tag{41} \\] 即 \\(\\bm{\\alpha}(s)\\perp\\bm{\\alpha}'(s)\\) ，所以 \\(\\bm{\\alpha}'(s)\\) 是曲线 \\(C\\) 的一个法向量。如果\n\\[ \\kappa(s) \\ne 0 \\tag{42} \\] 则向量 \\(\\bm{\\alpha}'(s)\\) 有完全确定的方向，将这个方向的单位向量记作 \\(\\bm{\\beta}(s)\\) ，称为其为曲线 \\(C\\) 的主法向量。于是由式(37)，曲率向量 \\(\\bm{\\alpha}'(s)\\) 可以表示为\n\\[ \\bm{\\alpha}'(s)=\\kappa(s)\\bm{\\beta}(s) \\tag{43} \\] 曲线的单位切向量 \\(\\bm{\\alpha}(s)\\) 和主法向量 \\(\\bm{\\beta}(s)\\) 唯一地确定了曲线的第二个法向量\n\\[ \\bm{\\gamma}(s)=\\bm{\\alpha}(s)\\times\\bm{\\beta}(s) \\tag{44} \\] 称其为曲线的次法向量。这样，在正则曲线上曲率 \\(\\kappa(s)\\) 不为零的点有一个完全确定的右手单位正交标架 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s),\\bm{\\gamma}(s)}\\) ，它与表示曲线的Cartesian直角坐标系的选取无关（因为 \\(s\\) 和 \\(\\mathrm{d}s\\) 都和Cartesian直角坐标系无关），也不受曲线作保持定向的容许参数变换的影响，称为曲线在该点的Frenet标架。\n如上所述，曲线在 \\(\\kappa(s)=0\\) 的点，Frenet标架是没有定义的。如果在一个区间 \\((s_0-\\varepsilon, s_0+\\varepsilon)\\) 内有 \\(\\kappa(s)\\equiv 0\\) ，则该曲线段是一条直线。对于直线而言，通常取它的两个彼此正交的法向量 \\(\\bm{\\beta},\\bm{\\gamma}\\) ，而且使 \\(\\bm{\\alpha},\\bm{\\beta},\\bm{\\gamma}\\) 构成右手系，然后让它们沿直线作平行移动，这样得到的标架场 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s),\\bm{\\gamma}(s)}\\) 可以被看作是直线的Frenet标架场。如果 \\(s_0\\) 是曲率 \\(\\kappa(s)\\) 的孤立零点，则情形就变得十分复杂了。在 \\(s_0\\) 的两侧，曲线的曲率 \\(\\kappa(s)\\) 不为零，所以有确定的Frenet标架场。如果在 \\(s \\to s_0 \\pm 0\\) 时它们的极限是同一个，则可以把该极限定义为Frenet标架场在 \\(s_0\\) 处的值，这就是说Frenet标架场可以延拓到 \\(\\kappa(s)\\) 的孤立零点 \\(s_0\\) 。如果在 \\(s \\to s_0 \\pm 0\\) 时，Frenet标架场的极限不是同一个，则Frenet标架场不能够延拓到 \\(\\kappa(s)\\) 的孤立零点 \\(s_0\\) 。\n在曲率 \\(\\kappa(s)\\) 处处不为零的正则曲线上有内在地确定的Frenet标架场，这样一来， \\(E^3\\) 中的正则曲线便成为在 \\(E^3\\) 内由全体右手单位正交标架构成的6维空间中的一条曲线。这种看法有基本的重要性。事实上，在下一节我们会知道，在给定了描写曲线形状的全部几何不变量之后，从 \\(E^3\\) 内由全体右手单位正交标架所构成的6维空间中来看，曲线所满足的微分方程是一个一阶常微分方程组。\n在曲率 \\(\\kappa(s)\\) 不为零的点，Frenet标架 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s),\\bm{\\gamma}(s)}\\) 的三根轴分别称为曲线的切线，主法线和次法线；三个坐标面分别称为曲线的法平面（以 \\(\\bm{\\alpha}\\) 为法向量的平面），从切平面（以 \\(\\bm{\\beta}\\) 为法向量的平面）和密切平面（以 \\(\\bm{\\gamma}\\) 为法向量的平面），它们的方程分别为\n◦法平面： \\((\\bm{X}-\\bm{r}(s))\\cdot\\bm{\\alpha}(s)=0\\) ◦从切平面： \\((\\bm{X}-\\bm{r}(s))\\cdot\\bm{\\beta}(s)=0\\) ◦密切平面： \\((\\bm{X}-\\bm{r}(s))\\cdot\\bm{\\gamma}(s)=0\\)\n其中 \\(\\bm{X}\\) 是相应平面上的动点的向径。\nFrenet标架的计算 下面叙述曲线的曲率和Frenet标架的计算方法。如果曲线 \\(\\bm{r}=\\bm{r}(s)\\) 以 \\(s\\) 为弧长参数，则曲线的曲率和Frenet标架可以根据定义直接计算。实际上\n\\[ \\bm{\\alpha}(s)=\\bm{r}'(s) \\tag{45} \\] \\[ \\kappa(s)=|\\bm{\\alpha}'(s)|=|\\bm{r}''(s)| \\tag{46} \\]\n如果 \\(\\kappa(s)\\ne 0\\) ，则由式(43)可得\n\\[ \\bm{\\beta}(s)=\\frac{\\bm{r}''(s)}{|\\bm{r}''(s)|} \\tag{47} \\] 因此\n\\[ \\bm{\\gamma}(s)=\\bm{\\alpha}(s)\\times\\bm{\\beta}(s)=\\frac{\\bm{r}'(s)\\times\\bm{r}''(s)}{|\\bm{r}''(s)|} \\tag{48} \\] 如果曲线的方程是 \\(\\bm{r}=\\bm{r}(t)\\) ， \\(t\\) 不是弧长参数，则由式(32)\n\\[ \\frac{\\mathrm{d}s}{\\mathrm{d}t}=|\\bm{r}'(t)| \\tag{49} \\] 故\n\\[ \\bm{\\alpha}(t)=\\bm{\\alpha}(s(t))=\\frac{\\mathrm{d}\\bm{r}'(s(t))}{\\mathrm{d}s}=\\frac{\\mathrm{d}\\bm{r}'(s(t))}{\\mathrm{d}t}\\frac{\\mathrm{d}t}{\\mathrm{d}s}=\\frac{\\left(\\cfrac{\\mathrm{d}\\bm{r}'(s(t))}{\\mathrm{d}t}\\right)}{\\left(\\cfrac{\\mathrm{d}s}{\\mathrm{d}t}\\right)}=\\frac{\\bm{r}'(t)}{|\\bm{r}'(t)|} \\tag{50} \\] 即\n\\[ \\bm{r}'(t)=|\\bm{r}'(t)|\\cdot\\bm{\\alpha}(t) \\tag{51} \\] 将上式对 \\(t\\) 求导，由式(43)和式(32)\n\\[ \\begin{aligned} \\bm{r}''(t)=\u0026\\frac{\\mathrm{d}|\\bm{r}'(t)|}{\\mathrm{d}t}\\bm{\\alpha}(t)+|\\bm{r}'(t)|\\cdot\\frac{\\mathrm{d}\\bm{\\alpha}(t)}{\\mathrm{d}s}\\cdot\\frac{\\mathrm{d}s}{\\mathrm{d}t}\\\\[10pt] =\u0026\\frac{\\mathrm{d}|\\bm{r}'(t)|}{\\mathrm{d}t}\\bm{\\alpha}(t)+|\\bm{r}'(t)|^2\\cdot\\kappa(t)\\bm{\\beta}(t) \\end{aligned} \\tag{52} \\] 所以由式(44)\n\\[ \\begin{aligned} \\bm{r}'(t)\\times\\bm{r}''(t)=\u0026|\\bm{r}'(t)|^3\\cdot\\kappa(t)(\\bm{\\alpha}(t)\\times\\bm{\\beta}(t))\\\\[5pt] =\u0026|\\bm{r}'(t)|^3\\cdot\\kappa(t)\\bm{\\gamma}(t) \\end{aligned} \\tag{53} \\] 两边取模再利用 \\(\\bm{\\gamma}(t)\\) 单位向量的性质可得\n\\[ \\kappa(t)=\\cfrac{|\\bm{r}'(t)\\times\\bm{r}''(t)|}{|\\bm{r}'(t)|^3} \\tag{54} \\] 再代入回式(53)可得\n\\[ \\bm{\\gamma}(t)=\\frac{\\bm{r}'(t)\\times\\bm{r}''(t)}{|\\bm{r}'(t)\\times\\bm{r}''(t)|} \\tag{55} \\] 由正交标架的性质Euclid空间-式(24)可得\n\\[ \\bm{\\beta}(t)=\\bm{\\gamma}(t)\\times\\bm{\\alpha}(t) \\tag{56} \\] 代入式(55)和式(50)再利用Euclid空间-公式2可得\n\\[ \\begin{aligned} \\bm{\\beta}(t)=\u0026\\frac{(\\bm{r}'(t)\\times\\bm{r}''(t))\\times\\bm{r}'(t)}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\\\[10pt] =\u0026\\frac{|\\bm{r}'(t)|}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}''(t)-\\frac{\\bm{r}'(t)\\cdot\\bm{r}''(t)}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}'(t) \\end{aligned} \\tag{57} \\] 由此得到曲率和Frenet标架的一般计算公式为\n\\[ \\begin{cases} \\kappa(t)=\\cfrac{|\\bm{r}'(t)\\times\\bm{r}''(t)|}{|\\bm{r}'(t)|^3}\\\\[10pt] \\bm{\\alpha}(t)=\\cfrac{\\bm{r}'(t)}{|\\bm{r}(t)|}\\\\[10pt] \\bm{\\beta}(t)=\\cfrac{|\\bm{r}'(t)|}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}''(t)-\\cfrac{\\bm{r}'(t)\\cdot\\bm{r}''(t)}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}'(t)\\\\[10pt] \\bm{\\gamma}(t)=\\cfrac{\\bm{r}'(t)\\times\\bm{r}''(t)}{|\\bm{r}'(t)\\times\\bm{r}''(t)|} \\end{cases} \\tag{58} \\] 曲线的挠率和Frenet公式 密切平面的转动 曲线在一点的切线和主法线所张的平面是曲线的密切平面，它的法向量是曲线的次法向量 \\(\\bm{\\gamma}\\) 。如果曲线本身落在一个平面内，则该平面就是曲线的密切平面，于是它的法向量 \\(\\bm{\\gamma}\\) 是常向量。如果曲线不是平面曲线，则 \\(\\bm{\\gamma}\\) 必定不是常向量（证明见定理4）。根据定理2，单位切向量 \\(\\bm{\\alpha}\\) 关于弧长参数 \\(s\\) 的导数的长度 \\(|\\bm{\\alpha}'(s)|\\) 反映了曲线的切线方向转动的快慢；同理次法向量 \\(\\bm{\\gamma}\\) 关于弧长参数 \\(s\\) 的导数的长度 \\(|\\bm{\\gamma}'(s)|\\) 反映了曲线的密切平面方向转动的快慢，因而它刻画了曲线偏离平面曲线的程度，反映了曲线扭曲的程度，即曲线的“挠率”。\n由 \\(\\bm{\\gamma}\\) 的定义式(44)\n\\[ \\bm{\\gamma}=\\bm{\\alpha}\\times\\bm{\\beta} \\tag{59} \\] 并且由式(43)\n\\[ \\bm{\\alpha}'(s)\\parallel\\bm{\\beta}(s) \\tag{60} \\] 可得\n\\[ \\bm{\\gamma}'(s)=\\bm{\\alpha}'(s)\\times\\bm{\\beta}(s)+\\bm{\\alpha}(s)\\times\\bm{\\beta}'(s)=\\bm{\\alpha}(s)\\times\\bm{\\beta}'(s) \\tag{61} \\] 这说明 \\(\\bm{\\gamma}'(s)\\perp\\bm{\\alpha}(s)\\) 。同时，因为 \\(\\bm{\\gamma}(s)\\) 是单位向量场，由Euclid空间-定理3的 (1) 可知 \\(\\bm{\\gamma}'(s)\\perp\\bm{\\gamma}(s)\\) 。因此 \\(\\bm{\\gamma}'(s)\\) 与 \\(\\bm{\\beta}(s)\\) 必共线，不妨设\n\\[ \\bm{\\gamma}'(s)=-\\tau\\bm{\\beta}(s) \\tag{62} \\] 两边点乘 \\(\\bm{\\beta}(s)\\) 并利用 \\(\\bm{\\beta}(s)\\) 的单位向量性质\n\\[ \\tau(s)=-\\bm{\\gamma}'(s)\\cdot\\bm{\\beta}(s) \\tag{63} \\] 对式(62)两端取模可得\n\\[ |\\tau(s)|=|\\bm{\\gamma}'(s)| \\tag{64} \\] 挠率 定义2（挠率）：设 \\(\\bm{\\beta}(s)\\) 和 \\(\\bm{\\gamma}(s)\\) 分别是曲线 \\(C\\) 的主法向量和次法向量，其中 \\(s\\) 是曲线的弧长参数，则 \\(\\tau(s)=\\bm{\\gamma}'(s)\\cdot\\bm{\\beta}(s)\\) 称为曲线 \\(C\\) 的挠率。\n定理4：设曲线 \\(C\\) 不是直线，则它是平面曲线当且仅当它的挠率为零。\n证明（定理4）：先讨论必要性。如果曲线 \\(C\\) 是平面曲线，则其切向量 \\(\\bm{\\alpha}(s)\\) 必在该平面内，由图3可看出 \\(\\bm{\\alpha}'(s)\\) 也在该平面内，故由 \\(\\bm{\\beta}\\) 的定义式(43)可知 \\(\\bm{\\beta}\\) 也在该平面内，那么由 \\(\\bm{\\gamma}\\) 的定义式(44)可知 \\(\\bm{\\gamma}\\) 垂直于该平面且为单位向量，故 \\(\\bm{\\gamma}\\) 不变， \\(\\bm{\\gamma}'(s)=0\\) ，故曲线挠率为 \\(0\\) 。\n再讨论充分性。设曲线 \\(C\\) 的参数方程式 \\(\\bm{r}=\\bm{r}(s)\\) ， \\(s\\) 是弧长参数，并且 \\(\\kappa(s)\\ne 0,\\tau(s)\\equiv 0\\) 。此时曲线有确定的Frenet标架 \\(\\set{\\bm{r}(s); \\bm{\\alpha(s)}, \\bm{\\beta}(s), \\bm{\\gamma}(s)}\\) ，并且\n\\[ \\bm{\\gamma}'(s)=-\\tau(s)\\cdot\\bm{\\beta}(s)\\equiv 0 \\tag{65} \\] 因此 \\(\\bm{\\gamma}(s)=\\bm{\\gamma}_0=\\text{常向量}\\) 。又由式(48)得\n\\[ 0=\\bm{r}'(s)\\cdot\\bm{\\gamma}(s)=\\bm{r}'(s)\\cdot\\bm{\\gamma}_0=\\frac{\\mathrm{d}}{\\mathrm{d}s}(\\bm{r}(s)\\cdot\\bm{\\gamma}_0) \\tag{66} \\] 所以\n\\[ \\bm{r}(s)\\cdot\\bm{\\gamma}_0=常数=\\bm{r}(s_0)\\cdot\\bm{\\gamma}_0 \\tag{67} \\] 也就是\n\\[ (\\bm{r}(s)-\\bm{r}(s_0))\\cdot\\bm{\\gamma}_0=0 \\tag{68} \\] 这说明曲线 \\(\\bm{r}=\\bm{r}(s)\\) 落在经过点 \\(\\bm{r}(s_0)\\) 、以常向量 \\(\\bm{\\gamma}_0\\) 为法向量的平面内。证毕。\nFrenet公式 根据曲率、挠率和Frenet标架的定义，我们已经有下面的公式（见式(34)、式(43)、式(62)）\n\\[ \\bm{r}'(s)=\\bm{\\alpha}(s),\\quad \\bm{\\alpha}'(s)=\\kappa(s)\\bm{\\beta}(s),\\quad \\bm{\\gamma}'(s)=-\\tau(s)\\bm{\\beta}(s) \\tag{69} \\] Frenet标架 \\(\\set{\\bm{r}(s); \\bm{\\alpha(s)}, \\bm{\\beta}(s), \\bm{\\gamma}(s)}\\) 是随着点在曲线 \\(\\bm{r}(s)\\) 上的运动而运动的，而 \\(\\bm{r}'(s),\\bm{\\alpha}'(s),\\bm{\\gamma}'(s)\\) 分别给出Frenet标架的原点 \\(\\bm{r}(s)\\) 和标架向量 \\(\\bm{\\alpha}(s),\\bm{\\gamma}(s)\\) 的运动公式，要获得整个Frenet标架的运动公式，只要求出 \\(\\bm{\\beta}'(s)\\) 就行了。由于 \\(\\set{\\bm{r}(s); \\bm{\\alpha(s)}, \\bm{\\beta}(s), \\bm{\\gamma}(s)}\\) 是空间 \\(E^3\\) 的一个标架，所以 \\(\\bm{\\beta}'(s)\\) 总是可以表示成 \\( \\bm{\\alpha(s)}, \\bm{\\beta}(s), \\bm{\\gamma}(s)\\) 的线性组合，不妨设\n\\[ \\bm{\\beta}'(s)=a(s)\\bm{\\alpha}(s)+b(s)\\bm{\\beta}(s)+c(s)\\bm{\\gamma}(s) \\tag{70} \\] 将上式分别于 \\( \\bm{\\alpha}(s), \\bm{\\beta}(s), \\bm{\\gamma}(s)\\) 作点乘，并且利用 \\( \\bm{\\alpha}(s), \\bm{\\beta}(s), \\bm{\\gamma}(s)\\) 的单位正交性，我们有\n\\[ \\begin{cases} a(s)=\\bm{\\beta}'(s)\\cdot\\bm{\\alpha}(s)=-\\bm{\\beta}(s)\\cdot\\bm{\\alpha}'(s)=-\\kappa(s)\\\\[5pt] b(s)=\\bm{\\beta}'(s)\\cdot\\bm{\\beta}(s)=0\\\\[5pt] c(s)=\\bm{\\beta}(s)\\cdot\\bm{\\gamma}(s)=-\\bm{\\beta}(s)\\cdot\\bm{\\gamma}'(s)=\\tau(s) \\end{cases} \\tag{71} \\] 上式利用了 \\(\\bm{\\alpha}(s)\\cdot\\bm{\\beta}(s)=0\\) 两端求导得到的 \\(\\bm{\\alpha}'(s)\\cdot\\bm{\\beta}(s)+\\bm{\\alpha}(s)\\cdot\\bm{\\beta}'(s)=0\\) ， \\(\\bm{\\beta}(s)\\cdot\\bm{\\gamma}(s)=0\\) 两端求导得到的 \\(\\bm{\\beta}'(s)\\cdot\\bm{\\gamma}(s)+\\bm{\\beta}(s)\\cdot\\bm{\\gamma}'(s)=0\\) ，以及由Euclid空间-定理3的 (1) 得到的结论 \\(\\bm{\\beta}'(s)\\cdot\\bm{\\beta}(s)=0\\) 。代入式(70)可得\n\\[ \\bm{\\beta}'(s)=-\\kappa(s)\\bm{\\alpha}(s)+\\tau(s)\\bm{\\gamma}(s) \\tag{72} \\] 把式(69)和式(72)合并起来可得到Frenet标架 \\(\\set{\\bm{r}(s); \\bm{\\alpha(s)}, \\bm{\\beta}(s), \\bm{\\gamma}(s)}\\) 沿曲线 \\(C\\) 运动的公式\n公式1（Frenet公式）：\n\\[ \\begin{cases} \\bm{r}'(s)=\\bm{\\alpha}(s)\\\\[5pt] \\bm{\\alpha}'(s)=\\kappa(s)\\bm{\\beta}(s)\\\\[5pt] \\bm{\\beta}'(s)=-\\kappa(s)\\bm{\\alpha}(s)+\\tau(s)\\bm{\\gamma}(s)\\\\[5pt] \\bm{\\gamma}'(s)=-\\tau(s)\\bm{\\beta}(s) \\end{cases} \\tag{73} \\] 上述公式称为Frenet公式，是曲线论中最重要、最基本的公式，由法国数学家Serret和Frenet分别在1851和1852年发表（他们给出的是切线、主法线、次法线的方向余弦的导数公式）。Frenet公式中后三个方程可以写成矩阵的形式\n\\[ \\begin{pmatrix} \\bm{\\alpha}'(s)\\\\[5pt] \\bm{\\beta}'(s)\\\\[5pt] \\bm{\\gamma}'(s) \\end{pmatrix} = \\begin{pmatrix} 0 \u0026 \\kappa(s) \u0026 0 \\\\[5pt] -\\kappa(s) \u0026 0 \u0026 \\tau(s)\\\\[5pt] 0 \u0026 -\\tau(s) \u0026 0 \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{\\alpha}(s)\\\\[5pt] \\bm{\\beta}(s)\\\\[5pt] \\bm{\\gamma}(s) \\end{pmatrix} \\tag{74} \\] 在上面的公式中系数矩阵是反对称矩阵，这不是Frenet标架的导数所特有的。一般地，沿曲线定义的任意一个单位正交标架场的导数公式的系数矩阵都是反对称的。\n球面曲线 熟练地运用Frenet公式对于研究曲线的性质是十分要紧的。下面以球面上曲线的特征性质为例来说明这一点。\n定理5：设曲线 \\(\\bm{r}=\\bm{r}(s)\\) 的曲率 \\(\\kappa(s)\\) 和挠率 \\(\\tau(s)\\) 都不为零， \\(s\\) 是弧长参数。如果该曲线落在一个球面上，则它的曲率和挠率必满足关系式\n\\[ \\left(\\frac{1}{\\kappa(s)}\\right)^2+\\left(\\frac{1}{\\tau(s)}\\frac{\\mathrm{d}}{\\mathrm{d}s}\\left(\\frac{1}{\\kappa(s)}\\right)\\right)^2=常数 \\tag{75} \\] 证明（定理5）：假定曲线 \\(\\bm{r}=\\bm{r}(s)\\) 落在一个球面上，该球面的球心是 \\(\\bm{r}_0\\) ，半径是 \\(a\\) ，则有关系式\n\\[ (\\bm{r}(s)-\\bm{r}_0)^2=a^2 \\tag{76} \\] 将上式两边对 \\(s\\) 求导并利用式(34)\n\\[ \\bm{\\alpha}(s)\\cdot(\\bm{r}(s)-\\bm{r}_0)=0 \\tag{77} \\] 故 \\((\\bm{r}(s)-\\bm{r}_0)\\) 垂直于切线，因此是曲线的法向量。不妨设\n\\[ \\bm{r}(s)-\\bm{r}_0=\\lambda(s)\\bm{\\beta}(s)+\\mu(s)\\bm{\\gamma}(s) \\tag{78} \\] 将上式对于 \\(s\\) 求导并且利用公式1得到\n\\[ \\bm{\\alpha}(s)=-\\lambda(s)\\kappa(s)\\bm{\\alpha}(s)+(\\lambda'(s)-\\mu(s)\\tau(s))\\bm{\\beta}(s)+(\\lambda(s)\\tau(s)+\\mu'(s))\\bm{\\gamma}(s) \\tag{79} \\] 比较等式两边的系数得到\n\\[ \\lambda(s)\\kappa(s)=-1,\\quad \\lambda'(s)=\\mu(s)\\tau(s),\\quad \\mu'(s)=\\lambda(s)\\tau(s) \\tag{80} \\] 于是\n\\[ \\lambda=-\\frac{1}{\\kappa(s)},\\quad \\mu(s)=\\frac{\\lambda'(s)}{\\tau(s)}=-\\frac{1}{\\tau(s)}\\frac{\\mathrm{d}}{\\mathrm{d}s}\\left(\\frac{1}{\\kappa(s)}\\right) \\tag{81} \\] 将式(81)代入到式(78)可得\n\\[ \\bm{r}(s)-\\bm{r}_0=-\\frac{1}{\\kappa(s)}\\bm{\\beta}(s)-\\frac{1}{\\tau(s)}\\frac{\\mathrm{d}}{\\mathrm{d}s}\\left(\\frac{1}{\\kappa(s)}\\right)\\bm{\\gamma}(s) \\tag{82} \\] 因此根据式(76)和 \\(\\bm{\\beta}(s)\\) 和 \\(\\bm{\\gamma}(s)\\) 的正交性得到\n\\[ \\left(\\frac{1}{\\kappa(s)}\\right)^2+\\left(\\frac{1}{\\tau(s)}\\frac{\\mathrm{d}}{\\mathrm{d}s}\\left(\\frac{1}{\\kappa(s)}\\right)\\right)^2=常数 \\tag{83} \\] 挠率的计算 设曲线的参数方程是 \\(\\bm{r}=\\bm{r}(t)\\) ，将式(55)两边对 \\(t\\) 求导并利用公式1得到\n\\[ \\begin{aligned} -\\tau(t)\\bm{\\beta}(t)\\cdot\\frac{\\mathrm{d}s}{\\mathrm{d}t}=\\frac{\\bm{r}'(t)\\times\\bm{r}'''(t)}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}+\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{1}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\right)\\cdot\\left(\\bm{r}'(t)\\times\\bm{r}''(t)\\right) \\end{aligned} \\tag{84} \\] 将上式两边用式(57)作点乘并利用叉乘的性质 \\(\\bm{a}\\cdot(\\bm{a}\\times\\bm{b})=0\\) 和Euclid空间-公式1可得\n\\[ \\begin{aligned} -\\tau(t)|\\bm{\\beta}(t)|^2\\cdot\\frac{\\mathrm{d}s}{\\mathrm{d}t} =\u0026\\left(\\frac{|\\bm{r}'(t)|}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}''(t)-\\frac{\\bm{r}'(t)\\cdot\\bm{r}''(t)}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\bm{r}'(t)\\right)\\cdot\\\\[15pt] \u0026\\left(\\frac{\\bm{r}'(t)\\times\\bm{r}'''(t)}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}+\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{1}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\right)\\cdot\\left(\\bm{r}'(t)\\times\\bm{r}''(t)\\right)\\right)\\\\[15pt] =\u0026\\frac{|\\bm{r}'(t)|\\cdot(\\bm{r}''(t)\\cdot(\\bm{r}'(t)\\times\\bm{r}'''(t)))}{|\\bm{r}'(t)\\times\\bm{r}''(t)|^2}-\\frac{(\\bm{r}'(t)\\cdot\\bm{r}''(t))(\\bm{r}'(t)\\cdot(\\bm{r}'(t)\\times\\bm{r}'''(t)))}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|^2}+\\\\[15pt] \u0026+\\frac{|\\bm{r}'(t)|}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{1}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\right)(\\bm{r}''(t)\\cdot(\\bm{r}'(t)\\times\\bm{r}''(t))\\\\[15pt] \u0026-\\frac{\\bm{r}'(t)\\cdot\\bm{r}''(t)}{|\\bm{r}'(t)|\\cdot|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\frac{\\mathrm{d}}{\\mathrm{d}t}\\left(\\frac{1}{|\\bm{r}'(t)\\times\\bm{r}''(t)|}\\right)(\\bm{r}'(t)\\cdot(\\bm{r}'(t)\\times\\bm{r}''(t)))\\\\[15pt] =\u0026|\\bm{r}'(t)|\\frac{(\\bm{r}''(t)\\cdot(\\bm{r}'(t)\\times\\bm{r}'''(t)))}{|\\bm{r}'(t)\\times\\bm{r}''(t)|^2}=-|\\bm{r}'(t)|\\frac{(\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t))}{|\\bm{r}'(t)\\times\\bm{r}''(t)|^2} \\end{aligned} \\tag{85} \\] 代入式(32)并由 \\(\\bm{\\beta}(t)\\) 的单位向量性质得\n\\[ \\tau(t)=\\frac{(\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t))}{|\\bm{r}'(t)\\times\\bm{r}''(t)|^2} \\tag{86} \\] 如果 \\(t\\) 是弧长参数 \\(s\\) ，则由定理1和Euclid空间-公式5，上式成为\n\\[ \\tau(s)=\\frac{(\\bm{r}'(s),\\bm{s}''(s),\\bm{s}'''(s))}{|\\bm{r}''(s)|^2} \\tag{87} \\] 定理6：曲线 \\(\\bm{r}=\\bm{r}(t)\\) 是一条平面曲线的充分必要条件是\n\\[ (\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t)) \\equiv 0 \\tag{88} \\] 证明（定理6）：先证必要性。如果 \\(\\bm{r}=\\bm{r}(t)\\) 是一条直线，由定理3可得 \\(\\kappa(s)\\equiv 0\\) ，再由式(54)可得 \\(\\bm{r}'(t)\\times\\bm{r}''(t)=\\bm{0}\\) ，因此由Euclid空间-公式1得\n\\[ (\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t))=(\\bm{r}'(t)\\times\\bm{r}''(t))\\cdot\\bm{r}'''(t) \\equiv 0 \\tag{89} \\] 如果不是一条直线，则由定理4可知 \\(\\tau(t)\\equiv 0\\) ，再由式(86)可得 \\((\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t)) \\equiv 0\\) 。\n再证充分性。如果 \\((\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t)) \\equiv 0\\) ，代入式(86)可得 \\(\\tau(t)\\equiv 0\\) ，故由定理4可得该直线是平面曲线。\n曲线论基本定理 曲率和挠率不为零且处处相等的两条曲线必有刚体运动使其相互变换 根据前面各节的讨论，我们已经知道正则参数曲线的弧长参数、曲率和挠率都是与曲线的保持定向的容许参数变换无关的。实际上，弧长参数的不变性在弧长参数中已经作过讨论，而曲率和挠率是通过曲线的参数方程关于弧长参数的各阶导数作适当的代数运算（点乘和叉乘等）得到的，它们同样不依赖曲线上参数的选择。很明显，这三个量与欧氏空间 \\(E^3\\) 中的Cartesian直角坐标系的选取也是无关的。实际上，这三个量的计算公式是用曲线的向量形式的参数方程给出的，该事实本身就蕴涵着它们不依赖空间的Cartesian直角坐标系的选取。此外，在Euclid空间-定理1处已经解释过，欧氏空间 \\(E^3\\) 上的刚体运动在某种意义上相当于空间的Cartesian直角坐标系的变换，因此当曲线在空间中经受一个刚体运动时，曲线的弧长、曲率和挠率是不变的。反过来说如果在空间 \\(E^3\\) 中有两条曲线，它们的曲率和挠率表示成弧长参数的函数分别是相同的，则这两条曲线的形状是相同的。这个论断可以叙述成下面的基本定理。\n定理7：设 \\(\\bm{r}=\\bm{r}_1(s)\\) 和 \\(\\bm{r}=\\bm{r}_2(s)\\) 是 \\(E^3\\) 中两条以弧长 \\(s\\) 为参数的正则参数曲线，如果它们的曲率处处不为零，并且它们的曲率和挠率分别相等，即 \\(\\kappa_1(s)=\\kappa_2(s),\\tau_1(s)=\\tau_2(s)\\) ，则有 \\(E^3\\) 中的一个刚体运动 \\(\\sigma\\) ，它把曲线 \\(\\bm{r}=\\bm{r}_1(s)\\) 变为曲线 \\(\\bm{r}=\\bm{r}_2(s)\\) 。\n证明（定理7）：由于这两条曲线的曲率处处不为零，因此沿着这两条曲线有完全确定的Frenet标架。假定它们在 \\(s=0\\) 处的Frenet标架分别是 \\(\\set{\\bm{r}_1(0);\\bm{\\alpha}_1(0),\\bm{\\beta}_1(0),\\bm{\\gamma}_1(0)}\\) 和 \\(\\set{\\bm{r}_2(0);\\bm{\\alpha}_2(0),\\bm{\\beta}_2(0),\\bm{\\gamma}_2(0)}\\) 。因为它们都是右手单位正交标架，由Euclid空间-定理1，在 \\(E^3\\) 中有一个刚体运动 \\(\\sigma\\) 把后一个标架变成前一个标架。不妨把第二条曲线经过刚体运动 \\(\\sigma\\) 得到的像仍然记为 \\(\\bm{r}=\\bm{r}_2(s)\\) ，那么曲线 \\(\\bm{r}=\\bm{r}_1(s)\\) 和 \\(\\bm{r}=\\bm{r}_2(s)\\) 在对应点仍旧有相同的曲率和挠率（曲率和挠率是曲线的内禀属性，和Cartesian坐标系无关），并且在 \\(s=0\\) 处有相同的Frenet标架。我们要证明\n\\[ \\bm{r}_1(s)=\\bm{r}_2(s),\\quad \\forall s \\tag{90} \\] 为此，首先定义函数\n\\[ f(s)=(\\bm{\\alpha}_1(s)-\\bm{\\alpha}_2(s))^2+(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))^2+(\\bm{\\gamma}_1(s)-\\bm{\\gamma}_2(s))^2 \\tag{91} \\] 根据假设得知 \\(f(0)=0\\) 。对 \\(f(s)\\) 直接求导，利用公式1并且注意到 \\(\\kappa_1(s)=\\kappa_2(s),\\tau_1(s)=\\tau_2(s)\\) ，则得\n\\[ \\begin{aligned} \\frac{1}{2}\\frac{\\mathrm{d}f(s)}{\\mathrm{d}s}=\u0026(\\bm{\\alpha}_1(s)-\\bm{\\alpha}_2(s))\\cdot(\\kappa_1(s)\\bm{\\beta}_1(s)-\\kappa_2(s)\\bm{\\beta}_2(s))\\\\[5pt] \u0026+(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\cdot(-\\kappa_1(s)\\bm{\\alpha}_1(s)+\\kappa_2(s)\\bm{\\alpha}_2(s))\\\\[5pt] \u0026+(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\cdot(-\\tau_1(s)\\bm{\\gamma}_1(s)+\\tau_2(s)\\bm{\\gamma}_2(s))\\\\[5pt] \u0026+(\\bm{\\gamma}_1(s)-\\bm{\\gamma}_2(s))\\cdot(-\\tau_1(s)\\bm{\\beta}_1(s)+\\tau_2(s)\\bm{\\beta}_2(s))\\\\[5pt] =\u0026\\kappa_1(s)(\\bm{\\alpha}_1(s)-\\bm{\\alpha}_2(s))\\cdot(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\\\[5pt] \u0026-\\kappa_1(s)(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\cdot(\\bm{\\alpha}_1(s)-\\bm{\\alpha}_2(s))\\\\[5pt] \u0026+\\tau_1(s)(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\cdot(\\bm{\\gamma}_1(s)-\\bm{\\gamma}_2(s))\\\\[5pt] \u0026-\\tau_1(s)(\\bm{\\gamma}_1(s)-\\bm{\\gamma}_2(s))\\cdot(\\bm{\\beta}_1(s)-\\bm{\\beta}_2(s))\\\\[5pt] \\equiv \u0026 \\space 0 \\end{aligned} \\tag{92} \\] 故 \\(f(s)=f(0)=0\\) ，即\n\\[ \\bm{\\alpha}_1(s)=\\bm{\\alpha}_2(s),\\quad \\bm{\\beta}_1(s)=\\bm{\\beta}_2(s),\\quad \\bm{\\gamma}_1(s)=\\bm{\\gamma}_2(s) \\tag{93} \\] 再定义函数\n\\[ g(s)=(\\bm{r}_1(s)-\\bm{r}_2(s))^2,\\quad g(0)=0 \\tag{94} \\] 则\n\\[ \\frac{1}{2}\\frac{\\mathrm{d}g(s)}{\\mathrm{d}s}=(\\bm{r}_1(s)-\\bm{r}_2(s))\\cdot(\\bm{\\alpha}_1(s)-\\bm{\\alpha}_2(s))\\equiv 0 \\tag{95} \\] 所以 \\(g(s)=g(0)=0\\) ，即 \\(\\bm{r}_1(s)=\\bm{r}_2(s),\\forall s\\) 。证毕。\n定理8：设 \\(\\bm{r}=\\bm{r}_1(t)\\) 和 \\(\\bm{r}=\\bm{r}_2(u)\\) 是 \\(E^3\\) 中两条正则参数曲线，它们的曲率处处不为零。如果存在三次以上的连续可微函数 \\(u=\\lambda(t),\\lambda'(t)\\ne0\\) ，使得这两条曲线的弧长参数、曲率函数和挠率函数之间有关系式\n\\[ s_1(t)=s_2(\\lambda(t)),\\quad \\kappa_1(t)=\\kappa_2(\\lambda(t)),\\quad \\tau_1(t)=\\tau_2(\\lambda(t)) \\tag{96} \\] 则有 \\(E^3\\) 中的一个刚体运动 \\(\\sigma\\) ，它把曲线 \\(\\bm{r}=\\bm{r}_1(t)\\) 变为曲线 \\(\\bm{r}=\\bm{r}_2(u)\\) ，即曲线 \\(\\bm{r}=\\bm{r}_2(\\lambda(t))\\) 是曲线 \\(\\bm{r}=\\bm{r}_1(t)\\) 在刚体运动 \\(\\sigma\\) 下的像。\n证明（定理8）：由式(96)可得 \\(\\bm{r}=\\bm{r}_1(t)\\) 和 \\(\\bm{r}=\\bm{r}_2(\\lambda(t))\\) 拥有相同的弧长参数，假设\n\\[ s(t)=s_1(t)=s_2(\\lambda(t)) \\tag{97} \\] 则\n\\[ \\kappa_1(s)=\\kappa_1(s(t))=\\kappa_1(s_1(t))=\\kappa_1(t),\\\\[5pt] \\kappa_2(s)=\\kappa_2(s(t))=\\kappa_1(s_2(\\lambda(t)))=\\kappa_2(\\lambda(t)) \\tag{98} \\] 故由式(96)可得 \\(\\kappa_1(s)=\\kappa_2(s)\\) 。同理可得 \\(\\tau_1(s)=\\tau_2(s)\\) 。此时由定理7可以直接得到定理8的结论。\n给定连续可微的曲率和挠率（曲率大于零）则必有曲线对应 在曲线的曲率和Frenet标架中已经知道，在曲率 \\(\\kappa(s)\\) 处处不为零的正则曲线上有内在的、确定的Frenet标架场，所以 \\(E^3\\) 中的曲线便变成在 \\(E^3\\) 的正交标架空间中的一条曲线．而公式1正好是这个标架场的运动方程其系数恰好是曲线的曲率和挠率，它们完全确定了曲线在空间中的形状。我们的问题是：给定了曲率和挠率作为弧长参数 \\(s\\) 的函数 \\(\\kappa(s),\\tau(s)\\) 之后，在空间 \\(E^3\\) 中是否存在正则参数曲线以给定的函数 \\(\\kappa(s),\\tau(s)\\) 为它的曲率和挠率？根据上面的分析，我们在 \\(E^3\\) 上由全体正交标架构成的6维空间中考虑，千是Frenet公式成为现成的已知常微分方程组，它的解是依赖参数 \\(s\\) 的一族正交标架，其标架原点在 \\(E^3\\) 中描出的轨迹应该是我们所要的曲线，而这族正交标架本身应该是曲线的Frenet标架场。\n定理9：设 \\(\\kappa(s),\\tau(s)\\) 是在区间 \\([a,b]\\) 上两个任意给定的连续可微函数，并且 \\(\\kappa(s)\u003e0\\) ，则在空间 \\(E^3\\) 中存在正则参数曲线 \\(\\bm{r}=\\bm{r}(s),a\\le s \\le b\\) ，以 \\(s\\) 为弧长参数，以给定的函数 \\(\\kappa(s),\\tau(s)\\) 为它的曲率和挠率，且这样的曲线在空间 \\(E^3\\) 中是完全确定的，其差异至多为曲线在空间中的位置不同。\n证明（定理9）：定理7已经证明这样的曲线在空间 \\(E^3\\) 中确定到至多差一个位置的不同，因此我们只要证明这样的曲线的存在性。\n为了能够用和式表示方程组，引进新的函数记号\n\\[ \\begin{pmatrix} a_{11}(s) \u0026 a_{12}(s) \u0026 a_{13}(s) \\\\[5pt] a_{21}(s) \u0026 a_{22}(s) \u0026 a_{23}(s) \\\\[5pt] a_{31}(s) \u0026 a_{32}(s) \u0026 a_{33}(s) \\end{pmatrix} = \\begin{pmatrix} 0 \u0026 \\kappa(s) \u0026 0 \\\\[5pt] -\\kappa(s) \u0026 0 \u0026 \\tau(s)\\\\[5pt] 0 \u0026 -\\tau(s) \u0026 0 \\end{pmatrix} \\tag{99} \\] 并且用 \\(\\bm{r},\\bm{e}_1,\\bm{e}_2,\\bm{e}_3\\) 记成向量形式的未知函数，每一个向量函数代表 \\(3\\) 个未知函数，共 \\(12\\) 个未知函数。考虑一阶常微分方程组\n\\[ \\begin{cases} \\cfrac{\\mathrm{d}\\bm{r}}{\\mathrm{d}s}=\\bm{e}_1\\\\[10pt] \\cfrac{\\mathrm{d}\\bm{e}_i}{\\mathrm{d}s}=\\displaystyle\\sum_{j=1}^{3}a_{ij}(s)\\bm{e}_j,\\quad 1 \\le i \\le 3 \\end{cases} \\tag{100} \\] 这是由 \\(4\\) 个向量形式的线性齐次微分方程组组成的方程组（实际上有十二个方程）。由于方程组的系数是连续可微函数，根据解的存在和唯一性-Picard定理，对于任意给定的一组初值 \\(\\bm{r}^{(0)},\\bm{e}_1^{(0)},\\bm{e}_2^{(0)},\\bm{e}_3^{(0)}\\) ，方程组有唯一的一组解 \\(\\bm{r}, \\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s),a\\le s \\le b\\) ，满足初始条件\n\\[ \\bm{r}(s_0)=\\bm{r}^{(0)},\\quad \\bm{e}_i(s_0)=\\bm{e}_i^{(0)},\\quad 1 \\le i \\le 3 \\tag{101} \\] 其中 \\(s_0\\) 是区间 \\([a,b]\\) 中任意固定的一点。一般来说，这样的解并不会满足我们的要求。如果 \\(\\bm{r}=\\bm{r}(s)\\) 是我们想要的曲线，而 \\(\\set{\\bm{r}(s);\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)}\\) 是曲线的Frenet标架，则我们必须要求初始值 \\(\\set{\\bm{r}^{(0)};\\bm{e}_1^{(0)},\\bm{e}_2^{(0)},\\bm{e}_3^{(0)}}\\) 是右手单位正交标架，即它们要满足条件\n\\[ \\begin{cases} \\bm{e}_i^{(0)}\\cdot\\bm{e}_j^{(0)}=\\delta_{ij},\\quad 1\\le i,j \\le 3\\\\[10pt] (\\bm{e}_1^{(0)},\\bm{e}_2^{(0)},\\bm{e}_3^{(0)})=1 \\end{cases} \\tag{102} \\] 我们要证明，当初值满足条件式(102)，方程组式(100)满足初始条件式(101)给出的 \\(\\bm{r}=\\bm{r}(s)\\) 是一条正则曲线，以 \\(s\\) 为弧长参数，并以给定的函数 \\(\\kappa(s),\\tau(s)\\) 为它的曲率和挠率。为此，首先证明这组解 \\(\\set{\\bm{r}(s);\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)}\\) 是右手单位正交标架族。命\n\\[ \\bm{g}_{ij}(s)=\\bm{e}_i(s)\\cdot\\bm{e}_j(s),\\quad 1\\le i,j \\le 3 \\tag{103} \\] 初值所满足的条件式(102)说明\n\\[ g_{ij}(s_0)=0,\\quad 1 \\le i,j \\le 3 \\tag{104} \\] 将式(103)求导，并且利用 \\(\\bm{e}_i(s)\\) 满足方程组式(100)得到\n\\[ \\begin{aligned} \\frac{\\mathrm{d}g_{ij}(s)}{\\mathrm{d}s}=\u0026\\frac{\\mathrm{d}\\bm{e}_i(s)}{\\mathrm{d}s}\\cdot\\bm{e}_j+\\bm{e}_i\\cdot\\frac{\\mathrm{d}\\bm{e}_j(s)}{\\mathrm{d}s}\\\\[15pt] =\u0026\\sum_{k=1}^{3}(a_{ik}\\bm{e}_k(s)\\cdot\\bm{e}_j(s)+a_{jk}\\bm{e}_i(s)\\cdot\\bm{e}_k(s))\\\\[15pt] =\u0026\\sum_{k=1}^{3}(a_{ik}g_{kj}(s)+a_{jk}g_{ik}(s)) \\end{aligned} \\tag{105} \\] 这是线性齐次常微分方程组且系数连续可微，所以再次由解的存在和唯一性-Picard定理可得它在初值条件式(104)下的解是唯一的，又注意\n\\[ g_{ij}(s)\\equiv 0,\\quad 1 \\le i,j \\le 3 \\tag{106} \\] 是方程满足初值条件的一个平凡解。由解的唯一性，方程的唯一解只能是这个平凡解。也就是满足\n\\[ \\bm{e}_i(s)\\cdot\\bm{e}_j(s)=\\delta_{ij},\\quad 1 \\le i,j \\le 3 \\tag{107} \\] 故 \\(\\set{\\bm{r}(s);\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)}\\) 是单位正交标架。这样，向量 \\(\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)\\) 的混合积 \\((\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s))\\) 的值是 \\(1\\) 或 \\(-1\\) 。注意向量 \\(\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)\\) 是连续的，因此 \\((\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s))\\) 也是连续的，因此\n\\[ (\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s))=1 \\tag{108} \\] 所以 \\(\\set{\\bm{r}(s);\\bm{e}_1(s),\\bm{e}_2(s),\\bm{e}_3(s)}\\) 是右手单位正交标架族。\n由方程式(100)的第一式可知\n\\[ \\left|\\frac{\\mathrm{d}\\bm{r}(s)}{\\mathrm{d}s}\\right|=|\\bm{e}_1(s)|=1 \\tag{109} \\] 故由定理1知 \\(\\bm{r}(s)\\) 是正则参数曲线， \\(s\\) 是弧长参数， \\(\\bm{\\alpha}(s)\\bm{e}_1(s)\\) 。再由方程式(100)的第二式得知\n\\[ \\frac{\\mathrm{d}\\bm{\\alpha}(s)}{\\mathrm{d}s}=\\frac{\\mathrm{d}\\bm{e}_1(s)}{\\mathrm{d}s}=\\kappa(s)\\bm{e}_2(s) \\tag{110} \\] 对比式(43)可知 \\(\\kappa(s)\\) 就是曲线 \\(\\bm{r}=\\bm{r}(s)\\) 的曲率， \\(\\bm{e}_2(s)\\) 是它的主法向量，于是\n\\[ \\bm{\\gamma}(s)=\\bm{\\alpha}(s)\\times\\bm{\\beta}(s)=\\bm{e}_1(s)\\times\\bm{e}_2(s)=\\bm{e}_3(s) \\tag{111} \\] 由式(100)的最后一式得到\n\\[ \\frac{\\mathrm{d}\\bm{e}_3(s)}{\\mathrm{d}s}=-\\tau(s)\\bm{e}_2(s) \\tag{112} \\] 两边点乘 \\(\\bm{e}_2(s)\\) 并利用 \\(|\\bm{e}_2(s)|^2=1\\) 可得\n\\[ \\tau(s)=-\\frac{\\mathrm{d}\\bm{e}_3(s)}{\\mathrm{d}s}\\cdot\\bm{e}_2(s)=-\\frac{\\mathrm{d}\\bm{\\gamma}(s)}{\\mathrm{d}s}\\cdot\\bm{\\beta}(s) \\tag{113} \\] 故 \\(\\tau(s)\\) 是曲线 \\(\\bm{r}=\\bm{r}(s)\\) 的挠率。证毕。\n上面的定理说明，函数 \\(\\kappa(s)\u003e0\\) 于 \\(\\tau(s)\\) 在空间 \\(E^3\\) 中不计位置差异唯一地确定了一条曲线，因此它们可以看作是该曲线的方程，成为曲线的内在方程，或自然方程。从曲线的自然方程得到参数方程的过程就是求解方程组式(100)的过程。一般说来，该过程是比较难的。如果知道方程组式(100)的一个特解，则定理7告诉我们，其余的解都是上述特解在 \\(E^3\\) 的刚体运动下的像。\n曲线参数方程在一点的标准展开 我们知道，解析函数 \\(y=f(x)\\) 在任意一点 \\(x_0\\) 的邻域内可以展开成收敛成幂级数。如果函数 \\(y=f(x)\\) 是光滑的，即它有任意阶的导数，则函数 \\(f(x)\\) 可以表示成任意 \\(n\\) 次的一个多项式与一个余项之和，该多项式的系数由 \\(f(x)\\) 的直到 \\(n\\) 阶的各阶导数在 \\(x_0\\) 处的值决定，并且余项在 \\(x \\to x_0\\) 时是比 \\((x-x_0)^n\\) 更高阶的无穷小量．这样的展开式称为函数 \\(y=f(x)\\) 的Taylor展开式，它是原来函数的近似。当然，多项式函数比原来的函数简单，它的性状更容易了解和描写。正则曲线的参数方程是由三个可微函数组成的，将Taylor展开式用到这三个函数上，便能够得到一条多项式曲线来近似原来的曲线。特别是，在曲线的曲率和挠率都不为零的时候，在一点的附近可以求得一条三次曲线，它与原来的曲线在该点有相同的曲率、挠率和Frenet标架，于是原曲线在该点附近的性状可以用这条近似曲线来模拟。\n曲线的Taylor展开 设 \\(\\bm{r}=\\bm{r}(s)\\) 是一条以弧长 \\(s\\) 为参数的正则曲线，它在 \\(s=0\\) 处的Taylor展开式为（见Taylor展开）\n\\[ \\bm{r}(s)=\\bm{r}(0)+\\frac{s}{1!}\\bm{r}'(0)+\\frac{s^2}{2!}\\bm{r}''(0)+\\frac{s^3}{3!}\\bm{r}'''(0)+\\bm{\\omicron}(s^3) \\tag{114} \\] 其中 \\(\\bm{\\omicron}(s^3)\\) 是余项，满足条件\n\\[ \\lim\\limits_{s \\to 0}\\frac{|\\bm{\\omicron}(s^3)|}{s^3}=0 \\tag{115} \\] 由公式1第一式取 \\(s=0\\) 可得\n\\[ \\bm{r}'(0)=\\bm{\\alpha}(0) \\tag{116} \\] 将上式代入公式1第二式并取 \\(s=0\\) 可得\n\\[ \\bm{r}''(0)=\\kappa(0)\\bm{\\beta}(0) \\tag{117} \\] 将公式1第1. 二式代入第三式\n\\[ \\begin{aligned} \\bm{\\beta}'(s)=\u0026\\left(\\frac{\\bm{\\alpha}'(s)}{\\kappa(s)}\\right)'=\\frac{\\bm{\\alpha}''(s)\\kappa(s)-\\bm{\\alpha}'(s)\\kappa'(s)}{\\kappa(s)^2}=\\frac{\\bm{r}'''(s)\\kappa(s)+\\kappa(s)\\kappa'(s)\\bm{\\beta}(s)}{\\kappa(s)^2}\\\\[15pt] \u0026=\\frac{\\bm{r}'''(s)-\\kappa'(s)\\bm{\\beta}(s)}{\\kappa(s)}=-\\kappa(s)\\bm{\\alpha}(s)+\\tau(s)\\gamma(s) \\end{aligned} \\tag{118} \\] 取 \\(s=0\\) 可得\n\\[ \\bm{r}'''(0)=-\\kappa^2(0)\\bm{\\alpha}(0)+\\kappa'(0)\\bm{\\beta}(0)+\\kappa(0)\\tau(0)\\bm{\\gamma}(0) \\tag{119} \\] 将式(116)、式(117)和式(119)代入式(114)可得\n\\[ \\bm{r}(s)=\\bm{r}(0)+\\left(s-\\frac{\\kappa_0^2}{6}s^3\\right)\\bm{\\alpha}(0)+\\left(\\frac{\\kappa_0}{2}s^2+\\frac{\\kappa'_0}{6}s^3\\right)\\bm{\\beta}(0)+\\frac{\\kappa_0\\tau_0}{6}s^3\\bm{\\gamma}(0)+\\bm{\\omicron}(s^3) \\tag{120} \\] 其中 \\(\\kappa_0=\\kappa(0),\\kappa'_0=\\kappa'(0),\\tau_0=\\tau(0)\\) 。如果把曲线在 \\(s=0\\) 处的Frenet标架 \\(\\set{\\bm{r}(0);\\bm{\\alpha}(0),\\bm{\\beta}(0),\\bm{\\gamma}(0)}\\) 取作空间 \\(E^3\\) 的Cartesian直角坐标系的标架，则曲线在 \\(s=0\\) 处附近的参数方程成为\n\\[ \\begin{cases} x=s-\\cfrac{\\kappa_0^2}{6}s^3+\\omicron(s^3)\\\\[10pt] y=\\cfrac{\\kappa_0}{2}s^2+\\cfrac{\\kappa'_0}{6}s^3+\\omicron(s^3)\\\\[10pt] z=\\cfrac{\\kappa_0\\tau_0}{6}s^3+\\omicron(s^3) \\end{cases} \\tag{121} \\] 上式成为曲线 \\(\\bm{r}=\\bm{r}(s)\\) 在 \\(s=0\\) 处的标准展开式。\n近似曲线 当 \\(\\kappa_0\\tau_0\\ne 0\\) 时，曲线的标准展开式中的坐标函数 \\(x(s),y(s),z(s)\\) 作为 \\(s\\) 的无穷小量的主要部分分别是 \\(s,\\cfrac{\\kappa_0}{2}s^2\\) 和 \\(\\cfrac{\\kappa_0\\tau_0}{6}s^3\\) ，于是我们可以考虑一条新的曲线\n\\[ \\tilde{\\bm{r}}(s)=\\left(s,\\frac{\\kappa_0}{2}s^2,\\frac{\\kappa_0\\tau_0}{6}s^3\\right) \\tag{122} \\] 这是一条三次曲线，而且参数 \\(s\\) 一般不是曲线 \\(\\tilde{\\bm{r}}(s)\\) 的弧长参数，但是在 \\(s=0\\) 处有\n\\[ \\begin{aligned} \\tilde{\\bm{r}}(0)=\u0026(0,0,0)\\\\[5pt] \\tilde{\\bm{r}}'(0)=\u0026(1,0,0)\\\\[5pt] \\tilde{\\bm{r}}''(0)=\u0026(0,\\kappa_0,0)\\\\[5pt] \\tilde{\\bm{r}}'''(0)=\u0026(0,0,\\kappa_0\\tau_0) \\end{aligned} \\tag{123} \\] 代入式(54)和式(86)，曲线 \\(\\bm{r}=\\tilde{\\bm{r}}(s)\\) 在 \\(s=0\\) 处的曲率是 \\(\\kappa_0\\) ，挠率是 \\(\\tau_0\\) ，并且Frenet标架是 \\(\\set{\\bm{r}(0);\\bm{\\alpha}(0),\\bm{\\beta}(0),\\bm{\\gamma}(0)}\\) ，即它与原来的曲线 \\(\\bm{r}=\\bm{r}(s)\\) 在 \\(s=0\\) 处有相同的曲率、挠率和Frenet标架。\n曲线 \\(\\bm{r}=\\tilde{\\bm{r}}(s)\\) 称为原曲线 \\(\\bm{r}=\\bm{r}(s)\\) 在 \\(s=0\\) 处的近似曲线，它的性状反映了原曲线的性状。例如，它在密切平面的投影是\n\\[ x=s,\\quad y=\\frac{\\kappa_0}{2}s^2,\\quad z=0 \\tag{124} \\] 它在从切平面上的投影是\n\\[ x=s,\\quad y=0,\\quad z=\\frac{\\kappa_0\\tau_0}{6}s^3 \\tag{125} \\] 它在法平面上的投影是\n\\[ x=0,\\quad y=\\frac{\\kappa_0}{2}s^2,\\quad z=\\frac{\\kappa_0\\tau_0}{6}s^3 \\tag{126} \\] 它们的图像如图4所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图4\u0026emsp;近似曲线在各坐标面的投影\n从图上可以见到，曲线在 \\(s=0\\) 处是穿过曲线在该点的密切平面的。当 \\(\\tau_0\u003e0\\) 时，曲线是从下而上地穿过密切平面的；而当 \\(\\tau_0\u003c0\\) 时，曲线是从上而下地穿过密切平面的。这就是挠率的正、负号的几何意义。\n切触 两条相交的曲线在交点附近的接近程度是用所谓的切触阶来刻画的。设曲线 \\(C_1\\) 和 \\(C_2\\) 相交于点 \\(p_0\\) ，在 \\(C_1\\) 和 \\(C_2\\) 上各取一点 \\(p_1\\) 和 \\(p_2\\) ，使得曲线 \\(C_1\\) 在点 \\(p_0\\) 和 \\(p_1\\) 之间的弧长是 \\(\\Delta s\\) ， \\(C_2\\) 在点 \\(p_0\\) 和 \\(p_2\\) 之间的弧长也是 \\(\\Delta s\\) ，若有正整数 \\(n\\) 使得\n\\[ \\lim\\limits_{\\Delta s \\to 0}\\frac{|p_1p_2|}{(\\Delta s)^n}=0,\\quad \\lim\\limits_{\\Delta s \\to 0}\\frac{|p_1p_2|}{(\\Delta s)^{n+1}}\\ne 0 \\tag{127} \\] 则称曲线 \\(C_1\\) 和 \\(C_2\\) 在交点 \\(p_0\\) 处有n阶切触。\n定理10：设曲线 \\(\\bm{r}_1(s)\\) 和 \\(\\bm{r}_2(s)\\) 都以 \\(s\\) 为它们的弧长参数，且 \\(\\bm{r}_1(0)=\\bm{r}_2(0)\\) ，则它们在 \\(s=0\\) 处有 \\(n\\) 阶切触的充分必要条件是\n\\[ \\begin{cases} \\bm{r}_1^{(i)}(0)=\\bm{r}_2^{(i)}(0), \\space \\forall 1 \\le i \\le n\\\\[5pt] \\bm{r}_1^{(n+1)}(0)\\ne \\bm{r}_2^{(n+1)}(0) \\end{cases} \\tag{128} \\] 证明（定理10）：实际上，由Taylor展开\n\\[ \\bm{r}_1(s)=\\bm{r}_1(0)+\\frac{s}{1!}\\bm{r}_1'(0)+\\frac{s^2}{2!}\\bm{r}_1''(0)+\\cdots+\\frac{s^{n+1}}{(n+1)!}\\bm{r}_1^{(n+1)}(0)+\\bm{\\omicron}(s^{n+1}) \\tag{129} \\] \\[ \\bm{r}_2(s)=\\bm{r}_2(0)+\\frac{s}{1!}\\bm{r}_2'(0)+\\frac{s^2}{2!}\\bm{r}_2''(0)+\\cdots+\\frac{s^{(n+1)}}{(n+1)!}\\bm{r}_2^{(n+1)}(0)+\\bm{\\omicron}(s^{n+1}) \\tag{130} \\]\n将上面两个式子相减并利用条件式(128)：\n\\[ \\bm{r}_1(s)-\\bm{r}_2(s)=\\frac{s^{n+1}}{(n+1)!}\\left(\\bm{r}_1^{(n+1)}(0)-\\bm{r}_2^{(n+1)}(0)\\right)+\\bm{\\omicron}(s^{n+1}) \\tag{131} \\] 因此\n\\[ \\lim\\limits_{s \\to 0}\\frac{|\\bm{r}_1(s)-\\bm{r}_2(s)|}{s^n}=0 \\tag{132} \\] \\[ \\lim\\limits_{s \\to 0}\\frac{|\\bm{r}_1(s)-\\bm{r}_2(s)|}{s^{n+1}}=\\frac{\\left|\\bm{r}_1^{(n+1)}(0)-\\bm{r}_2^{(n+1)}(0)\\right|}{(n+1)!}\\ne 0 \\tag{133} \\]\n反之亦然，证毕。\n由此可见，一条正则曲线与由它的Taylor展开式的前 \\(n+1\\) 项之和给出的曲线在该点处至少有 \\(n\\) 阶切触。正则曲线与它的切线至少有 \\(1\\) 阶切触。与它在一点处的近似曲线在该点至少有 \\(2\\) 阶切触。\n推论1：两条相交的正则曲线在交点处有 \\(2\\) 阶以上的切触的充分必要条件是，这两条曲线相切、有相同的有向密切平面和相同的曲率。\n证明（推论1）：实际上，由定理10，两条相交的正则曲线在交点 \\(s=0\\) 处有 \\(2\\) 阶以上的切触的充分必要条件是\n\\[ \\bm{r}_1(0)=\\bm{r}_2(0),\\quad \\bm{r}'_1(0)=\\bm{r}'_2(0), \\quad \\bm{r}''_1(0)=\\bm{r}''_2(0) \\tag{134} \\] 前两式说明这两条曲线相切。将第三式代入公式1的前两式可得\n\\[ \\kappa_1(0)\\bm{\\beta}_1(0)=\\kappa_2(0)\\bm{\\beta}_2(0) \\tag{135} \\] 注意 \\(|\\bm{\\beta}_1(0)|=|\\bm{\\beta}_2(0)|=1\\) ，则有\n\\[ \\kappa_1(0)=\\kappa_2(0),\\quad \\bm{\\beta}_1(0)=\\bm{\\beta}_2(0) \\tag{136} \\] 第一式说明这两条曲线有相同的曲率，第二式说明这两条曲线有相同的有向密切平面。证毕。\n曲率圆 对于曲线 \\(\\bm{r}=\\bm{r}(s)\\) 上 \\(\\kappa(s)\u003e0\\) 的点 \\(s=s_0\\) ，还可以在该点的密切平面上构造一条特殊的平面曲线，即在 \\(\\bm{r}(s_0)\\) 处的密切平面上作以 \\(\\bm{r}(s_0)+\\cfrac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\) 为中心、以 \\(\\cfrac{1}{\\kappa(s_0)}\\) 为半径的圆周。这个圆的弧长参数曲线方程可以写成如下两式\n\\[ \\left(\\tilde{\\bm{r}}(s')-\\left(\\bm{r}(s_0)+\\frac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\right)\\right)^2=\\left(\\frac{1}{\\kappa(s_0)}\\right)^2 \\tag{137} \\] 式(137)代入 \\(\\tilde{\\bm{r}}(s')=\\bm{r}(s_0)\\) ，等式成立，因此可说明该圆和 \\(\\bm{r}=\\bm{r}(s)\\) 有交点。不妨设 \\(s'=0\\) 时 \\(\\tilde{\\bm{r}}(s')=\\bm{r}(s_0)\\) 。式(137)对 \\(s'\\) 求导得\n\\[ \\tilde{\\bm{r}}'(s)\\cdot\\left(\\tilde{\\bm{r}}(s)-\\left(\\bm{r}(s_0)+\\frac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\right)\\right)=0 \\tag{138} \\] 代入 \\(s'=0\\) 可得\n\\[ \\tilde{\\bm{r}}'(0)\\cdot\\left(\\tilde{\\bm{r}}(0)-\\left(\\bm{r}(s_0)+\\frac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\right)\\right)=0 \\tag{139} \\] 注意 \\(\\tilde{\\bm{r}}(0)=\\bm{r}(s_0)\\) ，得\n\\[ \\tilde{\\bm{r}}'(0)\\cdot\\bm{\\beta}(s_0)=0 \\tag{140} \\] 注意 \\(\\tilde{\\bm{r}}'(0)\\) 和 \\(\\bm{\\alpha}(s_0)\\) 都在密切平面内并且由Frenet标架可知 \\(\\bm{\\alpha}(s_0)\\cdot\\bm{\\beta}(s_0)=0\\) ，所以 \\(\\tilde{\\bm{r}}'(0)\\parallel\\bm{\\alpha}(s_0)\\) ，即 \\(\\tilde{\\bm{r}}'(0)\\parallel\\bm{r}'(s_0)\\) （见式(34)），故该圆和 \\(\\bm{r}=\\bm{r}(s_0)\\) 相切。\n再对式(138)求导并取 \\(s=0\\) 可得\n\\[ \\tilde{\\bm{r}}''(0)\\cdot\\left(\\tilde{\\bm{r}}(0)-\\left(\\bm{r}(s_0)+\\frac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\right)\\right)+\\tilde{\\bm{r}}'(0)\\cdot\\tilde{\\bm{r}}'(0)=0 \\tag{141} \\] 代入 \\(\\tilde{\\bm{r}}(0)=\\bm{r}(s_0)\\) 并利用 \\(|\\bm{r}'(0)|=1\\) （见定理1）可得\n\\[ \\tilde{\\bm{r}}''(0)\\cdot\\bm{\\beta}(s_0)=\\kappa(s_0) \\tag{142} \\] 由式(34)和式(41)可知\n\\[ \\tilde{\\bm{r}}'(0)\\cdot\\tilde{\\bm{r}}''(0)=0 \\tag{143} \\] 由式(140)和上式可知 \\(\\tilde{\\bm{r}}''(0)\\parallel\\bm{\\beta}(s_0)\\) （ \\(\\tilde{\\bm{r}}''(0)\\) 和 \\(\\bm{\\beta}(s_0)\\) 都在密切平面内）。我们可以通过调整曲线的方向来使得 \\(\\tilde{\\bm{r}}''(0)\\) 与 \\(\\bm{\\beta}(s_0)\\) 同向，这样将 \\(|\\bm{\\beta}(s_0)|=1\\) 和 \\(\\tilde{\\kappa}(0)=|\\tilde{\\bm{r}}''(0)|\\) （见 定义1）代入式(142)可得\n\\[ \\tilde{\\kappa}(0)=\\kappa(s_0) \\tag{144} \\] 因此这个圆周与原曲线在 \\(s=s_0\\) 处相切，有相同的有向密切平面，并且曲率是 \\(\\kappa(s_0)\\) ，因此它与原曲线在点 \\(s=s_0\\) 处有 \\(2\\) 阶以上的切触．通常称这个圆周为曲线 \\(\\bm{r}=\\bm{r}(s)\\) 在点 \\(s=s_0\\) 处的曲率圆，其圆心 \\(\\bm{r}(s_0)+\\cfrac{\\bm{\\beta}(s_0)}{\\kappa(s_0)}\\) 称为曲线在 \\(s=s_0\\) 处的曲率中心。其半径 \\(\\cfrac{1}{\\kappa(s_0)}\\) 称为曲线再 \\(s=s_0\\) 处的曲率半径。曲率圆形象地反映了曲线再一点处的弯曲程度。\n与球面的切触 若一条曲线 \\(C\\) 和一个曲面 \\(\\Sigma\\) 相交，同样能够用切触阶来刻画曲线和曲面的接近程度。设交点是 \\(p_0\\) 。在曲线 \\(C\\) 上取一点 \\(p_1\\) ，把曲线 \\(C\\) 上从点 \\(p_0\\) 到点 \\(p_1\\) 的弧长记为 \\(\\Delta s\\) ，把点 \\(p_1\\) 到曲面 \\(\\Sigma\\) 的距离最近的点记为 \\(p_2\\) ，则当式(127)成立时，称曲线 \\(C\\) 和曲面 \\(\\Sigma\\) 的切触阶是 \\(n\\) 。如果 \\(\\Sigma\\) 是以点 \\(A\\) 为中心、以 \\(r\\) 为半径、且与曲线 \\(C\\) 交于点 \\(p_0\\) 的球面，于是点 \\(p_2\\) 恰好是线段 \\(p_1A\\) 与球面 \\(\\Sigma\\) 的交点，所以 \\(|p_1p_2|=|p_1A|-r\\) 。因此\n\\[ \\begin{aligned} \\lim\\limits_{\\Delta s \\to 0}\\frac{|p_1p_2|}{|p_1A|^2-r^2}=\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{|p_1A|-r}{|p_1A|^2-r^2}\\\\[15pt] =\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{|p_1A|-r}{(|p_1A|-r)(|p_1A|+r)}\\\\[15pt] =\u0026\\lim\\limits_{\\Delta s \\to 0}\\frac{1}{|p_1A|+r}\\\\[15pt] =\u0026\\frac{1}{|p_0A|+r}=\\frac{1}{2r} \\end{aligned} \\tag{145} \\] 因此 \\(|p_1p_2|\\) 和 \\(|p_1A|^2-r^2\\) 作为 \\(\\Delta s\\) 的无穷小量是同阶的，因此在用式(127)求曲线和球面的切触阶时可以用 \\(|p_1A|^2-r^2\\) 代替 \\(|p_1p_2|\\) 。下面，我们来求与曲线 \\(C\\) 在一点处有最高阶切触的球面。\n设曲线 \\(C\\) 的参数方程是 \\(\\bm{r}=\\bm{r}(s)\\) ， \\(s\\) 是弧长参数，它的曲率和挠率都不为零。设球面 \\(\\Sigma\\) 与曲线 \\(C\\) 在对应于参数 \\(s=0\\) 的点 \\(p_0\\) 处相交，用 \\(\\set{p_0;\\bm{\\alpha}_0,\\bm{\\beta}_0,\\bm{\\gamma}_0}\\) 记曲线 \\(C\\) 在点 \\(p_0\\) 的Frenet标架，则球面 \\(\\Sigma\\) 的球心 \\(A\\) 可以设为\n\\[ \\overrightarrow{p_0A}=a\\bm{\\alpha}_0+b\\bm{\\beta}_0+c\\bm{\\gamma}_0, \\quad a^2+b^2+c^2=r^2 \\tag{146} \\] 其中 \\(r\\) 是球面 \\(\\Sigma\\) 的半径。把曲线 \\(C\\) 上的一点 \\(\\bm{r}(s)\\) 记为 \\(p\\) ，则由式(121)得到\n\\[ \\begin{aligned} |pA|^2-r^2=\u0026\\left(s-\\frac{\\kappa_0^2}{6}s^3+\\omicron(s^3)-a\\right)^2+\\left(\\frac{\\kappa_0}{2}s^2+\\frac{\\kappa'_0}{6}s^3+\\omicron(s^3)-b\\right)^2\\\\[15pt] \u0026+\\left(\\frac{\\kappa_0\\tau_0}{6}s^3+\\omicron(s^3)-c\\right)^2-(a^2+b^2+c^2)\\\\[15pt] =\u0026-2a\\left(s-\\frac{\\kappa_0^2}{6}s^3+\\omicron(s^3)\\right)+\\left(s-\\frac{\\kappa_0^2}{6}s^3+\\omicron(s^3)\\right)^2\\\\[15pt] \u0026-2b\\left(\\frac{\\kappa_0}{2}s^2+\\frac{\\kappa'_0}{6}s^3+\\omicron(s^3)\\right)+\\left(\\frac{\\kappa_0}{2}s^2+\\frac{\\kappa'_0}{6}s^3+\\omicron(s^3)\\right)^2\\\\[15pt] \u0026-2c\\left(\\frac{\\kappa_0\\tau_0}{6}s^3+\\omicron(s^3)\\right)+\\left(\\frac{\\kappa_0\\tau_0}{6}s^3+\\omicron(s^3)\\right)^2 \\end{aligned} \\tag{147} \\] 可得\n\\[ \\lim\\limits_{s \\to 0}\\frac{|p_1p_2|}{s}=\\lim\\limits_{s \\to 0}\\frac{|pA|^2-r^2}{s}=2a \\tag{148} \\] 因此曲线 \\(C\\) 和球面 \\(\\Sigma\\) 有 \\(1\\) 阶以上切触的条件是 \\(a=0\\) 。在此条件下，上式可化简为\n\\[ |pA|^2-r^2=s^2-b\\left(\\kappa_0s^2+\\frac{\\kappa'_0}{3}s^3\\right)-c\\frac{\\kappa_0\\tau_0}{3}s^3+\\omicron(s^3) \\tag{149} \\] 有\n\\[ \\lim\\limits_{s \\to 0}\\frac{|pA|^2-r^2}{s^2}=1-b\\kappa_0 \\tag{150} \\] 因此曲线 \\(C\\) 和球面 \\(\\Sigma\\) 有 \\(2\\) 阶以上切触的条件是\n\\[ a=0,\\quad b=\\frac{1}{\\kappa_0} \\tag{151} \\] 在此条件下，式(149)成为\n\\[ |pA|^2-r^2=\\frac{\\kappa'_0}{3\\kappa_0}s^3-c\\frac{\\kappa_0\\tau_0}{3}s^3+\\omicron(s^3) \\tag{152} \\] 有\n\\[ \\lim\\limits_{s \\to 0}\\frac{|pA|^2-r^2}{s^3}=\\frac{\\kappa'_0}{3\\kappa_0}-c\\frac{\\kappa_0\\tau_0}{3} \\tag{153} \\] 因此，曲线 \\(C\\) 和球面 \\(\\Sigma\\) 有三阶以上切触的条件是\n\\[ a=0,\\quad b=\\frac{1}{\\kappa_0},\\quad c=-\\frac{\\kappa'_0}{\\kappa_0^2\\tau_0}=\\frac{1}{\\tau(s)}\\left.\\left(\\frac{1}{\\kappa(s)}\\right)'\\right|_{s=0} \\tag{154} \\] 并且一般说来，曲线 \\(C\\) 和球面 \\(\\Sigma\\) 的最高切触阶只能是 \\(3\\) 。上面的结果可以叙述成如下定理。\n定理11： \\(C:\\bm{r}=\\bm{r}(s)\\) 是曲率和挠率都不为零的正则参数曲线， \\(s\\) 是弧长参数，则在 \\(s\\) 处与曲线 \\(C\\) 有 \\(3\\) 阶以上切触的球面 \\(\\Sigma\\) 的球心是\n\\[ \\bm{r}(s)+\\frac{1}{\\kappa(s)}\\bm{\\beta}(s)+\\frac{1}{\\tau(s)}\\left(\\frac{1}{\\kappa(s)}\\right)'\\bm{\\gamma}(s) \\tag{155} \\] 半径是\n\\[ \\sqrt{\\left(\\frac{1}{\\kappa(s)}\\right)^2+\\left(\\frac{1}{\\tau(s)}\\left(\\frac{1}{\\kappa(s)}\\right)'\\right)^2} \\tag{156} \\] 该球面称为曲线 \\(C\\) 在 \\(s\\) 处的密切球面，其球心所在的直线\n\\[ \\bm{r}=\\bm{r}(\\lambda)=\\bm{r}(s)+\\frac{1}{\\kappa(s)}\\bm{\\beta}(s)+\\lambda\\bm{\\gamma}(s) \\tag{157} \\] 是通过曲线 \\(C\\) 的曲率中心、垂直于密切平面的直线，称为曲线 \\(C\\) 在 \\(s\\) 处的曲率轴。\n注：取 \\(\\lambda=0\\) 可得 \\(\\bm{r}(0)=\\bm{r}(s)+\\cfrac{1}{\\kappa(s)}\\bm{\\beta}(s)\\) ，该点即为曲率圆圆心（见式(137)）。求导得 \\(\\bm{r}'(\\lambda)=\\bm{\\gamma}(s)\\) 可得该直线垂直于密切平面。\n最后我们要指出，构造曲线的Frenet标架的过程正是曲线的参数方程逐次求导的过程。实际上，Frenet标架 \\(\\set{\\bm{\\alpha}(t),\\bm{\\beta}(t),\\bm{\\gamma}(t)}\\) 是 \\(\\set{\\bm{r}'(t),\\bm{r}''(t),\\bm{r}'''(t)}\\) 经过Schmit正交化得到的。 \\(\\bm{r}'(t)\\) 决定了曲线的切线而曲线的曲率是曲线切线的方向关于弧长的变化率。 \\(\\bm{r}'(t),\\bm{r}''(t)\\) 决定了曲线的密切平面。如果曲线的密切平面的方向不变，则它必定是平面曲线。如果该曲线不是平面曲线，则它的密切平面的方向关于弧长的变化率是曲线的挠率，它反映了曲线的扭曲程度。很明显，曲线方程的更高次导数仍然能够表示成Frenet标架向量的线性组合，其系数是曲率 \\(\\kappa\\) 和挠率 \\(\\tau\\) 及其各阶导数。\n存在对应关系的曲线偶 本节我们要研究存在一定的对应关系的曲线偶．假定在正则参数曲线 \\(C_1:\\bm{r}=\\bm{r}_1(t)\\) 和正则参数曲线 \\(C_2:\\bm{r}=\\bm{r}_2(u)\\) 之间存在一个对应，这个对应可以用参数 \\(t\\) 和 \\(u\\) 之间的一个对应来表示，设为 \\(u=u(t)\\) 如果 \\(u'(t)\\ne 0\\) ，则 \\(u=u(t)\\) 可以认为是曲线 \\(C_2\\) 的正则参数变换，于是曲线 \\(C_1\\) 和 \\(C_2\\) 之间的对应成为曲线 \\(C_1\\) 和 \\(C_2\\) 之间有相同参数的点之间的对应。\nBertrand曲线偶 定义 定义3：如果在互不重合的曲线 \\(C_1\\) 和 \\(C_2\\) 之间存在一个对应，使得它们在每一对对应点有公共的主法线，则称这两条曲线为Bertrand曲线偶，其中没一条曲线称为另外一条曲线的侣线，或共轭曲线。\n每一条平面曲线都有侣线，构成Bertrand曲线偶。事实上，设 \\(\\bm{r}=\\bm{r}(s)\\) 是在平面上的一条曲线，以 \\(s\\) 为它的弧长参数。于是， \\(\\bm{r}'(s)\\) 是曲线的单位切向量场，由式(46)和式(47)可得\n\\[ \\bm{r}''(s)=\\kappa(s)\\bm{n}(s) \\tag{158} \\] 这里 \\(\\bm{n}(s)\\) 是沿曲线定义的法向量场。命\n\\[ \\bm{r}_1(s)=\\bm{r}(s)+\\lambda\\bm{n}(s) \\tag{159} \\] 其中 \\(\\lambda\\) 是任意给定的一个非零实数，则\n\\[ \\bm{r}'_1(s)=\\bm{r}'(s)+\\lambda\\bm{n}'(s) \\tag{160} \\] 根据Euclid空间-定理3的 (1) 和 \\(|\\bm{r}'(s)|=1\\) 有\n\\[ \\bm{r}'(s)\\cdot\\bm{n}(s)=\\frac{1}{\\kappa(s)}\\bm{r}'(s)\\cdot\\bm{r}''(s)=0 \\tag{161} \\] 同样由 \\(|\\bm{n}(s)|=1\\) 有\n\\[ \\bm{n}(s)\\cdot\\bm{n}'(s)=0 \\tag{162} \\] 因此\n\\[ \\bm{r}_1'(s)\\cdot\\bm{n}(s)=\\bm{r}'(s)\\cdot\\bm{n}(s)+\\lambda\\bm{n}'(s)\\cdot\\bm{n}(s)=0 \\tag{163} \\] 注意 \\(\\bm{r}_1(s)\\) 也是平面曲线，所以 \\(\\bm{n}(s)\\) 也是曲线 \\(\\bm{r}_1(s)\\) 的法向量场。由此可见，曲线 \\(\\bm{r}(s)\\) 和 \\(\\bm{r}_1(s)\\) 在对应点有相同的法线（也是主法线）。因此，寻求Bertrand曲线偶应该在空间挠曲线（即挠率不为零的曲线）中去找。\n对应点的常数距离和定切线夹角性质 定理12：设曲线 \\(C_1\\) 和 \\(C_2\\) 是Bertrand曲线偶，则 \\(C_1\\) 和 \\(C_2\\) 的对应点之间的距离是常数，并且 \\(C_1\\) 和 \\(C_2\\) 在对应点的切线成定角。\n证明（定理12）：设曲线 \\(C_1\\) 和 \\(C_2\\) 的参数方程分别是 \\(\\bm{r}_1(s)\\) 和 \\(\\bm{r}_2(s)\\) ，并且曲线 \\(C_1\\) 和 \\(C_2\\) 之间的对应是有相同参数的点之间的对应，而且 \\(s\\) 是曲线 \\(C_1\\) 的弧长参数．用 \\(\\set{\\bm{r}_1(s);\\bm{\\alpha}_1(s),\\bm{\\beta}_1(s),\\bm{\\gamma}_1(s)}\\) 表示曲线 \\(C_1\\) 的Frenet标架，用 \\(\\set{\\bm{r}_2(s);\\bm{\\alpha}_2(s),\\bm{\\beta}_2(s),\\bm{\\gamma}_2(s)}\\) 表示曲线 \\(C_2\\) 的Frenet标架，但是参数 \\(s\\) 未必是曲线 \\(r_2(s)\\) 的弧长参数，假定曲线 \\(r_2(s)\\) 的弧长参数是 \\(\\tilde{s}\\) 。因为曲线 \\(C_1\\) 和 \\(C_2\\) 在对应点有相同的主法线，故（注意是相同的主法线，而不是主法向量）\n\\[ \\bm{r}_2(s)=\\bm{r}_1(s)+\\lambda(s)\\bm{\\beta}_1(s) \\tag{164} \\] 并且 \\(\\bm{\\beta}_1(s)=\\pm\\bm{\\beta}_2(s)\\) 。利用公式1对上式求导数得到\n\\[ \\begin{aligned} \\bm{\\alpha}_2(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}=\u0026\\bm{\\alpha}_1(s)+\\lambda'(s)\\bm{\\beta}_1(s)+\\lambda(s)(-\\kappa_1(s)\\bm{\\alpha}_1(s)+\\tau_1(s)\\bm{\\gamma}_1(s))\\\\[5pt] =\u0026(1-\\lambda(s)\\kappa_1(s))\\bm{\\alpha}_1(s)+\\lambda'(s)\\bm{\\beta}_1(s)+\\lambda(s)\\tau_1(s)\\bm{\\gamma}_1(s) \\end{aligned} \\tag{165} \\] 因为 \\(\\bm{\\beta}_1(s)=\\pm\\bm{\\beta}_2(s)\\) ，所以两边点乘 \\(\\bm{\\beta}_2(s)\\) 得到\n\\[ \\bm{\\alpha}_2(s)\\cdot\\bm{\\beta}_2(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}=0=\\pm\\lambda'(s)\\bm{\\beta}_1(s)\\cdot\\bm{\\beta}_1(s) \\tag{166} \\] 故 \\(\\lambda'(s)=0\\) ，即\n\\[ \\lambda(s)=\\lambda=常数 \\tag{167} \\] 因此\n\\[ |\\bm{r}_2(s)-\\bm{r}_1(s)|=|\\lambda(s)\\bm{\\beta}_1(s)|=|\\lambda| \\tag{168} \\] 对 \\(\\bm{\\alpha}_1(s)\\cdot\\bm{\\alpha}_2(s)\\) 求导并利用公式1得到\n\\[ \\frac{\\mathrm{d}}{\\mathrm{d}s}(\\bm{\\alpha}_1(s)\\cdot\\bm{\\alpha}_2(s))=\\kappa_1(s)\\bm{\\beta}_1(s)\\cdot\\bm{\\alpha}_2(s)+\\kappa_2(s)\\bm{\\alpha}_1(s)\\cdot\\bm{\\beta}_2(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s} \\tag{169} \\] 注意 \\(\\bm{\\beta}_1(s)=\\pm\\bm{\\beta}_2(s)\\) 且 \\(\\bm{\\alpha}_1(s)\\cdot\\bm{\\beta}_1(s)=0,\\bm{\\alpha}_2(s)\\cdot\\bm{\\beta}_2(s)=0\\) ，因此\n\\[ \\frac{\\mathrm{d}}{\\mathrm{d}s}(\\bm{\\alpha}_1(s)\\cdot\\bm{\\alpha}_2(s))=0 \\tag{170} \\] 故曲线 \\(C_1\\) 和 \\(C_2\\) 在对应点的切线成定角。证毕。\n存在的充分必要条件 定理13：设正则参数曲线 \\(C\\) 的曲率 \\(\\kappa\\) 和挠率 \\(\\tau\\) 都不是零，则存在另一条正则参数曲线 \\(C_1\\) ，使得曲线 \\(C_1\\) 和 \\(C\\) 称为Bertrand曲线偶的充分必要条件是，存在常数 \\(\\lambda\\ne 0\\) 和 \\(\\mu\\) 使得\n\\[ \\lambda\\kappa+\\mu\\tau=1 \\tag{171} \\] 证明（定理13）：先证必要性。设曲线 \\(C\\) 有侣线 \\(C_1\\) ，它们的参数方程分别是 \\(\\bm{r}(s)\\) 和 \\(\\bm{r}_1(s)\\) ，并且曲线 \\(C\\) 和 \\(C_1\\) 的对应是有相同参数的点之间的对应，而且 \\(s\\) 是曲线 \\(C\\) 的弧长参数。设 \\(\\tilde{s}\\) 是曲线 \\(C_1\\) 的弧长参数。用 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s),\\bm{\\gamma}(s)}\\) 表示曲线 \\(C\\) 的Frenet标架，则由式(165)和式(167)有\n\\[ \\bm{\\alpha}_1(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}=(1-\\lambda\\kappa(s))\\bm{\\alpha}(s)+\\lambda\\tau(s)\\bm{\\gamma}(s) \\tag{172} \\] 其中 \\(\\lambda\\ne 0\\) 是常数，因此\n\\[ \\left|\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}\\right|^2=(1-\\lambda\\kappa(s))^2+(\\lambda\\tau(s))^2 \\tag{173} \\] 另一方面，由定理12可知 \\(\\bm{\\alpha}(s)\\cdot\\bm{\\alpha}_1(s)=常数\\) ，并且由式(172)两边点乘 \\(\\bm{\\alpha}(s)\\) 并由Frenet标架的正交性得到\n\\[ \\bm{\\alpha}(s)\\cdot\\bm{\\alpha}_1(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}=1-\\lambda\\kappa(s) \\tag{174} \\] 所以\n\\[ \\frac{1-\\lambda\\kappa(s)}{\\sqrt{(1-\\lambda\\kappa(s))^2+(\\lambda\\tau(s))^2}}=常数 \\tag{175} \\] 化简可得\n\\[ \\frac{1-\\lambda\\kappa(s)}{\\tau(s)}=\\mu=常数 \\tag{176} \\] 即\n\\[ \\lambda\\kappa(s)+\\mu\\tau(s)=1 \\tag{177} \\] 反过来，设正则参数曲线 \\(C\\) 的参数方程是 \\(\\bm{r}(s)\\) ， \\(s\\) 是弧长参数，并且它的曲率 \\(\\kappa\\) 和挠率 \\(\\tau\\) 满足关系是 \\(\\lambda\\kappa(s)+\\mu\\tau(s)=1\\) ，其中 \\(\\lambda\\ne 0\\) ， \\(\\mu\\) 是常数。构作曲线 \\(C_1\\) ，使它的参数方程是\n\\[ \\bm{r}_1(s)=\\bm{r}(s)+\\lambda\\bm{\\beta}(s) \\tag{178} \\] 则由公式1可得\n\\[ \\begin{aligned} \\bm{r}_1'(s)=\u0026\\bm{\\alpha}(s)+\\lambda(-\\kappa\\bm{\\alpha}(s)+\\tau(s)\\bm{\\gamma}(s))\\\\[5pt] =\u0026(1-\\lambda\\kappa(s))\\bm{\\alpha}(s)+\\lambda\\tau(s)\\bm{\\gamma}(s)\\\\[5pt] =\u0026\\mu\\tau(s)\\bm{\\alpha}(s)+\\lambda\\tau(s)\\bm{\\gamma}(s) \\end{aligned} \\tag{179} \\] 由式(50)和 \\(\\bm{\\alpha}(s),\\bm{\\gamma}(s)\\) 的单位向量性质可得曲线 \\(\\bm{r}_1(s)\\) 的单位切向量是\n\\[ \\begin{aligned} \\bm{\\alpha}_1(s)=\u0026\\frac{\\bm{r}_1'(s)}{|\\bm{r}_1'(s)|}=\\frac{\\bm{r}_1'(s)}{\\sqrt{\\bm{r}_1'(s)\\cdot\\bm{r}_1'(s)}}\\\\[15pt] =\u0026\\frac{\\mu}{\\sqrt{\\lambda^2+\\mu^2}}\\bm{\\alpha}(s)+\\frac{\\lambda}{\\sqrt{\\lambda^2+\\mu^2}}\\bm{\\gamma}(s) \\end{aligned} \\tag{180} \\] 若用 \\(\\tilde{s}\\) 记曲线 \\(C_1\\) 的弧长参数，则上式两边对 \\(s\\) 求导，并两边分别使用公式1可得\n\\[ \\begin{aligned} \\frac{\\mathrm{d}\\bm{\\alpha}_1(s)}{\\mathrm{d}\\tilde{s}}\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}=\u0026\\kappa_1(s)\\bm{\\beta}_1(s)\\frac{\\mathrm{d}\\tilde{s}}{\\mathrm{d}s}\\\\[15pt] =\u0026\\left(\\frac{\\mu}{\\sqrt{\\lambda^2+\\mu^2}}\\kappa(s)+\\frac{\\lambda}{\\sqrt{\\lambda^2+\\mu^2}}\\tau(s)\\right)\\bm{\\beta}(s) \\end{aligned} \\tag{181} \\] 注意这个等式两边都是向量，因此 \\(\\bm{\\beta}_1(s)\\) 和 \\(\\bm{\\beta}(s)\\) 共线，但是 \\(\\bm{\\beta}_1(s)\\) 和 \\(\\bm{\\beta}(s)\\) 的模长都是 \\(1\\) ，因此 \\(\\bm{\\beta}_1(s)=\\pm\\bm{\\beta}(s)\\) 。注意由式(178)， \\(\\bm{\\beta}(s)\\) 即为 \\(\\bm{r}(s)\\) 指向 \\(\\bm{r}_1(s)\\) 的方向，因此 \\(C_1\\) 和 \\(C\\) 在 \\(s\\) 对应点有相同的主法线，构成Bertrand曲线偶。\n渐伸线与渐缩线 定义 定义4：如果在曲线 \\(C_1\\) 和 \\(C_2\\) 之间存在一个对应，使得曲线 \\(C_1\\) 在任意一点的切线恰好是曲线 \\(C_2\\) 在对应点的法线，则称曲线 \\(C_2\\) 是 \\(C_1\\) 的渐伸线，同时称曲线 \\(C_1\\) 是 \\(C_2\\) 的渐缩线。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图5\u0026emsp;渐伸线和渐缩线\n求渐伸线 定理14：设正则参数曲线 \\(C\\) 的参数方程是 \\(\\bm{r}(s)\\) ， \\(s\\) 是弧长参数，则 \\(C\\) 的渐伸线的参数方程是\n\\[ \\bm{r}=\\bm{r}(s)+(c-s)\\bm{\\alpha}(s) \\tag{182} \\] 其中 \\(c\\) 是任意的常数。\n证明（定理14）：设\n\\[ \\bm{r}_1(s)=\\bm{r}(s)+\\lambda(s)\\bm{\\alpha}(s) \\tag{183} \\] 是曲线 \\(C\\) 的渐伸线。由渐伸线的定义定义4可知， \\(\\bm{\\alpha}(s)\\) 是曲线 \\(\\bm{r}_1(s)\\) 的法向量。对上式求导并利用公式1可得\n\\[ \\bm{r}_1'(s)=(1+\\lambda'(s))\\bm{\\alpha}(s)+\\lambda(s)\\kappa(s)\\bm{\\beta}(s) \\tag{184} \\] 将上式两边与 \\(\\bm{\\alpha}(s)\\) 作点乘。注意 \\(\\bm{\\alpha}(s)\\) 是 \\(\\bm{r}_1(s)\\) 的法向量，所以与切向量 \\(\\bm{r}_1'(s)\\) 垂直。因此再利用 \\(\\bm{\\alpha}(s)\\) 和 \\(\\bm{\\beta}(s)\\) 的正交性\n\\[ 1+\\lambda'(s)=\\bm{r}_1'(s)\\cdot\\bm{\\alpha}(s)=0 \\tag{185} \\] 因此\n\\[ \\lambda(s)=c-s \\tag{186} \\] 将上式代入式(183)可得结果。证毕。\n曲线的渐伸线可以看作该曲线的切线族的正交轨线，而式(182)可以解释为：将一条软线沿曲线放置，把一端固定，另一端慢慢离开原曲线并且把软线抻直，使软线抻直的部分始终保持为原曲线的切线则这另一端描出的曲线就是原曲线的渐伸线。\n求渐缩线 定理15：设正则参数曲线 \\(C\\) 的参数方程是 \\(\\bm{r}(s)\\) ， \\(s\\) 是弧长参数，则 \\(C\\) 的渐缩线的参数方程是\n\\[ \\bm{r}=\\bm{r}(s)+\\frac{1}{\\kappa(s)}\\bm{\\beta}(s)-\\frac{1}{\\kappa(s)}\\left(\\tan \\int \\tau(s)\\mathrm{d}s \\right)\\bm{\\gamma}(s) \\tag{187} \\] 证明（定理15）：设\n\\[ \\bm{r}_1(s)=\\bm{r}(s)+\\lambda(s)\\bm{\\beta}(s)+\\mu(s)\\bm{\\gamma}(s) \\tag{188} \\] 是曲线的渐缩线。那么 \\(\\lambda(s)\\bm{\\beta}(s)+\\mu(s)\\bm{\\gamma}(s)\\) 应该与曲线 \\(\\bm{r}_1(s)\\) 的切向量 \\(\\bm{r}_1'(s)\\) 平行。对上式求导再由公式1得到\n\\[ \\bm{r}_1'(s)=(1-\\lambda(s)\\kappa(s))\\bm{\\alpha}(s)+(\\lambda'(s)-\\mu(s)\\tau(s))\\bm{\\beta}(s)+(\\mu'(s)+\\lambda(s)\\tau(s))\\bm{\\gamma}(s) \\tag{189} \\] 上式平行于 \\(\\lambda(s)\\bm{\\beta}(s)+\\mu(s)\\bm{\\gamma}(s)\\) 。又因为 \\(\\bm{\\alpha}(s),\\bm{\\beta}(s),\\bm{\\gamma}(s)\\) 是三个正交归一化矢量，所以其系数应该成比例，即\n\\[ \\lambda(s)\\kappa(s)=1 \\tag{190} \\] \\[ \\frac{\\lambda'(s)-\\mu(s)\\tau(s)}{\\lambda(s)}=\\frac{\\mu'(s)+\\lambda(s)\\tau(s)}{\\mu(s)} \\tag{191} \\]\n由式(191)得到\n\\[ \\lambda'(s)\\mu(s)-\\mu'(s)\\lambda(s)=(\\lambda^2(s)+\\mu^2(s))\\tau(s) \\tag{192} \\] 因此\n\\[ \\frac{\\mathrm{d}}{\\mathrm{d}s}\\left(\\frac{\\mu(s)}{\\lambda(s)}\\right)=-\\tau(s) \\tag{193} \\] 故\n\\[ \\arctan \\left(\\frac{\\mu(s)}{\\lambda(s)}\\right)=-\\int \\tau(s) \\mathrm{d}s \\tag{194} \\] 所以将上式和式(190)合并可得\n\\[ \\lambda(s)=\\frac{1}{\\kappa(s)},\\quad \\mu(s)=-\\frac{1}{\\kappa(s)}\\tan \\int \\tau(s) \\mathrm{d}s \\tag{195} \\] 证毕。\n平面曲线 参数方程与平面Frenet标架 平面曲线可以看作挠率为零的空间曲线（定理4），因此前面的讨论适用于平面曲线的情形．但是平面曲线有它自身的特点，因此本节只限于平面本身（而不考虑外围的空间）研究其中的曲线的弯曲性质。\n在平面 \\(E^3\\) 的右手Cartesian直角坐标系下，曲线 \\(\\bm{r}=\\bm{r}(s)\\) 可以表示为\n\\[ \\bm{r}(s)=(x(s),y(s)) \\tag{196} \\] 其中 \\(s\\) 是弧长参数，因此它的单位切向量是\n\\[ \\bm{\\alpha}(s)=(x'(s),y'(s)),\\quad (x'(s))^2+(y'(s))^2=1 \\tag{197} \\] 因为 \\(E^3\\) 是有向平面，故可以把 \\(\\bm{\\alpha}(s)\\) 沿正向转 \\(90\\degree\\) 得到唯一的一个与 \\(\\bm{\\alpha}(s)\\) 垂直的单位向量 \\(\\bm{\\beta}(s)\\) ，很明显\n\\[ \\bm{\\beta}(s)=(-y'(s),x'(s)) \\tag{198} \\] 这样，沿平面曲线 \\(\\bm{r}=\\bm{r}(s)\\) 有一个定义好的右手单位正交标架场 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s)}\\) ，它在平面曲线的理论中所担当的角色相当 \\(E^3\\) 空间曲线的Frenet标架，称为平面曲线的Frenet标架。值得指出的是，平面曲线的Frenet标架场 \\(\\set{\\bm{r}(s);\\bm{\\alpha}(s),\\bm{\\beta}(s)}\\) 的确定只用到曲线参数方程的一阶导数， \\(\\bm{\\beta}(s)\\) 是曲线的法向量，它与曲线的主法向量可能差一个正负号。\n相对曲率 由于 \\(\\bm{\\alpha}(s)\\) 是单位向量场，由Euclid空间-定理3的 (1) 有 \\(\\bm{\\alpha}(s)\\perp\\bm{\\alpha}'(s)\\) ，所以 \\(\\bm{\\alpha}'(s)\\) 是 \\(\\bm{\\beta}(s)\\) 的倍数，设为\n\\[ \\bm{\\alpha}'(s)=\\kappa_r(s)\\bm{\\beta}(s) \\tag{199} \\] 因此\n\\[ \\begin{aligned} \\kappa_r(s)=\u0026\\bm{\\alpha}'(s)\\cdot\\bm{\\beta}(s)=-x''(s)y'(s)+y''(s)x'(s)\\\\[10pt] =\u0026 \\begin{vmatrix} x'(s) \u0026 y'(s) \\\\[5pt] x''(s) \u0026 y''(s) \\end{vmatrix} \\end{aligned} \\tag{200} \\] 我们把 \\(\\kappa_r(s)\\) 称为平面曲线的相对曲率，如果该曲线的曲率是 \\(\\kappa(s)\\) ，则有\n\\[ \\kappa_r(s)=\\pm\\kappa(s) \\tag{201} \\] 其中“\\(+\\)”号表示曲线朝 \\(\\bm{\\beta}(s)\\) 所指的方向弯曲， \\(\\bm{\\beta}(s)\\) 恰好是曲线的主法向量，而“\\(-\\)” 号表示曲线朝 \\(\\bm{\\beta}(s)\\) 所指的相反方向弯曲，曲线的主法向量是 \\(-\\bm{\\beta}(s)\\) 。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图6\u0026emsp;平面曲线\n平面曲线的Frenet标架的运动公式成为\n\\[ \\begin{cases} \\bm{r}'(s)=\\bm{\\alpha}(s)\\\\[5pt] \\bm{\\alpha}'(s)=\\kappa_r(s)\\bm{\\beta}(s)\\\\[5pt] \\bm{\\beta}'(s)=-\\kappa_r(s)\\bm{\\alpha}(s) \\end{cases} \\tag{202} \\] 平面曲线的曲率中心是 \\(\\bm{r}(s)+\\cfrac{\\bm{\\beta}(s)}{\\kappa_r(s)}\\) （见见曲率中心），这也是平面曲线的渐缩线的参数方程（式(187)取 \\(\\tau(s)=0\\) ）。\n方向角 用 \\(\\theta(s)\\) 表示单位切向量 \\(\\bm{\\alpha}(s)\\) 与 \\(x\\) 轴的正向所构成的角，成为向量 \\(\\bm{\\alpha}(s)\\) 的方向角。方向角是一个多值函数，但是在 \\(s\\) 的一个小范围内总是可以取出函数 \\(\\theta(s)\\) 的一个连续分支。此时\n\\[ \\bm{\\alpha}(s)=(\\cos\\theta(s),\\sin\\theta(s)),\\quad \\bm{\\beta}(s)=(-\\sin\\theta(s),\\cos\\theta(s)) \\tag{203} \\] 即\n\\[ x'(s)=\\cos\\theta(s),\\quad y'(s)=\\sin\\theta(s) \\tag{204} \\] 再求导得到\n\\[ x''(s)=-\\sin\\theta(s)\\cdot\\theta'(s),\\quad y''(s)=\\cos\\theta(s)\\cdot\\theta'(s) \\tag{205} \\] 代入式(200)可得\n\\[ \\kappa_r(s)=\\frac{\\mathrm{d}\\theta(s)}{\\mathrm{d}s} \\tag{206} \\] 上面的式子清楚地说明了相对曲率 \\(\\kappa_r(s)\\) 的几何意义。对于平面曲线来说，曲线论基本定理成为下面的显式表达式\n\\[ \\theta(s)=\\theta(s_0)+\\int_{s_0}^{s}\\kappa_r(s)\\mathrm{d}s \\tag{207} \\] \\[ x(s)=x(s_0)+\\int_{s_0}^{s}\\cos\\theta(s)\\mathrm{d}s \\tag{208} \\] \\[ y(s)=y(s_0)+\\int_{s_0}^{s}\\sin\\theta(s)\\mathrm{d}s \\tag{209} \\]\n若平面曲线 \\(\\bm{r}=\\bm{r}(t)\\) 的参数方程是\n\\[ \\bm{r}(t)=(x(t),y(t)) \\tag{210} \\] 其中 \\(t\\) 未必是弧长参数。由式(33)知曲线的弧长元素是\n\\[ \\mathrm{d}s=|\\bm{r}'(t)|\\mathrm{d}t=\\sqrt{(x')^2+(y')^2}\\mathrm{d}t \\tag{211} \\] 因此由式(50)，它的单位切向量是\n\\[ \\bm{\\alpha}(t)=\\frac{\\bm{r}'(t)}{|\\bm{r}'(t)|}=\\left(\\frac{x'}{\\sqrt{(x')^2+(y')^2}},\\frac{y'}{\\sqrt{(x')^2+(y')^2}}\\right) \\tag{212} \\] 法向量是\n\\[ \\bm{\\beta}(t)=\\left(-\\frac{y'}{\\sqrt{(x')^2+(y')^2}},\\frac{x'}{\\sqrt{(x')^2+(y')^2}}\\right) \\tag{213} \\] 因此由式(200)和式(211)，曲线 \\(C\\) 的相对曲率是\n\\[ \\begin{aligned} \\kappa_r(t)=\u0026\\frac{\\mathrm{d}\\bm{\\alpha}(t)}{\\mathrm{d}s}\\cdot\\bm{\\beta}(t)=\\frac{\\mathrm{d}t}{\\mathrm{d}s}\\cdot\\bm{\\alpha}'(t)\\cdot\\bm{\\beta}(t)\\\\[15pt] =\u0026\\frac{x'(t)y''(t)-x''(t)y'(t)}{\\sqrt{((x')^2+(y')^2)^3}} \\end{aligned} \\tag{214} \\] 对于整条平面曲线 \\(\\bm{r}=\\bm{r}(s),\\space a \\le s \\le b\\) 而言，也能取出其方向角的连续分支 \\(\\theta(s)\\) 。事实上，在每一点处单位切向量 \\(\\bm{\\alpha}(s)\\) 的方向角确定到差 \\(2\\pi\\) 的整数倍。这样，我们可以将区间划分得充分的小，设为\n\\[ a = s_0 \u003c s_1 \u003c \\cdots \u003c s_n = b \\tag{215} \\] 使得在每一小段区间 \\([s_i,s_{i+1}]\\) 上，方向角的连续分支 \\(\\theta(s)\\) 的变差不超过 \\(\\pi\\) 。然后，从 \\([s_0,s_1]\\) 的一个连续分支出发，通过 \\(s_1,s_2,\\cdots\\) 处的连续性条件，依次唯一地确定了各个区间 \\([s_i,s_{i+1}]\\) 上的连续分支 \\(\\theta(s)\\) ，最终得到定义在整条曲线上的方向角连续分支 \\(\\theta(s)\\) 。由此可见，方向角任意两个连续分支 \\(\\theta(s)\\) 和 \\(\\tilde{\\theta}(s)\\) 之间差 \\(2\\pi\\) 个整数倍，即有整数 \\(k\\) 使得\n\\[ \\tilde{\\theta}(s)-\\theta(s)=2k\\pi \\tag{216} \\] 由于左边的 \\(s\\) 是连续函数，因此 \\(k\\) 只能是常数，故一条平面曲线的方向角的总变差与连续分支的取法无关，即\n\\[ \\tilde{\\theta}(b)-\\tilde{\\theta}(a)=\\theta(b)-\\theta(a) \\tag{217} \\] 由式(207)可知\n\\[ \\theta(b)-\\theta(a)=\\int_a^b\\kappa_r(s)\\mathrm{d}s \\tag{218} \\] 光滑闭曲线 如果 \\(\\bm{r}=\\bm{r}(s),a\\le s \\le b\\) 是 \\(E^3\\) 上的一条光滑曲线，并且\n\\[ \\bm{r}(b)=\\bm{r}(a),\\quad \\bm{r}'(b)=\\bm{r}'(a),\\quad \\bm{r}''(b)=\\bm{r}''(a),\\quad \\cdots \\tag{219} \\] 则称它为光滑闭曲线。如果 \\(\\bm{r}=\\bm{r}(s),a\\le s \\le b\\) 是若干段光滑曲线首尾相接而成的，并且 \\(\\bm{r}(b)=\\bm{r}(a)\\) ，则称它是分段光滑的闭曲线。\n如果 \\(\\bm{r}=\\bm{r}(s),a\\le s \\le b\\) 是 \\(E^3\\) 上的一条闭曲线，并且对任意的 \\(a \\le s_1 \u003c s_2 \u003c b\\) ，都有\n\\[ \\bm{r}(s_1)\\ne\\bm{r}(s_2) \\tag{220} \\] 则称该曲线是简单的。简单闭曲线就是没有自交点的闭曲线。\n旋转指标 对于连续可微的闭曲线\n\\[ C:\\bm{r}=\\bm{r}(s),\\quad a \\le s \\le b \\tag{221} \\] 它的单位切向量 \\(\\bm{\\alpha}(s)\\) 绕曲线转一圈回到起点时与原来的单位切向量重合，因此方向角的总变差 \\(\\theta(b)-\\theta(a)\\) 一定是 \\(2\\pi\\) 的整数倍，它与方向角连续分支 \\(\\bm{\\alpha}(s)\\) 无关。命\n\\[ i(C)=\\frac{1}{2\\pi}(\\theta(b)-\\theta(a)) \\tag{222} \\] 称为连续可谓闭曲线 \\(C\\) 的旋转指标。\n定理16（Hopf Umlaufsatz定理）：若 \\(C\\) 是平面 \\(E^2\\) 上一条连续可微的简单闭曲线，则它的旋转指标 \\(i(C)=\\pm 1\\) 。\n要证明定理16，首先证明如下两个引理。\n引理1：对于区间 \\(I=[a,b]\\) ，函数 \\(f\\in C(I,S^1)\\) 满足 \\(f(a)=f(b)\\) ，则存在 \\(\\theta\\in C(I,\\R)\\) 使得 \\(f(t)=(\\cos\\theta(t),\\sin\\theta(t)),\\forall t \\in I\\) 。其中 \\(S^1\\) 表示以原点为中心的单位圆。并称 \\(\\cfrac{1}{2\\pi}(\\theta(b)-\\theta(a))\\) 为 \\(f\\) 的角度改变量（注意 \\(f(a)=f(b)\\) ，因此 \\(\\theta(b)-\\theta(a)\\) 必为 \\(2\\pi\\) 的整数倍）。\n证明（引理1）：任取一点 \\(t_0 \\in I\\) ，由 \\(f\\) 的连续性，存在 \\(\\varepsilon_0\u003e0\\) 和连续函数 \\(\\theta_{t_0}\\) 使得 \\(f(t)=(\\cos\\theta_{t_0}(t),\\sin\\theta_{t_0}(t))\\) ，对于任意 \\(t \\in (t_0-\\varepsilon_0,t_0+\\varepsilon_0)\\cap I\\) 成立。注意对于所有 \\(t_0 \\in I\\) 都有这样的 \\((t_0-\\varepsilon_0,t_0+\\varepsilon_0)\\cap I\\) 成立，但是由有限覆盖定理，存在其中的有限个区间 \\(\\set{t_i-\\varepsilon_i,t_i+\\varepsilon_i}_{i=1}^{N}\\) 覆盖 \\(I\\) 。不妨设 \\(t_1 \u003c t_2 \u003c \\cdots \u003c t_N \\) ，记 \\(I_i=(t_i-\\varepsilon_i,t_i+\\varepsilon_i)\\) ，则相邻开区间交集非空，并且由 \\(f(t),\\cos\\theta,\\sin\\theta\\) 的连续性可知交集处的 \\(f(t)\\) 不会出现多值，即 \\(f(t)_{t_i}=f(t)_{t_{i+1}},\\theta(t)_{t_i}=\\theta(t)_{t_{i+1}},t\\in I_i \\cap I_{i+1} \\cap I\\) 。定义 \\(\\theta(t)=\\theta_{t_i}(t)\\) 当 \\( t \\in I_i \\cap I\\) ，则 \\(\\theta(t)\\) 连续，即满足条件的角函数。\n引理2：对于区间 \\(I=[a,b]\\) ，函数 \\(f_1,f_2 \\in C(I,S^1)\\) 满足 \\(f_1(a)=f_1(b),f_2(a)=f_2(b)\\) 。若 \\(f_1\\) 与 \\(f_2\\) 的角度改变量不相等，则存在 \\(t_0 \\in I\\) 使得 \\(f_1(t_0)=-f_2(t_0)\\) 。相反，若不存在 \\(t \\in I\\) 使得 \\(f_1(t)=-f_2(t)\\) ，则 \\(f_1\\) 与 \\(f_2\\) 角度改变量相等。\n证明（引理2）：记 \\(\\theta_1,\\theta_2\\) 分别为 \\(f_1,f_2\\) 的角函数，由引理1可知 \\(\\theta_1,\\theta_2\\) 在 \\([a,b]\\) 上连续。设 \\(\\delta(t)=\\theta_2(t)-\\theta_1(t)\\) ，则\n\\[ |\\delta(b)-\\delta(a)|=|(\\theta_2(b)-\\theta_2(a))-(\\theta_1(b)-\\theta_1(a))|\\ge 2\\pi \\tag{223} \\] 因为 \\(\\theta_2(b)-\\theta_2(a)\\) 和 \\(\\theta_1(b)-\\theta_1(a)\\) 分别是 \\(f_1\\) 和 \\(f_2\\) 的角度改变量，而 \\(f_1\\) 和 \\(f_2\\) 的角度改变量又不相等，所以至少相差 \\(2\\pi\\) 。由上式和介值定理可知， \\(\\delta(a)\\) 和 \\(\\delta(b)\\) 之间必然存在一个 \\(t_0 \\in [a,b]\\) 使得\n\\[ \\delta(t_0)=\\theta_1(t_0)-\\theta_2(t_0)=(2k+1)\\pi,k \\in \\Z \\tag{224} \\] 注意由引理1可得\n\\[ \\begin{cases} f_1(t_0)=(\\cos\\theta_1(t_0),\\sin\\theta_1(t_0))\\\\[5pt] f_2(t_0)=(\\cos\\theta_2(t_0),\\sin\\theta_2(t_0)) \\end{cases} \\tag{225} \\] 代入式(224)可得\n\\[ f_1(t_0)=-f_2(t_0) \\tag{226} \\] 接下来证明定理16。\n证明（定理16）：首先建立曲线相关的坐标系。设有一不和曲线 \\(C\\) 相交的直线，平行移动这条直线直到与曲线 \\(C\\) 相切，记此时的这条直线为 \\(L\\) ，切点为 \\(p\\) 。此时，整条曲线 \\(C\\) 落在 \\(L\\) 的一侧。如下图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图7\u0026emsp;曲线 \\(C\\) 和直线 \\(L\\)\n以切点 \\(p\\) 为起点构造简单闭曲线 \\(C\\) 的长参数 \\(s\\) ，以逆时针为正方向，同时设简单闭曲线 \\(C\\) 周长为 \\(l\\) 。对于简单闭曲线， \\(s\\) 可以延拓到 \\((-\\infin,\\infin)\\) 上，只需令\n\\[ \\bm{r}(s)=\\bm{r}\\left(s-l\\left\\lfloor \\frac{s}{l} \\right\\rfloor\\right) \\tag{227} \\] 其中 \\(\\left\\lfloor \\cfrac{s}{l} \\right\\rfloor\\) 是不大于 \\(\\cfrac{s}{l}\\) 的最小整数。 \\(\\bm{r}(s)\\) 是连续的，因为 \\(\\bm{r}(0)=\\bm{r}(l)\\) 。\n记 \\(T=\\set{(s_1,s_2)|0 \\le s_1 \\le s_2 \\le l}\\) ，其中 \\(s_1,s_2\\) 为弧长参数。定义函数 \\(\\bm{\\psi}:T \\to S^1\\) 如下\n\\[ \\bm{\\psi}(s_1,s_2)= \\begin{cases} \\bm{r}'(s)\\quad s_1=s_2=s\\\\[5pt] -\\bm{r}'(0)\\quad s_1=0,s_2=l\\\\[10pt] \\cfrac{\\bm{r}(s_2)-\\bm{r}(s_1)}{|\\bm{r}(s_2)-\\bm{r}(s_1)|} \\quad s_1 \\ne s_2 且 s_1=0 和 s_2 =l 不同时满足 \\end{cases} \\tag{228} \\] 首先证明 \\(\\bm{\\psi}\\) 连续。对 \\(s_1=s_2\\) ，首先由于 \\(s_1,s_2\\) 都是弧长参数，因此由定理1可得\n\\[ |\\bm{r}'(s_1)|=|\\bm{r}'(s_2)|=1 \\tag{229} \\] 根据导数的定义和极限的性质，上式可写成\n\\[ \\begin{aligned} |\\bm{r}'(s_2)|=\u0026\\left|\\lim\\limits_{s_1 \\to s_2}\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{s_2-s_1}\\right|=\\sqrt{\\left(\\lim\\limits_{s_1 \\to s_2}\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{s_2-s_1}\\right)^2}\\\\[15pt] =\u0026\\lim\\limits_{s_1 \\to s_2}\\sqrt{\\left(\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{s_2-s_1}\\right)^2}=\\lim\\limits_{s_1 \\to s_2}\\frac{|\\bm{r}(s_2)-\\bm{r}(s_1)|}{|s_2-s_1|}=1 \\end{aligned} \\tag{230} \\] 注意 \\(s_2 \\ge s_1\\) ，利用上式可得\n\\[ \\lim\\limits_{s_1 \\to s_2}\\bm{\\psi}(s_1,s_2)=\\lim\\limits_{s_1 \\to s_2}\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{|\\bm{r}(s_2)-\\bm{r}(s_1)|}=\\lim\\limits_{s_1 \\to s_2}\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{s_2-s_1}\\lim\\limits_{s_1 \\to s_2}\\frac{|s_2-s_1|}{|\\bm{r}(s_2)-\\bm{r}(s_1)|}=\\bm{r}'(s_2) \\tag{231} \\] 对 \\(s_1 \\to 0, s_2 \\to l\\) ，注意曲线的总长度为 \\(l\\) ，因此 \\(s_2 \\to l\\) 相当于 \\(s_2 \\to 0^-\\) 。因此利用式(230)可得\n\\[ \\begin{aligned} \\lim\\limits_{s_1 \\to 0, s_2 \\to l}\\bm{\\psi}(s_1,s_2)=\u0026\\lim\\limits_{s_1 \\to 0, s_2 \\to 0^-}\\frac{\\bm{r}(s_2)-\\bm{r}(s_1)}{|\\bm{r}(s_2)-\\bm{r}(s_1)|}=\\lim\\limits_{s_2 \\to 0^-}\\frac{\\bm{r}(s_2)-\\bm{r}(0)}{|\\bm{r}(s_2)-\\bm{r}(0)|}\\\\[15pt] =\u0026\\lim\\limits_{s_2 \\to 0^-}\\frac{\\bm{r}(s_2)-\\bm{r}(0)}{s_2-0}\\lim\\limits_{s_2 \\to 0^-}\\frac{-|s_2-0|}{|\\bm{r}(s_2)-\\bm{r}(0)|}=-\\bm{r}'(0) \\end{aligned} \\tag{232} \\] 注意曲线是简单曲线，由式(220)，对于 \\(s_1 \\ne s_2\\) ， \\(\\bm{r}(s_1) \\ne \\bm{r}(s_2)\\) ，所以 \\(\\bm{\\psi}(s_1,s_2)\\) 不会出现间断点。因此总的来说 \\(\\bm{\\psi}(s_1,s_2)\\) 是连续的。\n接下来我们需要在 \\(s_1s_2\\) 平面上构造一个连续映射。以 \\(s_1\\) 为横轴， \\(s_2\\) 为纵轴建立直角坐标系，则 \\(s_1,s_2 \\in T\\) 的区域为一个上三角形，如图8所示。设 \\(\\alpha_0:[0,1]\\to T\\) 为连接 \\((0,0),(l,l)\\) 两点的直线段参数曲线，， \\(\\alpha_1:[0,1]\\to T\\) 为连接 \\((0,0),(0,l),(l,l)\\) 三点的折线段参数曲线。在 \\(\\alpha_0,\\alpha_1\\) 之间取端点为 \\((0,0),(l,l)\\) 的参数曲线族 \\(\\alpha_u:[0,1]\\to T, u \\in [0,1]\\) ，使得当 \\(u\\) 由 \\(0\\) 连续变化到 \\(1\\) 时 \\(\\alpha_u\\) 也由 \\(\\alpha_0\\) 连续变化到 \\(\\alpha_1\\) 。注意这里连续的意思是指映射 \\((u,t) \\to \\alpha_u(t), \\space [0,1]\\times[0,1] \\to T\\) 为连续映射。例如选取 \\(\\alpha_u\\) 为连接 \\((0,0),\\left(\\cfrac{l-lu}{2},\\cfrac{l+lu}{2}\\right),(l,l)\\) 三点的折线段参数曲线即可。如下图。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图8\u0026emsp;连续映射\n我们假设这一族曲线段在在图8坐标系中的参数都是 \\(t \\in [0,1]\\) ， \\(t\\) 不一定是弧长参数，但是可以表征点在单个曲线上的位置。参数 \\(t\\) 先经过 \\(\\alpha_u(t)\\) 变换成 \\((s_1,s_2) \\in T\\) ，再经过 \\(\\bm{\\psi}(s_1,s_2)\\) 变换成 \\(S^1\\) 上的单位向量。对于任意 \\(u \\in [0,1]\\) ，定义 \\(D(u)\\) 为 \\(\\bm{\\psi} \\circ \\alpha_u:[0,1] \\to S^1\\) 的角度改变量。由映射 \\((u,t) \\to \\alpha_u(t), \\space [0,1]\\times[0,1] \\to T\\) 和 \\(\\bm{\\psi}\\) 的连续性可得函数 \\(\\bm{\\psi} \\circ \\alpha_u(t)\\) 关于 \\((u,t)\\) 连续（见拓扑空间-命题9）。因此，任取 \\(u_0 \\in [0,1]\\) ，对于任意 \\(\\varepsilon \u003e 0\\) ，存在 \\(\\delta \u003e 0\\) 使得 \\(|\\bm{\\psi} \\circ \\alpha_u(t) - \\bm{\\psi} \\circ \\alpha_{u_0}(t)| \u003c \\varepsilon,\\forall s \\in [0,1], u \\in B(u_0,\\delta)\\cap [0,1]\\) 。只需要取 \\(\\varepsilon_0 = 1\\) ，则存在 \\(\\delta_0\\) ，任取 \\(u \\in B(u_0,\\delta)\\cap [0,1]\\) ，有 \\(|\\bm{\\psi} \\circ \\alpha_u(t) - \\bm{\\psi} \\circ \\alpha_{u_0}(t)| \u003c \\varepsilon_0=1\\) ，因此 \\(\\bm{\\psi} \\circ \\alpha_u(t) \\ne -\\bm{\\psi} \\circ \\alpha_{u_0}(t), \\forall s \\in [0,1]\\) 。否则 \\(|\\bm{\\psi} \\circ \\alpha_u(t) - \\bm{\\psi} \\circ \\alpha_{u_0}(t)| = 2|\\bm{\\psi} \\circ \\alpha_u(t)| = 2 \u003e 1 = \\varepsilon_0\\) （注意 \\(\\bm{\\psi} \\circ \\alpha_u(t)\\) 是映射到 \\(S^1\\) 上的单位向量，因此模长为 \\(1\\) ）。因此根据引理2， \\(\\bm{\\psi} \\circ \\alpha_u(t)\\) 和 \\(\\bm{\\psi} \\circ \\alpha_{u_0}(t)\\) 的角度改变量相等。因此 \\(D(u)\\) 是一个局部连续的常函数（在 \\(B(u_0,\\delta)\\cap [0,1]\\) 内）。但是注意由引理1， \\(D(u)\\) 必须是整数，因此其不能跳跃，只能是在 \\([0,1]\\) 上的常函数。\n我们可以观察一下 \\(D(0)=\\bm{\\psi} \\circ \\alpha_0:[0,1] \\to S^1\\) 。对直线段 \\(\\alpha_0\\) 有 \\(s_1=s_2=s,s\\in[0,l]\\) ，由式(228)可知此时 \\(\\bm{\\psi} \\circ \\alpha_0 = \\bm{r}'(s)\\) ，而由 \\(D(u)\\) 的定义， \\(D(0)\\) 就是 \\(\\bm{r}'(s),s \\in [0,l]\\) 的角度改变量，也就是式(222)中的旋转指标。由于我们已经证明了 \\(D(u)\\) 是个常函数，因此有 \\(D(0)=D(1)\\) ，那我们不妨通过求 \\(D(1)\\) 来求旋转指标 \\(D(0)\\) 。对 \\(D(1)\\) ，从 \\((0,0)\\) 到 \\((0,l)\\) 这段路， \\(\\alpha_1(t)=(0,s_2),s_2 \\in [0,l],(0,s_2)\\in T\\) ，因此 \\(\\bm{\\psi}\\circ\\alpha_1(t)=\\bm{\\psi}(0,s_2)=\\cfrac{\\bm{r}(s_2)-\\bm{r}(0)}{|\\bm{r}(s_2)-\\bm{r}(0)|},s_2 \\in [0,1]\\) 。注意对于图7坐标系， \\(\\bm{r}(s_2)\\) 是不可能翻到直线 \\(L\\) 的另一侧去的，因此 \\(\\bm{r}(s_2),s_2\\in [0,l]\\) 的角度变化量必然被限制在 \\([0,\\pi]\\) 内， \\(\\bm{\\psi}(0,s_2)=\\cfrac{\\bm{r}(s_2)-\\bm{r}(0)}{|\\bm{r}(s_2)-\\bm{r}(0)|},s_2 \\in [0,l]\\) 的角度变化量也被限制在 \\([0,\\pi]\\) 内。而由式(228)可知 \\(\\bm{\\psi}(0,0)=\\bm{r}'(0),\\bm{\\psi}(0,l)=-\\bm{r}'(0)\\) ，刚好转了 \\(\\pi\\) 角度，因此 \\(\\bm{\\psi}\\circ\\alpha_1(t)=\\bm{\\psi}(0,s_2)\\) 在 \\(s_2 \\in [0,l]\\) 上的角度变化量就是 \\(\\pi\\) 。再考虑 \\((0,l)\\) 到 \\((l,l)\\) 这段路径。此时 \\(\\alpha_1(t)=(s_1,l),s_1 \\in [0,1],(s_1,l)\\in T\\) ， \\(\\bm{\\psi}\\circ\\alpha_1(t)=\\bm{\\psi}(s_1,l)=\\cfrac{\\bm{r}(s_1)-\\bm{r}(l)}{|\\bm{r}(s_1)-\\bm{r}(l)|},s_1 \\in [0,1]\\) ，同理由式(228)可知 \\(\\bm{\\psi}(0,l)=-\\bm{r}'(0),\\bm{\\psi}(l,l)=\\bm{r}'(l)=\\bm{r}'(0)\\) ， \\(\\bm{\\psi}\\circ\\alpha_1(t)=\\bm{\\psi}(s_1,l),s_1 \\in [0,1]\\) 的角度改变量也是 \\(\\pi\\) 。综上所述，由角度改变量的可叠加性， \\(\\bm{\\psi} \\circ \\alpha_1(t), t \\in [0,1]\\) 的角度改变量为 \\(\\pi+\\pi=2\\pi\\) ，即 \\(D(1)=2\\pi\\) 。由于 \\(D(0)=D(1)\\) ， \\(D(0)=2\\pi\\) ，即旋转指标为 \\(2\\pi\\) 。注意我们对曲线 \\(C\\) 的弧长参数 \\(s\\) 假设的是以逆时针方向为正方向，倘若以顺时针方向为正方向，由 \\(\\bm{r}'(0)\\) 转到 \\(-\\bm{r}'(0)\\) 就必须是转 \\(-\\pi\\) 角才能实现的了， \\(-\\bm{r}'(0)\\) 转到 \\(\\bm{r}'(0)\\) 同理。因此，根据弧长参数的方向是顺时针还是逆时针， \\(D(0)\\) 可取 \\(\\pm 2\\pi\\) 。即 \\(i(C)=\\pm 2\\pi\\) 。证毕。\n定理16是曲线大范围微分几何性质，其直观意义是明显的。若 \\(C\\) 是分段光滑的简单闭曲线，则曲线的方向角的总变差是\n\\[ \\theta(b)-\\theta(a)=\\int_a^b\\kappa_r(s)\\mathrm{d}s+\\sum_i\\theta_i \\tag{233} \\] 这里 \\(\\theta_i\\) 是曲线在各个角点处的外角， \\(-\\pi \u003c \\theta_i \u003c \\pi\\) ，即\n\\[ \\theta_i = \\angle(\\bm{\\alpha}(s_i^-),\\bm{\\alpha}(s_i^+)) \\tag{234} \\] 其中 \\(s_i\\) 是曲线的角点所对应的参数，曲线在每一段区间 \\((s_i,s_{i+1})\\) 上是连续可微的。在上述意义下，定理16对于分段连续可微的简单闭曲线仍然是成立的。实际上，在每个角点引入一小段弧线，让整体连续可微再取极限即可直接套用定理16。\n给岁月以文明，而不是给文明以岁月。 ― 刘慈欣, 《三体Ⅱ：黑暗森林》 ","date":"2024-10-14T20:01:28+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/geometry/differential_geometry/curve_theory/","title":"微分几何（二）：曲线论"},{"content":" Euclid空间 我们知道，一元函数 \\(y=f(x)\\) 的图像是一条曲线，二元函数 \\(z=f(x,y)\\) 的图像是一张曲面。但是，把曲线和曲面表示成参数方程则更加便利于研究，这种表示方法首先是由Euler引进的。例如，在空间中取定Cartesian直角坐标系之后一条曲线可以表示为三个一元函数\n\\[ x=x(t),\\quad y=y(t),\\quad z=z(t) \\tag{1} \\] 在向量的概念出现之后，空间中的一条曲线可以自然地表示为一个一元向量函数\n\\[ \\bm{r}=\\bm{r}(t)=(x(t),y(t),z(t)) \\tag{2} \\] 在本篇，我们首先要复习解析几何中已经学习过的向量代数知识，以及介绍向量函数相加、向量函数与函数相乘、向量函数的点乘和叉乘的求导法则，在三维Euclid空间中标架是建立坐标系的基础，而且我们将来要把曲线和曲面与仅附在曲线和曲面上的标架族联系起来，用标架族的变化状态来刻画曲线和曲面的弯曲情况。因此本文我们还要介绍三维Euclid空间中标架的概念，为在三维Euclid空间中研究曲线和曲面做好准备。\n三维Euclid空间中的标架 Euclid空间 通常把我们所处的空间称为三维Euclid空间。确切的说，所谓的三维Euclid空间 \\(E^3\\) 是一个非空的集合，其中的元素称为点，任意两个不同的点唯一地决定了连接他们的直线，不在一条直线上的任意三个不同的点唯一地决定了通过这三点的平面，而且在 \\(E^3\\) 中存在不共面的四个点。另外，过直线外任意一点能够作、并且只能作一条直线与已知直线平行。最后这个断言就是欧氏几何的平行公理。\n向量 定义 任意两个点 \\(A,B \\in E^3\\) 都可以连接成一条直线段 \\(AB\\) 。指定 \\(A\\) 为起点、 \\(B\\) 为终点的线段 \\(AB\\) 称为有向线段，记作 \\(\\overrightarrow{AB}\\) 。设 \\(\\overrightarrow{AB}\\) 和 \\(\\overrightarrow{CD}\\) 是两条有向线段，如果 \\(ABDC\\) 成为一个平行四边形，则称这两条有向线段是相等的，记为\n\\[ \\overrightarrow{AB}=\\overrightarrow{CD} \\tag{3} \\] 所有相等的有向线段的集合称为一个向量。因此，在三维Euclid空间 \\(E^3\\) 中，一个向量可以表示为 \\(E^3\\) 中的一条有向线段，而相等的有向线段所代表的是同一个向量。以后，我们经常用黑斜体单个字母，或者用带箭头的单个字母表示向量。\n加法 按照三角形法则，可以定义向量的加法如下：设 \\(\\bm{a},\\bm{b}\\) 是两个向量，并且假定它们用有向线段 \\(\\overrightarrow{AB}\\) 和 \\(\\overrightarrow{BC}\\) 来表示，则连接 \\(A\\) 和 \\(C\\) 的有向线段 \\(\\overrightarrow{AC}\\) 就代表向量 \\(\\bm{a}+\\bm{b}\\) 。我们把起点和终点相同的有向线段的集合称为零向量，记为 \\(\\bm{0}\\) ，于是任意一个向量与零向量之和为该向量自身，即\n\\[ \\bm{a}+\\bm{0}=\\bm{a} \\tag{4} \\] 另外，若向量 \\(a\\) 用有向线段 \\(\\overrightarrow{AB}\\) 来表示，并且把有向线段 \\(\\overrightarrow{BA}\\) 所代表的向量记为 \\(-\\bm{a}\\) ，于是\n\\[ \\bm{a}+(-\\bm{a})=\\bm{0} \\tag{5} \\] 我们把向量 \\(-\\bm{a}\\) 称为 \\(\\bm{a}\\) 的反向量。容易验证，向量的加法遵循下面的运算法则 \\[ \\bm{a}+\\bm{b}=\\bm{b}+\\bm{a} \\tag{6} \\] \\[ (\\bm{a}+\\bm{b})+\\bm{c}=\\bm{a}+(\\bm{b}+\\bm{c}) \\tag{7} \\]\n数乘 在三维Euclid空间 \\(E^3\\) 中还规定线段 \\(AB\\) 的长度是点 \\(A\\) 到点 \\(B\\) 的距离，记为 \\(|AB|\\) ，并对于任意三点 \\(A,B,C\\) ，下面的三角形不等式成立\n\\[ |AB|+|BC|\\ge|AC| \\tag{8} \\] 向量 \\(\\bm{a}\\) 的长度 \\(|\\bm{a}|\\) 定义为代表它的有向线段 \\(\\bm{a}=\\overrightarrow{AB}\\) 的长度。这样，向量 \\(\\bm{a}\\) 与实数 \\(c\\) 的乘积 \\(c\\cdot\\bm{a}\\) 可以定义为与 \\(\\bm{a}\\) 平行的向量。当 \\(c\u003e0\\) 时 \\(c\\cdot\\bm{a}\\) 与 \\(\\bm{a}\\) 同向，当 \\(c\u003c0\\) 时 \\(c\\cdot\\bm{a}\\) 与 \\(\\bm{a}\\) 反向，并且 \\(c\\cdot\\bm{a}\\) 的长度 \\(|c\\cdot\\bm{a}|\\) 是 \\(\\bm{a}\\) 的长度 \\(|\\bm{a}|\\) 的 \\(|c|\\) 倍；当 \\(c=0\\) 时， \\(c\\cdot\\bm{a}=0\\) 。容易验证，向量与实数的乘法遵循下面的运算规则\n\\[ \\lambda(\\bm{a}+\\bm{b})=\\lambda\\bm{a}+\\lambda\\bm{b} \\tag{9} \\] \\[ (\\lambda+\\mu)\\bm{a}=\\lambda\\bm{a}+\\mu\\bm{a} \\tag{10} \\] \\[ (\\lambda\\mu)\\bm{a}=\\lambda(\\mu\\bm{a}) \\tag{11} \\]\n其中 \\(\\lambda,\\mu\\) 是任意实数。\n点乘 向量 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 的点乘 \\(\\bm{a}\\cdot\\bm{b}\\) 定义为实数\n\\[ \\bm{a}\\cdot\\bm{b}=|\\bm{a}|\\cdot|\\bm{b}|\\cdot\\cos\\angle(\\bm{a},\\bm{b}) \\tag{12} \\] 很明显，向量的点乘遵循下面的运算法则\n\\[ \\bm{c}\\cdot(\\bm{a}+\\bm{b})=\\bm{c}\\cdot\\bm{a}+\\bm{c}\\cdot\\bm{b} \\tag{13} \\] \\[ (\\lambda\\bm{a})\\cdot\\bm{b}=\\lambda(\\bm{a}\\cdot\\bm{b}) \\tag{14} \\] \\[ \\bm{a}\\cdot\\bm{b}=\\bm{b}\\cdot\\bm{a} \\tag{15} \\]\n由此可见\n\\[ |\\bm{a}|^2=\\bm{a}\\cdot\\bm{a}\\ge0 \\tag{16} \\] 叉乘 当向量 \\(\\bm{a}\\) 和向量 \\(\\bm{b}\\) 平行时，规定它们的叉乘为零向量。当 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 不平行时，规定向量 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 的叉乘 \\(\\bm{a}\\times\\bm{b}\\) 是与已知向量 \\( \\bm{a}\\) 和 \\( \\bm{b}\\) 都垂直的一个向量，其长度等于向量 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 所张成的平行四边形的面积，即\n\\[ |\\bm{a}\\times \\bm{b}|=|\\bm{a}|\\cdot|\\bm{b}|\\sin\\angle(\\bm{a},\\bm{b}) \\tag{17} \\] 并且它和 \\(\\bm{a},\\bm{b}\\) 构成右手系。容易验证，向量的叉乘遵循下面的运算法则\n\\[ \\bm{c}\\times(\\bm{a}+\\bm{b})=\\bm{c}\\times\\bm{a}+\\bm{c}\\times\\bm{b} \\tag{18} \\] \\[ (\\lambda\\bm{a})\\times\\bm{b}=\\lambda(\\bm{a}\\times\\bm{b}) \\tag{19} \\] \\[ \\bm{a}\\times\\bm{b}=-\\bm{b}\\times\\bm{a} \\tag{20} \\]\n根据定义，向量 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 平行的充分必要条件是\n\\[ \\bm{a}\\times\\bm{b}=\\bm{0} \\tag{21} \\] 标架 定义 在 \\(E^3\\) 中取定不共面的4个点，把其中一点记作 \\(O\\) ，把另外三点分别记为 \\(A,B,C\\) ，于是得到由一点 \\(O\\) 和 \\(3\\) 个不共面的向量 \\(\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}\\) 构成的图形 \\(\\set{O;\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}}\\) 。这样的一个图形称为 \\(E^3\\) 中的一个标架，其中点 \\(O\\) 称为该标架的原点。在 \\(E^3\\) 中取定一个标架 \\(\\set{O;\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}}\\) 之后，则空间 \\(E^3\\) 中的任意一点 \\(P\\) 可以唯一地表示为 \\(3\\) 个有序的实数 \\((x,y,z)\\) 。事实上，从点 \\(P\\) 出发可以作唯一的一个平面与平面 \\(OBC\\) 平行，它和直线 \\(OA\\) 有唯一的交点，记为 \\(P_1\\) ，那么向量 \\(\\overrightarrow{OP_1}\\) 与 \\(\\overrightarrow{OA}\\) 共线，于是有实数 \\(x\\) ，使得 \\(\\overrightarrow{OP_1}=x\\space\\overrightarrow{OA}\\) 。同理，从点 \\(P\\) 出发可以作唯一的一个平面与平面 \\(OAC\\) 平行，它和直线 \\(OB\\) 有唯一的交点，记为 \\(P_2\\) ，从点 \\(P\\) 出发可以作唯一的一个平面与平面 \\(OAB\\) 平行，它和直线 \\(OC\\) 有唯一的交点，记为 \\(P_3\\) ，并且有实数 \\(y,z\\) ，使得 \\(\\overrightarrow{OP_2}=y\\space\\overrightarrow{OB}\\) ， \\(\\overrightarrow{OP_3}=z\\space\\overrightarrow{OC}\\) ，那么\n\\[ \\overrightarrow{OP}=\\overrightarrow{OP_1}+\\overrightarrow{OP_2}+\\overrightarrow{OP_3}=x\\space\\overrightarrow{OA}+y\\space\\overrightarrow{OB}+z\\space\\overrightarrow{OC} \\tag{22} \\] 因此，在 \\(E^3\\) 中取定标架 \\(\\set{O;\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}}\\) 之后，点 \\(P\\) 和有序的 \\(3\\) 个实数构成的组 \\((x,y,z)\\) 是一一对应的，该数组称为点 \\(P\\) 关于已知标架 \\(\\set{O;\\overrightarrow{OA},\\overrightarrow{OB},\\overrightarrow{OC}}\\) 的坐标。\n注：在此简单证明一下为什么 \\(\\overrightarrow{OP}=\\overrightarrow{OP_1}+\\overrightarrow{OP_2}+\\overrightarrow{OP_3}\\) 。构造点 \\(P^\\prime\\) 使得 \\(\\overrightarrow{OP^\\prime}=\\overrightarrow{P_3P}\\) ，由相等的定义知 \\(OP^\\prime PP_3\\) 构成一个平行四边形，故也有 \\(\\overrightarrow{OP_3}=\\overrightarrow{P^\\prime P}\\) 。由 \\(P_3\\) 的定义知 \\(\\overrightarrow{P_3P}\\) 平行于平面 \\(OAB\\) ，因此 \\(OP^\\prime\\) 平行于平面 \\(OAB\\) ，故 \\(P^\\prime\\) 在平面 \\(OAB\\) 上。在平面 \\(OAB\\) 上过 \\(P^\\prime\\) 可作唯一直线平行于直线 \\(OA\\) ，设这条直线和直线 \\(OB\\) 交于点 \\(P_2^\\prime\\) ，现在来证 \\(P_2^\\prime\\) 就是点 \\(P_2\\) 。由 \\(P_2^\\prime\\) 、 \\(P^\\prime\\) 和 \\(P_3\\) 的定义知 \\(\\overrightarrow{P_2^\\prime P^\\prime}\\parallel\\overrightarrow{OA}\\) 且 \\(\\overrightarrow{P^\\prime P}\\parallel\\overrightarrow{OP_3}\\parallel\\overrightarrow{OC}\\) ，因此平面 \\(PP^\\prime P_2^\\prime\\) 与平面 \\(OAC\\) 平行。注意从 \\(P\\) 出发只有唯一的一个平面能与平面 \\(OAC\\) 平行，因此平面 \\(PP^\\prime P_2^\\prime\\) 就是这个平面，其与直线 \\(OB\\) 的唯一交点 \\(P_2^\\prime\\) 就是 \\(P_2\\) 。同理可以证明类似定义的 \\(P_1^\\prime\\) 就是 \\(P_1\\) 。故 \\(\\overrightarrow{P_2 P^\\prime}\\parallel\\overrightarrow{OA}\\parallel\\overrightarrow{OP_1}\\) ， \\(\\overrightarrow{P_1 P^\\prime}\\parallel\\overrightarrow{OB}\\parallel\\overrightarrow{OP_2}\\) ，因此 \\(OP_1P^\\prime P_2\\) 构成平行四边形，因此 \\(\\overrightarrow{OP^\\prime}=\\overrightarrow{OP_1}+\\overrightarrow{OP_2}\\) 。综上所述， \\(\\overrightarrow{OP}=\\overrightarrow{OP^\\prime}+\\overrightarrow{P^\\prime P}=\\overrightarrow{OP_1}+\\overrightarrow{OP_2}+\\overrightarrow{OP_3}\\) 。\n正交标架 设 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 是 \\(E^3\\) 的一个标架，并且 \\(\\bm{i},\\bm{j},\\bm{k}\\) 是彼此垂直的、构成右手系的 \\(3\\) 个单位向量，于是\n\\[ \\bm{i}\\cdot\\bm{i}=\\bm{j}\\cdot\\bm{j}=\\bm{k}\\cdot\\bm{k}=1,\\quad\\bm{i}\\cdot\\bm{j}=\\bm{i}\\cdot\\bm{k}=\\bm{j}\\cdot\\bm{k}=0 \\tag{23} \\] 并且\n\\[ \\bm{i}\\times\\bm{j}=\\bm{k},\\quad\\bm{j}\\times\\bm{k}=\\bm{i},\\quad\\bm{k}\\times\\bm{i}=\\bm{j} \\tag{24} \\] 这样的标架称为右手单位正交标架，简称为正交标架。由正交标架给出的坐标系称为Cartesian直角坐标系。在Cartesian直角坐标系下，设向量 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 的分量分别是 \\((x_1,y_1,z_1)\\) 和 \\((x_2,y_2,z_2)\\) ，则\n\\[ \\begin{aligned} \\bm{a}\\cdot\\bm{b}=\u0026(x_1\\bm{i}+y_1\\bm{j}+z_1\\bm{k})\\cdot(x_2\\bm{i}+y_2\\bm{j}+z_2\\bm{k})\\hspace{4em}\\\\[5pt] =\u0026x_1x_2+y_1y_2+z_1z_2 \\end{aligned} \\tag{25} \\] \\[ \\begin{aligned} \\bm{a}\\times\\bm{b}=\u0026(x_1\\bm{i}+y_1\\bm{j}+z_1\\bm{k})\\times(x_2\\bm{i}+y_2\\bm{j}+z_2\\bm{k})\\\\[5pt] =\u0026(x_1y_2-x_2y_1)(\\bm{i}\\times\\bm{j})+(y_1z_2-y_2z_1)(\\bm{j}\\times\\bm{k})\\\\[5pt] \u0026+(z_1x_2-z_2x_1)(\\bm{k}\\times\\bm{i})\\\\[5pt] =\u0026\\left( \\begin{vmatrix} y_1 \u0026 z_1 \\\\[5pt] y_2 \u0026 z_2 \\end{vmatrix} , \\begin{vmatrix} z_1 \u0026 x_1 \\\\[5pt] z_2 \u0026 x_2 \\end{vmatrix} , \\begin{vmatrix} x_1 \u0026 y_1 \\\\[5pt] x_2 \u0026 y_2 \\end{vmatrix} \\right) \\\\[15pt] =\u0026 \\begin{vmatrix} \\bm{i} \u0026 \\bm{j} \u0026 \\bm{k} \\\\[5pt] x_1 \u0026 y_1 \u0026 z_1 \\\\[5pt] x_2 \u0026 y_2 \u0026 z_2 \\end{vmatrix} \\end{aligned} \\tag{26} \\]\n设点 \\(A,B\\) 的坐标分别是 \\((x_1,y_1,z_1)\\) 和 \\((x_2,y_2,z_2)\\) ，则线段 \\(AB\\) 的长度是\n\\[ |AB|=\\sqrt{\\overrightarrow{AB}\\cdot\\overrightarrow{AB}}=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2} \\tag{27} \\] 因此，通常我们把三维Euclid空间 \\(E^3\\) 写成 \\(\\R^3\\) ，并且把 \\(\\R^3\\) 中的向量 \\((x,y,z)\\) 的长度直接定义为 \\(\\sqrt{x^2+y^2+z^2}\\) 。事实上，这样的 \\(\\R^3\\) 是三维欧氏空间 \\(E^3\\) 在取定了一个正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 之后的具体表现形式。为简单起见，我们经常把三维Euclid空间理解为上面所说的 \\(\\R^3\\) 。\n标架变换 现在我们来考察由 \\(E^3\\) 中全体正交标架所构成的集合。设 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 是在 \\(E^3\\) 中的一个固定的正交标架，则 \\(E^3\\) 中的任意一个正交标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 可以如下来确定\n\\[ \\begin{cases} \\overrightarrow{OP}=a_1\\bm{i}+a_2\\bm{j}+a_3\\bm{k}\\\\[5pt] \\bm{e}_1=a_{11}\\bm{i}+a_{12}\\bm{j}+a_{13}\\bm{k}\\\\[5pt] \\bm{e}_2=a_{21}\\bm{i}+a_{22}\\bm{j}+a_{23}\\bm{k}\\\\[5pt] \\bm{e}_3=a_{31}\\bm{i}+a_{32}\\bm{j}+a_{33}\\bm{k}\\\\[5pt] \\end{cases} \\tag{28} \\] 因为 \\(\\bm{e}_i\\) 是彼此正交的单位向量，所以\n\\[ \\bm{e}_i\\cdot\\bm{e}_j=\\sum_{k=1}^{3}a_{ik}a_{jk}=\\delta{ij}= \\begin{cases} 1,\\quad i=j\\\\[5pt] 0,\\quad i \\ne j \\end{cases} \\tag{29} \\] 由于 \\(\\bm{e}_1,\\bm{e}_2,\\bm{e}_3\\) 构成右手系，所以\n\\[ \\bm{e}_1\\times\\bm{e}_2=\\bm{e}_3 \\tag{30} \\] 因而 \\(\\bm{e}_1,\\bm{e}_2,\\bm{e}_3\\) 的混合积\n\\[ \\begin{aligned} (\\bm{e}_1,\\bm{e}_2,\\bm{e}_3)=\u0026(\\bm{e}_1\\times\\bm{e}_2)\\cdot\\bm{e}_3=\\bm{e}_3\\cdot\\bm{e}_3\\\\[10pt] =\u0026 \\begin{vmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \\\\[5pt] a_{21} \u0026 a_{22} \u0026 a_{23} \\\\[5pt] a_{31} \u0026 a_{32} \u0026 a_{33} \\end{vmatrix} =1 \\end{aligned} \\tag{31} \\] 令\n\\[ \\bm{a}=(a_1,a_2,a_3) \\tag{32} \\] \\[ \\bm{A}= \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 a_{13} \\\\[5pt] a_{21} \u0026 a_{22} \u0026 a_{23} \\\\[5pt] a_{31} \u0026 a_{32} \u0026 a_{33} \\end{pmatrix} \\tag{33} \\]\n由式(29)可得 \\(\\bm{A}\\bm{A}^T=\\bm{A}^T\\bm{A}=1\\) ，由式(31)可得 \\(|\\bm{A}|=1\\) ，因此 \\(\\bm{A}\\) 是行列式为 \\(1\\) 的正交矩阵，即 \\(A \\in \\rm{SO(3)}\\) （见SO(3)群）。在取定一个正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 下， \\(E^3\\) 中的任意一个正交标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e_3}}\\) 与矩阵 \\((\\bm{a},\\bm{A})\\) 是一一对应的，因此 \\(E^3\\) 中的全体正交标架的集合可以与集合 \\(E^3\\times \\rm{SO(3)}\\) （见Cartesian乘积）等同起来。注意到正交矩阵的条件式(29)是矩阵元素 \\(a_{ij}\\) 所满足的 \\(6\\) 个关系式。\n\\[ \\begin{cases} (a_{11})^2+(a_{12})^2+(a_{13})^2=1\\\\[5pt] (a_{21})^2+(a_{22})^2+(a_{33})^2=1\\\\[5pt] (a_{31})^2+(a_{32})^2+(a_{33})^2=1\\\\[5pt] a_{11}a_{21}+a_{12}a_{22}+a_{13}a_{23}=0\\\\[5pt] a_{11}a_{31}+a_{12}a_{32}+a_{13}a_{33}=0\\\\[5pt] a_{21}a_{31}+a_{22}a_{32}+a_{23}a_{33}=0 \\end{cases} \\tag{34} \\] 因此，其行列式为 \\(1\\) 的正交矩阵的集合 \\(\\rm{SO(3)}\\) 有 \\(3\\) 个自由度，因而 \\(E^3\\times \\rm{SO(3)}\\) 是一个 \\(6\\) 维空间。\n坐标变换 在 \\(E^3\\) 中两个不同的正交标架给出了两个不同的Cartesian直角坐标系，设 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 和 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 是 \\(E^3\\) 中的两个正交标架。它们的关系由式(28)给出。假定点 \\(q\\) 关于 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 的坐标是 \\((x,y,z)\\) ，关于 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 的坐标是 \\((\\tilde{x},\\tilde{y},\\tilde{z})\\)\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图1\u0026emsp;坐标变换\n则一方面有\n\\[ \\overrightarrow{OQ}=x\\bm{i}+y\\bm{j}+z\\bm{k}= \\begin{pmatrix} x \u0026 y \u0026 z \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{i}\\\\[5pt] \\bm{j}\\\\[5pt] \\bm{k} \\end{pmatrix} \\tag{35} \\] 另一方面有\n\\[ \\begin{aligned} \\overrightarrow{OQ}=\u0026\\overrightarrow{OP}+\\overrightarrow{PQ}\\\\[5pt] =\u0026 \\begin{pmatrix} a_1 \u0026 a_2 \u0026 a_3 \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{i}\\\\[5pt] \\bm{j}\\\\[5pt] \\bm{k} \\end{pmatrix} +\\begin{pmatrix} \\tilde{x} \u0026 \\tilde{y} \u0026 \\tilde{z} \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{e}_1\\\\[5pt] \\bm{e}_2\\\\[5pt] \\bm{e}_3 \\end{pmatrix}\\\\ =\u0026\\left(\\bm{a}+\\begin{pmatrix}\\tilde{x}\u0026\\tilde{y}\u0026\\tilde{z}\\end{pmatrix}\\cdot\\bm{A}\\right)\\cdot \\begin{pmatrix} \\bm{i}\\\\[5pt] \\bm{j}\\\\[5pt] \\bm{k} \\end{pmatrix} \\end{aligned} \\tag{36} \\] 因此，点 \\(q\\) 在两个不同的Cartesian直角坐标系 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 和 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 下分别有坐标 \\((x,y,z)\\) 和 \\((\\tilde{x},\\tilde{y},\\tilde{z})\\) ，它们满足如下的关系式\n\\[ (x,y,z)=\\bm{a}+\\begin{pmatrix}\\tilde{x}\u0026\\tilde{y}\u0026\\tilde{z}\\end{pmatrix}\\cdot\\bm{A} \\tag{37} \\] 即\n\\[ \\begin{cases} x=a_1+a_{11}\\tilde{x}+a_{21}\\tilde{y}+a_{31}\\tilde{z}\\\\[5pt] y=a_2+a_{12}\\tilde{x}+a_{22}\\tilde{y}+a_{32}\\tilde{z}\\\\[5pt] z=a_3+a_{13}\\tilde{x}+a_{23}\\tilde{y}+a_{33}\\tilde{z} \\end{cases} \\tag{38} \\] 也可以写成\n\\[ \\begin{pmatrix} x\\\\[5pt] y\\\\[5pt] z \\end{pmatrix} = \\bm{a}^T+ \\bm{A}^T \\cdot \\begin{pmatrix} \\tilde{x}\\\\[5pt] \\tilde{y}\\\\[5pt] \\tilde{z} \\end{pmatrix} \\tag{39} \\] 刚体运动 定义 正交标架的重要性还在予它能够用来表示Euclid空间\\(E^3\\)中刚体的运动。所谓刚体运动原是物理学中的一个概念．如果一个物体在空间中的运动不改变它的形状及其大小，只改变它在空问中的位置，那么该物体的这种运动称为刚体运动。要确定一个刚体在 \\(E^3\\) 中的位置，只要确定在该刚体上不共线的三个点的位置就行了，而刚体上其他的点可以通过它到已知的三个点的距离、以及所成的三个向量构成右手系还是左手系来确定。但是，在 \\(E^3\\) 中正交标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 是由点 \\(P\\) 和两个彼此正交的单位向量 \\(\\bm{e}_1,\\bm{e}_2\\) 决定的，它们恰好相当于空间中不共线的三个点。这样，在刚体上安装一个正交标架，则这个标架在空间中的位置代表了这个刚体的位置。如果把空间和刚体捆绑在一起，把刚体在空间中的运动看作空间自身在空间中的刚体运动，则这是空间 \\(E^3\\) 到它自身的一个变换，这个变换保持该空间中任意两点之间的距离不变。\n刚体运动与标架 设在刚体上安装的正交标架是 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 。假定它在初始位置时该标架与空间中取定的正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 重合，经过刚体运动 \\(\\sigma\\) 达到了现在的位置，那么空间中的任意一点 \\(Q\\) 在刚体运动 \\(\\sigma\\) 下变成了像点\n\\[ \\tilde{Q}=\\sigma(Q) \\tag{40} \\] 它关于标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 的相对位置与 \\(Q\\) 关于 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 的相对位置是一样的。若设\n\\[ \\overrightarrow{OQ}= \\begin{pmatrix} x \u0026 y \u0026 z \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{i}\\\\[5pt] \\bm{j}\\\\[5pt] \\bm{k} \\end{pmatrix} \\tag{41} \\] 则也有\n\\[ \\overrightarrow{P\\tilde{Q}}= \\begin{pmatrix} x \u0026 y \u0026 z \\end{pmatrix} \\cdot \\begin{pmatrix} \\bm{e}_1\\\\[5pt] \\bm{e}_2\\\\[5pt] \\bm{e}_3 \\end{pmatrix} \\tag{42} \\] 所以\n\\[ \\begin{aligned} \\overrightarrow{O\\tilde{Q}}=\u0026\\overrightarrow{OP}+\\overrightarrow{P\\tilde{Q}}\\\\ =\u0026\\left(\\bm{a}+\\begin{pmatrix}x\u0026y\u0026z\\end{pmatrix}\\cdot\\bm{A}\\right)\\cdot \\begin{pmatrix} \\bm{i}\\\\[5pt] \\bm{j}\\\\[5pt] \\bm{k} \\end{pmatrix} \\end{aligned} \\tag{43} \\] 这就是说，像点 \\(\\tilde{q}=\\sigma(q)\\) 关于 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 的坐标是\n\\[ \\begin{pmatrix}\\tilde{x}\u0026\\tilde{y}\u0026\\tilde{z}\\end{pmatrix}=\\bm{a}+\\begin{pmatrix}x\u0026y\u0026z\\end{pmatrix}\\cdot\\bm{A} \\tag{44} \\] 即\n\\[ \\begin{cases} \\tilde{x}=a_1+a_{11}x+a_{21}y+a_{31}z\\\\[5pt] \\tilde{y}=a_2+a_{12}x+a_{22}y+a_{32}z\\\\[5pt] \\tilde{z}=a_3+a_{13}x+a_{23}y+a_{33}z \\end{cases} \\tag{45} \\] 也可以写成\n\\[ \\begin{pmatrix} \\tilde{x}\\\\[5pt] \\tilde{y}\\\\[5pt] \\tilde{z} \\end{pmatrix} = \\bm{a}^T+ \\bm{A}^T \\cdot \\begin{pmatrix} x\\\\[5pt] y\\\\[5pt] z \\end{pmatrix} \\tag{46} \\] 因此如果把正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 变到 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 的刚体运动同时把点 \\(q=(x,y,z)\\) 变到点 \\(\\tilde{q}=(\\tilde{x},\\tilde{y},\\tilde{z})\\) （它们分别是点 \\(q\\) 和 \\(\\tilde{q}\\) 关于正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 的坐标），则 \\((\\tilde{x},\\tilde{y},\\tilde{z})\\) 与 \\((x,y,z)\\) 之间的关系恰好是由式(44)给出的．注意到式(44)和式(37)有很大的相似性，但是它们的意义却是完全不同的，前者是点不变而标架变换，后者是点随标架一起同步变换。这种在公式上的相似性说明刚体运动在某种意义上可以看作一种坐标变换（参看图2）。具体地说，式(44)可以解读为把点 \\(\\tilde{q}\\) 在标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 下的坐标 \\((x,y,z)\\) 变换为在标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 下的坐标 \\((\\tilde{x},\\tilde{y},\\tilde{z})\\) 的公式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图2\u0026emsp;刚体运动\n我们可以把上述讨论总结成下面的定理。\n定理1： \\(E^3\\) 中的刚体运动把一个正交标架变成另一个正交标架；反过来，对于 \\(E^3\\) 中的任意两个正交标架，必有 \\(E^3\\) 的一个刚体运动把其中一个正交标架变成另一个正交标架。\n等距变换 距离不变的变换称为等距变换。刚体运动是一种等距变换。容易证明，等距变换把共线的三个点变为共线的三个点，并且保持它们的分比不变，进而可以证明等距变换是如式(44)给出的线性变换，但是此时只能证明其中的矩阵 \\(\\bm{A}\\) 是正交矩阵，而不要求它的行列式的值是正的。因此等距变换把单位正交标架变成一个另单位正交标架，但是可能把右手系变成左手系。换句话说刚体运动是保持右手系不变的等距变换，而等距变换或者是一个刚体运动，或者是一个刚体运动与关于某个平面的反射的合成。\n注：在此简单证明一下式(44)给出的变换是等距变换（ \\(\\bm{A}\\) 是正交矩阵，满足 \\(\\bm{A}\\bm{A}^T=\\bm{A}^T\\bm{A}=1\\) ）。设有 \\(P_1=(x_1,y_1,z_1),P_2=(x_2,y_2,z_2)\\) 被式(44)变换为 \\(\\tilde{P}_1(\\tilde{x}_1,\\tilde{y}_1,\\tilde{z}_1),\\tilde{P}_2=(\\tilde{x}_2,\\tilde{y}_2,\\tilde{z}_2)\\) 。其距离被变换为\n\\[ \\begin{aligned} \\left|\\tilde{P}_1\\tilde{P}_2\\right|=\u0026\\sqrt{(\\tilde{x}_1-\\tilde{x}_2)^2+(\\tilde{y}_1-\\tilde{y}_2)^2+(\\tilde{z}_1-\\tilde{z}_2)^2}\\\\[5pt] =\u0026\\sqrt{\\left(\\begin{pmatrix}\\tilde{x}_1\u0026\\tilde{y}_1\u0026\\tilde{z}_1\\end{pmatrix}-\\begin{pmatrix}\\tilde{x}_2\u0026\\tilde{y}_2\u0026\\tilde{z}_2\\end{pmatrix}\\right)\\cdot\\left(\\begin{pmatrix}\\tilde{x}_1\u0026\\tilde{y}_1\u0026\\tilde{z}_1\\end{pmatrix}-\\begin{pmatrix}\\tilde{x}_2\u0026\\tilde{y}_2\u0026\\tilde{z}_2\\end{pmatrix}\\right)^T}\\\\[5pt] =\u0026\\sqrt{\\left(\\begin{pmatrix}x_1\u0026y_1\u0026z_1\\end{pmatrix}-\\begin{pmatrix}x_2\u0026y_2\u0026z_2\\end{pmatrix}\\right)\\bm{A}\\cdot\\bm{A}^T\\left(\\begin{pmatrix}x_1\u0026y_1\u0026z_1\\end{pmatrix}-\\begin{pmatrix}x_2\u0026y_2\u0026z_2\\end{pmatrix}\\right)^T}\\\\[5pt] =\u0026\\sqrt{\\left(\\begin{pmatrix}x_1\u0026y_1\u0026z_1\\end{pmatrix}-\\begin{pmatrix}x_2\u0026y_2\u0026z_2\\end{pmatrix}\\right)\\cdot\\left(\\begin{pmatrix}x_1\u0026y_1\u0026z_1\\end{pmatrix}-\\begin{pmatrix}x_2\u0026y_2\u0026z_2\\end{pmatrix}\\right)^T}\\\\[5pt] =\u0026\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}=|P_1P_2| \\end{aligned} \\tag{47} \\] 故距离不变。对于共线的三个点 \\(P_1,P_2,P_3\\) ，必存在不为零的 \\(\\lambda,\\mu\\) 使得\n\\[ (x_1,y_1,z_1)=\\lambda\\cdot(x_2,y_2,z_2)+\\mu\\cdot(x_3,y_3,z_3) \\tag{48} \\] 而式(44)是个线性变换，因此变换后上式也能满足（容易代入验证），因此三点共线的性质不变。\n在空间 \\(E^3\\) 中取定Cartesian直角坐标系之后，几何图形就能够用坐标来表达，几何图形固有的性质自然也可以用坐标来表达，但是所表达的性质应该与Cartesian直角坐标系的取法无关。反过来，如果儿何图形的一个用Cartesian直角坐标表示的量与Cartesian直角坐标系的取法无关，则这个量应该是几何图形所固有的量；另外，这个量在几何图形的刚体运动下是保持不变的。我们所研究的就是几何图形的这种不变量。\n仿射标架 除了正交标架外，我们还经常使用仿射标架。所谓仿射标架，是指空间中的一个点 \\(P\\) 和在该点的三个不共面的向量 \\(\\bm{e}_1,\\bm{e}_2,\\bm{e}_3\\) 组成的图形 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) ，但是对该图形不要求这三个向量有单位正交的性质。令\n\\[ g_{ij}=\\bm{e}_i\\cdot\\bm{e}_j\\quad 1 \\le i,j \\le 3 \\tag{49} \\] 我们把 \\((g_{ij})\\) 称为仿射标架 \\(\\set{P;\\bm{e}_1,\\bm{e}_2,\\bm{e}_3}\\) 的度量系数。空间 \\(E^3\\) 的刚体运动把仿射标架变成仿射标架，并且保持它的度量系数不变，保持标架的定向不变。反过来，对于对于 \\(E^3\\) 中任意两个有相同度量系数的、成右手系的仿射标架，必有 \\(E^3\\) 中的一个刚体运动把其中一个仿射标架变成另一个仿射标架。很明显， \\(E^3\\) 中的全体仿射标架的集合可以等同于 \\(E^3\\times\\rm{GL(3)}\\) （见GL(3)群），其中 \\(\\rm{GL(3)}\\) 表示可逆的 \\(3\\times 3\\) 矩阵的集合。因此，\\(E^3\\) 的全体仿射标架构成一个 \\(12\\) 维的空间。\n向量函数 向量空间 定义 由三维Euclid空间 \\(E^3\\) 中的全体向量组成的空间称为三维Euclid向量空间。在给定了一个正交标架 \\(\\set{O;\\bm{i},\\bm{j},\\bm{k}}\\) 之后，该空间等同于由有序的三个实数的组构成的空间 \\(\\R^3\\) 。\n模长 设有 \\(\\R^3\\) 中的向量 \\(\\bm{a}=(a_1,a_2,a_3)\\) 的模长定义为\n\\[ |\\bm{a}|=\\sqrt{\\bm{a}\\cdot\\bm{a}}=\\sqrt{a_1^2+a_2^2+a_3^2} \\tag{50} \\] 数量积 设有 \\(\\R^3\\) 中的三个向量\n\\[ \\bm{a}=(a_1,a_2,a_3)\\\\[5pt] \\bm{b}=(b_1,b_2,b_3)\\\\[5pt] \\bm{c}=(c_1,c_2,c_3) \\tag{51} \\] 则 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 的点乘（以后也称为内积，或数量积）是\n\\[ \\bm{a}\\cdot\\bm{b}=|\\bm{a}|\\cdot|\\bm{b}|\\cdot\\cos\\angle(\\bm{a},\\bm{b})=a_1b_1+a_2b_2+a_3b_3 \\tag{52} \\] 向量积 \\(\\bm{a}\\) 和 \\(\\bm{b}\\) 的叉乘（也称为向量积）是\n\\[ \\begin{aligned} \\bm{a}\\times\\bm{b}=\u0026\\left( \\begin{vmatrix} a_2 \u0026 a_3 \\\\[5pt] b_2 \u0026 b_3 \\end{vmatrix} , \\begin{vmatrix} a_3 \u0026 a_1 \\\\[5pt] b_3 \u0026 b_1 \\end{vmatrix} , \\begin{vmatrix} a_1 \u0026 a_2 \\\\[5pt] b_1 \u0026 b_2 \\end{vmatrix} \\right) \\\\[15pt] =\u0026 \\begin{vmatrix} \\bm{i} \u0026 \\bm{j} \u0026 \\bm{k} \\\\[5pt] a_1 \u0026 a_2 \u0026 a_3 \\\\[5pt] b_1 \u0026 b_2 \u0026 b_3 \\end{vmatrix} \\end{aligned} \\tag{53} \\] 因此 \\(\\bm{a}\\times\\bm{b}\\perp\\bm{a}, \\bm{a}\\times\\bm{b}\\perp\\bm{b}\\) 。向量 \\(\\bm{a},\\bm{b}\\) 和 \\(\\bm{a}\\times\\bm{b}\\) 构成右手系，并且\n\\[ |\\bm{a}\\times\\bm{b}|=|\\bm{a}|\\cdot|\\bm{b}|\\cdot\\sin\\angle(\\bm{a},\\bm{b}) \\tag{54} \\] 混合积 \\(\\bm{a},\\bm{b}\\) 和 \\(\\bm{c}\\) 的混合积是\n\\[ (\\bm{a},\\bm{b},\\bm{c})=(\\bm{a}\\times\\bm{b})\\cdot\\bm{c}= \\begin{vmatrix} a_1 \u0026 a_2 \u0026 a_3 \\\\[5pt] b_1 \u0026 b_2 \u0026 b_3 \\\\[5pt] c_1 \u0026 c_2 \u0026 c_3 \\end{vmatrix} \\tag{55} \\] 它的几何意义是由向量 \\(\\bm{a},\\bm{b}\\) 和 \\(\\bm{c}\\) 所张成的平行六面体的有向体积。\n矢量代数 这里写几个常用的矢量代数公式。用带入坐标的方法容易验证这些恒等式成立。\n公式1（混合积恒等式）：\n\\[ \\begin{aligned} (\\bm{a},\\bm{b},\\bm{c})=\u0026(\\bm{a}\\times\\bm{b})\\cdot\\bm{c}=(\\bm{b}\\times\\bm{c})\\cdot\\bm{a}=(\\bm{c}\\times\\bm{a})\\cdot\\bm{b}\\\\[5pt] =\u0026\\bm{a}\\cdot(\\bm{b}\\times\\bm{c})=\\bm{b}\\cdot(\\bm{c}\\times\\bm{a})=\\bm{c}\\cdot(\\bm{a}\\times\\bm{b}) \\end{aligned} \\tag{56} \\] 公式2（Lagrange矢量公式）：\n\\[ \\bm{a}\\times(\\bm{b}\\times\\bm{c})=(\\bm{a}\\cdot\\bm{c})\\bm{b}-(\\bm{a}\\cdot\\bm{b})\\bm{c} \\tag{57} \\] 公式3（Jacobi恒等式）：\n\\[ \\bm{a}\\times(\\bm{b}\\times\\bm{c})+\\bm{b}\\times(\\bm{c}\\times\\bm{a})+\\bm{c}\\times(\\bm{a}\\times\\bm{b})=\\bm{0} \\tag{58} \\] 公式4（Binet-Cauchy恒等式）：\n\\[ (\\bm{a}\\times\\bm{b})\\cdot(\\bm{c}\\times\\bm{d})=(\\bm{a}\\cdot\\bm{c})(\\bm{b}\\cdot\\bm{d})-(\\bm{b}\\cdot\\bm{c})(\\bm{a}\\cdot\\bm{d}) \\tag{59} \\] 公式5（Lagrange恒等式）：\n\\[ |\\bm{a}\\times\\bm{b}|^2=|\\bm{a}|^2|\\bm{b}|^2-(\\bm{a}\\cdot\\bm{b})^2 \\tag{60} \\] 公式6（矢量四重积）：\n\\[ (\\bm{a}\\times\\bm{b})\\times(\\bm{c}\\times\\bm{d})=(\\bm{a},\\bm{b},\\bm{d})\\bm{c}-(\\bm{a},\\bm{b},\\bm{c})\\bm{d}=(\\bm{a},\\bm{c},\\bm{d})\\bm{b}-(\\bm{b},\\bm{c},\\bm{d})\\bm{a} \\tag{61} \\] 向量函数 定义 所谓向量函数是指从它的定义域到 \\(\\R^3\\) 中的映射，也就是三个有序的实函数。设有定义在区间[a,b]上的向量函数\n\\[ \\bm{r}(t)=(x(t),y(t),z(t))\\quad a \\le t \\le b \\tag{62} \\] 微积分 如果 \\(x(t),y(t),z(t)\\) 都是 \\(t\\) 的连续函数，则称向量函数 \\(\\bm{r}(t)\\) 是连续的；如果 \\(x(t),y(t),z(t)\\) 都是 \\(t\\) 的连续可微函数，则称向量函数 \\(\\bm{r}(t)\\) 是连续可微的。向量函数 \\(\\bm{r}(t)\\) 的导数和积分的定义与数值函数的导数和积分的定义是相同的，即\n\\[ \\begin{aligned} \\left.\\frac{\\mathrm{d}\\bm{r}}{\\mathrm{d}t}\\right|_{t=t_0}=\u0026\\lim\\limits_{\\Delta t \\to 0}\\frac{\\bm{r}(t_0+\\Delta t)-\\bm{r}(t_0)}{\\Delta t}\\\\[10pt] =\u0026\\lim\\limits_{\\Delta t \\to 0}\\left(\\frac{x(t_0+\\Delta t)-x(t_0)}{\\Delta t},\\frac{y(t_0+\\Delta t)-y(t_0)}{\\Delta t},\\frac{z(t_0+\\Delta t)-z(t_0)}{\\Delta t}\\right) \\end{aligned} \\tag{63} \\] \\[ \\begin{aligned} \\int_{a}^{b}\\bm{r}(t)\\mathrm{d}t=\u0026\\lim\\limits_{\\lambda\\to 0}\\sum_{i=1}^{n}\\bm{r}(t_i^\\prime)\\Delta t_i\\\\[10pt] =\u0026\\left(\\int_{a}^{b}x(t)\\mathrm{d}t,\\int_{a}^{b}y(t)\\mathrm{d}t,\\int_{a}^{b}z(t)\\mathrm{d}t\\right) \\end{aligned} \\tag{64} \\]\n其中 \\(a=t_0 \u003c t_1 \u003c \\cdots \u003c t_n = b\\) 是区间 \\([a,b]\\) 的任意一个分割， \\(\\Delta t_i=t_i-t_{i-1},\\space t_i^\\prime \\in [t_{i-1},t_i]\\) ，并且 \\(\\lambda=\\max\\set{\\Delta t_i;i=1,\\cdots,n}\\) 。这就是说，向量函数的求导和积分归结为它的分量函数的求导和积分，因此向量函数的可微性和可积性归结为它的分量函数的可微性和可积性。\n求导公式 定理2：假定 \\(\\bm{a}(t),\\bm{b}(t),\\bm{c}(t)\\) 是三个可微的向量函数，则它们的内积、向量积和混合积的导数有下面的公式\n\\[ (\\bm{a}(t)\\cdot\\bm{b}(t))^\\prime=\\bm{a}^\\prime(t)\\cdot\\bm{b}(t)+\\bm{a}(t)\\cdot\\bm{b}^\\prime(t) \\tag{65} \\] \\[ (\\bm{a}(t)\\times\\bm{b}(t))^\\prime=\\bm{a}^\\prime(t)\\times\\bm{b}(t)+\\bm{a}(t)\\times\\bm{b}^\\prime(t) \\tag{66} \\] \\[ (\\bm{a}(t),\\bm{b}(t),\\bm{c}(t))^\\prime=(\\bm{a}^\\prime(t),\\bm{b}(t),\\bm{c}(t))+(\\bm{a}(t),\\bm{b}^\\prime(t),\\bm{c}(t))+(\\bm{a}(t),\\bm{b}(t),\\bm{c}^\\prime(t)) \\tag{67} \\]\n证明（定理2）：对式(65)，由式(52)可得\n\\[ \\begin{aligned} (\\bm{a}(t)\\cdot\\bm{b}(t))'=\u0026(a_1(t)b_1(t))'+(a_2(t)b_2(t))'+(a_3(t)b_3(t))'\\\\[5pt] =\u0026a_1'(t)b_1(t)+a_2'(t)b_2(t)+a_3'(t)b_3(t)+a_1(t)b_1'(t)+a_2(t)b_2'(t)+a_3(t)b_3'(t)\\\\[5pt] =\u0026\\bm{a}'(t)\\cdot\\bm{b}(t)+\\bm{a}(t)\\cdot\\bm{b}'(t) \\end{aligned} \\tag{68} \\] 对式(66)，由式(53)可得\n\\[ \\begin{aligned} (\\bm{a}\\times\\bm{b})'=\u0026\\left( \\frac{\\mathrm{d}}{\\mathrm{d}t} \\begin{vmatrix} a_2(t) \u0026 a_3(t) \\\\[5pt] b_2(t) \u0026 b_3(t) \\end{vmatrix} , \\frac{\\mathrm{d}}{\\mathrm{d}t} \\begin{vmatrix} a_3(t) \u0026 a_1(t) \\\\[5pt] b_3(t) \u0026 b_1(t) \\end{vmatrix} , \\frac{\\mathrm{d}}{\\mathrm{d}t} \\begin{vmatrix} a_1(t) \u0026 a_2(t) \\\\[5pt] b_1(t) \u0026 b_2(t) \\end{vmatrix} \\right)\\\\[20pt] =\u0026\\left( \\frac{\\mathrm{d}}{\\mathrm{d}t}(a_2(t)b_3(t)-a_3(t)b_2(t)), \\frac{\\mathrm{d}}{\\mathrm{d}t}(a_3(t)b_1(t)-a_1(t)b_3(t)), \\frac{\\mathrm{d}}{\\mathrm{d}t}(a_1(t)b_2(t)-a_2(t)b_1(t)) \\right)\\\\[20pt] =\u0026((a_2'(t)b_3(t)-a_3'(t)b_2(t))+(a_2(t)b_3'(t)-a_3(t)b_2'(t)),\\\\[20pt] \u0026(a_3'(t)b_1(t)-a_1'(t)b_3(t))+(a_3(t)b_1'(t)-a_1(t)b_3'(t)),\\\\[20pt] \u0026(a_1'(t)b_2(t)-a_2'(t)b_1(t))+(a_1(t)b_2'(t)-a_2(t)b_1'(t)))\\\\[20pt] =\u0026(a_2'(t)b_3(t)-a_3'(t)b_2(t), a_3'(t)b_1(t)-a_1'(t)b_3(t),(a_1'(t)b_2(t)-a_2'(t)b_1(t)))+\\\\[20pt] \u0026(a_2(t)b_3'(t)-a_3(t)b_2'(t),a_3(t)b_1'(t)-a_1(t)b_3'(t),a_1(t)b_2'(t)-a_2(t)b_1'(t))\\\\[20pt] =\u0026\\left( \\begin{vmatrix} a_2'(t) \u0026 a_3'(t) \\\\[5pt] b_2(t) \u0026 b_3(t) \\end{vmatrix} , \\begin{vmatrix} a_3'(t) \u0026 a_1'(t) \\\\[5pt] b_3(t) \u0026 b_1(t) \\end{vmatrix} , \\begin{vmatrix} a_1'(t) \u0026 a_2'(t) \\\\[5pt] b_1(t) \u0026 b_2(t) \\end{vmatrix} \\right)+ \\left( \\begin{vmatrix} a_2(t) \u0026 a_3(t) \\\\[5pt] b_2'(t) \u0026 b_3'(t) \\end{vmatrix} , \\begin{vmatrix} a_3(t) \u0026 a_1(t) \\\\[5pt] b_3'(t) \u0026 b_1'(t) \\end{vmatrix} , \\begin{vmatrix} a_1(t) \u0026 a_2(t) \\\\[5pt] b_1'(t) \u0026 b_2'(t) \\end{vmatrix} \\right)\\\\[20pt] =\u0026\\bm{a}^\\prime(t)\\times\\bm{b}(t)+\\bm{a}(t)\\times\\bm{b}^\\prime(t) \\end{aligned} \\tag{69} \\] 对式(67)，由式(65)和式(66)\n\\[ \\begin{aligned} (\\bm{a}(t),\\bm{b}(t),\\bm{c}(t))^\\prime=\u0026(\\bm{a}(t)\\times\\bm{b}(t)\\cdot\\bm{c}(t))'\\\\[5pt] =\u0026(\\bm{a}(t)\\times\\bm{b}(t))'\\cdot\\bm{c}(t)+(\\bm{a}(t)\\times\\bm{b}(t))\\cdot(\\bm{c}(t))'\\\\[5pt] =\u0026\\bm{a}'(t)\\times\\bm{b}(t)\\cdot\\bm{c}(t)+\\bm{a}(t)\\times\\bm{b}'(t)\\cdot\\bm{c}(t)+(\\bm{a}(t)\\times\\bm{b}(t))\\cdot\\bm{c}'(t)\\\\[5pt] =\u0026(\\bm{a}^\\prime(t),\\bm{b}(t),\\bm{c}(t))+(\\bm{a}(t),\\bm{b}^\\prime(t),\\bm{c}(t))+(\\bm{a}(t),\\bm{b}(t),\\bm{c}^\\prime(t)) \\end{aligned} \\tag{70} \\] 结论1： \\(\\bm{a}(t)\\) 是一个可微的向量函数，则\n\\[ \\frac{\\mathrm{d}}{\\mathrm{d}t}|\\bm{a}(t)|=\\frac{\\bm{a}(t)}{|\\bm{a}(t)|}\\cdot\\frac{\\mathrm{d}\\bm{a}(t)}{\\mathrm{d}t} \\tag{71} \\] 证明（结论1）：由式(65)和式(50)可得\n\\[ \\begin{aligned} \\frac{\\mathrm{d}}{\\mathrm{d}t}|\\bm{a}(t)|=\u0026\\frac{\\mathrm{d}}{\\mathrm{d}t}\\sqrt{\\bm{a}(t)\\cdot\\bm{a}(t)}\\\\[15pt] =\u0026\\frac{1}{2\\sqrt{\\bm{a}(t)\\cdot\\bm{a}(t)}}\\frac{\\mathrm{d}}{\\mathrm{d}t}(\\bm{a}(t)\\cdot\\bm{a}(t))\\\\[15pt] =\u0026\\frac{1}{2|\\bm{a}(t)|}\\left(\\left(\\frac{\\mathrm{d}}{\\mathrm{d}t}\\bm{a}(t)\\right)\\cdot\\bm{a}(t)+\\bm{a}(t)\\cdot\\left(\\frac{\\mathrm{d}}{\\mathrm{d}t}\\bm{a}(t)\\right)\\right)\\\\[15pt] =\u0026\\frac{\\bm{a}(t)}{|\\bm{a}(t)|}\\cdot\\frac{\\mathrm{d}\\bm{a}(t)}{\\mathrm{d}t} \\end{aligned} \\tag{72} \\] 不变条件 定理3：设 \\(\\bm{a}(t)\\) 是一个处处非零的连续可微的向量函数，则\n(1) 向量函数 \\(\\bm{a}(t)\\) 的长度是常数当且仅当 \\(\\bm{a}'(t)\\cdot\\bm{a}(t)\\equiv 0\\) 。\n(2) 向量函数 \\(\\bm{a}(t)\\) 的方向不变当且仅当 \\(\\bm{a}'(t)\\times\\bm{a}(t)\\equiv 0\\) 。\n(3) 如果向量函数 \\(\\bm{a}(t)\\) 与某一个固定的方向垂直，那么\n\\[ ((\\bm{a}(t),(\\bm{a}'(t),(\\bm{a}''(t))\\equiv 0 \\tag{73} \\] 证明（定理3）：对(1)，因为\n\\[ \\frac{\\mathrm{d}}{\\mathrm{d}t}|\\bm{a}(t)|^2=\\frac{\\mathrm{d}(\\bm{a}(t)\\cdot\\bm{a}(t))}{\\mathrm{d}t}=2\\bm{a}'(t)\\cdot\\bm{a}(t) \\tag{74} \\] 所以 \\(|\\bm{a}(t)|^2\\) 是常数，当且仅当 \\(\\bm{a}'(t)\\cdot\\bm{a}(t)\\equiv 0\\) 。\n对(2)，如果向量函数 \\(\\bm{a}(t)\\) 的方向不变，则有一个固定的单位向量 \\(\\bm{b}\\) ，使得向量函数 \\(\\bm{a}(t)\\) 能够写成\n\\[ \\bm{a}(t)=f(t)\\cdot\\bm{b} \\tag{75} \\] 两边乘以 \\(\\bm{b}\\) 并利用单位向量的特性得 \\(f(t)=\\bm{a}(t)\\cdot\\bm{b}\\) 。其中 \\(f(t)\\) 是一个处处非零的连续可微函数，因此\n\\[ \\bm{a}'(t)=f'(t)\\cdot\\bm{b} \\tag{76} \\] \\[ \\bm{a}'(t)\\times\\bm{a}(t)=0 \\tag{77} \\]\n反过来，设 \\(\\bm{a}'(t)\\times\\bm{a}(t)=0\\) ，令 \\(\\displaystyle\\bm{b}(t)=\\frac{\\bm{a}(t)}{|\\bm{a}(t)|}\\) ，有 \\(|\\bm{b}(t)|=1\\) 。我们要证明 \\(\\bm{b}(t)\\) 是常向量函数。因为 \\(\\bm{b}(t)\\) 的长度是 \\(1\\) ，故由 (1) 可知 \\(\\bm{b}'(t)\\cdot\\bm{b}(t)\\equiv 0\\) ，即\n\\[ \\bm{b}'(t)\\cdot\\bm{a}(t)\\equiv 0 \\tag{78} \\] 由 \\(\\bm{b}(t)\\) 的定义得知\n\\[ \\bm{a}(t)=f(t)\\bm{b}(t) \\tag{79} \\] 其中 \\(f(t)=|\\bm{a}(t)|\\) 处处不为零，故\n\\[ \\bm{a}'(t)=f'(t)\\bm{b}(t)+f(t)\\bm{b}'(t) \\tag{80} \\] 注意由假设条件 \\(\\bm{a}(t)\\times\\bm{a}'(t)\\equiv 0\\) ，因此有\n\\[ \\bm{a}(t)\\times\\bm{a}'(t)=f'(t)\\bm{a}(t)\\times\\bm{b}(t)+f(t)\\bm{a}(t)\\times\\bm{b}'(t)=f(t)\\bm{a}(t)\\times\\bm{b}'(t)\\equiv\\bm{0} \\tag{81} \\] 故 \\(\\bm{a}(t)\\times\\bm{b}'(t)\\equiv 0\\) ，即 \\(\\bm{b}'(t)\\) 和 \\(\\bm{a}(t)\\) 共线，故存在 \\(\\lambda(t)\\) 使得\n\\[ \\bm{b}'(t)=\\lambda(t)\\bm{a}(t) \\tag{82} \\] 由式(78)得\n\\[ \\bm{b}'(t)\\cdot\\bm{a}(t)=\\lambda(t)\\bm{a}(t)\\cdot\\bm{a}(t)=\\lambda(t)f^2(t) \\equiv 0 \\tag{83} \\] 注意 \\(f(t)\\) 处处不为零，因此 \\(\\lambda(t)\\equiv 0\\) ，即\n\\[ \\bm{b}'(t)\\equiv \\bm{0} \\tag{84} \\] 故 \\(\\bm{}(t)\\) 是常向量，所以向量函数 \\(\\bm{a}(t)\\) 的方向不变。\n对 (3) ，设有单位常向量 \\(\\bm{b}\\) ，使得 \\(\\bm{a}(t)\\cdot\\bm{b}\\equiv 0\\) 。对此式求导数得到\n\\[ \\bm{a}'(t)\\cdot\\bm{b}\\equiv 0,\\quad \\bm{a}''(t)\\cdot\\bm{b}\\equiv 0 \\tag{85} \\] 因此对于任意 \\(t\\) ，向量 \\(\\bm{a}(t),\\bm{a}'(t),\\bm{a}''(t)\\) 共面，于是\n\\[ ((\\bm{a}(t),(\\bm{a}'(t),(\\bm{a}''(t))\\equiv 0 \\tag{86} \\] 反过来，假定上面的式子成立，则\n\\[ (\\bm{a}(t)\\times\\bm{a}'(t))\\cdot\\bm{a}''(t)\\equiv 0 \\tag{87} \\] 对于 \\(\\bm{a}(t)\\times\\bm{a}'(t)=\\bm{0}\\) 的情况，由 (2) 的结论可以得到 \\(\\bm{a}(t)\\) 的方向不变，因此 (3) 直接成立。对于 \\(\\bm{a}(t)\\times\\bm{a}'(t)\\ne\\bm{0}\\) ，令\n\\[ \\bm{b}(t)=\\bm{a}'(t)\\times\\bm{a}(t) \\tag{88} \\] \\(\\bm{b}(t)\\) 与 \\(\\bm{a}(t)\\) 垂直。有\n\\[ \\bm{b}'(t)=\\bm{a}''(t)\\times\\bm{a}(t)+\\bm{a}'(t)\\times\\bm{a}'(t)=\\bm{a}''(t)\\times\\bm{a}(t) \\tag{89} \\] 由三向量叉乘公式、式(87)和式(88)\n\\[ \\begin{aligned} \\bm{b}(t)\\times\\bm{b}'(t)=\u0026\\bm{b}(t)\\times(\\bm{a}''(t)\\times\\bm{a}(t))\\\\[5pt] =\u0026(\\bm{b}(t)\\cdot\\bm{a}(t))\\bm{a}''(t)-(\\bm{b}(t)\\cdot\\bm{a}''(t))\\bm{a}(t)\\text{（三向量叉乘公式）}\\\\[5pt] =\u0026-((\\bm{a}'(t)\\times\\bm{a}(t))\\cdot\\bm{a}''(t))\\bm{a}(t)\\text{（式(88)）}\\\\[5pt] =\u0026((\\bm{a}(t)\\times\\bm{a}'(t))\\cdot\\bm{a}''(t))\\bm{a}(t)\\\\[5pt] =\u0026(\\bm{a}(t),\\bm{a}'(t),\\bm{a}''(t))\\bm{a}(t)\\equiv 0\\text{（式(87)）} \\end{aligned} \\tag{90} \\] 根据 (2) 的结论，向量函数 \\(\\bm{b}(t)\\) 有确定的方向，令 \\(\\displaystyle\\bm{b}_0=\\frac{\\bm{b}(t)}{|\\bm{b}(t)|}\\) ，则 \\(\\bm{b}_0\\) 是单位常向量，并且\n\\[ \\bm{a}(t)\\cdot\\bm{b}_0=\\frac{\\bm{a}(t)\\cdot\\bm{b}(t)}{|\\bm{b}(t)|}\\equiv 0 \\tag{91} \\] 证毕。\n失去人性，失去很多；失去兽性，失去一切。 ― 刘慈欣, 《三体Ⅲ：死神永生》 ","date":"2024-10-08T15:55:08+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/geometry/differential_geometry/euclidean_space/","title":"微分几何（一）：Euclid空间"},{"content":" 函数的无穷级数和无穷乘积展开 在本文中，我们介绍一些在初等数学课程里不常讲到的关于函数的无穷级数展开，无穷乘积展开和渐近展开。\nBernoulli多项式和Bernoulli数 定义1（Bernoulli多项式）：称下列展开式给出的 \\(\\varphi_n(x)(n=0,1,2,\\cdots)\\) 为Bernoulli多项式\n\\[ \\frac{te^{xt}}{e^t-1}=\\sum_{n=0}^{\\infin}\\frac{t^n}{n!}\\varphi_n(x) \\tag{1} \\] 左方的函数称为Bernoulli多项式的生成函数。级数在 \\(|t|\u003c2\\pi\\) 时收敛，因为左方函数离 \\(t=0\\) 最近的奇点是 \\(t=\\pm 2\\pi i\\) （ \\(|t|\u003c2\\pi\\) 时没有奇点故值有限）。\n","date":"2024-10-06T22:21:34+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/analysis/special_functions/infinite_expansions/","title":"特殊函数（一）：函数的无穷级数和无穷乘积展开"},{"content":" Legendre函数 Legendre函数是一类特殊函数，在数学和物理学中扮演着重要的角色，特别是在涉及到球面和多项式近似的领域。作为一类正交多项式，勒让德多项式具有独特的性质，使其在数值分析、量子力学和电磁学等多个领域中广泛应用。尽管勒让德函数的应用十分广泛，但它们的理论基础及其数学性质同样值得深入研究。本篇文篇将重点探讨勒让德函数的定义、性质以及相关的数学工具，旨在为读者提供对这一重要数学对象的全面理解。\nLegendre函数 普通Legendre函数 定义1（Legendre方程）：将如下方程定义为Legendre方程（普通Legendre方程）\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+\\nu(\\nu+1)y=0 \\tag{1} \\] \\(\\nu\\) 和 \\(x\\) 可以是任何复数。该方程的解称为Legendre函数（普通Legendre函数）。\n连带Legendre函数 定义2（连带Legendre方程）：将如下方程定义为连带Legendre方程\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+\\left(\\nu(\\nu+1)-\\frac{\\mu}{1-x^2}\\right)y=0 \\tag{2} \\] 该方程的解称为连带Legendre函数。可以看到，定义1是连带Legendre方程在 \\(\\mu=0\\) 时的特殊情况。\n该方程有三个奇点： \\(-1,1,\\infin\\) ，而且都是正则奇点，指标分别为 \\(\\displaystyle\\left(\\frac{\\mu}{2},-\\frac{\\mu}{2}\\right),\\left(\\frac{\\mu}{2},-\\frac{\\mu}{2}\\right),\\left(\\nu+1,\\nu\\right)\\) ，因此这个方程属于超几何方程类型。它的解也可以用超几何方程表达。由《特殊函数概论》2.9节(12)和(16)有该方程解为\n\\[ P \\begin{Bmatrix} -1 \u0026 1 \u0026 \\infin \u0026 \\\\[10pt] \\displaystyle\\frac{\\mu}{2} \u0026 \\displaystyle\\frac{\\mu}{2} \u0026 \\nu+1; \u0026 x\\\\[10pt] \\displaystyle-\\frac{\\mu}{2} \u0026 \\displaystyle-\\frac{\\mu}{2} \u0026 -\\nu \u0026 \\end{Bmatrix} =P \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] \\displaystyle\\frac{\\mu}{2} \u0026 \\displaystyle\\frac{\\mu}{2} \u0026 \\nu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] \\displaystyle-\\frac{\\mu}{2} \u0026 \\displaystyle-\\frac{\\mu}{2} \u0026 -\\nu \u0026 \\end{Bmatrix} \\\\[10pt] =\\left(\\frac{1-x}{2}\\right)^{\\frac{\\mu}{2}}\\left(1-\\frac{1-x}{2}\\right)^{\\frac{\\mu}{2}} \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] 0 \u0026 0 \u0026 \\nu+\\mu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] -\\mu \u0026 -\\mu \u0026 -\\nu+\\mu \u0026 \\end{Bmatrix} \\\\[10pt] =2^{-\\mu}(1-x^2)^{\\frac{\\mu}{2}}P \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] 0 \u0026 0 \u0026 \\nu+\\mu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] -\\mu \u0026 -\\mu \u0026 -\\nu+\\mu \u0026 \\end{Bmatrix} \\tag{3} \\] 在实际应用中最常见的是 \\(\\mu\\) 和 \\(\\nu\\) 都等于整数的情形。当 \\(\\mu\\) 和 \\(\\nu\\) 不是整数时，需要较多地用到超几何函数理论。\nLegendre多项式 Legendre多项式的定义 定义3（Legendre多项式）：Legendre多项式是如下Legendre方程的多项式解\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+n(n+1)y=0\\quad(n=0,1,2,\\cdots) \\tag{4} \\] ","date":"2024-10-01T13:25:22+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/analysis/special_functions/legendre_functions/","title":"特殊函数（五）：Legendre函数"},{"content":" 3D高斯泼溅算法 在三维重建领域，随着计算机图形学和相关技术的飞速发展，各种创新算法不断涌现，为精准、高效地构建三维场景提供了强大支持。其中，3D高斯泼溅算法（3D Gaussian Splatting，简称3DGS）‌作为一种新兴的、具有革命性的三维重建技术，正逐渐受到广泛关注。\n3D高斯泼溅算法的创新在于其独特的表示和渲染方法。它通过将场景中的每个点视为一个高斯球，利用三维高斯函数的数学性质，将离散的数据点或体素转换为可视化的效果。这一过程中，三维高斯球的叠加不仅实现了数据的平滑过渡，还保留了场景中的细粒度细节。同时，结合快速的可见性感知渲染算法，3D高斯泼溅算法能够在保证高质量渲染效果的同时，实现实时的新视图合成。\n对比NeRF和传统的Mesh：一个是纯连续的、隐式表达在可微空间内；一个是纯离散的（虽然可以插值）、显式表达在三维空间内，3D高斯是在离散和连续间的一个平衡：在高斯球内部是连续的、可微的；在整个空间中，每个高斯球又是离散的。\n本文将深入探讨3D高斯泼溅算法的基本原理，从其数学基础、实现步骤到应用场景，全面解析这一先进技术的核心优势和技术特点。通过本文的介绍，读者将能够更深入地理解3D高斯泼溅算法的工作原理，并探索其在三维重建、点云渲染、体数据可视化等领域的广泛应用前景。\n算法框架 3DGS的主要任务有两个：三维重建和渲染。简单来说，就是提供一组某个场景的照片，然后将这个场景实时渲染出来。算法的主要框架如下图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e S f M P oi n t s Initialization 3D G a u s s ians P r oje c tion A d a p t i v e Den s i t y Co n t r o l Di ff e r e n tia b le T ile R as t erizer I m a g e Came r a O p e r ation F l o w G r adie n t F l o w 图1\u0026emsp;3D Gaussian Splatting整体框架\n由上图可以看出，当拿到一组场景照片以后，我们需要先使用某种SfM(Structure from Motion)算法估计出这一组照片的结构（位置）和姿态（摄像机方向）和一组稀疏点云(SfM Points)。然后交给3DGS进行初始化(Initialization)‌得到一组初始的3D高斯球(3D Gaussians)。然后，我们借助相机外参（结构和姿态）将这一组3D高斯球投影到相机平面上（Projection），接着再使用可微分块光栅化(Differentiable Tile Rasterizer)‌渲染得到图像（Image）。得到渲染图像后将其与相机原始的图像(Ground Truth)进行loss比对，然后沿着虚线箭头进行梯度回传。虚线箭头从上回传的时候，更新3D高斯球中的参数，从下回传时会经过自适应密度控制(Adaptive Density Control)‌的处理，而后更新3D高斯球中的点云。\n接下来，我们详细讲解算法中的每一个步骤，并给出具体的实现方式。\n算法内容 运动结构恢复 由于该步骤并不是3D Gaussian Splatting的主要内容（详细请见运动结构恢复），而且已经有较成熟的算法和软件可以实现这部分内容（例如COLMAP），因此在此不做过多介绍。\n3D高斯椭球集的创建及描述 拿到相机的位置、姿态和稀疏点云后，就可以开始创建初始的3D高斯椭球集。描述一个3D高斯椭球需要四种信息：位置、形状、颜色和不透明度。\n3D高斯椭球 在概率论中我们已经学到了多维高斯分布的表达式如下：\n\\[ f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^{T}\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right) \\tag{1} \\] 其中 \\(\\bm{\\mu}\\) 是均值， \\(\\bm{\\Sigma}\\) 是协方差矩阵，它是对称且正定的。在三维空间中，我们将这么一个三维高斯分布叫做一个3D高斯椭球。\n位置 3D高斯椭球的均值 \\(\\bm{\\mu}\\) 就是这个3D高斯椭球的位置，也就是其中心点。初始化3D高斯椭球的时候，这个中心点就是由SfM算法得到的稀疏点云。\n形状 3D高斯椭球的协方差 \\(\\bm{\\Sigma}\\) 就是代表它的形状。由实对称矩阵的正交相似对角化和 \\(\\bm{\\Sigma}\\) 的对称性和正定性， \\(\\bm{\\Sigma}\\) 可以被分解成 \\(\\bm{\\Sigma}=\\bm{R}\\bm{\\Lambda}\\bm{R}^T\\) ，其中 \\(\\bm{R}\\) 是一个正交矩阵， \\(\\bm{\\Lambda}\\) 是由 \\(\\bm{\\Sigma}\\) 的特征值构成的对角矩阵。注意正定矩阵的特征值都是正的，因此 \\(\\bm{\\Lambda}\\) 还可以被分解成 \\(\\bm{\\Lambda}=\\bm{S}\\bm{S}^T\\) ，其中 \\(\\bm{S}\\) 也是一个正的对角矩阵，且其对角线上的值其实就是对应的 \\(\\bm{\\Sigma}\\) 特征值的平方根。因此有\n\\[ \\bm{\\Sigma}=\\bm{R}\\bm{S}\\bm{S}^T\\bm{R}^T \\tag{2} \\] 我们注意看这个式子的几何意义。由于 \\(\\bm{S}\\) 是一个对角矩阵，因此其可以被看成一个放缩变换，而 \\(\\bm{R}\\) 是一个正交矩阵，因此可以看成一个旋转变换（见旋转变换）。将其代回式(1)，易得实际上这个操作就是把正交基先拉伸后旋转，再将去均值的随机向量 \\(\\bm{x}-\\bm{\\mu}\\) 投影到新的正交基上的操作。\n对于三维对角矩阵 \\(\\bm{S}\\) ，只需要一个三维向量 \\(\\bm{s}\\) 描述即可，该向量的每个分量对应对角矩阵 \\(\\bm{S}\\) 的每个对角分量。即\n\\[ \\bm{S}\\left(\\bm{s}\\right)= \\begin{pmatrix} s_1 \u0026 0 \u0026 0 \\\\[5pt] 0 \u0026 s_2 \u0026 0 \\\\[5pt] 0 \u0026 0 \u0026 s_3 \\end{pmatrix} \\tag{3} \\] 对于正交矩阵 \\(\\bm{R}\\) ，可以用一个四元数 \\(\\bm{q}\\) 来表示（见四元数与旋转）。在机器学习中，直接对 \\(\\bm{\\Sigma}\\) 进行学习很难保证其正定性。因此，3DGS采用的方法是对 \\(\\bm{s}\\) 和 \\(\\bm{q}\\) 进行学习，再用公式间接计算 \\(\\bm{\\Sigma}\\) 。这里，我们先给出四元数到旋转矩阵的计算关系（具体推导见四元数与旋转）：\n\\[ \\bm{R}\\left(\\bm{q}\\right)= \\begin{pmatrix} 1-2\\left(q_2^2+q_3^2\\right) \u0026 2\\left(q_1q_2-q_0q_3\\right) \u0026 2\\left(q_1q_3+q_0q_2\\right) \\\\[5pt] 2\\left(q_1q_2+q_0q_3\\right) \u0026 1-2\\left(q_1^2+q_3^2\\right) \u0026 2\\left(q_2q_3-q_0q_1\\right) \\\\[5pt] 2\\left(q_1q_3-q_0q_2\\right) \u0026 2\\left(q_2q_3+q_0q_1\\right) \u0026 1-2\\left(q_1^2+q_2^2\\right) \\end{pmatrix} \\tag{4} \\] 在初始化的时候，3DGS会利用KNN算法计算点云中每个点到与其最近的3个点的平均距离，然后取对数，将其同时作为 \\(\\bm{s}\\) 中的三个分量的值。对于 \\(\\bm{q}\\) ，3DGS将其初始化为 \\(\\bm{q}=\\left(1,0,0,0\\right)\\) ，也就是不进行旋转。\n颜色 对于一个3D高斯球，它的不同方向会呈现不同的颜色，那么这种各向异性的颜色该如何描述呢？这里需要运用到数学中的一个重要的展开工具：实球谐函数(Real Spherical Harmonics)（见球谐函数）。\n计算机图形学中常用的实球谐函数的定义如下：\n\\[ \\mathcal{Y}_l^m\\left(\\theta,\\varphi\\right)= \\begin{cases} \\displaystyle\\sqrt{2}K_l^mP^m_l\\left(\\cos\\theta\\right)\\cos m\\varphi\\quad \u0026(m\u003e0)\\\\[5pt] \\displaystyle K_l^mP^{m}_{l}\\left(\\cos\\theta\\right)\\quad \u0026(m=0)\\\\[5pt] \\displaystyle\\sqrt{2}K_l^mP^{-m}_{l}\\left(\\cos\\theta\\right)\\sin (-m\\varphi)\\quad \u0026(m\u003c0) \\end{cases} \\tag{5} \\] 其中\n\\[ K_l^m=\\sqrt{\\frac{2l+1}{4\\pi}\\frac{\\left(l-|m|\\right)!}{\\left(l+|m|\\right)!}} \\tag{6} \\] 是归一化系数。 \\(P^m_l\\left(\\cos\\theta\\right)\\) 是连带Legendre多项式（见连带Legendre多项式），定义如下：\n\\[ P^m_l\\left(x\\right)=\\left(-1\\right)^m\\frac{\\left(1-x^2\\right)^{\\frac{m}{2}}}{2^ll!}\\frac{\\mathrm{d}^{l+m}}{\\mathrm{d}x^{l+m}}(x^2-1)^l \\tag{7} \\] 类似于Tayler展开和Fourier展开，任何一个在球面上连续的实函数 \\(f(\\theta,\\varphi)\\) 可以用 \\(Y_{lm}(\\theta,\\varphi)\\) 展开为一平均收敛的级数\n\\[ f(\\theta,\\varphi)=\\sum_{l=0}^{\\infin}\\sum_{-l}^{l}C_l^m\\mathcal{Y}_l^m(\\theta,\\varphi) \\tag{8} \\] 其中\n\\[ C_l^m=\\int_0^\\pi\\int_0^{2\\pi}\\mathcal{Y}_l^m(\\theta,\\varphi)f(\\theta,\\varphi)\\sin\\theta d\\theta d\\varphi \\tag{9} \\] 3DGS算法使用 \\(3\\) 阶球函数近似，使用RGB颜色来进行渲染。也就是，一共有三个通道，每个通道由区间 \\([0,1]\\) 的一个数来映射到每个通道表示颜色的 \\(0\\text{\\textasciitilde}255\\) 的一个数字。将每个RGB通道展开成一个 \\(3\\) 阶球函数需要 \\((3+1)^2=16\\) 个系数。由此可得，要想表示一个3D高斯椭球的颜色信息，需要 \\(3\\times (3+1)^2=48\\) 个参数。\n具体的，当我们拿到这 \\(48\\) 个参数和一个方向向量 \\(\\bm{n}=(x,y,z)\\) 以后，利用式(8)，我们可以通过如下推导得到该方向的球谐函数值\n\\[ \\begin{aligned} f_i(\\bm{n})_{SH}=\u0026\\sum_{l=0}^{3}\\sum_{-l}^{l}C_l^m(i)\\mathcal{Y}_l^m(\\bm{n})\\\\[5pt] =\u0026C_0^0(i)\\mathcal{Y}_0^0(\\bm{n})+\\\\[5pt] \u0026C_1^{-1}(i)\\mathcal{Y}_1^{-1}(\\bm{n})+C_1^0\\mathcal{Y}_1^0(\\bm{n})+C_1^1\\mathcal{Y}_1^1(\\bm{n})+\\\\[5pt] \u0026C_2^{-2}(i)\\mathcal{Y}_2^{-2}(\\bm{n})+C_2^{-1}(i)\\mathcal{Y}_2^{-1}(\\bm{n})+C_{20}\\mathcal{Y}_{20}(\\bm{n})+C_{21}\\mathcal{Y}_{21}(\\bm{n})+C_{22}(i)\\mathcal{Y}_{22}(\\bm{n})+\\\\[5pt] \u0026C_3^{-3}(i)\\mathcal{Y}_3^{-3}(\\bm{n})+C_3^{-2}(i)\\mathcal{Y}_3^{-2}(\\bm{n})+C_3^{-1}(i)\\mathcal{Y}_3^{-1}(\\bm{n})+C_3^0\\mathcal{Y}_3^0(\\bm{n})+C_3^1\\mathcal{Y}_3^1(\\bm{n})+C_3^2(i)\\mathcal{Y}_3^2(\\bm{n})+C_3^3(i)\\mathcal{Y}_3^3(\\bm{n}) \\end{aligned} \\tag{10} \\] \\(i\\) 取 \\(1,2,3\\) 表示 \\(3\\) 个RGB通道， \\(C_{00}(i)\\text{\\textasciitilde}C_{33}(i)\\) 均已知，下面给出 \\(\\mathcal{Y}_{00}(\\bm{n})\\text{\\textasciitilde}\\mathcal{Y}_{33}(\\bm{n})\\) 的表达式（可直接根据式(5)得到）\n实球谐函数 表达式 值 \\(\\mathcal{Y}_0^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{1}{\\pi}}\\) \\(0.28209479177387814\\) \\(\\mathcal{Y}_1^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}y\\) \\(-0.4886025119029199\\times y\\) \\(\\mathcal{Y}_1^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}z\\) \\(0.4886025119029199\\times z\\) \\(\\mathcal{Y}_1^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}x\\) \\(-0.4886025119029199\\times x\\) \\(\\mathcal{Y}_2^{-2}(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}xy\\) \\(1.0925484305920792\\times xy\\) \\(\\mathcal{Y}_2^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}yz\\) \\(-1.0925484305920792\\times yz\\) \\(\\mathcal{Y}_2^0(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{4}\\sqrt{\\frac{5}{\\pi}}(3z^2-1)\\) \\(0.31539156525252005\\times (3z^2-1)\\) \\(\\mathcal{Y}_2^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}xz\\) \\(-1.0925484305920792\\times xz\\) \\(\\mathcal{Y}_2^2(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{15}{\\pi}}(x^2-y^2)\\) \\(0.5462742152960396\\times (x^2-y^2)\\) \\(\\mathcal{Y}_3^{-3}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{70}{\\pi}}y(3x^2-y^2)\\) \\(-0.5900435899266435\\times y(3x^2-y^2)\\) \\(\\mathcal{Y}_3^{-2}(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{105}{\\pi}}xyz\\) \\(2.890611442640554\\times xyz\\) \\(\\mathcal{Y}_3^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{42}{\\pi}}y(5z^2-1)\\) \\(-0.4570457994644658\\times y(5z^2-1)\\) \\(\\mathcal{Y}_3^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{7}{\\pi}}z(5z^2-3)\\) \\(0.3731763325901154\\times z(5z^2-3)\\) \\(\\mathcal{Y}_3^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{42}{\\pi}}x(5z^2-1)\\) \\(-0.4570457994644658\\times x(5z^2-1)\\) \\(\\mathcal{Y}_3^2(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{105}{\\pi}}z(x^2-y^2)\\) \\(1.445305721320277\\times z(x^2-y^2)\\) \\(\\mathcal{Y}_3^3(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{70}{\\pi}}x(x^2-3y^2)\\) \\(-0.5900435899266435\\times x(x^2-3y^2)\\) 表1\u0026emsp;球谐函数表达式及值\n这是在实球谐函数一侧进行合成的方法。但是我们还需要将其换算到RGB通道参数。为了方便合成与分解（减少精度损失）和让展开更对称，3DGS采用如下变换联系实球谐函数和RGB通道参数：\n\\[ f_i(\\bm{n})_{SH}=f_i(\\bm{n})_{RGB}-0.5 \\tag{11} \\] 在初始化的时候，3DGS将 \\(C_0^0(i)\\) 初始化成稀疏点云中的RGB通道值（需要通过上式变换到球谐函数侧），其他参数均初始化为0。\n不透明度 除了位置、形状和颜色，每个3D高斯椭球还有一个不透明度参数 \\(\\omicron\\) 。此时对于某个点 \\((x,y,z)\\) ，其不透明度为：\n\\[ \\alpha(x,y,z)=\\omicron\\cdot\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^{T}\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right) \\tag{12} \\] 这个不透明度会在下文渲染部分仔细讲解。初始化的时候，每个3D高斯椭球的透明度均被初始化成 \\(0.1\\) 。\n渲染 得到一组3D高斯椭球集之后，我们需要把他渲染出来。渲染操作的输入是3D高斯椭球集的各个参数和相机参数，输出是相机看到的图片。首先，我们需要将3D高斯椭球集投影到相机对应的2D平面内，然后再采用可微分块光栅化的办法进行渲染。\n投影 如何将3D高斯椭球投影到2D平面进行渲染是3DGS中非常重要的关键点。首先我们来证明一个重要的结论：\n结论1：多维高斯分布的概率分布函数 \\(\\displaystyle f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)\\) ，对仿射变换 \\(\\bm{u}=\\phi(\\bm{x})=\\bm{M}\\bm{x}+\\bm{c}\\) ，有\n\\[ f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)=\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right) \\tag{13} \\] 证明（结论1）：由上式和式(1)可得\n\\[ \\begin{aligned} \u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\phi(\\bm{x})|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{M}\\bm{x}+\\bm{c}|\\bm{M}\\bm{\\mu}+\\bm{c},\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)^{T}(\\bm{M}\\bm{\\Sigma}\\bm{M}^T)^{-1}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)\\right)\\\\ \\end{aligned} \\tag{14} \\] 由 \\(|AB|=|A||B|\\) 和 \\(|A^T|=|A|\\) ，对系数部分有\n\\[ \\begin{aligned} \u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left|\\bm{M}^{-1}\\right|^2\\left(2\\pi\\right)^3\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^T\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left|\\bm{M}^{-1}\\right|^2\\left(2\\pi\\right)^3\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}^{-1}\\right|\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^{-1}\\right|\\left|\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}^{-1}\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^{-1}\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}} \\end{aligned} \\tag{15} \\] 由 \\((AB)^{-1}=B^{-1}A^{-1}\\) 和 \\((AB)^T=B^TA^T\\) ，对指数部分有\n\\[ \\begin{aligned} \u0026\\exp\\left(-\\frac{1}{2}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)^{T}(\\bm{M}\\bm{\\Sigma}\\bm{M}^T)^{-1}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)^{T}\\left(\\bm{M}^T\\right)^{-1}\\bm{\\Sigma}^{-1}\\bm{M}^{-1}\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{M}^T\\left(\\bm{M}^T\\right)^{-1}\\bm{\\Sigma}^{-1}\\bm{M}^{-1}\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ \\end{aligned} \\tag{16} \\] 综上可得\n\\[ \\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)=f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right) \\tag{17} \\] 证毕。\n我们先将3D高斯椭球从世界坐标系下变换到相机坐标系下（只是平移和旋转）。这个变换可以写为\n\\[ \\bm{x}^{\\prime\\prime}=\\phi^{\\prime\\prime}(\\bm{x})=\\bm{W}\\bm{x}+\\bm{b} \\tag{18} \\] 其中 \\(\\bm{W}\\) 和 \\(\\bm{b}\\) 可以由相机坐标系的旋转矩阵 \\(\\bm{R}\\) 和位置坐标 \\(\\bm{t}\\) 得来。\n\\[ \\bm{W}=\\bm{R}^T\\\\[5pt] \\bm{b}=-\\bm{R}^T\\bm{t} \\tag{19} \\] 使用结论1，我们可以得到经过该变换后的期望值 \\(\\bm{\\mu}^{\\prime\\prime}\\) 协方差矩阵 \\(\\bm{\\Sigma}^{\\prime\\prime}\\)\n\\[ \\bm{\\mu}^{\\prime\\prime}=\\phi(\\bm{\\mu})\\\\[5pt] \\bm{\\Sigma}^{\\prime\\prime}=\\bm{W}\\bm{\\Sigma}\\bm{W}^T \\tag{20} \\] 然后，在相机坐标系下，我们需要使用一个透视变换将其变换到图像坐标系（见透视变换）。注意3DGS使用了和UnrealEngine相同的左手坐标系。\n\\[ \\bm{M}= \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}} \u0026 0 \u0026 \\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}} \u0026 0 \\\\[20pt] 0 \u0026 \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}} \u0026 \\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}} \u0026 0\\\\[20pt] 0 \u0026 0 \u0026 \\displaystyle\\frac{z_{far}}{z_{far}-z_{near}} \u0026 \\displaystyle-\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\\\[20pt] 0 \u0026 0 \u0026 1 \u0026 0 \\end{pmatrix} \\tag{21} \\] 该矩阵是在齐次坐标下的变换矩阵，所以是4维的。其中， \\(z_{near}\\) 是近平面， \\(z_{far}\\) 是远平面， \\(y_{top},y_{bottom},x_{left},x_{right}\\) 分别是相机取景框的上下左右边框。可以将其用 \\(x,y\\) 轴的视场角表示\n\\[ \\begin{aligned} \u0026x_{right}=z_{near}\\tan\\left(\\frac{fov_x}{2}\\right)\\\\[5pt] \u0026x_{left}=-x_{right}\\\\[5pt] \u0026y_{top}=z_{near}\\tan\\left(\\frac{fov_y}{2}\\right)\\\\[5pt] \u0026y_{bottom}=-y_{top} \\end{aligned} \\tag{22} \\] 透视变换的三维形式不是仿射变换，但我们可以尝试写出它。对于 \\(\\bm{P}^{\\prime\\prime}=(x^{\\prime\\prime},y^{\\prime\\prime},z^{\\prime\\prime},1)^T\\) ，由 \\(\\bm{P}^{\\prime}=\\bm{M}\\bm{P}^{\\prime\\prime}\\) 得\n\\[ \\bm{P}^{\\prime}= \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}x^{\\prime\\prime}+\\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}}z^{\\prime\\prime}\\\\[20pt] \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}y^{\\prime\\prime}+\\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}}z^{\\prime\\prime}\\\\[20pt] \\displaystyle\\frac{z_{far}}{z_{far}-z_{near}}z^{\\prime\\prime}\\displaystyle-\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\\\[20pt] z^{\\prime\\prime} \\end{pmatrix} \\tag{23} \\] 将其齐次化后可得\n\\[ \\begin{aligned} x^{\\prime}=\u0026\\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{x^{\\prime\\prime}}{z^{\\prime\\prime}}+\\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}}\\\\[20pt] y^{\\prime}=\u0026\\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{y^{\\prime\\prime}}{z^{\\prime\\prime}}+\\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}}\\\\[20pt] z^{\\prime}=\u0026\\displaystyle\\frac{z_{far}}{z_{far}-z_{near}}-\\displaystyle\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\frac{1}{z^{\\prime\\prime}} \\end{aligned} \\tag{24} \\] 这不是一个仿射变换。但是，考虑到3D高斯椭球都很小，我们可以将右端的式子在 \\(\\bm{\\mu}^{\\prime\\prime}=\\phi(\\bm{\\mu})\\) 处展开。由多元函数展开\n\\[ \\begin{pmatrix} x^{\\prime}\\\\ y^{\\prime}\\\\ z^{\\prime} \\end{pmatrix} =\\bm{\\mu}^{\\prime\\prime}+\\bm{J}(\\bm{\\mu}^{\\prime\\prime}) \\begin{pmatrix} x^{\\prime\\prime}\\\\ y^{\\prime\\prime}\\\\ z^{\\prime\\prime} \\end{pmatrix} \\tag{25} \\] 其中 \\(\\bm{J}(\\bm{\\mu}^{\\prime\\prime})\\) 是上述变换的Jacobi矩阵。具体来说对式(24)\n\\[ \\begin{aligned} \\bm{J}(\\bm{\\mu}^{\\prime\\prime})=\u0026 \\left. \\begin{pmatrix} \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\end{pmatrix} \\right._{\\bm{x}^{\\prime\\prime}=\\bm{\\mu}^{\\prime\\prime}} \\\\[50pt] =\u0026 \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{1}{\\mu_z^{\\prime\\prime}} \u0026 \\displaystyle-\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{\\mu_x^{\\prime\\prime}}{\\left(\\mu_z^{\\prime\\prime}\\right)^2} \u0026 0\\\\[20pt] 0 \u0026 \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{1}{\\mu_z^{\\prime\\prime}} \u0026 \\displaystyle-\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{\\mu_y^{\\prime\\prime}}{\\left(\\mu_z^{\\prime\\prime}\\right)^2}\\\\[20pt] 0 \u0026 0 \u0026 \\displaystyle\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\frac{1}{\\left(\\mu_z^{\\prime\\prime}\\right)^2} \\end{pmatrix} \\end{aligned} \\tag{26} \\] 这样就可以把透视变换近似为一个仿射变换。因此可以使用结论1\n\\[ \\bm{\\Sigma}^{\\prime}=\\bm{J}\\bm{\\Sigma}^{\\prime\\prime}\\bm{J}^T \\tag{27} \\] 综合式(20)和式(27)可得在相机视角下\n\\[ \\bm{\\Sigma}^{\\prime}==\\bm{J}\\bm{W}\\bm{\\Sigma}\\bm{W}^T\\bm{J}^T \\tag{28} \\] \\(\\bm{\\mu}\\) 按照点坐标规则变换就行。这样我们就将3D高斯椭球变换到了图像坐标系内。但是，在3DGS算法中， \\(\\bm{\\Sigma}^{\\prime}\\) 实际上是 \\(2\\times 2\\) 的2D形式，也就是忽略 \\(z\\) 坐标而直接投影到了 \\(xy\\) 平面。这也很简单，把式(28)中的 \\(\\bm{J}\\) 的第三行去掉，变成 \\(2 \\times 3\\) 的矩阵，此时容易验证结论1仍然适用。此时得到的 \\(\\bm{\\Sigma}^{\\prime}\\) 就是投影到 \\(xy\\) 平面上的2D矩阵了。\n着色 3DGS采用的是Alpha-Blending和体渲染光线行进着色算法。假设我们让视图平面某个点 \\((x,y)\\) 对N个高斯进行采样，那么该点的颜色为\n\\[ C(x,y)=\\sum_{i=1}^{N}c_i(x,y)\\alpha_i(x,y)\\prod_{j=1}^{i-1}(1-\\alpha_j(x,y)) \\tag{29} \\] 这N个高斯按照世界坐标系下与 \\((x,y)\\) 的距离（深度）由近到远的顺序排序。 \\(c_i(x^{\\prime},y^{\\prime})\\) 是第 \\(i\\) 个高斯在 \\((x^{\\prime},y^{\\prime})\\) 处的颜色（在世界坐标系下用式(10)和式(11)求出）。 \\(\\alpha_i(x^{\\prime},y^{\\prime})\\) 是第 \\(i\\) 个高斯在 \\((x^{\\prime},y^{\\prime})\\) 处的不透明度，在二维平面中式(12)也适用，因此有\n\\[ \\alpha_i(x^{\\prime},y^{\\prime})=\\omicron_i\\cdot\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)^{T}\\left(\\bm{\\Sigma}^{\\prime}\\right)^{-1}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)\\right) \\tag{30} \\] \\(\\omicron_i\\) 就是由不透明度定义的第 \\(i\\) 个3D高斯椭球的不透明度。注意，式(29)中的 \\(C(x,y)\\) 是三个RGB通道各自的颜色值，取值范围为 \\([0,1]\\) 。也就是三个RGB通道各自独立混合后，再一起作为 \\((x,y)\\) 点处的颜色。\n分块 如果对于每个像素，相对所有高斯(2D)都进行一次光线行进，那这将耗费巨大的计算资源而且还不一定能起到很好的效果。因此，3DGS提出了一种分块渲染的方法。其思想是将屏幕分成每个大小为 \\(16\\times 16\\) 像素的块，在渲染每个块中的像素的时候只考虑和这个块有交叠的高斯。对于不同的块，可以采用并行计算的方法加快渲染速度。\n那么该如何判断某个高斯与某个块是否有交叠呢？首先得确定它的边界。3DGS采用 \\(99\\\\%\\) 作为置信区间，也就是以概率为 \\(99\\\\%\\) 作为边界。即\n\\[ f\\left(\\bm{x}^\\prime|\\bm{\\mu}^\\prime,\\bm{\\Sigma}^\\prime\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}^\\prime\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)^{T}\\left(\\bm{\\Sigma}^{\\prime}\\right)^{-1}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)\\right)=0.99 \\tag{31} \\] 由于 \\(\\bm{\\Sigma}^\\prime\\) 是正定矩阵，因此这是一个椭圆。椭圆方程可以被求出来，再结合某个块的四条边的参数，就可以判断出是否交叠。（当然，在实际代码中并没有采用上述椭圆方程的求法，也没有采用传统的椭圆和矩形的碰撞检测算法，因为这样会增加不必要的计算量，因此在3DGS的代码实现中将2D高斯的碰撞箱简化为了一个矩形，再用这个矩形做碰撞判断，具体见代码）。\n我们先对所有高斯做一个预处理。对于我们需要处理的高斯，首先，这个高斯必须位于相机的视锥内部（或与其相交），这样可以预先排除掉很大一部分高斯。然后，这个高斯不能距离摄像机过近或过远（一般来说，会将 \\(z^\\prime\\) 控制在某一个区间内）。最后再执行判断这个高斯与某个块是否有交叠的操作。\n接下来的问题是如何得到与某个块有交叠的所有高斯，并按照深度进行排序方便进行着色。\n","date":"2024-09-23T19:43:18+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/artificial_intelligence/computer_vision/3d_gaussian_splatting/","title":"三维重建（一）：3D高斯泼溅算法"},{"content":" 操作系统引论 操作系统（Operating System，OS） 是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。OS是现代计算机系统中最基本和最重要的系统软件，而其他的诸如编译程序、数据库管理系统等系统软件，以及大量的应用软件，都直接依赖于操作系统的支持，取得它所提供的服务。事实上OS已经成为现代计算机系统、多处理机系统、计算机网络中都必须配置的系统软件。\n操作系统的目标和作用 操作系统的目标与应用环境有关。例如在查询系统中所用的OS，希望能提供良好的人机交互性；对于工业控制、武器控制以及多媒体环境下的OS，要求其具有实时性。而对于微机上配置的OS，则更看重的是其使用的方便性。\n操作系统的目标 在计算机系统上配置操作系统，其主要目标是：方便性、有效性、可扩充性和开放性。\n方便性 一个未配置OS的计算机系统是极难使用的。用户如果想直接在计算机硬件（裸机）上运行自己的程序，就必须用机器语言书写；但是如果配置了OS，系统就可以使用编译命令将用户采用高级语言书写的程序翻译成机器代码，或直接通过OS所提供的各种命令操纵计算机系统，极大地方便了用户，使计算机变得易学易用。\n有效性 有效性所包含的第一层含义是提高系统资源的利用率。在早期未配置OS的计算机系统中，诸如处理机、I/O设备等都经常处于空闲状态，各种资源无法得到充分利用，所以在当时，提高系统资源利用率是推动OS发展最主要的动力。有效性的另一层含义是提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。\n方便性和有效性是设计OS时最重要的两个目标。在过去很长的一段时间内，由于计算机系统非常昂贵，有效性显得特别重要。然而，近十多年来，随着硬件越来越便宜，在设计配置在微机上的OS时，似乎更加重视如何提高用户使用计算机的方便性。因此，在微机操作系统中都配置了深受用户欢迎的图形用户界面，以及为程序员提供了大量的系统调用，方便了用户对计算机的使用和编程。\n可扩充性 为适应计算机硬件、体系结构以及计算机应用发展的要求，OS必须具有很好的可扩充性。可扩充性的好坏与OS的结构有精密的联系，由此推动了OS结构的不断发展。从早期的无结构发展成模块化结构，进而又发展成层次化结构，近年来OS已广泛采用了微内核结构。微内核结构能方便地增添新的功能和模块，以及对原有的功能和模块进行修改，具有良好的可扩充性。\n开放性 随着计算机应用的日益普及，计算机硬件和软件的兼容性问题便提到了议事日程上来。世界各国相应地制定了一系列的软、硬件标准，使得不同厂家按照标准生产的软、硬件都能在本国范围内很好地相互兼容。这无疑给用户带来了极大的方便，也给产品的推广、应用铺平了道路。近年来，随着Internet的迅速发展，使得计算机OS的应用环境由单机环境转向了网络环境，其应用环境就必须更为开放，进而对OS的开放性提出了更高的要求。\n所谓开放性，是指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。事实上，凡遵循国际标准所开发的硬件和软件，都能彼此兼容，方便地实现互连。开放性已称为20世纪90年代以后计算机技术的一个核心问题，也是衡量一个新推出的系统或软件能否被广泛应用的至关重要的因素。\n操作系统的作用 操作系统在计算机系统中所起的作用，可以从用户、资源管理及资源抽象等多个不同的角度来进行分析和讨论。\nOS作为用户与计算机硬件系统之间的接口 OS作为用户与计算机硬件系统之间的接口的含义是：OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。或者说，用户在OS帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。图1是OS作为接口的示意图。由图可看出，用户可通过三种方式使用计算机，即通过命令方式、系统调用方式和图标\u0026mdash;窗口方式来实现与操作系统的通信，并取得它的服务。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 应用程序 命令 系统调用 图标—窗口 操作系统 计算机硬件 图1\u0026emsp;OS作为接口的示意图\nOS作为计算机系统资源的管理者 在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）。相应地，OS的主要功能也正是对这四类资源进行有效的管理。处理机管理适用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配（回收）与操纵；文件管理适用于实现对文件的存取、共享和保护。可见，OS的确是计算机系统资源的管理者。\n当一台计算机系统供多个用户使用时，诸多用户对系统中共享资源的需求（包括数量和时间）有可能发生冲突。为此，操作系统必须对使用资源的请求进行授权，以协调诸用户对共享资源的使用。\nOS实现了对计算机资源的抽象 对一台完全无软件的计算机系统（即裸机），由于它向用户提供的仅是硬件接口（物理接口），因此，用户必须对物理接口的实现细节有充分的了解，这就致使该物理机器难于广泛使用。为了方便用户使用I/O设备，人们在裸机上覆盖上一层I/O设备管理软件，如图2所示，由它来实现对I/O设备操作的细节，并向上将I/O设备抽象为一组数据结构以及一组I/O操作命令，如read或write命令，这样用户即可利用这些数据结构及操作命令来进行数据输入或输出，而无需关心I/O是如何具体实现的。此时用户所看到的机器是一台比裸机功能更强、使用更方便的机器。换言之，在裸机上铺设的I/O软件隐藏了I/O设备的具体细节，向上提供了一组抽象的I/O设备。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 物理接口 硬件 用户 物理接口 硬件 I/O软件 I/O操作命令 ( r e a d , wri t e ) 虚机器 图2\u0026emsp;I/O软件隐藏了I/O操作实现的细节\n通常把覆盖了上述软件的机器称为扩充机器或者虚机器。它向用户提供了一个对硬件操作的抽象模型。用户可利用该模型的接口使用计算机，无需了解物理接口的实现细节，从而使用户更容易地使用计算机硬件资源。亦即，I/O设备管理软件实现了对计算机硬件操作的第一个层次的抽象。\n同理，为了方便用户使用文件系统，又可在第一层软件（I/O管理软件）上再覆盖一层用于文件管理的软件，由它来实现对文件操作的细节，并向上层提供一组实现对文件进行存取操作的数据结构和命令。这样，用户可利用该软件提供的数据结构及命令对文件进行存取。此时用户所看到的是一台功能更强、使用更方便的虚机器。亦即，文件管理软件实现了对硬件资源操作的第二个层次的抽象。以此类推，如果文件管理软件上再覆盖一层面向用户的窗口软件，则用户便可在窗口环境下方便地使用计算机，从而形成一台功能更强的虚机器。\n由此可知，OS是铺设在计算机硬件上的多层软件的集合，它们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。值得说明的是，不仅可在底层对一个硬件资源加以抽象，还可以在高层对该资源底层已抽象的模型再次进行抽象，称为更高层的抽象模型。随着抽象层次的提高，抽象接口所提供的功能就越强，用户使用起来也越方便。\n推动操作系统发展的主要动力 OS自20世纪50年代产生后，经历了由简单到复杂，由低级到高级的发展。在短短60多年间，OS在各方面都有了长足的进步，能够很好地适应计算机硬件和体系结构的快速发展，以及应用需求的不断变化。下面我们对推动OS发展的主要推动力做具体阐述。\n不断提高计算机资源利用率 在计算机发展的初期，计算机系统特别昂贵，人们必须千方百计地提高计算机系统中各种资源的利用率，这就是OS最初发展的推动力。由此形成了能自动地对一批作业进行处理的多道批处理系统。20世纪60年代和70年代有分别出现了能够有效提高I/O设备和CPU利用率的SPOOLing系统，以及极大地改善了存储器系统利用率的虚拟存储器技术。此后在网络环境下，通过在服务器上配置网络文件系统和数据库系统算法，将资源提供给全网络用户共享，又进一步提高了资源的利用率。\n方便用户 当资源利用率不高的问题得到基本解决后，用户在上机、调试程序时的不方便行便成为主要矛盾，这又成为继续推动OS发展的主要因素。20世纪60年代分时系统的出现，不仅提高了系统资源的利用率，还能实现人\u0026mdash;机交互，使用户能像早期使用计算机时一样，感觉自己是独占全机资源，对其进行直接操控，极大地方便了程序员对程序进行调试和修改的操作。90年代初，图形用户界面的出现收到用户的广泛欢迎，进一步方便了用户对计算机的使用，这无疑又加速推动了计算机的迅速普及和广泛使用。\n器件的不断更新换代 随着IT技术的飞讯发展，尤其是微机芯片的不断更新换代，使得计算机的性能快速提高，从而也推动了OS的功能和性能迅速增强和提高。例如当微机芯片由8位发展到16位、32位，进而又发展到64位时，相应的微机OS也就由8位OS发展到16位和32位，进而又发展到64位，此时，相应OS的功能和性能也有了显著的增强和提高。\n与此同时，外部设备也在迅速发展。OS所能支持的外部设备也越来越多，如现在的微机OS已能够支持种类繁多的外部设备，除了传统的外设外，还可以支持光盘、移动硬盘、闪存盘、扫描仪、数码相机等。\n计算机体系结构的不断发展 计算机体系结构的发展，也不断推动着OS的发展，并产生新的OS类型。例如当计算机由单处理机系统发展为多处理机系统时，相应地，OS也就由单处理机OS发展为多处理机OS。又如当出现了计算机网络后，配置在计算机网络上的操作系统也就应运而生。它不仅能有效地管理好网络中的共享资源，而且还向用户提供了许多网络服务。\n不断提出新的应用需求 操作系统能如此迅速发展的另一个重要原因是，人们不断提出新的应用需求，例如，为了提高产品的质量和数量，需要将计算机应用于工业控制中，此时在计算机上就需要配置能进行实时控制的OS，由此产生了实时系统。此后，为了能满足用户在计算机上听音乐、看电影和玩游戏等需求，又在OS中添加了多媒体功能。另外，由于在计算机系统中保存了越来越多的宝贵信息，致使能够确保系统安全性也成为OS必须具备的功能。尤其是随着VLSI（超大规模集成电路） 的发展，计算机芯片的体积越来越小，价格也越来越便宜，大量智能设备应运而生，这样，微机操作系统的产生和发展也成了一种必然。\n操作系统的发展过程 在20世纪50年代中期，出现了第一个简单的批处理OS；60年代中期开发出多道程序批处理系统；不久又推出分时系统，与此同时，用于工业和武器控制的实时OS也相继问世。20世纪70到90年代，是VLSI和计算机体系结构大发展的年代，导致了卫星及、多处理机和计算机网络的诞生和发展，与与此相应地，也相继开发出了微机OS，多处理机OS和网络OS，并得到极为迅猛的发展。\n未配置操作系统的计算机系统 从1945年诞生的第一台计算机，到50年代中期的计算机，都属于第一代计算机。这时还未出现OS，对计算机的全部操作都是由用户采取人工操作方式进行的。\n人工操作方式 早期的操作方式是由程序员将事先已穿孔的纸带（或卡片），装入纸带输入机（或卡片输入机），再启动它们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面缺点：\n(1) 用户独占全机，即一台计算机的全部资源由上级用户所独占。\n(2) CPU等待人工操作。当用户进行装带（卡），卸带（卡）等人工操作时，CPU及内存等资源是空闲的。\n可见，人工操作方式严重降低了计算机资源的利用率，此即所谓的人机矛盾。虽然CPU的速度在迅速提高，但I/O设备的速度却提高缓慢，这使CPU与I/O设备之间速度不匹配的矛盾更加突出。为此，曾先后出现了通道技术、缓冲技术，然而都未能很好地解决上述矛盾，直到后来引入了脱机输入/输出技术，才获得了相对较为满意的结果。\n脱机输入/输出（Off-Line IO）方式 为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。该技术是实现将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。\n类似地，当CPU需要输出时，可先由CPU把数据直接从内存高速地输送到磁带上，然后在另一台外围机的控制下，再将此大地上的结果通过相应地输出设备输出。图3示出了脱机输入/输出的过程。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 输入设备 外围机 磁盘 磁盘 主机 磁盘 磁盘 外围机 输出设备 图3\u0026emsp;脱机I/O示意图\n由于程序和数据的输入和输出都是在外围机的控制下完成的，或者说，它们是在脱离主机的情况下进行的，故称为脱机输入/输出方式。反之，把在主机的直接控制下进行输入/输出的方式称为联机输入/输出（On-Line I/O） 方式。这种脱机I/O方式的主要优点为：\n(1) 减少了CPU的空闲时间。装带、卸带，以及将数据从低俗I/O设备送到高速磁带上（或反之）的操作，都是在脱机情况下由外围机万郴个，并不占用主机时间，从而有效地减少了CPU的空闲时间。\n(2) 提高了I/O速度。当CPU在运行中需要输入数据时，是直接从高速的磁带上将数据输入到内存的，这便极大地提高了I/O速度，从而进一步减少了CPU的空闲时间。\n单道批处理系统(Simple Batch Processing System) 20世纪50年代中期出现了第二代晶体管计算机，此时计算机虽已具有推广应用的价值，但计算机系统仍然非常昂贵，为了能充分地提高它的利用率，应尽量保持系统的连接运行，即在处理完一个作业后，紧接着处理下一个作业，以减少机器的空闲等待时间。\n单道批处理系统的处理过程 为了实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下，使这批作业能一个接一个连续处理。其处理过程是：首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交给监督程序，再由监督程序把磁带上的第二个作业调入内存。计算机系统就这样自动地一个作业紧接着一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。虽然系统对作业的处理是成批进行的，但在内存中时终止保持一道作业，故称为单道批处理系统。图4示出了单道批处理系统的处理流程。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 还有下 一个作业 ？ 把下一个作业 的源程序转换 为目标程序 是 源程序 有错吗 ？ 开始 否 装配 目标程序 运行 目标程序 是 否 停止 图4\u0026emsp;单道批处理系统的处理流程\n单道批处理系统的缺点 单道批处理系统最主要的缺点是，系统中的资源得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。图5示出了单道程序的运行情况，从图可以看出：在 $t_2$ ~ $t_3$ 、 $t_6$ ~ $t_7$ 时间间隔内CPU空闲。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户程序 监督程序 I/O操作 I/O中断请求 启动I/O I/O完成 结束中断 I/O中断请求 启动I/O I/O完成 结束中断 图5\u0026emsp;单道程序的运行情况\n为了能在系统中运行较大的作业，通常在计算机中都配置了较大容量的内存，但实际情况是有80%以上的作业都属于中小型，因此在单道程序环境下，也必定造成内存的浪费。类似地，为了满足各种类型的作业需要，在系统中将会配置多种类型的I/O设备。显然在单道程序环境下也不能充分利用系统资源。\n多道批处理系统(Multiprogrammed Batch Processing System) 20世纪60年代中期，IBM公司生产了第一台小规模集成电路计算机IBM 360（第三代计算机系统）。由于它较之于晶体管计算机无论在体积、功耗、速度和可靠性上都有了显著的改善，因而获得了极大的成功。IBM公司为该机开发的OS/360操作系统是第一个能运行多道程序的批处理系统。\n多道程序设计的基本概念 为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。在该系统中，用户所提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的CPU空挡时间，再调度另一道程序B运行，同样可以利用程序B在I/O操作时的空档时间，再调度程序C运行，使多道程序交替地运行，这样便可以保持CPU处于忙碌状态。图6示出了四道程序时的运行情况。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 程序A 程序B 程序C 程序D 调度程序 程序B 程序A I/O请求 程序B I/O请求 程序A 程序A I O处理 程序B I/O处理 程序C 程序C I/O处理 程序D 程序C I/O请求 程序D I/O请求 程序A I/O完成 程序A 再被调度 程序C I/O完成 程序A 完成 程序C 再被调度 程序D I/O处理 程序B 被调度 程序C 程序C 被调度 程序D 被调度 C P U 执行线 程序A 调度 调度 调度 调度 调度 图6\u0026emsp;多道程序的运行情况\n多道批处理系统的优缺点 多道批处理系统的优点如下：\n(1) 资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。\n(2) 系统吞吐量大。能提高系统吞吐量的主要原因可归结为：\n①CPU和其他资源保持“忙碌状态”。\n②仅当作业完成时或运行不下去时才进行切换，系统开销小。\n多道批处理系统的缺点如下：\n(1) 平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。\n(2) 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极不方便。\n多道批处理系统需要解决的问题 多道批处理系统是一种十分有效，但又非常复杂的系统，为使系统中的多道程序间能协调地运行，系统必须解决下述一系列问题：\n(1) 处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。\n(2) 内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们各得其所，且不会因某道程序出现异常情况而破坏其他程序。\n(3) I/O设备分配问题。系统应采取适当的策略来分配系统中的I/O设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。\n(4) 文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。\n(5) 作业管理问题。系统中存在着各种作业（应用程序），系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同需求。\n(6) 用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与OS之间的接口。\n为此，应在计算机系统中增加一组软件，用以对上述问题进行妥善、有效的处理。这组软件应包括：能有效地组织和管理四大资源的软件、合理地对各类作业进行调度和控制它们运行的软件，以及方便用户使用计算机的软件。正是这样一组软件构成了操作系统。据此，我们可以把操作系统定义为：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。\n分时系统(Time Sharing System) 分时系统的引入 如果说推动多道批处理系统形成和发展的主要动力是提高资源利用率和系统吞吐量，那么，推动分时系统的形成和发展的主要动力，则是为了满足用户对人\u0026mdash;机交互的需求，由此形成了一种新型OS，用户的需求具体表现在以下几个方面：\n(1) 人\u0026mdash;机交互。每当程序员写好一个新程序时，都需要上机进行调试。由于新编程序难免存在一些错误或不当之处，需要进行修改，因此用户希望能像早期使用计算机时一样，独占权及并对它进行直接控制，宜宾能方便地对程序中的错误进行修改。亦即，用户希望能进行人\u0026mdash;机交互。\n(2) 共享主机。在20世纪60年代，计算机还十分昂贵，一台计算机要同时供很多用户共享使用。显然，用户们在共享一台计算机时，每个人都希望能像独占时一样，不仅可以随时与计算机进行交互，而且还不会感觉到其他用户的存在。\n由上述不难得知，分时系统是指，在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。\n分时系统实现中的关键问题 在多道批处理系统中，用户无法与自己的作业进行交互的主要原因是：作业都先驻留在外存上，即使以后被调入内存，也要经过较长时间的等待后方能运行。用户无法与自己的作业进行交互。为了能够实现人机交互，必须解决的关键问题是，如何使用户能与自己的作业进行交互。为此，系统首先必须能提供多个终端，同时给多个用户使用。其次，当用户在自己的终端上键入命令时，系统应能及时接收，并及时处理该命令，再将结果返回给用户。此后，用户可根据系统返回的响应情况，再继续键入下一条命令，此即人\u0026mdash;机交互。亦即，允许有多个用户同时通过自己的键盘键入命令，系统也应能全部及时接收并处理。\n(1) 及时接收。要做到及时接收多个用户键入的命令或数据，只需在系统中配置一个多路卡即可。例如当主机上要连接64个终端时，就配置一个64用户的多路卡。多路卡的作用是，实现分时多路复用。即主机以很快的速度周期性地扫描各个终端，在每个终端处停留很短的时间，如30ms，用于接收从终端发来的数据。对于64用户的多路卡，用不到2秒的时间便可完成一次扫描，即主机能用不到2秒的时间分时接收哥哥用户从终端上输入的数据一次。此外，为了能使从终端上输入的数据被依次逐条地进行处理，还需要为每个终端配置一个缓冲区，用来暂存用户键入的命令（或数据）。\n(2) 及时处理。人\u0026mdash;机交互的关键在于，用户键入命令后，能对自己的作业及其运行及时地实时控制，或进行修改。因此，各个用户的作业都必须驻留在内存中，并能频繁地获得处理机运行。否则，用户键入的命令将无法作用到自己的作业上。由此可见，为了实现人\u0026mdash;机交互，必须彻底地改变原来批处理系统的运行方式，转而采用下面的方式：\n①作业直接进入内存。因为作业在磁盘上是不能运行的，所以作业应该直接进入内存。\n②采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业就没有机会被调度运行。为避免一个作业长期独占处理机，引入了时间片的概念。一个时间片，就是一段很短的时间（例如30ms）。系统规定每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业的运行。如果在不长时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而可使用户的请求得到及时相应。\n分时系统的特征 分时系统与多道批处理系统相比，具有非常明显的不同特性，可归纳成以下四个方面。\n(1) 多路性。该特性是指系统允许将堕胎终端同时连接到一台主机上，并按分时原则为每个用户服务。多路性允许多个用户共享一台计算机，显著地提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。\n(2) 独立性。该特性是指系统提供了这样的用机环境，即每个用户在各自的终端上进行操作，彼此之间互不干扰，给用户的感觉就像是他一人独占主机进行操作。\n(3) 及时性。及时性是指用户的请求能在很短时间内获得响应。这一时间间隔是根据人们所能接受的等待时间确定的，通常仅为1~3秒钟。\n(4) 交互性。交互性是指用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如进行文件编辑和数据处理，访问系统中的文件系统和数据库系统，请求提供打印服务等。\n实时系统(Real Time System) 所谓实时，是表示“及时”。而“实时计算”，则可定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。事实上实时系统最主要的特征，是将时间作为关键参数，它必须对所接收到的某些信号做出“及时”或“实时”的反应。由此得知，实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\n实时系统的类型 随着计算机应用的普及，实时系统的类型也相应增多，下面列出当前常见的几种：\n(1) 工业（武器）控制系统。当计算机被用于生产过程的控制，形成以计算机为中心的控制系统时，该系统应具有能实时采集现场数据，并对所采集的数据进行及时处理，进而能够自动地控制相应的执行机构，使之具有按预定的规律变化的功能，确保产品的质量和产量。类似地，也可将计算机用于对武器的控制，如火炮的自动控制系统、飞机的自动驾驶系统、以及导弹的制导系统等。\n(2) 信息查询系统。该系统接受从远程终端上发来的服务请求，根据用户提出的请求，对信息进行检索和处理，并能及时对用户做出正确的回答。实时信息处理系统由飞机或火车的订票系统等。\n(3) 多媒体系统。随着计算机硬件和软件的快速发展，已可将文本、图像、音频和视频等信息集成在一个文件中，形成一个多媒体文件。如在用DVD播放器所播放的数字电影中就包含了音频、适配和横向滚动的文字等信息。为了保证有好的听觉和视觉感受，用于播放音频和视频的多媒体系统等，也必须是实时信息处理系统。\n(4) 嵌入式系统。随着集成电路的发展，已制作出各种类型的芯片，可将这些芯片嵌入到各种一起和设备中，用于对设备进行控制或对其中的信息作出处理，这样就构成了所谓的智能仪器和设备。此时还需要配置嵌入式OS，它同样需要具有实时控制或处理的功能。\n实时任务的类型 (1) 周期性实时任务和非周期性实时任务。周期性实时任务是指这样一类任务，外部设备周期性地发出激励信号给计算机，要求它按指定周期循环执行，以便周期性地控制某我i不设备。反之，非周期性实时任务并无明显的周期性，但都必须联系着一个截止时间(Deadline)，或称为最后期限。它又可分为：①开始截止时间：指某个任务在某时间以前必须开始执行；②完成截止时间：指某任务在某时间以前必须完成。\n(2) 硬实时任务和软实时任务。硬实时任务（Hard Real-time Task，HRT） 是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果。用于工业和武器控制的实时系统，通常它所执行的是硬实时任务。软实时任务（Soft Real-time Task, SRT） 也联系着一个截止时间，但并不严格，若偶尔错过了截止时间，对系统产生的影响也不会太大。诸如用于信息查询系统和多媒体系统中的实时系统，通常是软实时任务。\n实时系统与分时系统特征的比较 (1) 多路性。信息查询系统和分时系统中的多路性都表现为系统按分时原则为多个终端用户服务；实时控制系统的多路性则是指系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。\n(2) 独立性。信息查询系统中的每个终端用户在与系统交互时，彼此相互独立互不干扰，同样在实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰的。\n(3) 及时性。信息查询系统对实时性的要求是依据人所能接受的等待时间确定的。而多媒体系统实时性的要求是，播放出来的音乐和电视能令人满意。实时控制系统的实时性则是以控制对象所要求的截止时间来确定的，一般为秒级到毫秒级。\n(4) 交互性。在信息查询系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序，它并不像分时系统那样，能向终端用户提供数据处理、资源共享等服务。而多媒体系统的交互性也仅限于用户发送某些特定的命令，如开始、停止、快进等，由系统立即响应。\n(5) 可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠，因为任何差错都可能带来无法预料的灾难性的后果。因此，在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。\n微机操作系统 随着VLSI和计算机体系结构的发展，以及应用需求的不断扩大，操作系统仍在继续发展。由此先后形成了微机操作系统、网络操作系统等。本小节对微机操作系统的发展作扼要的介绍。\n配置在微型机上的操作系统称为微机操作系统，最早诞生的危机操作系统是配置在8位微机上的CP/M，后来出现了16位微机，相应地，16位微机操作系统也就应运而生。当微机发展为32位、64位时，32位和64位微机操作系统也应运而生。可见微机操作系统可按微机的字长来分，但也可以将它按运行方式分为如下几类：\n单用户单任务操作系统 单用户单任务操作系统的含义是：只允许一个用户上机，且只允许用户程序作为一个任务运行，这是最简单的微机操作系统，主要配置在8位和16位微机上，最有代表性的单用户单任务微机操作系统时CP/M和MS-DOS。\n(1) CP/M。1974年第一代通用8位微处理机芯片Intel 8080出现后的第二年，Digital Research公司就开发出带有软盘系统的8位微机操作系统CP/M。1977年Digital Research公司对CP/M进行了重写，使其剋配置在以Intel 8080、8085、Z80等8位芯片为基础的多种微机上。1979年又推出带有硬盘管理功能的CP/M 2.2版本。由于CP/M具有较好的体系结构，可适应性强，可以执行以及易学易用等优点，使之在8位微机中占据了统治地位。\n(2) MS-DOS。1981年IBM公司首次推出了IBM-PC个人计算机（16位微机），在微机中采用了微软公司开发的MS-DOS(Disk Operating System) 操作系统，该操作系统在CP/M的基础上进行了较大的扩充，使其在功能上有很大的提高。1983年IBM退出PC/AT（配有Intel 80286芯片），相应地微软又开发出MS-DOS 2.0版本，它不仅能支持硬盘设备，还采用了树形目录结构的文件系统。1987年又宣布了MS-DOS 3.3版本。从MS-DOS 1.0到3.3位置的版本都属于单用户单任务操作系统，内存被限制在640KB。从1989到1993年又先后推出了多个MS-DOS版本，它们都可以配置在Intel 80386、80486等32位微机上。从80年代到90年代初，由于MS-DOS性能优越受到当时用户的广泛欢迎，称为事实上的16位单用户单任务操作系统标准。\n单用户多任务操作系统 单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发，从而有效地改善了系统的性能。目前在32位维基上配置的操作系统，基本上都是单用户多任务操作系统。其中最有代表性的是由微软公司推出的Windows。1985年和1987年微软公司先后推出了Windows 1.0和Windows 2.0版本操作系统，由于当时的硬件平台还只是16位微机，对1.0和2.0版本不能很好地支持。1990年微软公式又发布了Windows 3.0版本，随后又宣布了Windows 3.1版本，它们主要是针对386和486等32位微机开发的，它较之以前的操作系统有着很重大的改进，引入了友善的图形用户界面，支持多任务和扩展内存的功能。使计算机更好使用，从而称为386和486等微机的主流操作系统。\n1995年微软公司推出了Windows 95，它较之以前的Windows 3.1有许多重大改进，采用了全32位的处理技术，并兼容以前的16位应用程序，在该系统中还集成了支持Internet的网络功能。1998年微软公司又推出了Windows 95的改进版Windows 98，它已是最后一个仍然兼容以前16位应用程序的Windows。其最主要的改进是把微软公司自己开发的Internet浏览器整合到系统中，大大方便了用户上网浏览；另一个改进是增加了对多媒体的支持。2001年微软又发布了Windows XP，同时提供了家用和商业工作站两种版本，在此后相当长的一段时间，称为使用最广泛的个人操作系统之一。在开发上述Windows操作系统的同时，微软公司又开始对网络操作系统Windows NT进行开发，它是针对网络开发的操作系统，在系统中融入许多面向网络的功能，从2006年后推出的一系列内核版本号为NT6.X的桌面操作系统，包括Windows Vista、Windows 7、Windows 8等，这里就不对它们进行介绍。\n多用户多任务操作系统 多用户多任务操作系统的含义是，允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中配置的大多是多用户多任务操作系统，而在32位微机上，也有不少配置的是多用户多任务操作系统，其中最有代表性的是UNIX OS。\nUNIX OS是美国电报电话公司的Bell实验室在1969~1970年期间开发的，1979年推出来的UNIX V.7已被广泛应用于多种小型机上。随着微机性能的提高，人们又将UNIX移植到微机上。在1980年后，将UNIX第7版本移植到Motorola公司的MC 680xx微机上，后来又将UNIX V7.0版本进行简化后，移植到Intel 8080上，把它称为Xenix。现在最有影响的两个能运行在微机上的UNIX操作系统变形是Solaris OS和Linux OS。\n(1) Solaris OS：SUN公司于1982年推出的SUN OS 1.0，是一个运行在MOTOROLA 680X0平台上的UNIX OS，在1988年宣布的SUN OS 4.0，把运行平台从早期的MOTOROLA 680X0平台迁移到SPARC平台，并开始支持Intel公司的80X86；1992年SUN发布了Solaris 2.0。从1998年开始，Sun公司推出64位操作系统Solaris 2.7和2.8，这几款操作系统在网络特性、互操作性、兼容性以及易于配置和管理方面均有很大的提高。\n(2) Linux OS：Linux是UNIX的一个重要变种，最初是由芬兰学生Linus Torvalds针对Intel 8086开发的，1991年，在Internet网上发布第一个Linux版本，由于源代码公开，因此有很多人通过Internet与之合作，使Linux的性能迅速提高，其应用范围也日益扩大，相应地，源代码而急剧膨胀，此时它已是具有全面功能的UNIX系统，大量在UNIX上运行的软件（包括1000多种使用工具软件和大量网络软件），被移植到Linux上，而且可以在主要的微机上运行，如Intel 80X86 Pentium等。\n操作系统的基本特性 前面所介绍的多道批处理系统、分时系统和实时系统这三种基本草祖宗系统都具有各自不同的特征，如批处理系统有着高的资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，它们还共同具有并发、共享、虚拟和异步四个基本特征。\n并发(Concurrence) 正是系统中的程序能并发执行这一特征，才使得OS能有效地提尕奥系统中的资源利用率，增加系统的吞吐量。\n并行与并发 并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却只能有一道程序执行，故微观上这些程序只能是分时地交替进行。例如，在1秒钟时间内，0~15ms程序A运行；15~30ms程序B运行；30~45ms程序C运行；45~60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。\n倘若在计算机系统中有多个处理机，这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序。这样，多个程序便可同时执行。\n引入进程 在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O程序之间只能是顺序执行，即只有在计算程序执行告一段落后，才允许I/O程序执行；反之，在程序执行I/O操作时，计算程序也不能执行。但在为计算程序和1/0程序分别建立一个进程(Process)‌后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。\n所谓进程，是指在系统中能独立运行并作为资源分配的基本单位。它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。事实上，进程和并发是现代操作系统中最重要的基本概念，也是操作系统运行的基础。\n共享(Sharing) 一般情况下的共享与操作系统环境下的共享其含义并不完全相同。前者只是说明某种资源能被大家使用，如图书馆中的图书能提供给大家借阅，但并未限定借阅者必须在同一时间（间隔）和同一地点阅读。又如，学校中的计算机机房供全校学生上机，或者说，全校学生共享该机房中的计算机设备，虽然所有班级的上机地点是相同的，但各班的上机时间并不相同。对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。\n而在OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源远少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。由于资 源属性的不同，进程对资源复用的方式也不同，目前主要实现资源共享的方式有如下两种。\n互斥共享方式 系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程（线程）使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，在系统中应建立一种机制，以保证多个进程对这类资源的互斥访问。当进程A要访问某资源时，必须先提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。此后若再有其它进程也要访问该资源，只要A未用完就必须等待。仅当A进程访问完并释放系统资源后，才允许另一进程对该资源进行访问。这种资源共享方式称为互斥式共享，把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。系统中的大多数物理设备，以及栈、变量和表格，都属于临界资源，都只能被互斥地共享。为此，在系统中必须配置某种机制，用于保证诸进程互斥地使用临界资源。\n同时访问方式 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源是磁盘设备。一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件。\n并发和共享是多用户（多任务）OS的两个最基本的特征。它们又是互为存在的条件。即一方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题：另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间并发执行的程度，甚至根本无法并发执行。\n虚拟(Virtual) 用于实现“虚拟”的技术最早出现在通信系统中。在早期，每一条物理信道只能供一对用户通话，为了提高通信信道的利用率而引入了\u0026quot;虚拟”技术。该技术是通过\u0026quot;空分复用”或“时分复用”技术，将一条物理信道变为若干条逻辑信道，使原来只能供一对用户通话的物理信道，变为能供多个用户同时通话的逻辑信道。\n在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为\u0026quot;虚拟”。前者是实的，即实际存在的，而后者是虚的，是用户感觉上的东西。相应地，把用于实现虚拟的技术称为虚拟技术。在OS中也是利用时分复用和空分复用技术来实现\u0026quot;虚拟”的。\n时分复用技术 在计算机领域中，广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，使资源的利用率得以提高。时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。\n(1) 虚拟处理机技术。利用多道程序设计技术，为每道程序建立至少一个进程，让多道程序并发执行。此时虽然系统中只有一台处理机，但通过分时复用的方法，能实现同时（宏观上）为多个用户服务，使每个终端用户都认为是有一个处理机在专门为他服务。亦即，利用多道程序设计技术，可将一台物理上的处理机虚拟为多台逻辑上的处理机，在每台逻辑处理机上运行一道程序，我们把用户所感觉到的处理机称为虚拟处理器。\n(2) 虚拟设备技术。我们还可以利用虚拟设备技术，也通过分时复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备。 这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户\u0026quot;同时”访问的共享设备，既宏观上能\u0026quot;同时”为多个用户服务。例如原来的打印机属于临界资源，而通过虚拟设备技术又可以把它变为多台逻辑上的打印机，供多个用户\u0026quot;同时”打印。\n空分复用技术 20世纪初，电信业中就已使用频分复用技术来提高信道的利用率。它是指将一个频率范围比较宽的信道划分成多个频率范围较窄的信道（称为频带），其中的任何一个频带都仅供一对用户通话。早期的频分复用技术只能将一条物理信道划分为几条到几十条话路，后来又很快发展到成千上万条话路，每条话路供一对用户通话。再后来在计算机中也把空分复用技术用于对存储空间的管理，用以提高存储空间的利用率。\n如果说，多道程序技术（时分复用技术）是通过利用处理机的空闲时间运行其它程序，提高了处理机的利用率，那么，空分复用技术则是利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率。\n但是，单纯的空分复用存储器只能提高内存的利用率，并不能实现在逻辑上扩大存储器容量的功能，还必须引入虚拟存储技术才能达到此目的。虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。例如，一个100MB的应用程序之所以可以运行在30MB的内存空间，实质上就是每次只把用户程序的一部分调入内存运行，运行完成后将该部分换出，再换入另一部分到内存中运行，通过这样的置换功能，便实现了用户程序的各个部分分时地进入内存运行。应当着重指出：虚拟的实现，如果是采用分时复用的方法，即对某一物理设备进行分时使用，设N是某物理设备所对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N。类似地，如果是利用空分复用方法来实现虚拟，此时一台虚拟设备平均占用的空间必然也等于或低于物理设备所拥有空间的1/N。\n异步(Asynchronism) 在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不可能\u0026quot;一气呵成”，而是以\u0026quot;停停走走”的方式运行。\n对于内存中的每个进程，在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需要多少时间才能完成等等，都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要I/O；而有的程序其计算少而I/O多，这样，很可能是先进入内存的作业后完成，而后进入内存的作业先完成。或者说，进程是以人们不可预知的速度向前推进的，此即进程的异步性。尽管如此，但只要在OS中配置有完善的进程同步机制，且运行环境相同，则作业即便经过多次运行，也都会获得完全相同的结果。因此异步运行方式是允许的，而且是操作系统的一个重要特征。\n操作系统的主要功能 引入OS的主要目的是，为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率，方便用户的使 用。为此，在传统的OS中应具有处理机管理、存储器管理、设备管理和文件管理等基本功能。此外，为了方便用户使用OS，还需向用户提供方便的用户接口。\n处理机管理功能 在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位的，因而对处理机的管理可归结为对进程的管理。处理机管理的主要功能有：创建和撤消进程，对诸进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理机分配给进程。\n进程控制 在多道程序环境下为使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤消该进程，以便能及时回收该进程所占用的各类资源，供其它进程使用。在设置有线程的OS中，进程控制还应包括为一个进程创建若干个线程，以提高系统的并发性。因此，进程控制的主要功能也就是为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换。\n进程同步 为使多个进程能有条不紊地运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程（含线程）的运行进行协调。常用的协调方式有两种：①进程互斥方式，这是指诸进程在对临界资源进行访问时，应采用互斥方式；②进程同步方式，指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。最简单的用于实现进程互斥的机制是为每一个临界资源配置一把锁W，当锁打开时，进程可以对该临界资源进行访问:而当锁关上时，则禁止进程访问该临界资源。而实现进程同步时，最常用的机制是信号量机制。\n进程通信 当有一组相互合作的进程去完成一个共同的任务时，在它们之间往往需要交换信息。例如，有输入进程、计算进程和打印进程三个相互合作的进程，输入进程负责将所输入的数据传送给计算进程；计算进程利用输入数据进行计算，并把计算结果传送给打印进程；最后由打印进程把计算结果打印出来。进程通信的任务是实现相互合作进程之间的信息交换。\n当相互合作的进程处于同一计算机系统时，通常在它们之间采用直接通信方式，即由源进程利用发送命令直接将消息(message)‌挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。\n调度 在传统OS中，调度包括作业调度和进程调度两步。\n(1) 作业调度。作业调度的基本任务是从后备队列中按照一定的算法选择出若干个作业，为它们分配运行所需的资源，在将这些作业调入内存后，分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并将它们插入就绪队列中。\n(2) 进程调度。进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给它，并为它设置运行现场，使其投入执行。\n存储器管理功能 存储器管理的主要任务，是为多道程序的运行提供良好的环境，提高存储器的利用率， 方便用户使用，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存 保护、地址映射和内存扩充等功能。\n内存分配 内存分配的主要任务是：\n(1) 为每道程序分配内存空间，使它们\u0026quot;各得其所”。\n(2) 提高存储器的利用率，尽量减少不可用的内存空间(碎片)。\n(3) 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。\nOS在实现内存分配时，可采取静态和动态两种方式：\n(1) 静态分配方式。每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”。\n(2) 动态分配方式。每个作业所要求的基本内存空间虽然也是在装入时确定的，但允 许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动\u0026quot;。\n内存保护 内存保护的主要任务是：\n(1) 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。\n(2) 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。\n为了确保每道程序都只在自己的内存区中运行，必须设置内存保护机制。一种比较简单的内存保护机制是设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。在程序运行时，系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。\n地址映射 在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其地址都是从0开始的，但不可能将它们从\u0026quot;0”地址(物理)开始装入内存，致使(各程序段的)地址空间内的逻辑地址与其在内存空间中的物理地址并不相一致。为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。\n内存扩充 内存扩充并非是从物理上去扩大内存的容量，而是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。这样既满足了用户的需要，又改善了系统的性能。为了能在逻辑上扩充内存，系统必须设置内存扩充机制(包含少量的硬件)，用于实现下述各功能：\n(1) 请求调入功能，系统允许在仅装入部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向OS发出请求，由OS从磁盘中将所需部分调入内存，以便继续运行。\n(2) 置换功能，若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至硬盘上，以腾出内存空间，然后再将所需调入的部分装入内存。\n设备管理功能 设备管理的主要任务如下：\n(1) 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。\n(2) 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。\n为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。\n缓冲管理 如果在I/O设备和CPU之间引入缓冲，则可有效地缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量。因此在现代OS中，无一例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法来改善系统的性能。不同的系统可采用不同的缓冲区机制。最常见的缓冲区机制有：单缓冲机制、能实现双向同时传送数据的双缓冲机制、能供多个设备同时使用的公用缓冲池机制。上述这些缓冲区都由OS缓冲 管理机制将它们管理起来。\n设备分配 设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。如果在I/O设备和CPU之间还存在着设备控制器和I/O通道，则还需为分配出去的设备分配相应的控制器和通道。为实现设备分配，系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器等的标识符和状态。根据这些表格可以了解指定设备当前是否可用，是否忙碌，以供进行设备分配时参考。在进行设备分配时，应针对不同的设备类型而采用不同的设备分配方式。对于独占设备的分配还应考虑到该设备被分配出去后系统是否安全。在设备使用完后，应立即由系统回收。\n设备处理 设备处理程序又称为设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作：反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。\n设备处理过程是：首先检查I/O请求的合法性，了解设备状态是否是空闲的，读取有关的传递参数及设置设备的工作方式。然后向设备控制器发出I/O命令，启动I/O设备完成指定的I/O操作。此外设备驱动程序还应能及时响应由控制器发来的中断请求，并根据该中断请求的类型，调用相应的中断处理程序进行处理。对于设置了通道的计算机系统，设备处理程序还应能根据用户的I/O请求自动地构成通道程序。\n文件管理功能 文件管理的主要任务是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间的管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。\n文件存储空间的管理 在多用户环境下，若由用户自己对文件的存储进行管理，不仅非常困难，而且也必然十分低效。因而需要由文件系统对诸多文件及文件的存储空间实施统一的管理。其主要任务是：为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存、取速度。为此，系统中应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考。还应具有对存储空间进行分配和回收的功能。\n目录管理 目录管理的主要任务是为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名存取。即用户只需提供文件名，即可对该文件进行存取。目录管理还应能实现文件共享，这样，只需在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件检索的速度。\n文件的读/写管理和保护 (1) 文件的读/写管理。该功能是根据用户的请求，从外存中读取数据，或将数据写入外存。在进行文件读/写时，系统先根据用户给出的文件名去检索文件目录，从中获得文件在外存中的位置。然后，利用文件读/写指针，对文件进行读/写。一旦读/写完成，便修改读/写指针，为下一次读/写做好准备。由于读和写操作不会同时进行，故可合用一个读/写指针。\n(2) 文件保护。为了防止系统中的文件被非法窃取和破坏，在文件系统中必须提供有效的存取控制功能，以实现下述目标：①防止未经核准的用户存取文件；②防止冒名顶替存取文件：③防止以不正确的方式使用文件。\n操作系统与用户之间的接口 为了方便用户对操作系统的使用，操作系统向用户提供了 \u0026ldquo;用户与操作系统的接口二 该接口通常可分为如下两大类：\n用户接口 为了便于用户直接或间接地控制自己的作业，操作系统向用户提供了命令接口。用户可通过该接口向作业发出命令以控制作业的运行。该接口又进一步分为联机用户接口、脱机用户接口和图形用户接口三种。\n(1) 联机用户接口。这是为联机用户提供的，它由一组键盘操作命令及命令解释程序组成。当用户在终端或控制台上键入一条命令后，系统便立即转入命令解释程序，对该命令加以解释执行。在完成指定功能后系统又返回到终端或控制台上，等待用户键入下一条命令。这样，用户便可通过先后键入不同命令的方式来实现对作业的控制，直至作业完成。\n(2) 脱机用户接口。这是为批处理作业的用户提供的。用户用作业控制语言JCL把需要对作业进行的控制和干预的命令事先写在作业说明书上，然后将它与作业一起提供给系统。当系统调度到该作业运行时，通过调用命令解释程序去对作业说明书上的命令逐条解释执行，直至遇到作业结束语句时系统才停止该作业的运行。\n(3) 图形用户接口。通过联机用户接口取得OS的服务既不方便又花时间，用户必须熟 记所有命令及其格式和参数，并逐个字符地键入命令，于是图形用户接口便应运而生。图 形用户接口采用了图形化的操作界面，用非常容易识别的各种图标(icon)来将系统的各项功能、各种应用程序和文件直观、逼真地表示出来。用户可通过菜单（和对话框）用移动鼠标选择菜单项的方式取代命令的键入，以方便、快捷地完成对应用程序和文件的操作，从而把用户从繁琐且单调的操作中解脱出来。\n程序接口 程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。每当应用程序要求OS提供某种服务（功能）时，便调用具有相应功能的系统调用（子程序）。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。但在高级语言以及C语言中，往往提供了与各系统调用一一对应的库函数，这样，应用程序便可通过调用对应的库函数来使用系统调用。但在近几年所推出的操作系统中，如UNIX、OS/2版本中，其系统调用本身已经采用C语言编写，并以函数形式提供，故在用C语言编制的程序中，可直接使用系统调用。\n现代操作系统的新功能 现代操作系统是在传统操作系统基础上发展起来的，它除了具有传统操作系统的功能外，还增加了面向安全、面向网络和面向多媒体等功能。\n系统安全 通常，政府机关和企事业单位有大量的、重要的信息，必须高度集中地存储在计算机系统中。这样，如何确保在计算机系统中存储和传输数据的保密性、完整性和系统可用性，便成为信息系统亟待解决的重要问题，而保障系统安全性的任务也责无旁贷地落到了现代OS的身上。\n虽然在传统的OS中也采取了一些保障系统安全的措施，但随着计算技术的进步和网络的普及，传统的安全措施已远不能满足要求。为此，在现代OS中采取了多种有效措施来确保系统的安全。在本书中我们仅局限于介绍保障系统安全的几个技术问题，包括：\n(1) 认证技术。这是一个用来确认被认证的对象是否名副其实的过程，以确定对象的真实性，防止入侵者进行假冒和篡改等。如身份认证，是通过验证被认证对象的一个或多个参数的真实性和有效性来确定被认证对象是否名副其实；因此，在被认证对象与要验证的那些参数之间应存在严格的对应关系。\n(2) 密码技术。即对系统中所需存储和传输的数据进行加密，使之成为密文，这样，攻击者即使截获到数据，也无法了解到数据的内容。只有指定的用户才能对该数据予以解密，了解其内容，从而有效地保护了系统中信息资源的安全性。近年来，国内外广泛应用数据加密技术来保障计算机系统的安全性。\n(3) 访问控制技术，可通过两种途径来保障系统中资源的安全：①通过对用户存取权限的设置，可以限定用户只能访问被允许访问的资源，这样也就限定了用户对系统资源的访问范围；②访问控制还可以通过对文件属性的设置来保障指定文件的安全性，如设置文件属性为只读时，该文件就只能被读而不能被修改等。\n(4) 反病毒技术。对于病毒的威胁，最好的解决方法是预防，不让病毒侵入系统，但要完全做到这一点是十分困难的，因此还需要非常有效的反病毒软件来检测病毒。在反病毒软件被安装到计算机后，便可对硬盘上所有的可执行文件进行扫描，检查盘上的所有可执行文件，若发现有病毒，便立即将它清除。\n网络功能和服务 在现代OS中，为支持用户联网取得各类网络所提供的服务，如电子邮件服务、Web服务等，应在操作系统中增加面向网络的功能，用于实现网络通信和资源管理，以及提供用户取得网络服务的手段。作为一个网络操作系统，应当具备多方面的功能：\n(1) 网络通信，用于在源主机和目标主机之间，实现无差错的数据传输，如建立和拆除通信链路、传输控制、差错控制和流量控制等。\n(2) 资源管理，即对网络中的共享资源(硬件和软件)实施有效的管理，协调诸用户对共享资源的使用，保证数据的安全性和一致性。典型的共享硬件资源有硬盘、打印机等，软 件资源有文件和数据。\n(3) 应用互操作，即在一个由若干个不同网络互连所构成的互连网络中，必须提供应 用互操作功能，以实现信息的互通性和信息的互用性。信息的互通性是指在不同网络中的用户之间，能实现信息的互通。信息的互用性是表示用户可以访问不同网络中的文件系统 和数据库系统中的信息。\n支持多媒体 一个支持多媒体的操作系统必须能像一般OS处理文字、图形信息那样去处理音频和视频信息等多媒体信息，为此，现代操作系统增加了多媒体的处理功能：\n(1) 接纳控制功能。在多媒体系统中，为了保证同时运行多个实时进程的截止时间，需要对在系统中运行的软实时任务，即SRT任务的数目、驻留在内存中的任务数目加以限制，为此设置了相应的接纳控制功能，如媒体服务器的接纳控制、存储器接纳控制和进程接纳控制。\n(2) 实时调度。多媒体系统中的每一个任务，往往都是一些要求较严格的、周期性的软实时任务SRT，如为了保证动态图像的连续性，图像更新的周期必须在40ms之内，因此在SRT调度时，不仅需要考虑进程的调度策略，还要考虑进程调度的接纳度等，相比传统的OS这就要复杂得多。\n(3) 多媒体文件的存储。为了存放多媒体文件，对OS最重要的要求是能把硬盘上的数据快速地传送到输出设备上。因此，对于在传统文件系统中数据的离散存放方式以及磁盘寻道方式都要加以改进。\nOS结构设计 早期OS的规模很小，如只有几十KB，完全可以由一个人以手工方式，用几个月的时间编制出来。此时，编制程序基本上是一种技巧，OS是否是有结构的并不那么重要，重要的是程序员的程序设计技巧。但随着OS规模的愈来愈大，其所具有的代码也愈来愈多，往往需要由数十人或数百人甚至更多的人参与，分工合作，共同来完成操作系统的设计。这意味着，应采用工程化的开发方法对大型软件进行开发。由此产生了\u0026quot;软件工程学”。\n软件工程的目标是十分明确的，所开发出的软件产品应具有良好的软件质量和合理的费用。整个费用应能为用户所接受：软件质量可用这样几个指标来评价：功能性、有效性、可靠性、易使用性、可维护性和易移植性。为此，先后产生了多种操作系统的开发方法，如模块化方法、结构化方法和面向对象的方法等。利用不同的开发方法所开发出的操作系统将具有不同的操作系统结构。\n传统操作系统的结构 软件开发技术的不断发展，促进了 OS结构的更新换代。这里，我们把早期的无结构的OS（第一代）、模块化结构的OS（第二代）和分层式结构的OS（第三代），都统称为传统结构的OS，而把微内核结构的OS称为现代结构的OS。\n无结构操作系统 在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。\n此时程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。当系统不太大，在一个人能够完全理解和掌握的情况下问题还不是太大，但随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。这一方面会使所编制出的程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。\n模块化结构操作系统 1. 模块化程序设计技术的基本概念\n模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术基于\u0026quot;分解\u0026quot;和“模块化”的原则来控制大型软件的复杂度。为使OS具有较清晰的结构，OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，如进程管理模块、存储器管理模块、I/O设备管理模块等，并仔细地规定好各模块间的接口，使各模块之间能通过接口实现交互。然后再进一步将各模块细分为若干个具有一定功能的子模块，如把进程管理模块又分为进程控制、进程同步等子模块，同样也规定好各子模块之间的接口。若子模块较大，可再进一步将它细分。我们把这种设计方法称为模块-接口法，由此构成的操作系统就是具有模块化结构的操作系统。图7示出了由模块、子模块等组成的模块化OS结构。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 操作系统 模块 进程控制 进程调度 ··· 进程管理 存储器管理 文件管理 ··· ··· 内存分配 内存保护 ··· 磁盘管理 目录管理 ··· 子模块 图7\u0026emsp;模块化结构的操作系统\n2. 模块独立性\n在模块\u0026mdash;接口法中，关键问题是模块的划分和规定好模块之间的接口。如果我们在划分模块时将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，从而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加，因此在划分模块时，应在两者间进行权衡。\n另外，在划分模块时，必须充分注意模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性有以下两个标准： (1) 内聚性。指模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越强。 (2) 耦合度。指模块间相互联系和相互影响的程度。显然，耦合度越低，模块独立性越好。\n3. 模块接口法的优缺点\n利用模块\u0026mdash;接口法开发的OS，较之无结构OS具有以下明显的优点：\n(1) 提高OS设计的正确性、可理解性和可维护性。\n(2) 增强OS的可适应性。\n(3) 加速OS的开发过程。\n模块化结构设计仍存在下述问题：\n(1) 在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。\n(2) 在OS设计阶段，设计者必须做出一系列的决定（决策），每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。\n分层式结构操作系统 1. 分层式结构的基本概念\n为了将模块\u0026mdash;接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统 \\(A_n\\) 和裸机系统（又称宿主系统） \\(A_0\\) 之间，铺设若干个层次的软件 \\(A_1,A_2,A_3,\\cdot,A_{n-1}\\) ，使 \\(A_n\\) 通过 \\(A_{n-1},A_{n-2},\\cdots,A_2,A_1\\) 层，最终能在 \\(A_0\\) 上运行。在操作系统中，常采用自底向上法来铺设这些中间层。\n自底向上的分层设计的基本原则是：每一步设计都建立在可靠的基础上。为此规定，每一层仅能使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得更容易。例如，在调试第一层软件 \\(A_1\\) 时，由于它使用的是一个完全确定的物理机器（宿主系统）所提供的功能，在对 \\(A_1\\) 软件经过精心设计和几乎是穷尽无遗的测试后，可以认为 \\(A_1\\) 是正确的，而且它与其所有的高层软件 \\(A_2,\\cdots,A_n\\) 无关；同样在调试第二层软件 \\(A_2\\) 时，它也只使用了软件 \\(A_1\\) 和物理机器所提供的功能，而与其高层软件 \\(A_3,\\cdots,A_n\\) 无关，如此一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。在用这种方法构成操作系统时，已将一个操作系统分为若干个层次，每层又由若干个模块组成，各层之间只存在着单向的依赖关系，即高层仅依赖于紧邻它的低层。\n2. 分层结构的优缺点\n分层结构的主要优点有：\n(1) 易保证系统的正确性。自下而上的设计方式使所有设计中的决定都是有序的，或 者说是建立在较为可靠的基础上的，这样比较容易保证整个系统的正确性。\n(2) 易扩充和易维护性。在系统中增加、修改或替换一个层次中的模块或整个层次时，只要不改变相应层次间的接口，就不会影响其他层次，这必将使系统维护和扩充变得更加容易。分层结构的主要缺点是系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。\n客户/服务器模式（Client/Server Model）简介 客户/服务器(Client/Server)模式可简称为C/S模式。其在20世纪90年代已风靡全球，不论是LAN,还是企业网，以及Internet所提供的多种服务，都广泛采用了客户/服务器的模式。\n客户/服务器模式的由来、组成和类型 客户/服务器系统主要由三部分组成。\n(1) 客户机：通常在一个LAN网络上连接有多台网络工作站（简称客户机），每台客户机都是一个自主计算机，具有一定的处理能力，客户进程在其上运行，平时它处理一些本 地业务，也可发送一个消息给服务器，以请求某项服务。\n(2) 服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，它应能为网上所有的用户提供一种或多种服务。平时它一直处于工作状态，被动地等待来自客户机的请求，一旦检查到有客户提出服务请求，便去完成客户的请求，并将结果送回客户，这样，工作站中的用户进程与服务器进程就形成了客户/服务器关系。\n(3) 网络系统：是用于连接所有客户机和服务器，实现它们之间通信和网络资源共享的系统。\n客户/服务器之间的交互 在采用客户/服务器的系统中，通常是客户机和服务器共同完成对应用（程序）的处理。这时，在客户机和服务器之间就需要进行交互，即必须利用消息机制在这两者之间进行多次通信。一次完整的交互过程可分成以下四步：\n(1) 客户发送请求消息。当客户机上的用户要请求服务器进行应用处理时，应输入相应的命令和有关参数。由客户机上的发送进程先把这些信息装配成请求消息，然后把它发往服务器；客户机上的接收进程则等待接收从服务器发回来的响应消息。 (2) 服务器接收消息。服务器中的接收进程平时处于等待状态，一旦有客户机发来请 求，接收进程就被激活，根据请求信息的内容，将之提供给服务器上的相应软件进行处理。\n(3) 服务器回送消息。服务器的软件根据请求进行处理，在完成指定的处理后，把处 理结果装配成一个响应消息，由服务器中的发送进程将之发往客户机。\n(4) 客户机接收消息。客户机中的接收进程把收到的响应消息转交给客户机软件，再 由后者做出适当处理后提交给发送该请求的客户。\n客户/服务器模式之间的优点 C/S模式之所以能成为在分布式系统和网络环境下软件的一种主要工作模式，是由于该模式具有传统集中模式所无法比拟的一系列优点。\n(1) 数据的分布处理和存储。由于客户机具有相当强的处理和存储能力，可进行本地处理和数据的分布存储，从而摆脱了由于把一切数据都存放在主机中而造成的既不可靠又容易产生瓶颈现象的困难局面。\n(2) 便于集中管理。尽管C/S模式具有分布处理功能，但公司(单位)中的有关全局的重 要信息、机密资料、重要设备以及网络管理等，仍可采取集中管理方式，这样可较好地保障系统的“可靠”和\u0026quot;安全”。\n(3) 灵活性和可扩充性。C/S模式非常灵活，极易扩充。理论上，客户机和服务器的数 量不受限制，其灵活性还表现在可以配置多种类型的客户机和服务器上。\n(4) 易于改编应用软件。在客户/服务器模式中，对于客户机程序的修改和增删，比传 统集中模式要容易得多，必要时也允许由客户进行修改。\n基本客户/服务器模式的不足之处是存在着不可靠性和瓶颈问题。在系统仅有一个服务器时，一旦服务器故障，将导致整个网络瘫痪。当服务器在重负荷下工作时，会因忙不过来而显著地延长对用户请求的响应时间。如果在网络中配置多个服务器，并采取相应的安全措施，则这种不足可加以改善。\n面向对象的程序设计（Object-Orientated Programming）技术简介 面向对象技术的基本概念 面向对象技术是20世纪80年代初提出并很快流行起来的。该技术是基于\u0026quot;抽象\u0026quot;和\u0026quot;隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物（事物可以是一个物理实体、一个概念或一个软件模块等）的抽象，而把其中的具体事物称为对象的实例。如果在OS中的各类实体如进程、线程、消息、存储器和文件等都使用了对象这一概念，相应地，便有了进程对象、线程对象、消息对象、存储器对象和文件对象等。\n1. 对象\n在面向对象的技术中，是利用被封装的数据结构（变量）和一组对它进行操作的过程（方法）来表示系统中的某个对象的，如图8所示。对象中的变量（数据）也称为属性，它可以是单个标量或一张表。面向对象中的方法是用于执行某种功能的过程，它可以改变对象的状态，更新对象中的某些数据值或作用于对象所要访问的外部资源。如果把一个文件作为一个对象图9,该对象的变量便是文件类型、文件大小、文件的创建者等。对象中的方法包含对文件的操作，如创建文件、打开文件、读文件、写文件、关闭文件等。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据结构 过程 1 过程 2 过程 3 图8\u0026emsp;一个对象的示意图\n对象中的变量（数据）对外是隐蔽的，因而外界不能对它直接进行访问，必须通过该对象中的一组方法（操作函数）对它进行访问。例如要想对图9所示的文件A执行打开操作，必须用该对象中的打开过程去打开它。同样地，对象中的一组方法的实现细节也是隐蔽的，因此对象中的变量可以得到很好的保护，而不会允许未经受权者使用和对它进行不正确的操作。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 类名 属性 操作 类 (类名)对象名 属性值 操作 类的实例 文件 类型 打开() 大小 创建者 读() 写() 关闭() （文件）文件 图表 打开() 20K X用户 读() 写() 关闭() 图9\u0026emsp;类和对象的关系\n2. 对象类\n在实践中，有许多对象可能表示的是同一类事物，每个对象具有自己的变量集合，而它们所具有的方法是相同的。如果为每一个相似的对象都定义一组变量和方法，显然是低效的，由此产生了“对象类”的概念，利用\u0026quot;对象类”来定义一组大体相似的对象。一个类同样定义了一组变量和针对该变量的一组方法，用它们来描述一组对象的共同属性和行为。类是在对象上的抽象，对象则是类的实例。对象类中所定义的变量在实例中均有具体的值。\n例如，我们将文件设计成一个类，类的变量同样是文件类型、文件大小和创建者等。类中的方法是文件的创建、打开、读写、关闭等。图9示出了一个文件类，在类的变量中没有具体数值，一旦被赋予了具体数值就成了文件A对象。对象类的概念非常有用，因为它极大地提高了创建多个相似对象的效率。\n3. 继承\n在面向对象的技术中，可以根据已有类来定义一个新的类，新类被称为子类(B),原来的类被称为父类(A),见图10所示。继承是父类和子类之间共享变量和方法的机制，该机制规定子类自动继承父类中定义的变量和方法，并允许子类再增加新的内容。继承特性可使定义子类变得更容易。一个父类可以定义多个子类，它们分别是父类的某种特例，父类描述了这些子类的公共变量和方法。类似地，这些子类又可以定义自己的子类，通过此途经可以生成一个继承的层次。另外，也允许一个子类有两个父类或多个父类，它可以从多个父类获得继承，此时称为\u0026quot;多重继承”。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 继承部分 A 增加部分 B 从A继承 图10\u0026emsp;类和继承的关系\n面向对象技术的优点 在操作系统设计时，将计算机中的实体作为对象来处理，可带来如下好处: (1) 通过“重用”提高产品质量和生产率。在面向对象技术中可通过“重用”以前项目中经过精心测试的对象或“重用”由其他人编写、测试和维护的对象类来构建新的系统，这不仅可大大降低开发成本，而且能获得更好的系统质量。\n(2) 使系统具有更好的易修改性和易扩展性。通过封装，可隐蔽对象中的变量和方法，因而当改变对象中的变量和方法时，不会影响到其它部分，从而可方便地修改老的对象类。另外，继承是面向对象技术的重要特性，在创建一个新对象类时，通过利用继承特性可显著减少开发的时空开销，使系统具有更好的易扩展性和灵活性。\n(3) 更易于保证系统的\u0026quot;正确性”和\u0026quot;可靠性”。对象是构成操作系统的基本单元，由于可以独立地对它进行测试，易于保证每个对象的正确性和可靠性，因此也就比较容易保证整个系统的正确性和可靠性。此外，封装对对象类中的信息进行了隐蔽，这样又可有效地防止未经授权者的访问和用户不正确的使用，有助于构建更为安全的系统。\n微内核操作系统 微内核(MicroKernel)操作系统结构是20世纪80年代后期发展起来的。由于它能有效地支持多处理机运行，故非常适用于分布式系统环境，当前比较流行的、能支持多处理机运行的OS,几乎全部都采用了微内核结构，如CarngieMellon大学研制的MachOS,便属于微内核结构OS；又如当前广泛使用的Windows2000/XP操作系统，也采用了微内核结构。\n微内核操作系统的基本概念 为了提高操作系统的\u0026quot;正确性”、“灵活性”、\u0026ldquo;易维护性”和“可扩充性”，在进行现代操作系统结构设计时，即使在单计算机环境下，大多也采用基于客户/服务器模式的微内核结构，将操作系统划分为两大部分：微内核和多个服务器。至于什么是微内核操作系统结构,现在尚无一致公认的定义，但我们可以从下面四个方面对微内核结构的操作系统进行描述。\n1. 足够小的内核\n在微内核操作系统中，内核是指精心设计的、能实现现代OS最基本核心功能的小型内核，微内核并非是一个完整的OS,而只是将操作系统中最基本的部分放入微内核，通常包含有：①与硬件处理紧密相关的部分：②一些较基本的功能；③客户和服务器之间的通信。这些OS最基本的部分只是为构建通用OS提供一个重要基础，这样就可以确保把操作系统内核做得很小。\n2. 基于客户/服务器模式\n由于客户/服务器模式具有非常多的优点，故在单机微内核操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供I/O设备管理的I/O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图11示出了在单机环境下的客户/服务器模式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 客户 进程 客户 进程 进程 服务器 终端 服务器 ··· 文件 服务器 存储器 服务器 核心 请求 回答 用户方式 核心方式 图11\u0026emsp;在单机环境下的客户/服务器模式\n3. 应用“机制与策略分离”原理\n在现在操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造OS结构。所谓机制，是指实现某一功能的具体执行机构。而策略，则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。\n4. 采用面向对象技术\n操作系统是一个极其复杂的大型软件系统，我们不仅可以通过结构设计来分解操作系统的复杂度，还可以基于面向对象技术中的\u0026quot;抽象”和\u0026quot;隐蔽”原则控制系统的复杂性，再进一步利用\u0026quot;对象”、\u0026ldquo;封装”和“继承”等概念来确保操作系统的\u0026quot;正确性”、\u0026ldquo;可靠性\u0026rdquo;、“易修改性\u0026rdquo;、\u0026ldquo;易扩展性”等，并提高操作系统的设计速度。正因为面向对象技术能带来如此多的好处，故面向对象技术被广泛应用于现代操作系统的设计中。\n微内核的基本功能 微内核应具有哪些功能，或者说哪些功能应放在微内核内，哪些应放在微内核外，目前尚无明确的规定。现在一般都采用“机制与策略分离”的原理，将机制部分以及与硬件紧密相关的部分放入微内核中。由此可知微内核通常具有如下几方面的功能：\n1. 进程（线程）管理\n大多数的微内核OS,对于进程管理功能的实现，都采用“机制与策略分离”的原理，例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列;能将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，应将它放入微内核中。而对于用户（进程）如何进行分类，以及其优先级的确认方式或原则，则都是属于策略问题。可将它们放入微内核外的进程（线程）管理服务器中。由于进程（线程）之间的通信功能是微内核OS最基本的功能，被频繁使用，因此几乎所有的微内核OS都是将进程（线程）之间的通信功能放入微内核中。此外，还将进程的切换、线程的调度，以及多处理机之间的同步等功能也放入微内核中。\n2. 低级存储器管理。\n通常在微内核中，只配置最基本的低级存储器管理机制，如用于实现将用户空间的逻辑地址变换为内存空间的物理地址的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法、采用何种内存分配与回收的策略等，应将这部分放在微内核外的存储器管理服务器中去实现。\n3. 中断和陷入处理\n大多数微内核操作系统都是将与硬件紧密相关的一小部分放入微内核中处理，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行相应的前期处理，如进行中断现场保护，识别中断和陷入的类型，然后将有关事件的信息转换成消息后，把它发送给相关的服务器。由服务器根据中断或陷入的类型调用相应的处理程序来进行后期处理。在微内核OS中是将进程管理、存储器管理以及I/O管理这些功能-分为二，属于机制的很小一部分放入微内核中，另外绝大部分放在微内核外的各种服务器中来实现。事实上，其中大多数服务器都要比微内核大。这进一步说明了为什么能在采用客户/服务器模式后，还能把微内核做得很小的原因。\n微内核操作系统的优点 由于微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的操作系统是集各种技术优点之大成，因而使之具有如下优点：\n(1) 提高了系统的可扩展性。由于微内核OS的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核OS只需在相应的服务器中增加新的功能， 或再增加一个专门的服务器。与此同时，也必然改善系统的灵活性，不仅可在操作系统中增加新的功能,还可修改原有的功能，以及删除已过时的老功能，以形成一个更为精干的有效的操作系统。\n(2) 增强了系统的可靠性。这一方面是由于微内核是通过精心设计和严格测试的，容易保证其正确性，另一方面，它提供了规范而精简的应用程序接口(API),为微内核外部的 程序编制高质量的代码创造了条件。此外，由于所有服务器都是运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，当某个服务器出现错误时，不会影响内核，也不会影响其它服务器。\n(3) 可移植性强。随着硬件的快速发展，出现了各种各样的硬件平台，作为一个好的 操作系统，必须具备可移植性，使其能较容易地运行在不同的计算机硬件平台上。在微内 核结构的操作系统中，所有与特定CPU和I/O设备硬件有关的代码，均放在内核和内核下 面的硬件隐藏层中，而操作系统其它绝大部分——各种服务器，均与硬件平台无关，因而， 把操作系统移植到另一个计算机硬件平台上所需作的修改是比较小的。\n(4) 提供了对分布式系统的支持。由于在微内核0S中，客户和服务器之间、服务器和服务器之间的通信采用消息传递通信机制，致使微内核OS能很好地支持分布式系统和网络系统。事实上，只要在分布式系统中赋予所有进程和服务器唯一的标识符，在微内核中再配置一张系统映射表（即进程和服务器的标识符与它们所驻留的机器之间的对应表），在进行客户与服务器通信时，只需在所发送的消息中标上发送进程和接收进程的标识符，微内核便可利用系统映射表将消息发往目标，而无论目标是驻留在哪台机器上。\n(5) 融入了面向对象技术。在设计微内核OS时采用了面向对象的技术，其中的“封装”，\u0026ldquo;继承”，\u0026ldquo;对象类”和“多态性\u0026rdquo;，以及在对象之间采用消息传递机制等，都十分有利于提高系统的正确性、可靠性、易修改性、易扩展性等，而且还能显著地减少开发系统所付出的开销。\n微内核操作系统存在的问题 应当指出，在微内核操作系统中，由于采用了非常小的内核，客户/服务器模式和消息传递机制虽给微内核操作系统带来了许多优点，但由此也使微内核OS存在着潜在缺点，其中最主要的是，较之早期的操作系统，微内核操作系统的运行效率有所降低。\n效率降低最主要的原因是，在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只需进行两次上下文的切换：一次是在执行系统调用后由用户态转向系统态时：另一次是在系统完成用户请求的服务后，由系统态返回用户态时。\n在微内核OS中，由于客户和服务器、服务器和服务器之间的通信都需通过微内核，致使同样的服务请求至少需要进行四次上下文切换。第一次是发生在客户发送请求消息给内核，以请求取得某服务器特定的服务时；第二次是发生在由内核把客户的请求消息发往服务器时；第三次是当服务器完成客户请求后，把响应消息发送到内核时；第四次是在内核将响应消息发送给客户时。\n实际情况是往往还会引起更多的上下文切换。例如，当某个服务器自身尚无能力完成客户请求而需要其它服务器的帮助时，如图12所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行8次上下文的切换。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 客户机应用 OS内核 (a)在整体式内核文件操作中的上下文切换 客户机应用 文件服务器 磁盘设备驱动器 微内核 (b)在微内核中等价操作中的上下文切换 图12\u0026emsp;在传统OS和微内核OS中的上下文切换\n为了改善运行效率，可以重新把一些常用的操作系统基本功能由服务器移入微内核中。这样可使客户对常用操作系统功能的请求所发生的用户/内核模式和上下文的切换的次数由4次或8次降为2次。但这又会使微内核的容量明显地增大，在小型接口定义和适应性方面的优点也有所下降，并提高了微内核的设计代价。\n弱小和无知不是生存的障碍，傲慢才是。 ― 刘慈欣, 《三体Ⅲ：死神永生》 ","date":"2024-09-19T22:28:10+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/engineering/computer_science/operating_system/introduction_to_operating_system/","title":"操作系统（一）：操作系统概论"},{"content":" Markov过程 有一类随机过程，它具备所谓的“无后效性”（Markov性），即，要确定过程将来的状态，知道它此刻的情况就足够了，并不需要对它以往的情况的认识，这类过程称为Markov过程。本文将介绍Markov过程中最简单的两种类型：离散时间Markov链（简称马氏链）及连续时间的Markov链。\n基本概念 Markov链的定义 Markov链 定义1（Markov链）：给定随机过程 \\(\\set{X_n,n=0,1,2,\\cdots}\\) ，若它只取有限或可列个值 \\(E_0,E_1,E_2,\\cdots\\) （我们以 \\(\\set{0,1,2,\\cdots}\\) 来标记 \\(E_0,E_1,E_2\\) 并称他们是过程的状态， \\(\\set{0,1,2\\cdots}\\) 或者其子集记为 \\(S\\) ，称为过程的状态空间）。若对 \\(\\set{X_n,n=0,1,2,\\cdots}\\) （一般就认为它的状态是非负整数）和任意的 \\(n\\ge0\\) 及状态 \\(i,j,i_0,i_1\\cdots,i_{n-1}\\) ，有\n\\[ \\begin{aligned} \u0026P\\set{X_{n+1}=j|X_0=i_0,X_1=i_1,X_2=i_2,\\cdots,X_{n-1}=i_{n-1},X_n=i}\\\\[5pt] =\u0026P\\set{X_{n+1}=j|X_n=i} \\end{aligned} \\tag{1} \\] 则称随机过程 \\(\\set{X_n,n=0,1,2,\\cdots}\\) 为Markov链。\nMarkov性 式(1)刻画了Markov链的特性，故称为Markov性。\n转移概率 转移概率的定义 定义2（一步转移概率）：称式(1)中的条件概率 \\(P\\set{X_{n+1}=j|X_n=i}\\) 为Markov链 \\(\\set{X_n\\left(n=0,1,2,\\cdots\\right)}\\) 的一步转移概率，简称转移概率。\n一般情况下，转移概率与状态 \\(i,j\\) 和时刻 \\(n\\) 有关。\n时齐Markov链 定义3（时齐）：当Markov链的转移概率只与状态 \\(i,j\\) 有关，而与 \\(n\\) 无关时，称Markov链为时齐的，并记 \\(p_{ij}=P\\set{X_{n+1}=j|X_n=i}\\left(n \\ge 0\\right)\\) ；否则，就称之为非时齐的。\n本文只讨论时齐Markov链并将其简称为Markov链。\n有限链和无限链 定义4（有限链和无限链）：当Markov链的状态为有限时，成为有限链，否则成为无限链。但无论状态有限还是无限，我们都可以将 \\(p_{ij}\\left(i,j\\in S\\right)\\) 排成一个矩阵的形式，令\n\\[ \\bm{P}=\\left(p_{ij}\\right)= \\begin{pmatrix} p_{00} \u0026 p_{01} \u0026 p_{02} \u0026 p_{03} \u0026 \\cdots \\\\[5pt] p_{10} \u0026 p_{11} \u0026 p_{12} \u0026 p_{13} \u0026 \\cdots \\\\[5pt] p_{20} \u0026 p_{21} \u0026 p_{22} \u0026 p_{23} \u0026 \\cdots \\\\[5pt] p_{30} \u0026 p_{31} \u0026 p_{32} \u0026 p_{33} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \\\\[5pt] \\end{pmatrix} \\tag{2} \\] 则称 \\(\\bm{P}\\) 为转移概率矩阵，一般称为转移矩阵。容易看出 \\(p_{ij}\\left(i,j\\in S\\right)\\) 有性质\n\\[ p_{ij} \\ge 0, i,j\\in S \\tag{3} \\] \\[ \\sum_{j \\in S}{p_{ij}} = 1, \\forall i \\in S \\tag{4} \\]\nn步转移概率与C-K方程 n步转移概率 定义5（n步转移概率）：称条件概率\n\\[ p_{ij}^{\\left(n\\right)}=P\\set{X_{m+n}=j|X_m=i}\\quad i,j\\in S,m \\ge 0, n \\ge 1 \\tag{5} \\] 为Markov链的n步转移概率，相应地称 \\(\\bm{P}^{\\left(n\\right)}=\\left(p_{ij}^{\\left(n\\right)}\\right)\\) 为n步转移矩阵。\n当 \\(n=1\\) 时， \\(p_{ij}^{\\left(1\\right)}=p_{ij}\\) ， \\(\\bm{P}^{\\left(1\\right)}=\\bm{P}\\) 。此外规定\n\\[ p_{ij}^{\\left(0\\right)}= \\begin{cases} 0, \\quad i \\ne j\\\\[5pt] 1, \\quad i=j \\end{cases} \\tag{6} \\] 显然，n步转移概率 \\(p_{ij}^{\\left(n\\right)}\\) 指的就是系统从状态 \\(i\\) 经过 \\(n\\) 步后转移到了 \\(j\\) 的概率，它对中间的 \\(n-1\\) 步转移经过的状态无要求。下面的定理给出了 \\(p_{ij}^{\\left(n\\right)}\\) 和 \\(p_{ij}\\) 的关系。\nC-K方程 定理1（Charpman-Kolmogorov方程，简称C-K方程）：对一切 \\(n,m \\ge 0\\) ， \\(i,j \\in S\\) 有\n\\[ p_{ij}^{\\left(m+n\\right)}=\\sum_{k \\in S}{p_{ik}^{\\left(m\\right)}}p_{kj}^{\\left(n\\right)} \\tag{7} \\] \\[ \\bm{P}^{\\left(n\\right)}=\\bm{P} \\cdot \\bm{P}^{\\left(n-1\\right)} = \\bm{P} \\cdot \\bm{P} \\cdot \\bm{P}^{\\left(n-2\\right)} = \\cdots = \\bm{P}^n \\tag{8} \\] 证明（定理1）‌：由全概率公式可得\n\\[ \\begin{aligned} p_{ij}^{\\left(m+n\\right)}\u0026=P\\set{X_{m+n}=j|X_0=i}\\\\[5pt] \u0026=\\frac{P\\set{X_{m+n}=j,X_0=i}}{P\\set{X_0=i}}\\\\[10pt] \u0026=\\sum_{k \\in S}{\\frac{P\\set{X_{m+n}=j,X_m=k,X_0=i}}{P\\set{X_0=i}}}\\text{（全概率公式）}\\\\ \u0026=\\sum_{k \\in S}{\\frac{P\\set{X_{m+n}=j,X_m=k,X_0=i}}{P\\set{X_m=k,X_0=i}}\\frac{P\\set{X_m=k,X_0=i}}{P\\set{X_0=i}}}\\\\ \u0026=\\sum_{k \\in S}{P\\set{X_{m+n}=j|X_m=k,X_0=i}}P\\set{X_m=k|X_0=i}\\\\ \u0026=\\sum_{k \\in S}{p_{kj}^{\\left(n\\right)}p_{ik}^{\\left(m\\right)}}\\\\ \u0026=\\sum_{k \\in S}{p_{ik}^{\\left(m\\right)}p_{kj}^{\\left(n\\right)}} \\end{aligned} \\tag{9} \\] 由矩阵乘法易得式(8)是式(7)的矩阵形式。\n结论1：对任意 \\(n_1,n_2,n_3,\\cdots,n_m\\left(n_i\\ge0\\right)\\) 和 \\(k_1,k_2,k_3,\\cdots,k_m\\left(k_j \\in S\\right)\\) ，有\n\\[ p_{ij}^{\\left(n_1+n_2+n_3+\\cdots+n_m\\right)}\\ge p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2k_3}^{\\left(n_3\\right)}\\cdots p_{k_{m-1}j}^{\\left(n_m\\right)} \\tag{10} \\] 证明（结论1）‌：由C-K方程和概率的非负性可得\n\\[ \\begin{aligned} p_{ij}^{\\left(n_1+n_2+n_3+\\cdots+n_m\\right)}=\u0026\\sum_{k \\in S}p_{ik}^{\\left(n_1\\right)}p_{kj}^{\\left(n_2+n_3+\\cdots+n_m\\right)}\\\\[5pt] \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1j}^{\\left(n_2+n_3+\\cdots+n_m\\right)}\\\\[5pt] \\ge\u0026\\sum_{k \\in S}p_{ik_1}^{\\left(n_1\\right)}p_{k_1k}^{\\left(n_2\\right)}p_{kj}^{\\left(n_3+\\cdots+n_m\\right)}\\\\ \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2j}^{\\left(n_3+\\cdots+n_m\\right)}\\\\ \\vdots\\\\ \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2k_3}^{\\left(n_3\\right)}\\cdots p_{k_{m-1}j}^{\\left(n_m\\right)} \\end{aligned} \\tag{11} \\] 状态的分类及性质 可达、互通、类、可约 定义6（可达与互通）：称状态 \\(i\\) 可达状态 \\(j\\left(i,j \\in S\\right)\\) ，若存在 \\(n \\ge 0\\) 使得 \\(p_{ij}^{\\left(n\\right)} \\ge 0\\) ，记为 \\(i \\rightarrow j\\) 。若同时有状态 \\(j \\rightarrow i\\) ，则称 \\(i\\) 与 \\(j\\) 互通，记为 \\(i \\leftrightarrow j\\) 。\n定理2：互通是一种等价关系，即满足：\n(1) 自反性： \\(i \\leftrightarrow i\\) 。\n(2) 对称性： \\(i \\leftrightarrow j\\) ，则 \\(j \\leftrightarrow i\\) 。\n(3) 传递性： \\(i \\leftrightarrow j\\) , \\(j \\leftrightarrow k\\) ，则 \\(i \\leftrightarrow k\\) 。\n证明（定理2）‌：从互通的定义可知(1)(2)是显然的，只证(3)。由互通定义可知，需证 \\(i \\rightarrow k\\) 且 \\(k \\rightarrow i\\) 。首先，由 \\(i \\rightarrow j\\) ， \\(j \\rightarrow k\\) 可知存在 \\(m\\) ， \\(n\\) 使得 \\(p_{ij}^{\\left(m\\right)}\u003e0\\) ， \\(p_{jk}^{\\left(n\\right)}\u003e0\\) 。再由结论1可知 \\(p_{ik}^{\\left(m+n\\right)}\\ge {p_{ij}^{\\left(m\\right)}p_{jk}^{\\left(n\\right)}}\u003e0\\) ，故 \\(i \\rightarrow k\\) 。反过来同样有 \\(k \\rightarrow i\\) ，即证 \\(i \\leftrightarrow k\\) 。\n定义7（类）：我们把任何两个相通状态归为一个类，由上述定理可知，同在一类的状态应该都是互通的，并且任何一个状态不能同时属于两个不同的类。\n定义8（可约）：若Markov链只存在一个类，就称它是不可约的。否则称为可约的。\n周期 定义9（周期）：若集合 \\(\\set{n|n \\ge 1,p_{ii}^{\\left(n\\right)} \\ge 0}\\) 非空，则称它的最大公约数 \\(d=d\\left(i\\right)\\) 为状态 \\(i\\) 的周期。若 \\(d \\ge 1\\) ，则称 \\(i\\) 是周期的；若 \\(d=1\\) ，则称 \\(i\\) 是非周期的。并特别规定上述集合为空集时，称 \\(i\\) 的周期为无穷大。 。\n定理3：若状态 \\(i,j\\) 同属一类，则 \\(d\\left(i\\right)=d\\left(j\\right)\\) 。\n证明（定理3）‌：由定义7的定义可知 \\(i \\leftrightarrow j\\) ，即存在 \\(m,n\\) 使 \\(p_{ij}^{\\left(m\\right)}\u003e0,p_{ji}^{\\left(n\\right)}\u003e0\\) 。则由结论1知 \\(p_{ii}^{\\left(m+n\\right)}\\ge p_{ij}^{\\left(m\\right)}p_{ji}^{\\left(n\\right)}\u003e0\\) ，同时对所有使得 \\(p_{jj}^{\\left(s\\right)} \u003e 0\\) 的 \\(s\\) ，有\n\\[ p_{ii}^{\\left(m+s+n\\right)} \\ge p_{ij}^{\\left(m\\right)}p_{jj}^{\\left(s\\right)}p_{ji}^{\\left(n\\right)}\u003e0 \\tag{12} \\] 由定义9的定义可知，由于 \\(p_{ii}^{\\left(m+n\\right)}\u003e0\\) 且 \\(p_{ii}^{\\left(m+s+n\\right)}\u003e0\\) ， \\(d\\left(i\\right)\\) 必然同时整除 \\(n+m\\) 和 \\(n+m+s\\) ，因此，它也必然整除 \\(s\\) （见整除的基本性质）。同时我们还需注意我们已经假设了 \\(p_{jj}^{\\left(s\\right)} \u003e 0\\) ，因此 \\(d\\left(j\\right)\\) 必定也整除 \\(s\\) 。注意 \\(s\\) 的任意性，不妨直接令 \\(s=d\\left(j\\right)\\) ，由此可得 \\(d\\left(i\\right)\\) 整除 \\(d\\left(j\\right)\\) 。我们把上述证明的 \\(i\\) 和 \\(j\\) 交换一下，就也能得到 \\(d\\left(j\\right)\\) 整除 \\(d\\left(i\\right)\\) ，于是 \\(d\\left(i\\right)=d\\left(j\\right)\\) （见 整除的基本性质）。\n常返 首达概率、常返与非常返（瞬过） 定义10（首达概率）：对于任何状态 \\(i,j\\) ，以 \\(f_{ij}^{\\left(n\\right)}\\) 记从i出发经n步后首次到达 \\(j\\) 的概率（首达概率），则有\n\\[ f_{ij}^{\\left(n\\right)}= \\begin{cases} 0 \\quad n=0 \\\\[5pt] P\\set{X_n=j,X_k \\ne j\\left(k=1,2,\\cdots ,n-1\\right)| X_0=i} \\quad n \\ge 1 \\end{cases} \\tag{13} \\] 定义11（常返）：令 \\(f_{ij}=\\displaystyle\\sum_{n=1}^{\\infin}{f_{ij}^{\\left(n\\right)}}\\) ，若 \\(f_{jj}=1\\) ，则称状态 \\(j\\) 为常返状态，若 \\(f_{jj}\u003c1\\) ，称 \\(j\\) 为非常返状态或瞬过状态。\n\\(f_{ij}\\) 的含义可由如下得出：由集合 \\(A_n\\) 的定义 \\(A_n=\\set{X_n=j,X_k \\ne j, k=1,2,\\cdots n-1 | X_0=i}\\) 可知 \\(n\\) 不同的时候 \\(A_n\\) 不相交。而 \\(\\displaystyle\\bigcup_{n=1}^{\\infin}{A_n}\\) 表示的事件正是总有一个 \\(n\\) 使得过程经 \\(n\\) 步后可从 \\(i\\) 到达 \\(j\\) ,那么由不相交事件概率的可加性可得：\n\\[ P\\left(\\bigcup_{n=1}^{\\infin}{A_n}\\right)=\\sum_{n=1}^{\\infin}{P\\left(A_n\\right)}=\\sum_{n=1}^{\\infin}f_{ij}^{\\left(n\\right)}=f_{ij} \\tag{14} \\] 因此 \\(f_{ij}\\) 表示从 \\(i\\) 出发，有限步内可以到达 \\(j\\) 的概率。当 \\(i\\) 为常返状态时，以概率 \\(1\\) 从 \\(i\\) 出发，在有限步过程将重新返回 \\(i\\) ，而当 \\(i\\) 为非常返状态时，若也以概率 \\(1\\) 从 \\(i\\) 出发，则以概率 \\(1-f_{ii}\\) 不再回到 \\(i\\) （即从 \\(i\\) 滑过）。\n对于常返态 \\(i\\) ，定义\n\\[ \\mu_i=\\sum_{n=1}^{\\infin}{nf_{ii}^{\\left(n\\right)}} \\tag{15} \\] 表示由 \\(i\\) 出发再返回到 \\(i\\) 所需的平均步数（时间）。\n正常返、零常返、遍历、吸收 定义12（正常返、零常返、遍历、吸收）：对于常返态 \\(i\\) ，若 \\(\\mu_i\u003c+\\infin\\) ，则称 \\(i\\) 为正常返态；若 \\(\\mu_i=+\\infin\\) ，则称 \\(i\\) 为零常返态。特别地，若 \\(i\\) 正常返且是非周期的，则称之为遍历状态。若 \\(i\\) 是遍历状态，且 \\(f_{ii}^{\\left(1\\right)}=1\\) ，则称 \\(i\\) 为吸收状态。此时显然 \\(\\mu_i=1\\) 。\n若干性质证明 常返的极限判定 定理4：状态 \\(i\\) 为常返状态当且仅当 \\(\\displaystyle\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=+\\infin\\) 。状态 \\(i\\) 为非常返状态时\n\\[ \\sum_{n=0}^{\\left(\\infin\\right)}{p_{ii}^{\\left(n\\right)}}=\\frac{1}{1-f_{ii}} \\tag{16} \\] 因而此时有 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 。\n为了证明定理4，我们需要先证明结论2和引理1。\n结论2：对任意状态 \\(i,j\\) ，有\n\\[ f_{ij}^{\\left(l+1\\right)}=\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}} \\tag{17} \\] 证明（结论2）‌：由定义10的定义、定义1的定义、定义3的定义和全概率公式可得\n\\[ \\begin{aligned} f_{ij}^{\\left(l+1\\right)}=\u0026P\\set{X_{l+1}=j,X_m \\ne j\\left(m=1,2,\\cdots ,l\\right) | X_0=i}\\quad \\text{（首达概率）}\\\\[5pt] =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k | X_0=i}}\\text{（全概率公式）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{\\frac{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k,X_0=i}}{P\\set{X_0=i}}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{\\frac{P\\set{X_1=k,X_0=i}}{P\\set{X_0=i}}\\frac{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k,X_0=i}}{P\\set{X_1=k,X_0=i}}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right)|X_1=k,X_0=i}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right)|X_1=k}}\\text{（Markov链）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_l=j,X_m \\ne j \\left(m=1,\\cdots ,l-1\\right)|X_0=k}}\\text{（时齐）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}} \\end{aligned} \\tag{18} \\] 引理1：对任意状态 \\(i,j\\) 及 \\(1 \\le n \u003c \\infin\\) ，有\n\\[ p_{ij}^{\\left(n\\right)}=\\sum_{l=1}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}} \\tag{19} \\] 证明（引理1）‌：用归纳法。对 \\(n=1\\) ，由 \\(p_{ij}^{\\left(1\\right)}=f_{ij}^{\\left(1\\right)}\\) ，易证上式成立。\n假设对 \\(n-1\\) ，已有 \\(p_{ij}^{\\left(n-1\\right)}=\\displaystyle\\sum_{l=1}^{n-1}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-1-l\\right)}}\\) 成立。\n当取 \\(n\\) 时，利用C-K方程、归纳假设和结论2，可以推导出\n\\[ \\begin{aligned} p_{ij}^{\\left(n\\right)}\u0026=\\sum_{k \\in S}{p_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}} \\qquad \\text{（C-K方程）}\\\\ \u0026=p_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}{p_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}} \\text{（归纳法n=1时的情况）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}f_{ik}^{\\left(1\\right)}\\left(\\sum_{l=1}^{n-1}{f_{kj}^{\\left(l\\right)}p_{jj}^{\\left(n-1-l\\right)}}\\right) \\text{（归纳假设n-1时的情况）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=1}^{n-1}{\\left(\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}}\\right)p_{jj}^{\\left(n-1-l\\right)}}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=1}^{n-1}{f_{ij}^{\\left(l+1\\right)}p_{jj}^{\\left(n-1-l\\right)}} \\quad \\text{（结论2）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=2}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}\\\\ \u0026=\\sum_{l=1}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}\\\\ \\end{aligned} \\tag{20} \\] 现在，我们可以用引理1证明定理4。\n证明（定理4）‌：\n\\[ \\begin{aligned} \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\u0026\\:p_{ii}^{\\left(0\\right)}+\\sum_{n=1}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\\\ =\u0026\\:1+\\sum_{n=1}^{\\infin}\\left(\\sum_{l=1}^{n}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(n-l\\right)}}\\right)\\\\ =\u0026\\:1+\\sum_{l=1}^{\\infin}\\sum_{n=l}^{\\infin}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(n-l\\right)}}\\\\ =\u0026\\:1+\\sum_{l=1}^{\\infin}\\sum_{m=0}^{\\infin}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(m\\right)}}\\\\ =\u0026\\:1+\\left(\\sum_{l=1}^{\\infin}{f_{ii}^{\\left(l\\right)}}\\right)\\left(\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\right)\\\\ =\u0026\\:1+f_{ii}\\left(\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\right) \\end{aligned} \\tag{21} \\] 左右有相同项 \\(\\displaystyle\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\) ，则解该等式得\n\\[ \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\\frac{1}{1-f_{ii}} \\tag{22} \\] 因此\n\\[ \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\text{收敛}\\iff f_{ii}\u003c1\\text{；} \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\\infin \\iff f_{ii}=1 \\tag{23} \\] 常返互通则必达 引理2：若 \\(i \\leftrightarrow j\\) 且 \\(i\\) 为常返态，则 \\(f_{ji}=1\\) 。\n证明（引理2）‌：用反证法。假设 \\(f_{ji}\u003c1\\) ，则从 \\(j\\) 出发不一定能在有限步内到达 \\(i\\) ，但是由于 \\(i \\rightarrow j\\) ，则从 \\(i\\) 出发一定能在有限步到达 \\(j\\) 。这意味着从 \\(i\\) 出发如果经过 \\(j\\) ，将不一定能在有限步之内再回到 \\(i\\) ，这与 \\(i\\) 的常返性相矛盾，假设不成立。因此 \\(f_{ij}=1\\) 。\n常返是一个类性质 定理5：常返性是一个类性质。即若 \\(i \\leftrightarrow j\\) 则 \\(i,j\\) 同为常返状态或非常返状态，且当 \\(i,j\\) 同为常返状态时，它们同为正常返态或零常返态。\n证明（定理5）‌：先证明若 \\(i \\leftrightarrow j\\) 则 \\(i,j\\) 同为常返状态或非常返状态。\n由 \\(i \\leftrightarrow j\\) 知。存在 \\(n, m\\) 使得 \\(p_{ij}^{\\left(n\\right)}\u003e0,p_{ji}^{\\left(m\\right)}\u003e0\\) ，由结论1易得\n\\[ p_{ii}^{\\left(n+m+l\\right)} \\ge p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(l\\right)}p_{ji}^{\\left(m\\right)}\\\\[5pt] p_{jj}^{\\left(n+m+l\\right)} \\ge p_{ji}^{\\left(n\\right)}p_{ii}^{\\left(l\\right)}p_{ij}^{\\left(m\\right)} \\tag{24} \\] 两边求和得到\n\\[ \\sum_{l=0}^{\\infin}{p_{ii}^{\\left(n+m+l\\right)}} \\ge \\sum_{l=0}^{\\infin}{p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(l\\right)}p_{ji}^{\\left(m\\right)}}\\\\[5pt] \\sum_{l=0}^{\\infin}{p_{jj}^{\\left(n+m+l\\right)}} \\ge \\sum_{l=0}^{\\infin}{p_{ji}^{\\left(n\\right)}p_{ii}^{\\left(l\\right)}p_{ij}^{\\left(m\\right)}} \\tag{25} \\] 考虑到 \\(\\displaystyle\\sum_{l=0}^{n+m-1}{p_{ii}^{\\left(l\\right)}}\\) 和 \\(\\displaystyle\\sum_{l=0}^{n+m-1}{p_{jj}^{\\left(l\\right)}}\\) 都是有限的，那么可以把上式写成这样：\n\\[ \\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}} - \\sum_{l=0}^{n+m-1}{p_{ii}^{\\left(l\\right)}} \\ge p_{ij}^{\\left(n\\right)}p_{ji}^{\\left(m\\right)}\\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}}\\\\[5pt] \\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}} - \\sum_{l=0}^{n+m-1}{p_{jj}^{\\left(l\\right)}} \\ge p_{ji}^{\\left(n\\right)}p_{ij}^{\\left(m\\right)}\\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}} \\tag{26} \\] 因此我们可以直观的看出 \\(\\displaystyle\\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}}\\) 和 \\(\\displaystyle\\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}}\\) 当中任意一个为无穷时，另一个必然也为无穷；任意一个为有限时，另一个必然也为有限。因此 \\(i,j\\) 同为常返状态或非常返状态。故常返性是一个类性质，类中任意成员满足，则其他成员也必定满足；反之若类中任一成员不满足，则其他成员也不满足。\n其次还能证明当 \\(i,j\\) 同为常返状态时，它们同为正常返态或零常返态。该证明需要用到下文的推论1。\n假设 \\(i\\) 为零常返状态且 \\(i \\leftrightarrow j\\) 。由推论1可知 \\(\\lim\\limits_{m \\rightarrow \\infin}p_{ii}^{\\left(m\\right)}=0\\) 。由于 \\(i \\leftrightarrow j\\) ，存在 \\(n,l\\) 使得 \\(p_{ij}^{\\left(n\\right)}\u003e0,p_{ji}^{\\left(l\\right)}\u003e0\\) 。同时由结论1可得 \\(p_{ii}^{\\left(n+m+l\\right)} \\ge p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(m\\right)}p_{ji}^{\\left(l\\right)}\\ge0\\) 。令 \\(m \\rightarrow \\infin\\) ，由夹挤准则可知 \\(\\lim\\limits_{m \\rightarrow \\infin}p_{jj}^{\\left(m\\right)}=0\\) ，故由推论1，状态 \\(j\\) 也是零常返状态。\n状态空间分解定理 定理6（状态空间分解定理）：任意Markov链的状态空间 \\(S\\) ，可唯一分解为有限个或可列个互不相交的子集 \\(D,C_1,C_2,\\cdots\\) 之和，使得\n(1) 每一个 \\(C_n\\) 是常返状态组成的不可约闭集， \\(D\\) 由全体非常返状态组成。\n(2) \\(C_n\\) 中的状态同类，或者全是正常返态，或者全是零常返态。它们有相同的周期且 \\(f_{ij}=1\\left(i,j \\in C_n\\right)\\) 。\n(3) 自 \\(C_n\\) 中的状态出发不能到达 \\(D\\) 中状态。\n证明（定理6）‌：设 \\(C\\) 为全体常返状态组成的集合，则 \\(D=S-C\\) 为非常返状态的全体组成的集合。注意到定义在 \\(C\\) 上的互通是一种等价关系，由等价关系与集合的划分可知， \\(C\\) 可以按互通关系划分为 \\(C_1 \\bigcup C_2 \\bigcup \\dots\\) ，其中每一个 \\(C_n\\) 是由同一类常返状态组成的不可约的闭集。因此 \\(S=D \\bigcup C_1 \\bigcup C_2 \\bigcup \\dots\\) 。定理假设和(1)证毕。由定理5可知 \\(C_n\\) 中的状态都是同类型的（正常返或零常返），由定理3可知 \\(C_n\\) 中的状态都有相同的周期，由引理2可知 \\(C_n\\) 中的状态都满足 \\(f_{ij}=1\\left(i,j \\in C_n\\right)\\) 。 (2) 证毕。对于 (3) ，可用反证法证明。假设 \\(C_n\\) 中的状态 \\(i\\) 可以到达 \\(D\\) 中的状态 \\(j\\) ，由于 \\(i\\) 是常返的，状态在到达 \\(j\\) 后必定还会再返回 \\(i\\) ，而后再由假设，状态还可能继续回到 \\(j\\) 。因此，状态从 \\(j\\) 出发后再次返回 \\(j\\) 的情况是可能出现的，这与 \\(j\\) 是非常返态相矛盾，因此假设不成立。故 \\(C_n\\) 中的状态 \\(i\\) 不可到达 \\(D\\) 中的状态 \\(j\\) 。 (3) 证毕。至此，定理6证毕。\n不可约Markov链的转移 定理7：周期为 \\(d\\) 的不可约Markov链，其状态空间 \\(S\\) 可唯一地分解为 \\(d\\) 个互不相交的子集之和，即\n\\[ S=\\bigcup_{r=0}^{d-1}{S_r},\\quad S_r \\bigcap S_s=\\varnothing,\\quad r \\ne S \\tag{27} \\] 且使得自 \\(S_r\\) 任意状态出发，经 \\(1\\) 步转移必进入 \\(S_{r+1}\\) 中（其中 \\(S_d=S_0\\) ）。\n证明（定理7）‌：先给出子集 \\(S_r\\) 的定义：\n任意取状态 \\(i\\) ，对每一个 \\(r=0,1,\\cdots,d-1\\) ，定义集合\n\\[ S_r=\\set{j|存在n \\ge 0使得p_{ij}^{\\left(nd+r\\right)}\u003e0} \\tag{28} \\] 因为 \\(S\\) 不可约，故 \\(S\\) 中从 \\(i\\) 出发一定可以遍历每一个状态，而 \\(nd+r\\left(r=0,1,\\cdots,n-1\\right)\\) 可以遍历从 \\(i\\) 出发后的每一个时间，因此所有 \\(S_r\\) 的并集一定为 \\(S\\) ，即 \\(\\displaystyle\\bigcup_{r=0}^{d-1}{S_r}=S\\) 。\n接下来证明 \\(S_r\\) 不相交。用反证法，假设存在 \\(S_r,S_s\\) 和状态 \\(j\\) 满足 \\(j \\in S_r \\bigcap S_s\\) 。由 \\(S_r\\) 的定义知存在 \\(n,m\\) 使得 \\(p_{ij}^{\\left(nd+r\\right)}\u003e0,p_{ij}^{\\left(md+s\\right)}\u003e0\\) 。又因为 \\(i \\leftrightarrow j\\) ，故存在 \\(h\\) 使得 \\(p_{ji}^{\\left(h\\right)}\u003e0\\) ，于是由结论1可得：\n\\[ p_{ii}^{\\left(nd+r+h\\right)} \\ge p_{ij}^{\\left(nd+r\\right)}p_{ji}^{\\left(h\\right)}\u003e0\\\\[5pt] p_{ii}^{\\left(md+s+h\\right)} \\ge p_{ij}^{\\left(md+s\\right)}p_{ji}^{\\left(h\\right)}\u003e0 \\tag{29} \\] 由定义9的定义可知 \\(nd+r+h\\) 和 \\(md+s+h\\) 都可以被 \\(d\\) 整除。省去前面的 \\(n\\) 和 \\(m\\) 可得 \\(r+h\\) 和 \\(s+h\\) 都可被 \\(d\\) 整除。从而其差 \\(\\left(r+h\\right)-\\left(s+h\\right)=r-s\\) 都能被 \\(d\\) 整除（见整除的基本性质）。但是 \\(0 \\le r \\le d-1,0 \\le s \\le d-1\\) ，故 \\(0 \\le r-s \\le d-1\\) ，因此 \\(r-s\\) 只能为 \\(0\\) ，也就是 \\(r=s\\) 。故 \\(S_r=S_s\\) ，假设不成立，故 \\(S_r\\) 不相交。\n接下来证明自 \\(S_r\\) 任意状态出发，经 \\(1\\) 步转移必进入 \\(S_{r+1}\\) 中（其中 \\(S_d=S_0\\) ）。等价于证明对任意 \\(j \\in S_r\\) ，有 \\(\\displaystyle\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}}=1\\) 。事实上，由 式(28)可知 \\(p_{ij}^{\\left(nd+r\\right)}\u003e0\\) ，同样可知对 \\(k \\notin S_{r+1}\\) 必有 \\(p_{ik}^{\\left(nd+r+1\\right)}=0\\) 。因此由结论1可推导：\n\\[ 0=p_{ik}^{\\left(nd+r+1\\right)} \\ge p_{ij}^{\\left(nd+r\\right)}p_{jk}^{\\left(1\\right)}\u003e0 \\tag{30} \\] 从而 \\(p_{jk}^{\\left(1\\right)}=0\\) 。于是\n\\[ 1\\:=\\sum_{k \\in S}{p_{jk}}=\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}} + \\sum_{k \\notin S_{r+1}}{p_{jk}^{\\left(1\\right)}}=\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}} \\tag{31} \\] 最后证明分解的唯一性。等价于与证明 \\(\\set{S_k}\\) 与初始的 \\(i\\) 无关。也就是，对于任意的 \\(i,i^\\prime\\) 生成的分解 \\(\\set{S_k},\\set{S_k^\\prime}\\) 必相等。\n首先，证明对于 \\(\\set{S_k}\\) 中的任意 \\({S_r}\\) ，存在 \\({S_s^\\prime}\\) 与其状态完全相等。首先证对所有 \\(j \\in S_r\\) ， \\(j\\) 都只能属于 \\(\\set{S_k^\\prime}\\) 中某个固定的集合。假设 \\(i^{\\prime}\\) 满足 \\(i^\\prime \\in S_s\\) 。由于自 \\(S_k\\) 任意状态出发经 \\(1\\) 步转移必进入 \\(S_{k+1}\\) 中，所以当 \\(s \\le r\\) 时，从 \\(i^{\\prime}\\) 到达 \\(j\\) 只可能通过如下过程之一：\n\\[ \\begin{cases} S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\\\ S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\rightarrow S_{r+1} \\rightarrow \\cdots \\rightarrow S_{d-1} \\rightarrow S_0 \\rightarrow S_1 \\rightarrow \\cdots \\rightarrow S_r\\\\ S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\rightarrow \\overbrace{S_{r+1} \\rightarrow \\cdots \\rightarrow S_{d-1} \\rightarrow S_0 \\rightarrow S_1 \\rightarrow \\cdots \\rightarrow S_r}^{重复2次}\\\\ \\quad \\vdots \\end{cases} \\tag{32} \\] 也就是从 \\(i^{\\prime}\\) 出发只能在 \\(r-s,r-s+d,r-s+2d,\\dots\\) 步上到达 \\(j\\) 。我们发现这刚好与 \\(S_{r-s}^{\\prime}\\) 的定义是一致的。因此 \\(j \\in S_{r-s}^{\\prime}\\) 。反过来讨论任意 \\(j^\\prime \\in S_{r-s}^{\\prime}\\) 。从 \\(i\\) 转移到 \\(i^\\prime\\) 需要 \\(s\\) 步，而从 \\(i^\\prime\\) 转移到 \\(j^\\prime\\) 需要 \\(r-s\\) 步，因此从 \\(i\\) 转移到 \\(j^\\prime\\) 需要 \\(r\\) 步，故 \\(j^\\prime \\in S_r\\) 。故 \\(S_r\\) 与 \\(S_{r-s}^\\prime\\) 完全对等。\n另外当 \\(s \u003e r\\) 时，由类似的方法可以证明从 \\(i^{\\prime}\\) 出发，只能在 \\(d-\\left(s-r\\right),2d-\\left(s-r\\right),\\dots\\) 步到达 \\(j\\) ，因此 \\(j \\in S_{d-\\left(s-r\\right)}^{\\prime}\\) 。类似的也可证明 \\(S_r\\) 与 \\(S_{d-\\left(s-r\\right)}^{\\prime}\\) 完全对等。综上，有\n\\[ \\begin{cases} S_r与S_{r-s}^{\\prime}完全对等，若r \\ge s \\\\[5pt] S_r与S_{d-\\left(s-r\\right)}^{\\prime}完全对等，若r \u003c s \\end{cases} \\tag{33} \\] 易证此时 \\(\\set{S_k},\\set{S_k^\\prime}\\) 一一对应。故分解是唯一的。\n极限定理与不变分布 极限定理及其衍生定理 极限定理 定理8（极限定理）：若状态 \\(j\\) 是周期为 \\(d\\) 的常返状态，则\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{jj}^{\\left(nd\\right)}=\\frac{d}{\\mu_j} \\tag{34} \\] 证明（定理8）‌：对 \\(n \\ge 0\\) ，令：\n\\[ r_n=\\sum_{v=n+1}^{\\infin}{f_v} \\tag{35} \\] 其中 \\(f_v=f_{jj}^{\\left(v\\right)}\\) 。于是\n\\[ \\begin{aligned} \\sum_{n=0}^{\\infin}{r_n}=\u0026\\sum_{n=0}^{\\infin}\\sum_{v=n+1}^{\\infin}{f_v}\\\\ =\u0026\\left(f_1+f_2+f_3+\\cdots\\right)+\\left(f_2+f_3+\\cdots\\right)+\\left(f_3+\\cdots\\right)+\\cdots\\\\[5pt] =\u00261\\cdot f_1 + 2 \\cdot f_2 + 3 \\cdot f_3 + \\cdots\\\\ =\u0026\\sum_{n=1}^{\\infin}{nf_n}=\\mu_j \\end{aligned} \\tag{36} \\] 由 \\(r_n\\) 定义可知 \\(f_n=r_{v-1}-r_v\\) ，代入引理1并记 \\(p_v=p_{jj}^{\\left(v\\right)}\\) 可得\n\\[ p_n=p_{jj}^{\\left(n\\right)}=\\sum_{l=1}^{n}{f_{jj}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}=-\\sum_{v=1}^{n}{\\left(r_v-r_{v-1}\\right)p_{n-v}} \\tag{37} \\] 注意 \\(j\\) 是常返状态，故 \\(r_0=1\\) 。则上式可以写成\n\\[ \\sum_{v=0}^{n}{r_vp_{n-v}}=\\sum_{v=0}^{n-1}r_vp_{n-1-v} \\tag{38} \\] 上面这个式子表示了一个很明显的结论： \\(\\displaystyle\\sum_{v=0}^{n}{r_vp_{n-v}}\\) 的值与 \\(n\\) 无关。因此：\n\\[ \\sum_{v=0}^{n}{r_vp_{n-v}}=r_0p_0=1,\\quad n \\ge 0 \\tag{39} \\] 设\n\\[ \\lambda=\\limsup\\limits_{n \\rightarrow \\infin}p_{nd} \\tag{40} \\] 根据上极限的定义可知，必然存在 \\(\\set{n}\\) 的子列 \\(\\set{n_m},n_m \\rightarrow \\infin\\) 使得\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}{p_{n_md}}=\\limsup\\limits_{m \\rightarrow \\infin}{p_{n_md}}=\\liminf\\limits_{m \\rightarrow \\infin}{p_{n_md}} \\tag{41} \\] 任取 \\(s\\) 使得 \\(f_s\u003e0\\) ，由引理1和下极限的性质可得\n\\[ \\begin{aligned} \\lambda=\u0026\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md}=\\liminf\\limits_{m \\rightarrow \\infin}p_{jj}^{\\left(n_md\\right)}=\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1}^{n_md}f_{jj}^{\\left(v\\right)}p_{jj}^{\\left(n_md-v\\right)}\\\\ =\u0026\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1}^{n_md}f_{v}p_{n_md-v}=\\liminf\\limits_{m \\rightarrow \\infin}\\left(f_sp_{n_md-s}+\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\right)\\\\ \\le\u0026\\liminf\\limits_{m \\rightarrow \\infin}f_sp_{n_md-s}+\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}\\left(a_n+b_n\\right)\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n+\\liminf\\limits_{n \\rightarrow \\infin}b_n\\text{）} \\end{aligned} \\tag{42} \\] 由概率的非负性和上下极限的性质和可推导出\n\\[ \\begin{aligned} \\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\le\u0026\\sum_{v=1,v \\ne s}^{n_md}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}\\left(a_n+b_n\\right)\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n+\\liminf\\limits_{n \\rightarrow \\infin}b_n\\text{）}\\\\ \\le\u0026\\sum_{v=1,v \\ne s}^{\\infin}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}p_{n_md-v}\\quad\\text{（概率的非负性）}\\\\ \\le\u0026\\sum_{v=1,v \\ne s}^{\\infin}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}a_nb_n\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n\\limsup\\limits_{n \\rightarrow \\infin}b_n\\text{）}\\\\ =\u0026\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\\\ \\end{aligned} \\tag{43} \\] 注意当 \\(v\\) 不是 \\(d\\) 的倍数时 \\(p_{n_md-v}=0\\) ，此时 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v} \\le \\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}\\) ；若 \\(v\\) 是 \\(d\\) 的倍数，由上极限的性质可知仍有 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v} \\le \\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}\\) 。故接上式\n\\[ \\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}=\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\le\\left(\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\right)\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md} \\tag{44} \\] 注意状态 \\(j\\) 是定义11的，所以 \\(\\displaystyle\\sum_{v=1}^{\\infin}f_{v}=1\\) ，也就是 \\(\\displaystyle\\sum_{v=1,v \\ne s}^{\\infin}f_{v}=1-f_s\\) 。而将式(41)代入式(44)后再将式(44)代回式(42)得\n\\[ \\lambda\\le f_s\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}+\\left(1-f_s\\right)\\lambda \\tag{45} \\] 即\n\\[ \\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\lambda \\tag{46} \\] 由定义9的定义和 \\(f_s\u003e0\\) 知 \\(d\\) 必整除 \\(s\\) 。因此 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}=\\lambda\\) 。但是由上下极限的定义可知 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\) ，即 \\(\\lambda=\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\lambda\\) 。故由夹挤准则可知 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lambda\\) 。又由式(41)可得：\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-2s}=\\cdots \\tag{47} \\] 任取 \\(l\\) 个正整数 \\(c_i\\) 和满足 \\(f_{d_i}\u003e0\\) 的 \\(l\\) 个正整数 \\(d_i,i=1,2,\\cdots,l\\) 。由式(47)可知有\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_md-c_id_i}=\\lambda \\tag{48} \\] 注意由定义9的定义， \\(d\\) 一定可以整除 \\(d_i\\) 。假设 \\(d_i=k_id\\) ， \\(k_i\\) 为正整数，则上式又可以写为\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{\\left(n_m-c_ik_i\\right)d}=\\lambda \\tag{49} \\] 可以定义一个正整数 \\(n_m^\\prime=n_m-c_ik_i\\) 。则上式可以写成\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d}=\\lambda \\tag{50} \\] 我们发现上式和式(41)形式完全一样，因此再次重复从式(41)到式(48)的推导又可以得到\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-s^\\prime}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-2s^\\prime}=\\cdots \\tag{51} \\] 也就是\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-c_{i^\\prime}d_{i^\\prime}}=\\lambda \\tag{52} \\] 因此，不同的 \\(c_id_i\\) 可以叠加而不影响结论。故对 \\(u=\\displaystyle\\sum_{i=1}^{l}c_id_i\\) 也满足\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_md-u}=\\lambda \\tag{53} \\] 由定义9的定义知，存在满足 \\(f_{d_i}\u003e0\\) 的 \\(d_i,i=1,2,\\cdots,l\\) 使得 \\(d_1,d_2,\\cdots,d_l\\) 的最大公因子也是 \\(d\\) 。于是，当 \\(k\\) 大于某个正整数 \\(k_0\\) 时，必有正整数 \\(c_i\\) ，使得\n\\[ kd=\\sum_{i=1}^{l}c_id_i \\tag{54} \\] 上述结论见Frobenius问题（实际上 \\(k_0\\) 就是数论中著名的Frobenius数，该数在 \\(l\\ge3\\) 时无一般表示式，但是可以证明 \\(k_0\\le \\displaystyle\\sum_{i=2}^{l}\\frac{d_i\\cdot gcd\\left(d_1,d_2,\\dots,d_{i-1}\\right)}{d \\cdot gcd\\left(d_1,d_2,\\dots,d_i\\right)} - \\displaystyle\\sum_{i=1}^{l}\\frac{d_i}{d}\\) ）。于是，对每一个 \\(k\\ge k_0\\) 有\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{\\left(n_m-k\\right)d}=\\lambda \\tag{55} \\] 在式(39)中令 \\(n=\\left(n_m-k_0\\right)d\\) ， 并注意到 \\(v\\) 不是 \\(d\\) 的整数倍时 \\(p_v=0\\) ，故可把 \\(v\\) 替换为 \\(vd\\) ，则得\n\\[ \\sum_{v=0}^{n_m-k_0}r_{vd}p_{\\left(n_m-k_0-v\\right)d}=1 \\tag{56} \\] 令 \\(m \\rightarrow \\infin\\) 可得\n\\[ \\lambda=\\frac{1}{\\displaystyle\\sum_{v=0}^{\\infin}r_{vd}} \\tag{57} \\] 因为当 \\(v\\) 不是 \\(d\\) 的整数倍时， \\(f_v=0\\) ，由式(35)可得\n\\[ r_{vd} = r_{vd+1} = \\cdots = r_{vd+d-1} = \\frac{1}{d}\\sum_{j=vd}^{vd+d-1}r_j \\tag{58} \\] 从而由式(36)得\n\\[ \\sum_{v=0}^{\\infin}r_{vd}=\\frac{1}{d}\\sum_{v=0}^{\\infin}\\sum_{j=vd}^{vd+d-1}r_j=\\frac{1}{d}\\sum_{v=0}^{\\infin}r_v=\\frac{\\mu_j}{d} \\tag{59} \\] 代入式(57)可得\n\\[ \\lambda = \\frac{d}{\\mu_j} \\tag{60} \\] 把式(40)换成 \\(\\lambda=\\liminf\\limits_{n \\rightarrow \\infin}p_{nd}\\) ，下面的推导过程完全相同，仍可以得到 \\(\\lambda = \\displaystyle\\frac{d}{\\mu_j}\\) 。因此，由极限的性质可知\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{nd}=\\frac{d}{\\mu_j} \\tag{61} \\] 由此，定理8证毕。\n推论1：设 \\(i\\) 为常返状态，则\n\\[ i\\text{为零常返状态}\\iff\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0 \\tag{62} \\] 证明（推论1）‌：若 \\(i\\) 为零常返状态，则 \\(\\mu_i \\rightarrow \\infin\\) ，从而由定理8知 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(nd\\right)}=0\\) 。而当 \\(m\\) 不等于 \\(d\\) 的整数倍时， \\(p_{ii}^{\\left(m\\right)}=0\\) ，故 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 。反之，若 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) ，假如 \\(i\\) 为正常返状态，则由定理8知 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(nd\\right)}\u003e0\\) ，由极限的性质知这与 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 矛盾，因此 \\(i\\) 为零常返状态。\n再论非常返与零常返 定理9：若 \\(j\\) 为非常返状态或零常返状态，则对 \\(\\forall i \\in S\\)\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{ij}^{\\left(n\\right)}=0 \\tag{63} \\] 证明（定理9）‌：由引理1得\n\\[ p_{ij}^{\\left(n\\right)}=\\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)} \\tag{64} \\] 对 \\( N \u003c n \\) ，由概率小于 \\(1\\) 可知 \\(f_{ij}^{\\left(l\\right)}\u003c1\\) ，因此上式可写成\n\\[ \\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}\\le \\sum_{l=1}^{N}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}+\\sum_{l=N+1}^{n}f_{ij}^{\\left(l\\right)} \\tag{65} \\] 先固定 \\(N\\) ，令 \\(n \\rightarrow \\infin\\) 。由定理8知 \\(p_{jj}^{\\left(n\\right)} \\rightarrow 0\\) ，故上式右端第一项为 \\(0\\) 。再令 \\(N \\rightarrow \\infin\\) ，上式右端第二项因 \\(\\displaystyle\\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}\u003c1\\) 而趋于 \\(0\\) ，故\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{ij}^{\\left(n\\right)}=0 \\tag{66} \\] 定理得证。\n推论2：有限状态的Markov链，不可能全为非常返状态，也不可能有零常返状态，从而不可约的有限Markov链是正常返的。\n证明（推论2）‌：设状态空间 \\(S=\\set{1,2,\\cdots,N}\\) ，若全部 \\(N\\) 个状态都是非常返，则任取其中两个状态 \\(i,j\\) ，若 \\(i \\rightarrow j \\) ，有 \\(p_{ij}^{\\left(n\\right)}\\rightarrow 0\\) （定理9）；若 \\(i \\nrightarrow j\\) ，则对 \\(\\forall n\\) ， \\(p_{ij}^{\\left(n\\right)}=0\\) 。不管是哪种情况， \\(\\displaystyle\\sum_{j=0}^{N}p_{ij}^{\\left(n\\right)}\\to 0\\) ，但是 \\(\\displaystyle\\sum_{j=0}^{N}p_{ij}^{\\left(n\\right)}=1\\) （与式(4)类似），矛盾。因此有限状态的Markov链，不可能全为非常返状态。\n若 \\(S\\) 中有零常返状态，设为 \\(i\\) ，令 \\(C=\\set{j | i \\rightarrow j}\\) ，则有 \\(\\displaystyle\\sum_{j \\in C}p_{ij}^{\\left(n\\right)}=1\\) 且 \\(j \\rightarrow i\\) （ \\(j \\nrightarrow i\\) 与 \\(i\\) 的常返性相矛盾，类似引理2的证明）。故 \\(i \\leftrightarrow j\\) ，从而 \\(j\\) 也为零常返状态（定理5）。则 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=0\\) （定理9），从而 \\(\\displaystyle\\sum_{j \\in C}^{}p_{ij}^{\\left(n\\right)}\\to 0\\) 。但是由 \\(j\\) 的定义知 \\(\\displaystyle\\sum_{j \\in C}^{}p_{ij}^{\\left(n\\right)}=1\\) ，矛盾。因此有限状态的Markov链不可能有零常返状态。\n推论3：若Markov链有一个零常返状态，则必有无限个零常返状态。\n证明（推论3）‌：假设Markov链有一个零常返状态。由定理6可知这个零常返状态必然存在于某个不可约类中，又有定理5可知这个类必然全都是零常返状态。由推论2可知该不可约类不可能是有限状态的。因此，该Markov链必然有无限个零常返状态。\n再论正常返 定理10：若 \\(j\\) 为正常返状态且周期为 \\(d\\) ，则对 \\(\\forall i\\) 及 \\(0 \\le r \\le d-1\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd+r\\right)}=f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j} \\tag{67} \\] 其中 \\(f_{ij}\\left(r\\right)\\) 为：\n\\[ f_{ij}\\left(r\\right)=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md+r\\right)},\\quad 0 \\le r \\le d-1 \\tag{68} \\] 证明（定理10）‌：当 \\(n \\ne kd\\) 时， \\(p_{jj}^{\\left(n\\right)}=0\\) 。因此由引理1可得\n\\[ \\begin{aligned} p_{ij}^{\\left(nd+r\\right)}=\u0026\\sum_{k=0}^{\\left(nd+r\\right)}f_{ij}^{\\left(k\\right)}p_{jj}^{\\left(nd+r-k\\right)}\\quad\\text{（引理1）}\\\\ =\u0026\\sum_{m=0}^{n}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}\\text{（}换元k=md+r，其余的k的项值都为0\\text{）} \\end{aligned} \\tag{69} \\] 于是由 \\(0 \\le p_{jj}^{\\left(n-m\\right)d} \\le 1\\) （概率的性质），对 \\(1 \\le N \u003c n\\) 有\n\\[ \\sum_{m=0}^{N}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}\\le p_{ij}^{\\left(nd+r\\right)}\\le \\sum_{m=0}^{N}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}+\\sum_{N+1}^{n}f_{ij}^{\\left(md+r\\right)} \\tag{70} \\] 类似于定理9的推导，先令 \\(n \\to \\infin\\) ，再令 \\(N \\to \\infin\\) ，由定理8得\n\\[ f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j}\\le p_{ij}^{\\left(nd+r\\right)} \\le f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j} \\tag{71} \\] 由夹挤准则可得定理10得证。\n推论4：设有不可约的、正常返的、周期为 \\(d\\) 的Markov链（即每个状态都是正常返的），其状态空间为 \\(S\\) ，则对任何状态 \\(i \\leftrightarrow j\\left(i,j \\in S\\right)\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd\\right)}= \\begin{cases} \\space\\displaystyle\\frac{d}{\\mu_j}\\quad\u0026若\\space i \\space 与\\space j \\space 同属于子集\\space S\\\\[10pt] \\space 0\\quad\u0026其他 \\end{cases} \\tag{72} \\] 其中 \\(S=\\displaystyle\\bigcup_{i=0}^{d-1}S_s\\) 即为定理7所给出的 \\(S_s\\) 。特别的，当 \\(d=1\\) 时， \\(\\forall i,j \\in S\\) 有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\frac{1}{\\mu_j} \\tag{73} \\] 证明（推论4）‌：在定理10中取 \\(r=0\\) 得\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd\\right)}=f_{ij}\\left(0\\right)\\space\\frac{d}{\\mu_j} \\tag{74} \\] 其中 \\(f_{ij}\\left(0\\right)=\\displaystyle\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md\\right)}\\) 。若 \\(i\\) 与 \\(j\\) 不在同一个 \\(S_s\\) 中，则由定理7可知所有的 \\(f_{ij}^{\\left(md\\right)}=0\\) 。若 \\(i,j\\) 在同一个 \\(S_s\\) 中，注意当 \\(n\\) 不为 \\(d\\) 的倍数的时候 \\(p_{ij}^{\\left(n\\right)}=0\\) ，因此 \\(f_{ij}^{\\left(n\\right)}=0\\) （见定义11）。此时有\n\\[ f_{ij}\\left(0\\right)=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md\\right)}=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(m\\right)}=f_{ij}=1 \\tag{75} \\] 综上，推论4得证。\nn步转移概率的期望 定理11：对于任意状态 \\(i,j \\in S\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}= \\begin{cases} \\space 0 \\quad j\\space 为非常返状态或零常返状态\\\\[10pt] \\space \\displaystyle\\frac{f_{ij}}{\\mu_{j}} \\quad j \\space 为正常返状态 \\end{cases} \\tag{76} \\] 为了证明定理11，我们需要先证明引理3。\n引理3：设有非负数列 \\(\\set{a_n}\\) 的 \\(d\\) 个子列 \\(\\set{a_{kd+s}}\\left(s=0,1,2,\\cdots,d-1\\right)\\) ，如果对每一个 \\(d\\) ，存在极限 \\(\\lim\\limits_{k \\to \\infin}a_{kd+s}=b_s\\) ，则有：\n\\[ \\lim_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}a_k=\\frac{1}{d}\\sum_{s=0}^{d-1}b_s \\tag{77} \\] 证明（引理3）‌：设 \\(n=md+r\\left(0 \\le r \u003c d-1\\right)\\) ，数列的前 \\(n\\) 项和 \\(\\displaystyle\\sum_{k=1}^{n}a_k\\) 可以写为：\n\\[ \\sum_{k=1}^{n}a_k=\\sum_{t=1}^{d-1}a_{t}+\\sum_{s=0}^{d-1}\\sum_{k=1}^{m-1}a_{kd+s}+\\sum_{t=0}^{r}a_{md+t} \\tag{78} \\] 等式两端除以 \\(m\\) 并令 \\(m \\to \\infin\\) 。右端第一项和第三项都为有限值，因此极限为 \\(0\\) 。讨论右端第二项，由Stolz定理可推导得：\n\\[ \\lim\\limits_{m \\to \\infin}\\frac{\\displaystyle\\sum_{k=1}^{m-1}a_{kd+s}}{m}=\\lim\\limits_{m \\to \\infin}\\frac{\\displaystyle\\sum_{k=1}^{m-1}a_{kd+s}-\\displaystyle\\sum_{k=1}^{m-2}a_{kd+s}}{m-\\left(m-1\\right)}=\\lim\\limits_{m \\to \\infin}a_{\\left(m-1\\right)d+s}=b_s \\tag{79} \\] 因此\n\\[ \\lim\\limits_{m \\to \\infin}\\frac{1}{m}\\sum_{k=1}^{n}a_k=\\sum_{s=0}^{d-1}b_s \\tag{80} \\] 最后再令 \\(n \\to \\infin\\) ，得\n\\[ \\lim_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}a_k=\\lim_{m \\to \\infin}\\frac{m}{md+r}\\cdot\\lim_{m \\to \\infin}\\frac{1}{m}\\sum_{k=1}^{n}a_k=\\frac{1}{d}\\sum_{s=0}^{d-1}b_s \\tag{81} \\] 现在，我们可以证明定理11。\n证明（定理11）‌：若 \\(j\\) 为非常返状态或零常返状态，由定理9可知 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=0\\) 。因此 \\(\\lim\\limits_{n \\to \\infin}\\displaystyle\\frac{1}{n}\\displaystyle\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=0\\) 。若 \\(j\\) 为正常返状态且有周期 \\(d\\) ，则令引理3中的 \\(a_{kd+s}=p_{ij}^{\\left(kd+s\\right)}\\) ，然后利用定理10得到 \\(b_s=f_{ij}\\left(s\\right)\\displaystyle\\space\\frac{d}{\\mu_j}\\) 。从而得\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=\\frac{1}{d}\\sum_{s=0}^{d-1}f_{ij}\\left(s\\right)\\space\\frac{d}{\\mu_j}=\\frac{1}{\\mu_j}\\sum_{s=0}^{d-1}f_{ij}\\left(s\\right)=f_{ij} \\tag{82} \\] 推论5：如果 \\(\\set{X_n}\\) 是不可约的、常返的Markov链（即每个状态都是常返的），则对任意状态 \\(i,j \\in S\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=\\frac{1}{\\mu_j} \\tag{83} \\] 证明（推论5）‌：由引理2可知 \\(f_{ij}=1\\) ，又由推论2可知 \\(i,j\\) 都是正常返的。因此直接代入定理11可证得该推论。\n不变分布与极限分布 不变分布 定义13（不变分布）：对于Markov链，概率分布 \\(\\set{\\pi_j,j \\in S}\\) 称为不变的，若\n\\[ \\pi_j=\\sum_{i \\in S}\\pi_ip_{ij} \\tag{84} \\] 可见，若Markov链的初始分布 \\(P\\set{X_0=j}=p_j\\) 是不变分布，则 \\(X_1\\) 的分布将是\n\\[ \\begin{aligned} P\\set{X_1=j}=\u0026\\sum_{i \\in S}P\\set{X_1=j|X_0=i}P\\set{X_0=i}\\\\ =\u0026\\sum_{i \\in S}p_{ij}p_i=p_j \\end{aligned} \\tag{85} \\] 这与 \\(X_0\\) 的分布是相同的。依此类推， \\(X_n\\left(n=0,1,2,\\cdots\\right)\\) 将有相同的分布，这也是称 \\(\\set{p_i\\left(i \\in S\\right)}\\) 为不变分布的原因。\n极限分布 定义14（极限分布）：称Markov链是遍历的，如果所有状态相通且均是周期为 \\(1\\) 的正常返状态，对遍历的Markov链，极限\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\pi_j\\quad j \\in S \\tag{86} \\] 称为Markov链的极限分布。由推论4知 \\(\\pi_j\\) 存在且 \\(\\pi_j=\\displaystyle\\frac{1}{\\mu_j}\\) 。\n定理12：对于不可约非周期的Markov链：\n(1) 若它是遍历的，则 \\(\\pi_j=\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}\u003e0\\) 是不变分布且是唯一的不变分布（遍历定理）。\n(2) 若状态都是瞬过的或全为零常返的，则不变分布不存在。\n证明（定理12）‌：(1)对遍历的Markov链，由推论4可知 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}\\) 存在，记为 \\(\\pi_j\\) 。首先证 \\(\\set{\\pi_j,j \\in S}\\) 是不变分布。由Fatou引理和C-K方程可得（因为级数是Riemann-Stieljes积分的特例， 也可以看成关于点测度的Lebesgue积分， 所以Fatou引理和下文出现的Lebesgue控制收敛定理仍成立）。\n\\[ \\pi_j=\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n+1\\right)}=\\lim\\limits_{n \\to \\infin}\\sum_{k \\in S}p_{ik}^{\\left(n\\right)}p_{kj}\\ge\\sum_{k \\in S}\\lim\\limits_{n \\to \\infin}p_{ik}^{\\left(n\\right)}p_{kj}=\\sum_{k \\in S}\\pi_kp_{kj} \\tag{87} \\] 两边对 \\(j\\) 求和，由概率归一性有\n\\[ \\sum_{j \\in S}\\pi_j\\ge\\sum_{j \\in S}\\sum_{k \\in S}\\pi_kp_{kj}=\\sum_{k \\in S}\\pi_k\\left(\\sum_{j \\in S}p_{kj}\\right)=\\sum_{k \\in S}\\pi_k \\tag{88} \\] 因此，上式的大于等于号必须取等，否则将产生矛盾。因此：\n\\[ \\pi_j=\\sum_{k \\in S}\\pi_kp_{kj} \\tag{89} \\] 从而 \\(\\set{\\pi_j,j \\in S}\\) 是不变分布。再来证 \\(\\set{\\pi_j,j \\in S}\\) 是唯一的不变分布。由上式和C-K方程可得\n\\[ \\pi_j=\\sum_{k \\in S}\\pi_kp_{kj}=\\sum_{k \\in S}\\sum_{l \\in S}\\pi_lp_{lk}p_{kj}=\\sum_{l \\in S}\\pi_lp_{lj}^{\\left(2\\right)}=\\cdots=\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)} \\tag{90} \\] 对 \\(\\displaystyle\\sum_{j \\in S}p_{ij}^{\\left(n\\right)}=1\\) 两边取 \\(n \\to \\infin\\) 并由Fatou引理可得\n\\[ 1=\\lim\\limits_{n \\to \\infin}\\sum_{j \\in S}p_{ij}^{\\left(n\\right)}\\ge\\sum_{j \\in S}\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\sum_{j \\in S}\\pi_j \\tag{91} \\] 因此 \\(\\displaystyle\\sum_{j \\in S}\\pi_j\\le 1\\) 有限。将式(90)左右两边取 \\(n \\to \\infin\\) 并由Lebesgue控制收敛定理可得\n\\[ \\pi_j=\\lim\\limits_{n \\to \\infin}\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)}=\\sum_{k \\in S}\\lim\\limits_{n \\to \\infin}\\pi_kp_{kj}^{\\left(n\\right)}=\\pi_j\\left(\\sum_{k \\in S}\\pi_k\\right) \\tag{92} \\] 因此 \\(\\displaystyle\\sum_{k \\in S}\\pi_k=1\\) 。假设另外还有一个平衡分布 \\(\\set{\\tilde\\pi_j,j \\in S}\\) ，则有\n\\[ \\tilde\\pi_j=\\pi_j\\left(\\sum_{k \\in S}\\tilde\\pi_k\\right)=\\pi_j \\tag{93} \\] 因此 \\(\\tilde\\pi_j=\\pi_j\\) 。故分布唯一。接下来证(2)。假设存在一个不变分布 \\(\\set{\\pi_j,j \\in S}\\) ，则由(1)中证明可知 \\(\\pi_j=\\displaystyle\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)}\\left(n=1,2,\\dots\\right)\\) 。令 \\(n \\to \\infin\\) ，由定理9可知 \\(p_{kj}^{\\left(n\\right)} \\to 0\\) ，则任意 \\( \\pi_j = 0\\) ，然而这是不可能的。于是对非常返或零常返Markov链不存在不变分布。\n连续时间Markov链 基本定义和性质 连续时间Markov链的定义 定义15（连续时间Markov链）：过程 \\(\\set{X\\left(t\\right),t\\ge0}\\) 的状态空间 \\(S\\) 为离散空间，为方便书写，设 \\(S\\) 为 \\(\\set{0,1,2,\\cdots}\\) 或其子集。若对一切 \\(s,t\\ge0\\) 及 \\(i,j \\in S\\) 有\n\\[ \\begin{aligned} \u0026P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i,X\\left(u\\right)=x\\left(u\\right),0\\le u \u003c s}\\\\[5pt] =\u0026P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i} \\end{aligned} \\tag{94} \\] 成立，则称 \\(\\set{X\\left(t\\right),t \\ge 0}\\) 是一个连续时间Markov链。\n条件概率 \\(P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i}\\) 记作 \\(p_{ij}\\left(s,t\\right)\\) 表示过程在时刻 \\(s\\) 处处于状态 \\(i\\) ，经过 \\(t\\) 时间后转移到 \\(j\\) 的转移概率，并称 \\(\\bm{P}\\left(s,t\\right)=\\left(p_{ij}\\left(s,t\\right)\\right)\\) 为相应的转移概率矩阵。\n时齐连续时间Markov链 定义16（时齐性）：称连续时间Markov链是时齐的，若 \\(p_{ij}\\left(s,t\\right)\\) 与 \\(s\\) 无关。简记 \\(p_{ij}\\left(s,t\\right)=p_{ij}\\left(t\\right)\\) ，相应的记 \\(\\bm{P}\\left(t\\right)=\\left(p_{ij}\\left(t\\right)\\right)\\) 。本篇只讨论时齐的连续时间Markov链，并简称为连续时间Markov链。\n定理13：设 \\(\\set{X\\left(t\\right),t\\ge 0}\\) 是连续时间Markov链，假定在时刻0过程刚刚到达 \\(i\\) ，以 \\(\\tau_i\\) 记过程离开 \\(i\\) 之前在 \\(i\\) 停留的时间，则 \\(\\tau_i\\) 服从指数分布。\n证明（定理13）‌：只需证明 \\(\\tau_i\\) 是无记忆性的，即证明对 \\(s,t \\ge 0\\) 有（见指数分布）\n\\[ P\\set{\\tau_i\u003es+t|\\tau_i\u003es}=P\\set{\\tau_i\u003et} \\tag{95} \\] 将上式写开并由定义15和定义16可得\n\\[ \\begin{aligned} \u0026P\\set{\\tau_i\u003es+t|\\tau_i\u003es}\\\\[5pt] =\u0026P\\set{X\\left(u\\right)=i\\space \\left(0 \u003c u \\le s\\right),X\\left(v\\right)=i\\space \\left(s \u003c v \\le s+t\\right)|X\\left(u\\right)=i\\space \\left(0 \u003c u \\le s\\right)}\\\\[5pt] =\u0026P\\set{X\\left(v\\right)=i\\space \\left(s \u003c v \\le s+t\\right)|X\\left(s\\right)=i}\\quad\\text{（连续时间Markov链的定义）}\\\\[5pt] =\u0026P\\set{X\\left(v\\right)=i\\space \\left(0 \u003c v \\le t\\right)|X\\left(0\\right)=i}\\quad\\text{（时齐性）}\\\\[5pt] =\u0026P\\set{\\tau_i\u003et} \\end{aligned} \\tag{96} \\] 正则连续时间Markov链 定义17（正则性）：称一个连续时间Markov链是正则的，若以概率1在任意有限长的时间内转移的次数是有限的。从而可得连续性条件\n\\[ \\lim\\limits_{t \\to 0}p_{ij}\\left(t\\right)=\\delta_{ij}= \\begin{cases} 1,\\quad i=j\\\\[5pt] 0,\\quad i \\ne j \\end{cases} \\tag{97} \\] 本文讨论的连续时间Markov链都是正则的。\n注：“成立”和“以概率1成立”是有很大区别的。在概率论中，“以概率1成立”意味着某个事件在无限多次试验中几乎肯定会发生，但并不意味着它在每一次试验中都会发生。换句话说，存在极小的可能性（尽管这个可能性可能非常小，接近于0）该事件不会发生。见以概率1收敛。\n转移概率和Kolmogorov微分方程 转移概率的性质 定理14：时齐连续时间Markov链的转移概率 \\(p_{ij}\\left(t\\right)\\) 满足：\n(1) \\(p_{ij}\\left(t\\right)\\ge 0\\)\n(2) \\(\\displaystyle\\sum_{j \\in S}p_{ij}\\left(t\\right)=1\\)\n(3) \\(p_{ij}\\left(t+s\\right)=\\displaystyle\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(s\\right)\\) （连续时间Markov链的C-K方程）\n证明（定理14）‌：(1)和(2)由 \\(p_{ij}\\left(t\\right)\\) 的定义易知。下面证明 (3) 。由定义15和定义16可得\n\\[ \\begin{aligned} p_{ij}\\left(t+s\\right)=\u0026P\\set{X\\left(t+s\\right)=j|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}\\frac{P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(0\\right)=i}}\\\\[5pt] =\u0026\\sum_{k \\in S}\\frac{P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(t\\right)=k,X\\left(0\\right)=i}}\\frac{P\\set{X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(0\\right)=i}}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j|X\\left(t\\right)=k,X\\left(0\\right)=i}P\\set{X\\left(t\\right)=k|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j|X\\left(t\\right)=k}p_{ik}\\left(t\\right)\\quad\\text{（定义15）}\\\\[5pt] =\u0026\\sum_{k \\in S}p_{kj}\\left(s\\right)p_{ik}\\left(t\\right)=\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(s\\right)\\quad\\text{（定义16）} \\end{aligned} \\tag{98} \\] 转移概率具有一致连续性 定理15：对固定的 \\(i,j \\in S=\\set{0,1,2,\\cdots}\\) ， \\(p_{ij}\\left(t\\right)\\) 是 \\(t\\) 的一致连续函数（见一致连续性）。\n证明（定理15）‌：设 \\(h\u003e0\\) ，则\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)=\u0026\\sum_{k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)-p_{ij}\\left(t\\right)\\\\ =\u0026p_{ii}\\left(h\\right)p_{ij}\\left(t\\right)-p_{ij}\\left(t\\right)+\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)\\\\ =\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right)+\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\end{aligned} \\tag{99} \\] 从而得到\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)\\ge\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right)\\\\ \\ge\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)\\\\ \\end{aligned} \\tag{100} \\] 和\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)\\le\u0026\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)\\\\ \\le\u0026\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)=1-p_{ii}\\left(h\\right)\\\\ \\end{aligned} \\tag{101} \\] 因此得到\n\\[ |p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)|\\le 1-p_{ii}\\left(h\\right) \\tag{102} \\] 对 \\(h\u003c0\\) 也可以得到类似的结果。注意由定义17可知 \\(\\displaystyle\\lim\\limits_{h \\to 0}p_{ii}\\left(h\\right)=1\\) 。因此 \\(\\forall \\varepsilon \u003e 0\\) ， \\(\\exist \\delta \u003e 0\\) 满足 \\(h \u003c \\delta\\) 时恒有 \\(1-p_{ii}\\left(h\\right)\u003c\\varepsilon\\) ，即 \\(|p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)|\u003c\\varepsilon\\) 。因此， \\(p_{ij}\\left(t\\right)\\) 一致连续（见一致连续性）。\n转移速率 定理16：\n\\[ \\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=q_{ii}\\le+\\infin \\tag{103} \\] \\[ \\lim\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t}=q_{ij}\u003c+\\infin ,\\quad i \\ne j \\tag{104} \\]\n称 \\(q_{ij}\\) 为从状态 \\(i\\) 转移到状态 \\(j\\) 的转移速率。\n证明（定理16）‌：先证式(103)。首先由定义17可知对任意固定的 \\(t\u003e0\\) ，当 \\(n\\) 充分大时，有 \\(p_{ii}\\left(\\displaystyle\\frac{t}{n}\\right)\u003e0\\) ，再由定理14可得结论 \\(p_{ii}\\left(s+t\\right)=\\displaystyle\\sum_{k \\in S}p_{ik}\\left(s\\right)p_{ki}\\left(t\\right)\\ge p_{ii}\\left(s\\right)p_{ii}\\left(t\\right)\\) ，因此 \\(p_{ii}\\left(t\\right)\\ge \\left(p_{ii}\\left(\\displaystyle\\frac{t}{n}\\right)\\right)^n\u003e0\\) 。故可以定义 \\(\\phi\\left(t\\right)=-\\ln p_{ii}\\left(t\\right)\\) ，它非负有限，且由于 \\(p_{ii}\\left(s+t\\right)\\ge p_{ii}\\left(s\\right)p_{ii}\\left(t\\right)\\) ，有 \\(\\phi\\left(s+t\\right) \\le \\phi\\left(s\\right)+\\phi\\left(t\\right)\\) 。令 \\(q_{ii}=\\displaystyle\\sup\\limits_{t\u003e0}\\frac{\\phi\\left(t\\right)}{t}\\) ，现在要证明 \\(\\displaystyle\\frac{\\phi\\left(t\\right)}{t}\\) 极限存在且为其上确界。显然\n\\[ 0 \\le q_{ii} \\le \\infin,\\quad \\limsup\\limits_{t \\to 0}\\le q_{ii} \\tag{105} \\] 所以以下只需证下极限 \\(\\displaystyle\\liminf\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\ge q_{ii}\\) 。任给 \\(0 \u003c h \u003c t\\) ，取 \\(n\\) 使 \\(t=nh+\\varepsilon,\\space 0 \\le \\varepsilon \u003c h\\) ，得\n\\[ \\frac{\\phi\\left(t\\right)}{t} \\le \\frac{n\\phi\\left(h\\right)}{t}+\\frac{\\phi\\left(\\varepsilon\\right)}{t} = \\frac{nh}{t}\\frac{\\phi\\left(h\\right)}{h}+\\frac{\\phi\\left(\\varepsilon\\right)}{t} \\tag{106} \\] 注意当 \\(h \\to 0^+\\) 时， \\(\\varepsilon \\to 0\\) ， \\(\\displaystyle\\frac{nh}{t} \\to 1\\) ， \\(\\phi\\left(\\varepsilon\\right)=-\\ln p_{ii}\\left(\\varepsilon\\right) \\to 0\\) ，故 \\(\\displaystyle\\frac{\\phi\\left(t\\right)}{t}\\le\\liminf\\limits_{h \\to 0}\\frac{\\phi\\left(h\\right)}{h}\\) 因此 \\(q_{ii}=\\displaystyle\\sup\\limits_{t\u003e0}\\frac{\\phi\\left(t\\right)}{t}\\le\\liminf\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\) 。从而 \\(\\displaystyle q_{ii}=\\lim\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\) 。由 \\(\\phi\\left(t\\right)\\) 定义得\n\\[ \\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=\\lim\\limits_{t \\to 0}\\frac{1-e^{-\\phi\\left(t\\right)}}{\\phi\\left(t\\right)}\\frac{\\phi\\left(t\\right)}{t}=\\lim\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}=q_{ii} \\tag{107} \\] 再证式(104)。由定义17，对任意 \\(\\displaystyle 0 \u003c \\varepsilon \u003c \\frac{1}{3}\\) ，存在 \\(0 \u003c \\delta \u003c 1\\) ，使当 \\(0 \u003c t \\le \\delta \\) 时，有 \\(p_{ii}\\left(t\\right)\u003e1-\\varepsilon\\) ， \\(p_{jj}\\left(t\\right)\u003e1-\\varepsilon\\) ， \\(p_{ji}\\left(t\\right)\u003c\\varepsilon\\) 。\n下面要证：对任意 \\(0 \\le h \u003c t\\) ，只要 \\(t \\le \\delta\\) ，则有\n\\[ p_{ij}\\left(h\\right)\\le\\frac{p_{ij}\\left(t\\right)}{n}\\frac{1}{1-3\\varepsilon} \\tag{108} \\] 其中 \\(\\displaystyle n=\\left\\lfloor \\frac{t}{h} \\right\\rfloor\\) （向下取整）。记\n\\[ \\begin{cases} _jp_{ik}\\left(h\\right)=p_{ik}\\left(h\\right)\\\\[10pt] _jp_{ik}\\left(mh\\right)=\\displaystyle\\sum_{r \\ne j}{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)} \\end{cases} \\tag{109} \\] 其中 \\(_jp_{ik}\\left(mh\\right)\\) 表示从 \\(i\\) 出发，在时刻 \\(h,2h,\\cdots,\\left(m-1\\right)h\\) 未到达 \\(j\\) 而在 \\(mh\\) 时刻到达 \\(k\\) 的概率。反复展开 \\(_jp_{ik}\\left(mh\\right)\\) 并由定理14可得\n\\[ \\begin{aligned} _jp_{ik}\\left(mh\\right)=\u0026\\sum_{r \\ne j}{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)}\\\\ =\u0026\\sum_r{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\sum_r\\sum_{s \\ne j}{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sr}\\left(h\\right)p_{rk}\\left(h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\sum_{s \\ne j}{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\quad\\text{（定理14）}\\\\ =\u0026\\sum_s{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-2\\right)h\\right)p_{jk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\cdots\\\\ =\u0026\\sum_r{_jp_{ir}\\left(h\\right)p_{rk}\\left(\\left(m-1\\right)h\\right)}-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\\\ =\u0026\\sum_r{p_{ir}\\left(h\\right)p_{rk}\\left(\\left(m-1\\right)h\\right)}-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\\\ =\u0026p_{ik}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\quad\\text{（定理14）}\\\\ =\u0026p_{ik}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)\\right)}\\quad（换元l \\to \\left(m-l\\right)） \\end{aligned} \\tag{110} \\] 由定义17可得\n\\[ \\begin{aligned} p_{ik}\\left(mh\\right)=\u0026_jp_{ik}\\left(mh\\right)+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\\\ =\u0026_jp_{ij}\\left(mh\\right)\\delta_{jk}+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\\\ =\u0026_jp_{ij}\\left(mh\\right)p_{jk}\\left(0\\right)+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\quad（定义17）\\\\ =\u0026\\sum_{l=1}^{m}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)} \\end{aligned} \\tag{111} \\] 由上式和定理14可得\n\\[ \\begin{aligned} p_{ij}\\left(t\\right)=\u0026\\sum_k{p_{ik}\\left(nh\\right)p_{kj}\\left(t-nh\\right)}\\\\ =\u0026\\sum_k\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jk}\\left(\\left(n-m\\right)h\\right)}p_{kj}\\left(t-nh\\right)\\\\ =\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)} \\end{aligned} \\tag{112} \\] 当 \\(h \u003c t \\le \\delta\\) 时，由上式可得\n\\[ \\begin{aligned} \\varepsilon \u003e 1-p_{ii}\\left(t\\right)=\u0026\\sum_{k \\ne i}p_{ik}\\left(t\\right)\\\\[10pt] \\ge\u0026p_{ij}\\left(t\\right)\\quad（注意i \\ne j）\\\\[5pt] \\ge\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)}\\\\ \\ge\u0026\\left(1-\\varepsilon\\right)\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)} \\end{aligned} \\tag{113} \\] 即\n\\[ \\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)} \\le \\frac{\\varepsilon}{1-\\varepsilon} \\tag{114} \\] 式(110)取 \\(k=i\\) 可得\n\\[ \\begin{aligned} _jp_{ii}\\left(mh\\right)=\u0026p_{ii}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)p_{ji}\\left(\\left(m-l\\right)h\\right)\\right)}\\\\ \\ge\u0026p_{ii}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)\\right)}\\\\ \\ge\u00261 - \\varepsilon - \\frac{\\varepsilon}{1-\\varepsilon} \\end{aligned} \\tag{115} \\] 因此由式(112)和定理14可得\n\\[ \\begin{aligned} p_{ij}\\left(t\\right)=\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)}\\\\[5pt] \\ge\u0026\\sum_{m=1}^{n}{_jp_{ii}\\left(\\left(m-1\\right)h\\right)p_{ij}\\left(h\\right)p_{jj}\\left(t-mh\\right)}\\\\[5pt] \\ge\u0026n\\left(1 - \\varepsilon - \\frac{\\varepsilon}{1-\\varepsilon}\\right)p_{ij}\\left(h\\right)\\left(1-\\varepsilon\\right)\\\\[10pt] \\ge\u0026n\\left(1-3\\varepsilon\\right)p_{ij}\\left(h\\right) \\end{aligned} \\tag{116} \\] 式(108)得证。两边除以 \\(h\\) 并注意当 \\(h \\to 0\\) 时 \\(nh \\to t\\) ，得\n\\[ \\limsup\\limits_{h \\to 0}\\frac{p_{ij}\\left(h\\right)}{h} \\le \\frac{1}{1+3\\varepsilon}\\frac{p_{ij}\\left(t\\right)}{t} \u003c \\infin \\tag{117} \\] 再令 \\(t \\to 0\\) ，有\n\\[ \\limsup\\limits_{h \\to 0}\\frac{p_{ij}\\left(h\\right)}{h} \\le \\frac{1}{1+3\\varepsilon}\\liminf\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t} \u003c \\infin \\tag{118} \\] 再令 \\(\\varepsilon \\to 0\\) ，定理得证。\n推论6：对有限状态时齐的连续时间的Markov链，有\n\\[ q_{ii}=\\sum_{j \\ne i}q_{ij} \u003c +\\infin \\tag{119} \\] 证明（推论6）‌：由定理14知， \\(\\displaystyle\\sum_{j \\in S}p_{ij}\\left(t\\right)=1\\) ，即\n\\[ 1-p_{ii}\\left(t\\right)=\\sum_{j \\ne i}p_{ij}\\left(t\\right) \\tag{120} \\] 故由定理16\n\\[ \\begin{aligned} \\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=\u0026\\lim\\limits_{t \\to 0}\\sum_{j \\ne i}\\frac{p_{ij}\\left(t\\right)}{t}\\\\ =\u0026\\sum_{j \\ne i}\\lim\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t}\\\\ =\u0026\\sum_{j \\ne i}q_{ij} \u003c +\\infin \\end{aligned} \\tag{121} \\] 保守性 对于无限状态的情况，一般只能得到 \\(q_{ii} \\ge \\displaystyle\\sum_{j \\ne i}q_{ij}\\) （式(121)中积分和求和不可交换，因此只能使用Fatou引理）。设状态空间为 \\(S=\\set{1,2,\\cdots,n,\\cdots}\\) ，此时记\n\\[ \\bm{Q}= \\begin{pmatrix} -q_{11} \u0026 q_{12} \u0026 q_{13} \u0026 \\cdots \u0026 q_{1i} \u0026 \\cdots \\\\[5pt] q_{21} \u0026 -q_{22} \u0026 q_{23} \u0026 \\cdots \u0026 q_{2i} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\cdots \\\\[5pt] q_{i1} \u0026 q_{i2} \u0026 q_{i3} \u0026 \\cdots \u0026 -q_{ii} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\\\[5pt] \\end{pmatrix} \\tag{122} \\] 称为连续时间Markov链的 \\(\\bm{Q}\\) 矩阵。当矩阵元素 \\(q_{ii}=\\sum_{j \\ne i}q_{ij}\u003c+\\infin\\) 时，称该矩阵为保守的。\nKolmogorov微分方程 定理17（Kolmogorov微分方程）：对一切 \\(i,j \\in S，t \\ge 0\\) 且 \\(q_{ii}=\\displaystyle\\sum_{j \\ne i}q_{ij}\u003c+\\infin\\) ，有\n(1) 向后方程 \\[ p_{ij}^\\prime\\left(t\\right)=\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right)-q_{ii}p_{ij}\\left(t\\right) \\tag{123} \\] (2) 向前方程（如果满足 \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{kj}\\left(h\\right)}{h}\\) 有限） \\[ p_{ij}^\\prime\\left(t\\right)=\\sum_{k \\ne j}q_{kj}p_{ik}\\left(t\\right)-q_{jj}p_{ij}\\left(t\\right) \\tag{124} \\]\n证明（定理17）‌：先证明式(123)。由定理14可得\n\\[ p_{ij}\\left(t+h\\right)=\\sum_{k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\tag{125} \\] 或等价地\n\\[ p_{ij}\\left(t+h\\right)-p_{ii}\\left(h\\right)p_{ij}\\left(t\\right)=\\sum_{k \\ne i,k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\tag{126} \\] 变形为\n\\[ p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)=\\sum_{k \\ne i,k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right) \\tag{127} \\] 于是\n\\[ \\lim\\limits_{h \\to 0}\\frac{p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)}{h}=\\lim\\limits_{h \\to 0}\\sum_{k \\ne i,k \\in S}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)-\\lim\\limits_{h \\to 0}\\frac{1-p_{ii}\\left(h\\right)}{h}p_{ij}\\left(t\\right) \\tag{128} \\] 若此时Markov链状态是有限的，应用定理16和推论6从上式直接可以得到式(123)（向后方程）\n下面证明对于无限状态下依然有式(123)成立。由上式，我们只需证明其中的极限与求和可交换次序即可。由Fatou引理可推导出\n\\[ \\begin{aligned} \\liminf\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\ge\u0026\\sum_{k \\ne i}\\liminf\\limits_{h \\to 0}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\\\ =\u0026\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\end{aligned} \\tag{129} \\] 注意 \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\le\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}=\\frac{1-p_{ii}\\left(h\\right)}{h}\\) ，因此可以使用反向Fatou引理\n\\[ \\begin{aligned} \\limsup\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\le\u0026\\sum_{k \\ne i}\\limsup\\limits_{h \\to 0}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\\\ =\u0026\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\end{aligned} \\tag{130} \\] 因此\n\\[ \\lim\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)=\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\tag{131} \\] 因此无限状态下式(123)仍然成立。实际上式(123)可以被写成矩阵形式，也就是 \\(\\bm{P}^\\prime\\left(t\\right)=\\bm{Q}\\bm{P}\\left(t\\right)\\) ，其中 \\(\\bm{P}\\left(t\\right)=\\left(p_{ij}\\left(t\\right)\\right)\\) ， \\(\\bm{Q}=\\left(q_{ij}\\right)\\) 。依定理17条件知 \\(\\bm{Q}\\) 是保守的。\n下面证明式(124)。在式(123)中计算 \\(t+h\\) 的状态时是对退后到时刻 \\(h\\) 的状态来取条件的（所以称为后退方程），这里我们考虑对时刻 \\(t\\) 的状态取条件，用定理14有\n\\[ p_{ij}\\left(t+h\\right)=\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(h\\right) \\tag{132} \\] 同理得到\n\\[ \\lim\\limits_{h \\to 0}\\frac{p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)}{h}=\\lim\\limits_{h \\to 0}\\sum_{k \\ne i,k \\in S}p_{ik}\\left(t\\right)\\frac{p_{kj}\\left(h\\right)}{h}-\\lim\\limits_{h \\to 0}\\frac{1-p_{jj}\\left(h\\right)}{h}p_{ij}\\left(t\\right) \\tag{133} \\] 注意上式的极限和求和不一定是能交换的（ \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{kj}\\left(h\\right)}{h}\\) 不一定有限，因此反向Fatou引理不可用）。如果上式的极限和求和运算可以交换，则可得式(124)成立。\n前进！前进！不择手段的前进！ ― 刘慈欣, 《三体Ⅱ：黑暗森林》 ","date":"2024-09-14T21:05:01+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/science/mathematics/statistics/stochastic_processes/markov_process/","title":"随机过程（四）：Markov过程"}]