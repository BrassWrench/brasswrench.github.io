[{"content":" 关系数据库 关系数据库应用数学方法来处理数据库中的数据。最早将这类方法用于数据处理的是1962年CODASYL发表的“信息代数”，之后有1968年David Child在IBM7090机上实现的集合论数据结构，但系统、严格地提出关系模型的是美国IBM公司的E.F.Codd。\n1970年，E.F.Codd在美国计算机学会会刊《Communications of the ACM》上发表了题为“A Relational Model of Data for Shared Data Banks”的论文，开创了数据库系统的新纪元。ACM1983年把这篇论文列为从1958年以来的四分之一世纪中具有里程碑意义的25篇研究论文之一。此后，E.F.Codd连续发表了多篇论文，奠定了关系数据库的理论基础。\n20世纪70年代末，关系方法的理论研究和软件系统的研制均取得了丰硕的成果，IBM公司的San Jose实验室在IBM 370系列机上研制的关系数据库实验系统System R历时6年获得成功。1981年，IBM公司又宣布了具有System R全部特征的新的数据库软件产品SQL/DS问世。\n与System R同期，美国加州大学伯克利分校也研制了INGRES关系数据库实验系统,并由INGRES公司发展成为INGRES数据库产品。\n40多年来，关系数据库系统的研究和开发取得了辉煌的成就。关系数据库系统从实验室走向了社会，成为最重要、应用最广泛的数据库系统，大大促进了数据库应用领域的扩大和深入。因此，关系数据模型的原理、技术和应用十分重要。\n关系数据结构及形式化定义 关系 关系模型的数据结构非常简单，只包含单一的数据结构\u0026mdash;\u0026mdash;关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。\n关系模型的数据结构虽然简单却能够表达丰富的语义，描述出现实世界的实体以及实体间的各种联系。也就是说，在关系模型中，现实世界的实体以及实体间的各种联系均用单一的结构类型，即关系来表示。\n前面已经非形式化地介绍了关系模型及有关的基本概念。关系模型是建立在集合代数的基础上的，这里从集合论角度给出关系数据结构的形式化定义。\n域（domain） 定义1（域）：域是一组具有相同数据类型的值的集合。例如，自然数、整数、实数、长度小于25字节的字符串集合、 {0,1} 、 {男,女} 、大于等于0且小于等于100的正整数等，都可以是域。\nCartesian乘积（cartesian product） 定义2（Cartesian乘积）：给定一组域 \\(D_1,D_2,\\cdots,D_n\\) ，允许其中某些域是相同的， \\(D_1,D_2,\\cdots,D_n\\)的Cartesian乘积为\n\\[ D_1\\times D_2 \\times \\cdots \\times D_n=\\set{(d_1,d_2,\\cdots,d_n)|d_i\\in D_i,i=1,2,\\cdots,n} \\tag{1} \\] 其中，每一个元素 \\((d_1,d_2,\\cdots,d_n)\\) 叫作一个n元组（tuple），或简称元组（tuple）。元素中的每一个值 \\(d_i\\) 叫做一个分量（component）。\n一个域允许的不同取值个数称为这个域的基数（cardinal number）。若 \\(D_i(i=1,2,\\cdots,n)\\) 为有限集，其计数为 \\(m_i(i=1,2,\\cdots,n)\\) ，则 \\((D_1,D_2,\\cdots,D_n)\\) 的基数 \\(M\\) 为\n\\[ M=\\prod_{i=1}^{n}m_i \\tag{2} \\] Cartesian乘积可表示为一张二维表，表中的每行对应一个元组，表中的每一列来自一个域，例如给出三个域\n\\[ \\begin{aligned} D_1=\u0026\\text{导师集合(SUPERVISOR)}=\\set{张清玫,刘逸}\\\\ D_2=\u0026\\text{专业集合(SPECIALITY)}=\\set{计算机专业,信息专业}\\\\ D_3=\u0026\\text{研究生集合(POSTGRADUATE)}=\\set{李勇,刘晨,王敏} \\end{aligned} \\tag{3} \\] 则 \\(D_1,D_2,D_3\\) 的Cartesian乘积为\n\\[ \\begin{aligned} D1\\times D2\\times D3=｛\u0026\\\\ \u0026(张清玫,计算机专业,李勇),(张清玫,目算机专业,刘晨),\\\\[5pt] \u0026(张清玫,计算机专业,王敏),(张清玫,信息专业,李勇),\\\\[5pt] \u0026(张清玫,信息专业,刘晨),(张清玫,信息专业,王敏), \\\\[5pt] \u0026(刘逸,计算机专业,李勇),(刘逸,计算机专业,刘晨), \\\\[5pt] \u0026(刘逸,计算机专业,王敏),(刘逸,信息专业,李勇),\\\\[5pt] \u0026(刘逸,信息专业,刘晨),(刘逸,信息专业,王敏)｝ \\end{aligned} \\tag{4} \\] 其中，(张清玫,计算机专业,李勇)、(张清玫,计算机专业,刘晨)等都是元组。张清玫、计算机专业、李勇、刘晨等都是分量。该Cartesian乘积的基数为 \\(2\\times 2\\times 3=12\\) ，也就是说， \\(D_1\\times D_2\\times D_3\\) 一共有 \\(2\\times 2 \\times 3 = 12\\) 个元组。这12个元组可列成一张二维表，如表1所示\nSUPERVISOR SPECIALITY POSTGRADUATE 张清攻 计算机专业 李勇 张清攻 计算机专业 刘宸 张清攻 计算机专业 王敏 张清攻 信息专业 李勇 张清攻 信息专业 刘宸 张清攻 信息专业 王敏 刘逸 计算机专业 李勇 刘逸 计算机专业 刘宸 刘逸 计算机专业 王敏 刘逸 信息专业 李勇 刘逸 信息专业 刘宸 刘逸 信息专业 王敏 表1\u0026emsp; \\(D_1,D_2,D_3\\) 的Cartesian乘积\n。\n关系 定义3（关系） \\(D_1\\times D_2 \\times \\cdots\\times D_n\\) 的子集叫做在域 \\(D_1,D_2,\\times,D_n\\) 以上的关系，表示为\n\\[ R(D_1,D_2,\\times,D_n) \\tag{5} \\] 这里 \\(R\\) 表示关系的名字， \\(n\\) 是关系的目或度（degree）。\n关系中的每个元素是关系中的元组，通常用 \\(t\\) 表示。\n当 \\(n=1\\) 时，称该关系为单元关系（unary relation），或一元关系。\n当 \\(n=2\\) 时，称该关系为二元关系（binary relation）。\n关系是Cartesian乘积的有限子集，所以关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域。由于域可以相同，为了加以区分，必须对每列起一个名字，称为属性（attribute）。n目关系必有n个属性。\n若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（candidate key）。若一个关系有多个候选码，则选定其中一个为主码（primary key）。\n候选码的属性称为主属性（prime attribute）。不包含在任何候选码中的属性称为非主属性（non-prime attribute）‌或‌非码属性（non-key attribute）。\n在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为全码（all-key）。\n一般来说， \\(D_1,D_2,\\cdots,D_n\\) 的Cartesian乘积是没有实际语义的，只有它的某个真子集才有实际含义。例如，可以发现表1的Cartesian乘积中许多元组是没有意义的。因为在学校中一个专业方向有多个导师，而一个导师只在一个专业方向带研究生；一个导师可以带多名研究生，而一名研究生只有一个导师，学习某一个专业。因此，表1中的一个子集才是有意义的，才可以表示导师与研究生的关系，把该关系取名为 \\(\\text{SAP}\\) ，如表2所示。李勇和刘晨是计算机专业张清玫老师的研究生；王敏是信息专业刘逸老师的研究生。\n\\(\\text{SUPERVISOR}\\) \\(\\text{SPECIALITY}\\) \\(\\text{POSTGRADUATE}\\) 张清攻 计算机专业 李勇 张清攻 计算机专业 刘宸 刘逸 信息专业 王敏 表2\u0026emsp;SAP关系\n把关系 \\(\\text{SAP}\\) 的属性名取为域名，即 \\(\\text{SUPERVISOR}\\) , \\(\\text{SPECIALITY}\\) , \\(\\text{POSTGRADUATE}\\) 则这个关系可以表示为\n\\[ \\text{SAP}(\\text{SUPERVISOR},\\text{SPECIALITY},\\text{POSTGRADUATE}) \\tag{6} \\] 假设研究生不会重名（这在实际生活中是不合适的，这里只是为了举例方便），则 \\(\\text{POSTGRADUATE}\\) 属性的每一个值都唯一地标识了一个元组，因此可以作为SAP关系的主码。\n关系可以有三种类型：基本关系（通常又称为基本表或基表）、查询表和视图表。其中，基本表是实际存在的表，它是实际存储数据的逻辑表示：查询表是查询结果对应的表；视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。\n按照Cartesian乘积，关系可以是一个无限集合。由于组成Cartesian乘积的域不满足交换律，所以按照数学定义， \\((d_1,d_2,\\cdots,d_n)\\ne(d_2,d_1,\\cdots,d_n)\\) 。当关系作为关系数据模型的数据结构时，需要给予如下的限定和扩充。\n无限关系在数据库系统中是无意义的。因此，限定关系数据模型中的关系必须是有限集合。 通过为关系的每个列附加一个属性名的方法取消关系属性的有序性，即 \\((d_1,d_2,\\cdots,d_i,d_j,\\cdots,d_n)=(d_1,d_2,\\cdots,d_j,d_i,\\cdots,d_n)\\quad(i,j=1,2,\\cdots,n)\\) 因此，基本关系具有以下6条性质。\n列是同质的（homogeneous）,即每一列中的分量是同一类型的数据，来自同一个域。 不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。例如，在上面的例子中，也可以只给出两个域： \\[ \\begin{aligned} \u0026\\text{人(PERSON)}=\\set{张清玫，刘逸，李勇，刘晨，王敏}\\\\[5pt] \u0026\\text{专业(SPECIALITY)}=\\set{计算机专业，信息专业} \\end{aligned} \\tag{7} \\] \\(\\text{SAP}\\) 关系的导师属性和研究生属性都从 \\(\\text{PERSON}\\) 域中取值。为了避免混淆，必须给这两个属性取不同的属性名，而不能直接使用域名。例如，定义导师属性名为 \\(\\text{SUPERVISOR-PERSON}\\) （或 \\(\\text{SUPERVISOR}\\) ）研究生属性名为 \\(\\text{POSTGRADUATE-PERSON}\\) （或 \\(\\text{POSTGRADUATE}\\) ） 列的顺序无所谓，即列的次序可以任意交换。由于列顺序是无关紧要的，因此在许多实际关系数据库产品中增加新属性时，永远是插至最后一列。 任意两个元组的候选码不能取相同的值。 行的顺序无所谓，即行的次序可以任意交换。 分量必须取原子值，即每一个分量都必须是不可分的数据项。 关系模型要求关系必须是规范化（normalization）‌的，即要求关系必须满足一定的规范条件。这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式（NormalForm,NF）。范式的概念将在第6章关系数据理论中做进一步讲解。 例如，表2.3虽然很好地表达了导师与研究生之间的一对多关系，但由于属性 \\(\\text{POSTGRADUATE}\\) 中分量取了两个值，不符合规范化的要求，因此这样的关系在数据库中是不允许的。通俗地讲，关系表中不允许还有表，简言之不允许“表中有表”。直观地描述，表2.3中还有一个小表。\n\\(\\text{SUPERVISOR}\\) \\(\\text{SPECIALITY}\\) \\(\\text{POSTGRADUATE}\\) \\(\\text{PG1}\\) \\(\\text{PG2}\\) 张清攻 计算机专业 李勇 刘晨 刘逸 信息专业 王敏 表3\u0026emsp;非规范关系\n关系模式 在数据库中要区分型和值。关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述，那么一个关系需要描述哪些方面呢？\n关系是元组的集合，因此关系模式必须指出这个元组集合的结构，即它由哪些属性构成，这些属性来自哪些域，以及属性与域之间的映像关系。\n现实世界随着时间在不断地变化，因而在不同的时刻关系模式的关系也会有所变化。但是，现实世界的许多己有事实和规则限定了关系模式所有可能的关系必须满足一定的完整性约束条件。这些约束或者通过对属性取值范围的限定，例如职工年龄小于60岁（60岁以后退休），或者通过属性值间的相互关联反映出来。例如，如果2个元组的主码相等，那么元组的其他值也一定相等，因为主码唯一标识一个元组，主码相等就表示这是同一个元组。关系模式应当刻划出这些完整性约束条件。\n定义4（关系模式）：关系的描述称为关系模式（relation schema）。它可以形式化地表示为\n\\[ R(U,D,\\text{DOM},F) \\tag{8} \\] 其中 \\(R\\) 为关系名， \\(U\\) 为组成该关系的属性名集合， \\(D\\) 为 \\(U\\) 中属性所来自的域， \\(\\text{DOM}\\) 为属性向域的映像集合， \\(F\\) 为属性间数据的依赖关系集合。\n属性间的数据依赖将在后篇讨论，本章中关系模式仅涉及关系名、各属性名、域名、属性向域的映像四部分，即 \\(R(U,D,\\text{DOM})\\) 。\n例如，在上面例子中，由于导师和研究生出自同一个域\u0026mdash;\u0026mdash;人，所以要取不同的属性名，并在模式中定义属性向域的映像，即说明它们分别出自哪个域，如：\n\\[ \\text{DOM(SUPERVISOR)=DOM(POSTGRADUATE)=PERSON} \\tag{9} \\] 关系模式通常可以简记为\n\\[ R(U) \\tag{10} \\] 或\n\\[ R(A_1,A_2,\\cdots,A_n) \\tag{11} \\] 其中 \\(R\\) 为关系名， \\(A_1,A_2,\\cdots,A_n\\) 为属性名。而域名及属性向域的映像常常直接说明为属性的类型、长度。\n关系是关系模式在某一时刻的状态或内容。关系模式是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。例如，学生关系模式在不同的学年，学生关系是不同的。在实际工作中，人们常常把关系模式和关系都笼统地称为关系，这不难从上下文中加以区别，希望读者注意。\n关系数据库 在关系模型中，实体以及实体间的联系都是用关系来表示的。例如导师实体、研究生实体、导师与研究生之间的一对多联系都可以分别用一个关系来表示。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。\n关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。\n关系模型的存储结构 我们已经知道，在关系数据模型中实体及实体间的联系都用表来表示，但表是关系数据的逻辑模型.在关系数据库的物理组织中，有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成；有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。\n关系操作 关系模型给出了关系操作的能力的说明，但不对关系数据库管理系统语言给出具体的语法要求，也就是说不同的关系数据库管理系统可以定义和开发不同的语言来实现这些操作。\n基本的关系操作 关系模型中常用的关系操作包括查询（query）操作和插入（insert）、删除（delete）、修改（update）操作两大部分。关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为选择（select）、投影（project）、连接（join）、除（divide）、并（union）、差（except）、交（intersection）、Cartesian乘积等。其中选择、投影、并、差、Cartesian乘积是5种基本操作，其他操作可以用基本操作来定义和导出，就像乘法可以用加法来定义和导出一样。\n关系数据语言的分类 早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数（relational algebra）‌和关系演算（relational calculus）‌关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。一个关系数据语言能够表示关系代数可以表示的查询，称为具有完备的表达能力，简称关系完备性。已经证明关系代数、元组关系演算和域关系演算三种语言在表达能力上是等价的，都具有完备的表达能力。\n关系代数、元组关系演算和域关系演算均是抽象的查询语言，这些抽象的语言与具体的关系数据库管理系统中实现的实际语言并不完全一样。但它们能用作评估实际系统中查询语言能力的标准或基础。实际的查询语言除了提供关系代数或关系演算的功能外，还提供了许多附加功能，例如聚集函数（aggregation function）。关系赋值、算术运算等，使得目前实际查询语言的功能十分强大。\n另外，还有一种介于关系代数和关系演算之间的结构化查询语言（Structured Query Language,SQL）。SQL不仅具有丰富的查询功能，而且具有数据定义和数据控制功能，是集查询、数据定义语言、数据操纵语言和数据控制语言（Data Control Language,DCL）于一体的关系数据语言。它充分体现了关系数据语言的特点和优点，是关系数据库的标准语言。因此，关系数据语言可以分为三类：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 关系数据语言 关系代数语言（例如ISBL） 关系演算语言 具有关系代数和关系演算双重特性的语言(例如SQL) 元组关系演算语言（例如ALPHA、QUEL） 域关系演算语言（例如QBE） 图1\u0026emsp;关系数据语言\n特别地，SQL语言是一种高度非过程化的语言，用户不必请求数据库管理员为其建立特殊的存取路径，存取路径的选择由关系数据库管理系统的优化机制来完成。例如，在一个存储有几百万条记录的关系中查找符合条件的某一个或某一些记录，从原理上讲可以有多种查找方法。例如，可以顺序扫描这个关系，也可以通过某一种索引来查找。不同的查找路径（或者称为存取路径）的效率是不同的，有的完成某一个查询可能很快，有的可能极慢。关系数据库管理系统中研究和开发了查询优化方法，系统可以自动选择较优的存取路径，提高查询效率。\n关系的完整性 关系模型的完整性规则是对关系的某种约束条件。也就是说关系的值随着时间变化时应该满足一些约束条件。这些约束条件实际上是现实世界的要求。任何关系在任何时刻都要满足这些语义约束。\n关系模型中有三类完整性约束：实体完整性（entity integrity）、参照完整性（referential integrity）和用户定义的完整性（user-defined integrity）。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。\n实体完整性 关系数据库中每个元组应该是可区分的，是唯一的。这样的约束条件用实体完整性来保证。\n实体完整性规则：若属性（指一个或一组属性） \\(A\\) 是基本关系 \\(R\\) 的主属性,则 \\(A\\) 不能取空值（null value）。所谓空值就是\u0026quot;不知道”或\u0026quot;不存在”或“无意义”的值。\n按照实体完整性规则的规定，如果主码由若干属性组成，则所有这些主属性都不能取空值。例如选修（学号，课程号,成绩）关系中，“学号、课程号”为主码，则“学号”和“课程号”两个属性都不能取空值。\n对于实体完整性规则说明如下：\n实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。例如学生关系对应于学生的集合。 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。 相应地，关系模型中以主码作为唯一性标识。 主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与2. 相矛盾，因此这个规则称为实体完整性。 参照完整性 现实世界中的实体之间往往存在某种联系，在关系模型中实体及实体间的联系都是用关系来描述的，这样就自然存在着关系与关系间的引用。先来看三个例子。\n例1：学生实体和专业实体可以用下面的关系来表示，其中主码用下划线标识。\n\\[ \\begin{aligned} \u0026学生(\\underline{学号},姓名,性别,专业号,年龄)\\\\[5pt] \u0026专业(\\underline{专业号},专业名) \\end{aligned} \\tag{12} \\] 这两个关系之间存在着属性的引用，即学生关系引用了专业关系的主码“专业号”显然，学生关系中的“专业号”值必须是确实存在的专业的专业号，即专业关系中有该专业的记录。也就是说，学生关系中的某个属性的取值需要参照专业关系的属性取值。\n例2：学生、课程、学生与课程之间的多对多联系可以如下三个关系表示：\n\\[ \\begin{aligned} \u0026学生(\\underline{学号},姓名,性别,专业号,年龄)\\\\[5pt] \u0026课程(\\underline{课程号},课程名,学分)\\\\[5pt] \u0026选修(\\underline{学号,课程号},成绩) \\end{aligned} \\tag{13} \\] 这三个关系之间也存在着属性的引用，即选修关系引用了学生关系的主码“学号”和课程关系的主码“课程号”。同样，选修关系中的“学号”值必须是确实存在的学生的学号,即学生关系中有该学生的记录；选修关系中的“课程号”值也必须是确实存在的课程的课程号，即课程关系中有该课程的记录。换句话说，选修关系中某些属性的取值需要参照其他关系的属性取值。\n不仅两个或两个以上的关系间可以存在引用关系，同一关系内部属性间也可能存在引用关系。\n例3：在 \\(学生（\\underline{学号}，姓名，性别，专业号，年龄，班长）\\) 关系中，“学号”属性是主码，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系“学号”属性, 即“班长”必须是确实存在的学生的学号。\n这三个例子说明关系与关系之间存在着相互引用、相互约束的情况。下面先引入外码 的概念，然后给出表达关系之间相互引用约束的参照完整性的定义。\n定义5（参照关系）：设 \\(F\\) 是基本关系 \\(R\\) 的一个或一组属性，但不是关系 \\(R\\) 的码， \\(K_s\\) 是基本关系 \\(S\\) 的主码。如果 \\(F\\) 与 \\(K_s\\) 相对应，则称 \\(F\\) 是 \\(R\\) 的外码（foreign key），并称基本关系 \\(R\\) 为参照关系（referencing relation），基本关系 \\(S\\) 为被参照关系（referenced relation）‌或目标关系（target relation），关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 参照关系 被参照关系(目标关系) 图2\u0026emsp;参照关系与被参照关系\n显然，目标关系 \\(S\\) 的主码 \\(K_s\\) 和参照关系 \\(S\\) 的外码 \\(F\\) 必须定义在同一个（或同一组） 域上。\n在例1中，学生关系的“专业号”属性与专业关系的主码“专业号”相对应，因此“专业号”属性是学生关系的外码。这里专业关系是被参照关系，学生关系为参照关系。如图3（a）所示。\n在例2中，选修关系的“学号”属性与学生关系的主码“学号”相对应：选修关系的“课程号”属性与课程关系的主码“课程号”相对应，因此“学号”和“课程号”属性 是选修关系的外码。这里学生关系和课程关系均为被参照关系，选修关系为参照关系。如图3（b）所示。\n在例3中，“班长”属性与本身的主码“学号”属性相对应，因此“班长”是外码。这里，学生关系既是参照关系也是被参照关系。如图3（c）所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学生关系 专业关系 专业号 (a) 学生关系 选修关系 学号 课程关系 课程号 (b) 学生关系 学号 (c) 图3\u0026emsp;关系的参照图\n需要指出的是，外码并不一定要与相应的主码同名，如例2.3中学生关系的主码为学号，外码为班长。不过，在实际应用中为了便于识别，当外码与相应的主码属于不同关系时，往往给它们取相同的名字。\n参照完整性规则就是定义外码与主码之间的引用规则。\n参照完整性规则：若属性（或属性组） \\(F\\) 是基本关系 \\(R\\) 的外码，它与基本关系 \\(S\\) 的主码 \\(K_s\\) 相对应（基本关系 \\(R\\) 和 \\(S\\) 不一定是不同的关系），则对于 \\(R\\) 中每个元组在 \\(F\\) 上的值必须：\n或者取空值（ \\(F\\) 的每个属性值均为空值）。 或者等于 \\(S\\) 中某个元组的主码值。 例如，对于例1，学生关系中每个元组的“专业号”属性只能取下面两类值：\n空值，表示尚未给该学生分配专业。 非空值，这时该值必须是专业关系中某个元组的“专业号”值，表示该学生不可能分配到一个不存在的专业中。即被参照关系“专业”中一定存在一个元组，它的主码值等于该参照关系\u0026quot;学生\u0026quot;中的外码值。 对于例2，按照参照完整性规则，“学号”和“课程号”属性也可以取两类值：空值或目标关系中已经存在的值。但由于“学号\u0026quot;和\u0026quot;课程号”是选修关系中的主属性，按照实体完整性规则，它们均不能取空值，所以选修关系中的\u0026quot;学号”和“课程号”属性实际上只能取相应被参照关系中已经存在的主码值。\n参照完整性规则中， \\(R\\) 与 \\(S\\) 可以是同一个关系。例如对于例3按照参照完整性规则，“班长”属性值可以取两类值：\n空值，表示该学生所在班级尚未选出班长； 非空值，这时该值必须是本关系中某个元组的学号值。 用户定义的完整性 任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取唯一值、某个非主属性不能取空值等。例如，在例1的学生关系中，若按照应用的要求学生不能没有姓名，则可以定义学生姓名不能取空值；某个属性（如学生的成绩），的取值范围可以定义在0〜100之间等。\n关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不需由应用程序承担这一功能。\n在早期的关系数据库管理系统中没有提供定义和检验这些完整性的机制，因此需要应用开发人员在应用系统的程序中进行检查。例如在例2的选修关系中，每插入一条记录,必须在应用程序中写一段程序来检查其中的学号是否等于学生关系中的某个学号，并检查其中的课程号是否等于课程关系中的某个课程号。如果等于，则插入这一条选修记录，否则就拒绝插入，并给出错误信息。\n关系代数 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括两类：集合运算符和专门的关系运算符，如表4所示。关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。其中，传统的集合运算将关系看成元组的集合，其运算是从关系的“水平”方向，即行的角度来进行：而专门的关系运算不仅涉及行，而且涉及列。比较运算符和逻辑运算符是用来辅助专门的关系运算符进行操作的。\n运算符 含义 集合运算符 \\(\\cup\\) 并 \\(-\\) 差 \\(\\cap\\) 交 \\(\\times\\) Cartesian乘积 专门的关系运算符 \\(\\sigma\\) 选择 \\(\\pi\\) 投影 \\(\\Join\\) 连接 \\(\\div\\) 除 表4\u0026emsp;关系代数运算符\n传统的集合运算 传统的集合运算是二目运算，包括并、差、交、Cartesian乘积4种运算。\n设关系 \\(R\\) 和关系 \\(S\\) 具有相同的目 \\(n\\) （即两个关系都有 \\(n\\) 个属性），且相应的属性取自同一个域， \\(t\\) 是元组变量， \\(t \\in R\\) 表示 \\(t\\) 是 \\(R\\) 的一个元组。\n可以定义并、差、交、Cartesian乘积运算如下。\n并（union） 关系 \\(R\\) 与关系 \\(S\\) 的并记作\n\\[ R\\cup S=\\set{t|t \\in R \\lor t \\in S} \\tag{14} \\] 其中 \\(\\lor\\) 是或运算符。其结果仍为 \\(n\\) 目关系，由属于 \\(R\\) 或属于 \\(S\\) 的元组组成。\n差（except） 关系 \\(R\\) 与关系 \\(S\\) 的差记作\n\\[ R-S=\\set{t|t \\in R \\land t \\notin S} \\tag{15} \\] 其中 \\(\\land\\) 是与运算符。其结果关系仍为 \\(n\\) 目关系，由属于 \\(R\\) 而不属于 \\(S\\) 的所有元组组成。\n交（intersection） 关系 \\(R\\) 与关系 \\(S\\) 的交记作\n\\[ R\\cap S = \\set{t|t\\in R \\land t \\in S} \\tag{16} \\] 其结果关系仍为 \\(n\\) 目关系，由既属于 \\(R\\) 及又属于 \\(S\\) 的元组组成。关系的交可以用差来表示，即\n\\[ R \\cap S = R-(R-S) \\tag{17} \\] Cartesian乘积（cartesian product） 这里的Cartesian乘积严格地讲应该是广义的Cartesian乘积（extended cartesian product），因为这里Cartesian乘积的元素是元组。\n两个分别为 \\(n\\) 目和 \\(m\\) 目的关系 \\(R\\) 和 \\(S\\) 的Cartesian乘积是一个 \\((n+m)\\) 列的元组的集合。元组的前 \\(n\\) 列是关系 \\(R\\) 的一个元组，后所列是关系 \\(S\\) 的一个元组。若 \\(R\\) 有 \\(k_1\\) 个元组，S有 \\(k_2\\) 个元组，则关系 \\(R\\) 和关系 \\(S\\) 的Cartesian乘积有 \\(k_1\\times k_2\\) 个元组。记作\n\\[ R\\times S=\\set{\\overgroup{t_rt_s}|t_r \\in R \\land t_s \\in S} \\tag{18} \\] 图4(a)、图4(b)分别为具有三个属性列的关系 \\(R\\) 、 \\(S\\) 。图4(c)为关系 \\(R\\) 与 \\(S\\) 的并。图4(d)为关系 \\(R\\) 与 \\(S\\) 的交。图4(e)为关系 \\(R\\) 和 \\(S\\) 的差。图4(f)为关系 \\(R\\) 和 \\(S\\) 的Cartesian乘积。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e (a) (b) (c) (d) (e) (f) 图4\u0026emsp;传统集合运算举例\n专门的关系运算 专门的关系运算包括选择、投影、连接、除运算等。为了叙述上的方便，先引入几个记号。\n设关系模式为 \\(R(A_1,A_2,\\cdots,A_n)\\)，它的一个关系设为 \\(R\\) 。 \\(t \\in R\\) 表示 \\(t\\) 是 \\(R\\) 的一个元组。 \\(t[A_i]\\) 则表示元组 \\(t\\) 中相应于属性 \\(i\\) 的一个分量。 若 \\(A=\\set{A_{i1},A_{i2},\\cdots,A_{ik}}\\) ，其 \\(A_{i1},A_{i2},\\cdots,A_{ik}\\) 是 \\(A_1,A_2,\\cdots,A_n\\) 中的一部分,则 \\(A\\) 称为属性列或属性组。 \\(t[A]=(t[A_{i1}],t[A_{i2}],\\cdots,t[A_{ik}])\\) 表示元组 \\(t\\) 在属性列 \\(A\\) 上诸分量的集合， \\(\\bar{A}\\) 则表示 \\(\\set{A_1,A_2,\\cdots,A_n}\\) 中去掉 \\(\\set{A_{i1},A_{i2},\\cdots,A_{ik}}\\) 后剩余的属性组。 \\(R\\) 为 \\(n\\) 目关系， \\(S\\) 为 \\(m\\) 目关系。 \\(t_r\\in R,t_s \\in S\\) ， \\(\\overgroup{t_rt_s}\\) 称为元组的连接（concatenation）‌或元组的串接。它是一个 \\(n+m\\) 列的元组，前 \\(n\\) 个分量为 \\(R\\) 中的一个 \\(n\\) 元组，后 \\(m\\) 个分量为 \\(S\\) 中的一个 \\(m\\) 元组。 给定一个关系 \\(R(X,Z)\\) ， \\(X\\) 和 \\(Z\\) 为属性组。当 \\(t[X]=x\\) 时， \\(x\\) 在 \\(R\\) 中的象集（images set）‌定义为 \\[ Z_x=\\set{t[Z]|t \\in R, t[X]=x} \\tag{19} \\] 它表示 \\(R\\) 中属性组 \\(X\\) 上值为 \\(x\\) 的诸元组在 \\(Z\\) 上分量的集合。\n例如，图5中， \\(x_1\\) 在 \\(R\\) 中的象集为 \\(Z_{x_1}=\\set{{Z_1,Z_2,Z_3}}\\) ， \\(x_2\\) 在 \\(R\\) 中的象集为 \\(Z_{x_2}=\\set{Z_2,Z_3}\\) ， \\(x_3\\) 在 \\(R\\) 中的象集为 \\(Z_{x_3}=\\set{Z_1,Z_3}\\) 。 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 图5\u0026emsp;象集举例\n下面给出这些专门的关系运算的定义。\n选择 选择又称为限制（restriction）。它是在关系 \\(R\\) 中选择满足给定条件的诸元组，记作\n\\[ \\sigma_F(R)=\\set{t|t \\in R \\land F(t)=\\text{'真'}} \\tag{20} \\] 其中 \\(F\\) 表示一个选择条件，它是一个逻辑表达式，取逻辑“真”或“假”。\n逻辑表达式 \\(F\\) 的基本形式为\n\\[ X_1\\theta Y_1 \\tag{21} \\] 其中 \\(\\theta\\) 表示比较运算符，它可以是 \\(\u003e,\\ge,\u003c,\\le,=\\) 或 \\(\u003c\u003e\\) 。 \\(X_1,Y_1\\) 是属性名，或为常量，或为简单常数；属性名也可以用它的序号来代替，在基本的选择条件上可以进一步进行逻辑运算，即进行求非（ \\(\\lnot\\) ）、与（ \\(\\land\\) ）、或（ \\(\\lor\\) ）运算。条件表达式中的运算符如表2.5所示。\n运算符 含义 比较运算符 \\(\u003e\\) 大于 \\(\\ge\\) 大于等于 \\(\u003c\\) 小于 \\(\\le\\) 小于等于 \\(=\\) 等于 \\(\u003c\u003e\\) 不等于 逻辑运算符 \\(\\lnot\\) 非 \\(\\land\\) 与 \\(\\lor\\) 或 选择运算实际上是从关系火中选取使逻辑表达式 \\(F\\) 为真的元组。这是从行的角度进行的运算。\n设有一个学生\u0026mdash;课程数据库，包括学生关系Student，课程关系Course和选修关系SC。如图6所示。下面的多个例子将对这三个关系进行运算。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 201215121 学号 Sno 姓名 Sname 李勇 性别 Ssex 年龄 Sage 所在系 Sdept 男 20 CS 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS Student Course (a) 1 课程号 Cno 课程名 Cname 数据库 先行课 Cpno 学分 Credit 5 4 数学 2 信息系统 4 操作系统 3 2 3 4 5 6 7 数据结构 数据处理 PASCAL语言 1 6 7 6 4 2 4 (b) 学号 Sno 课程号 Cno 成绩 Grade 92 88 90 80 85 201215121 201215121 201215121 201215122 201215122 1 2 3 2 3 SC (c) 图6\u0026emsp;学生-课程数据库\n例4：查询信息系（IS系）全体学生。\n\\[ \\sigma_{\\text{Sdept}=\\text{'IS'}}(\\text{Student}) \\tag{22} \\] 结果如图7(a)所示。\n例5：查询年龄小于20岁的学生。\n\\[ \\sigma_{\\text{Sage\u003c20}}(\\text{Student}) \\tag{23} \\] 结果如图7(b)所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学号 Sno 姓名 Sname 性别 Ssex 年龄 Sage 所在系 Sdept 201215125 张立 男 19 IS Student (a) 学号 Sno 姓名 Sname 性别 Ssex 年龄 Sage 所在系 Sdept 201215122 刘晨 女 19 CS 201215123 王敏 女 18 MA 201215125 张立 男 19 IS Student (b) 图7\u0026emsp;选择运算举例\n投影（projection） 关系 \\(R\\) 上的投影是从 \\(R\\) 中选择出若干属性列组成新的关系。记作\n\\[ \\Pi_A(R)=\\set{t[A]|t \\in R} \\tag{24} \\] 其中 \\(A\\) 为 \\(R\\) 的属性列。\n投影操作就是从列的角度进行运算。\n例6：查询学生的姓名和所在系，即求Student关系上学生姓名和所在系两个属性上的投影。\n\\[ \\Pi_{\\text{Sname,Sdept}}(\\text{Student}) \\tag{25} \\] 结果如图8(a)所示。\n投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组，因为取消了某些属性列后，就可能出现重复行，应取消这些完全相同的行。\n例7：查询学生关系Student中都有哪些系，即查询关系Student上所在系属性上的投影。\n\\[ \\Pi_{\\text{Sdept}}(\\text{Student}) \\tag{26} \\] 结果如图8(b)所示。Student关系原来有4个元组，而投影结果取消了重复的CS元组，因此只有三个元组。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Sname Sdept 李勇 刘晨 王敏 张立 CS CS MA IS Sdept CS IS MA （a） （b） 图8\u0026emsp;投影运算举例\n连接（join） 连接也称为 \\(\\theta\\) 连接。它是从两个关系的Cartesian乘积中选取属性间满足一定条件的元组。记作\n\\[ R \\underset{A\\theta B}{\\Join} S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[A]\\theta t_s[B])} \\tag{27} \\] 其中， \\(A\\) 和 \\(B\\) 分别为 \\(R\\) 和 \\(S\\) 上列数相等且可比的属性组， \\(\\theta\\) 是比较运算符。连接运算从 \\(R\\) 和 \\(S\\) 的Cartesian乘积 \\(R\\times S\\) 中选取R关系在 \\(A\\) 属性组上的值与 \\(S\\) 关系在 \\(B\\) 属性组上的值满足比较关系 \\(\\theta\\) 的元组。\n连接运算中有两种最为重要也最为常用的连接，一种是等值连接（equijoin），另一种是自然连接（natural join）。\n\\(\\theta\\) 为“ \\(=\\) ”的连接运算称为等值连接。它是从关系 \\(R\\) 与 \\(S\\) 的广义Cartesian乘积中选取 \\(A\\) 、 \\(B\\) 属性值相等的那些元组，即等值连接为\n\\[ R \\underset{A=B}{\\Join} S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[A]=t_s[B])} \\tag{28} \\] 自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若 \\(R\\) 和 \\(S\\) 中具有相同的属性组 \\(B\\) ， \\(U\\) 为 \\(R\\) 和 \\(S\\) 的全体属性集合，则自然连接可记作\n\\[ R \\Join S=\\set{\\overgroup{t_rt_s}|(t_r \\in R) \\land (t_s \\in S) \\land (t_r[B]=t_s[B])} \\tag{29} \\] 一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。\n例8：设图9(a)和(b)分别为关系 \\(R\\) 和关系 \\(S\\) ，图图9(c)为非等值连接及 \\( R \\underset{C\\lt E}{\\Join} S \\) 的结果，图9(d)为等值连接 \\( R \\underset{R.B=S.B}{\\Join} S \\) 的结果，图9(e)为自然连接 \\( R \\Join S \\) 的结果。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e (a)关系 (b)关系 (c)非等值连接 (d)等值连接 (e)自然连接 图9\u0026emsp;连接运算举例\n两个关系 \\(R\\) 和 \\(S\\) 在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系 \\(R\\) 中某些元组有可能在 \\(S\\) 中不存在公共属性上值相等的元组，从而造成 \\(R\\) 中这些元组在操作时被舍弃了，同样， \\(S\\) 中某些元组也可能被舍弃。这些被舍弃的元组称为悬浮元组（dangling tuple），例如，在图9(e)的自然连接中， \\(R\\) 中的第 \\(4\\) 个元组， \\(S\\) 中的第 \\(5\\) 个元组都是被舍弃掉的悬浮元组。\n如果把悬浮元组也保存在结果关系中，而在其他属性上填空值（NULL），那么这种连接就叫做外连接（outer join），记作 \\(R⟗S\\) ；如果只保留左边关系 \\(R\\) 中的悬浮元组就叫做左外连接（left outer join或left join），记作 \\(R⟕S\\) ；如果只保留右边关系 \\(S\\) 中的悬浮元组就叫做右外连接（right outer join或right join），记作 \\(R⟖S\\) 。在图10中，(a)是图9中的关系 \\(R\\) 和关系 \\(S\\) 的外连接，(b)是左外连接，(c)是右外连接。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e (a)外连接 (b)左外连接 (c)右外连接 图10\u0026emsp;外连接运算举例\n除运算 设关系 \\(R\\) 除以关系 \\(S\\) 的结果为关系 \\(T\\) ，则 \\(T\\) 包含所有在 \\(R\\) 但不在 \\(S\\) 中的属性及其值，且 \\(T\\) 的元组与 \\(S\\) 的元组的所有组合都在 \\(R\\) 中。\n下面用象集来定义除法：\n给定关系 \\(R(X,Y)\\) 和 \\(S(Y,Z)\\) ，其中 \\(X,Y,Z\\) 为属性组。 \\(R\\) 中的 \\(Y\\) 与 \\(S\\) 中的 \\(Y\\) 可以有不同的属性名，但必须出自相同的域集。\n\\(R\\) 与 \\(S\\) 的除运算得到一个新的关系 \\(P(X)\\) ， \\(P\\) 是 \\(R\\) 中满足下列条件的元组在 \\(X\\) 属性列上的投影：元组在 \\(X\\) 上分量值 \\(x\\) 的象集 \\(Y_x\\) 包含 \\(S\\) 在 \\(Y\\) 上投影的集合。记作\n\\[ R\\div S=\\set{t_r[X]|(t_r\\in R)\\land(\\Pi_Y (S)\\sube Y_x)} \\tag{30} \\] 其中 \\(Y_x\\) 为 \\(x\\) 在 \\(R\\) 中的象集， \\(x=t_r[X]\\) 。\n除操作是同时从行和列角度进行运算。\n例9：设关系 \\(R\\) 、 \\(S\\) 分别为图11中的(a)和(b)， \\(R \\div S\\) 的结果为图11(c)。\n在关系 \\(R\\) 中， \\(A\\) 可以取 \\(4\\) 个值 \\(\\set{a_1,a_2,a_3,a_4}\\) 。其中：\n\\(a_1\\) 的象集为 \\(\\set{(b_1,c_2),(b_2,c_3),(b_2,c_1)}\\) ；\n\\(a_2\\) 的象集为 \\(\\set{(b_3,c_7),(b_2,c_3)}\\) ；\n\\(a_3\\) 的象集为 \\(\\set{(b_4,c_6)}\\) ；\n\\(a_4\\) 的象集为 \\(\\set{(b_6,c_6)}\\) ；\n\\(S\\) 在 \\((B,C)\\) 上的投影为 \\(\\set{(b_1,c_2),(b_2,c_1),(b_2,c_3)}\\) 。\n显然只有 \\(a_1\\) 的象集 \\((B,C)_{a_1}\\) 包含了 \\(S\\) 在 \\((B,C)\\) 属性组上的投影，所以\n\\[ R \\div S = \\set{a_1} \\tag{31} \\] \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e (a) (b) (c) 图11\u0026emsp;除运算举例\n下面再以学生\u0026mdash;课程数据库（图6）为例，给出几个综合应用多种关系代数运算进行查询的例子。\n例10：查询1号课程和3号课程都选秀了的学生的号码。\n首先建立一个临时关系 \\(K\\) ：\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e Cno 1 3 K 图12\u0026emsp;临时关系 \\(\\text{K}\\) 然后求\n\\[ \\Pi_{\\text{Sno},\\text{Cno}}(\\text{SC})\\div \\text{K} \\tag{32} \\] 结果为 \\(\\set{201215121}\\) 。\n求解过程与例9类似，先对 \\(\\text{SC}\\) 关系在 \\((\\text{Sno},\\text{Cno})\\) 属性上投影，然后逐一求出每 一学生（ \\(\\text{Sno}\\) ）的象集，并依次检查这些象集是否包含 \\(\\text{K}\\) 。\n例11：查询选修了 \\(2\\) 号课程的学生的学号。\n\\[ \\Pi_{\\text{Sno}}(\\sigma_{\\text{Cno}=\\text{'2'}}(\\text{SC}))=\\set{201215121,201215122} \\tag{33} \\] 例12：查询至少选修了一门其直接先行课为5号课程的学生姓名。\n\\[ \\Pi_{\\text{Sname}}(\\sigma_{\\text{Cpno}=\\text{'5'}}(\\text{Course})\\Join\\text{SC}\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student})) \\tag{34} \\] 或\n\\[ \\Pi_{\\text{Sname}}(\\Pi_{\\text{Sno}}(\\sigma_{\\text{Cpno}=\\text{'5'}}(\\text{Course})\\Join\\text{SC})\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student})) \\tag{35} \\] 例13：查询选修了全部课程的学生号码和姓名。\n\\[ \\Pi_{\\text{Sno},\\text{Cno}}(\\text{SC})\\div\\Pi_{\\text{Cno}}(\\text{Course})\\Join\\Pi_{\\text{Sno},\\text{Sname}}(\\text{Student}) \\tag{36} \\] 本节介绍了8种关系代数运算，其中并、差、Cartesian乘积、选择和投影这5种运算为基本的运算。其他三种运算，即交、连接和除，均可以用这5种基本运算来表达。引进它们并不增加语言的能力，但可以简化表达。\n关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。\n关系演算 关系演算是以数理逻辑中的谓词演算为基础的。按谓词变元的不同，关系演算可分为元组关系演算和域关系演算。本节先介绍元组关系演算，然后简单介绍域关系演算。\n元组关系演算语言ALPHA 元组关系演算以元组变量作为谓词变元的基本对象。一种典型的元组关系演算语言是E.F.Codd提出的ALPHA语言。这一语言虽然没有实际实现，但关系数据库管理系统INGRES最初所用的QUEL语言是参照ALPHA语言研制的，与ALPHA十分类似。ALPHA 语言主要有\\(\\text{GET}\\)、\\(\\text{PUT}\\)、\\(\\text{HOLD}\\)、\\(\\text{UPDATE}\\)、\\(\\text{DELETE}\\)、\\(\\text{DROP}\\) 6条语句，语句的基本格式为\n\\[ \\text{操作语句 工作空间名 (表达式)：操作条件}\\hspace{15em} \\tag{37} \\] 其中表达式用于指定语句的操作对象，它可以是关系名或（和）属性名，一条语句可以同时操作多个关系或多个属性。操作条件是一个逻辑表达式，用于将操作结果限定在满足条件的元组中，操作条件可以为空。除此之外，还可以在基本格式的基础上加上排序要求以及指定返回元组的条数等。\n检索操作 检索操作用 \\(\\text{GET}\\) 语句实现。\n1. 简单检索（即不带条件的检索）\n例14：查询所有被选修的课程号码。\n\\(\\text{GET W (SC.Cno)}\\)\n\\(\\text{W}\\)为工作空间名。这里条件为空，表示没有限定条件。\n例15：查询所有学生的数据。\n\\(\\text{GET W (Student)}\\)\n2. 限定的检索（即带条件的检索）\n例16：查询信息系（IS）中年龄小于20岁的学生的学号和年龄。\n\\(\\text{GET W (Student.Sno,Student.Sage): Student.Sdept='IS'}\\land\\text{Student.Sage\u003c20}\\)\n3. 带排序的检索\n例17：查询计算机科学系（CS）学生的学号、年龄，结果按年龄降序排序。\n\\(\\text{GET W (Student.Sno,Student.Sage): Student.Sdept='CS' DOWN Student.Sage}\\)\n\\(\\text{DOWN}\\)表示降序排序。\n4. 指定返回元组的条数的检索\n例18：取出一个信息系学生的学号。\n\\(\\text{GET W (1) (Student.Sno): Student.Sdept='IS'}\\)\n在\\(\\text{W}\\)后括号中的数量就是指定的返回元组的个数。\n例19：查询信息系年龄最大的三个学生的学号及其年龄，结果按年龄降序排序。\n\\(\\text{GET W (3) (Student.Sno,Student.Sage): Student.Sdept='IS' DOWN Student.Sage}\\)\n5. 用元组变量的检索\n前面已讲到，元组关系演算是以元组变量作为谓词变元的基本对象。元组变量是在某一关系范围内变化的，所以也称为范围变量（range variable），一个关系可以设多个元组变量。\n元组变量主要有两方面的用途：\n简化关系名。如果关系的名字很长，使用起来就会感到不方便，这时可以设一个较短名字的元组变量来代替关系名。如例20。 操作条件中使用量词时必须用元组变量。如例21至例23。 例20：查询信息系学生的名字。\n\\(\\text{RANGE Student X}\\)\n\\(\\text{GET W (X.Sname): X.Sdept='IS'}\\)\nALPHA语言用\\(\\text{RANGE}\\)来说明元组变量。本例中\\(\\text{X}\\)是关系\\(\\text{Student}\\)上的元组变量，用途是简化关系名，即用\\(\\text{X}\\)代表\\(\\text{Student}\\)。\n6. 用存在量词（existential qualifier）检索\n例21：查询选修2号课程的学生的名字。\n\\(\\text{RANGE SC X}\\)\n\\(\\text{GET W (Student.Sname): }\\exists\\text{X(X.Sno=Student.Sno}\\land\\text{X.Cno='2')}\\)\n例22：查询选修了这样课程的学生学号，其直接先行课是6号课程。\n\\(\\text{RANGE Course CX}\\)\n\\(\\text{GET W (SC.Sno): }\\exists\\text{CX(CX.Cno=SC.Cno}\\land\\text{CX.Pcno='6')}\\)\n例23：查询至少选修一门其先行课为6号课程的学生名字。\n\\(\\text{RANGE Course CX}\\)\n\\(\\text{SC SCX}\\)\n\\(\\text{GET W (Student.Sname): }\\exists\\text{SCX(SCX.Sno=Student.Sno}\\land\\)\n\\(\\hspace{116pt}\\exists\\text{CX(CX.Cno=SCX.Cno}\\land\\text{CX.Pcno='6'))}\\)\n在本例中的元组关系演算公式可以变换为前束范式（prenex normal form）‌的形式：\n\\(\\text{GET W (StudentSname): }\\exists\\text{SCX}\\exists\\text{CX(SCX.Sno=Student.Sno}\\land\\text{CX.Cno=SCX.Cno}\\land\\text{CX.Pcno='6')}\\)\n例21、例22、例23中的元组变量都是为存在量词而设的。其中例2.23需要对两个关系使用存在量词，所以设了两个元组变量。\n7. 带有多个关系表达式的检索\n上面所举的各个例子中，虽然查询时可能会涉及多个关系，即公式中可能涉及多个关系，但查询结果表达式中只有一个关系。实际上表达式中是可以有多个关系的。\n例24：查询成绩为90分以上的学生名字与课程名字。\n本查询所要求的结果是学生名字和课程名字，分别在Student和Course两个关系中。\n\\(\\text{RANGE SC SCX}\\)\n\\(\\text{GET W (Student.Sname,Course.Cname): }\\exists\\text{SCX(SCX.Grade}\\ge\\text{90}\\land\\)\n\\(\\hspace{150pt}\\text{SCX.Sno=Student.Sno}\\land\\text{Course.Cno=SCX.Cno)}\\)\n8. 用全称量词（generality quantifier）的检索\n例25：查询不选1号课程的学生名字。\n\\(\\text{RANGE SC SCX}\\)\n\\(\\text{GET W (Student.Sname): }\\forall\\text{SCX (SCX.Sno}\\ne\\text{Student.Sno}\\land\\text{SCX.Cno}\\ne\\text{'1')}\\)\n也可以用存在量词表示。\n\\(\\text{RANGE SC SCX}\\)\n\\(\\text{GET W (Student.Sname): }\\lnot\\exists\\text{SCX (SCX.Sno}=\\text{Student.Sno}\\land\\text{SCX.Cno}=\\text{'1')}\\)\n9. 用两种量词的检索\n例26：查询选修了全部课程的学生姓名。\n\\(\\text{RANGE Course CX}\\)\n\\(\\text{SC SCX}\\)\n\\(\\text{GET W (Student.Sname): }\\forall\\text{CX}\\exist\\text{SCX(SCX.Sno=Student.Sno}\\land\\text{SCX.Cno=CX.Cno)}\\)\n10. 用蕴涵（implication）的检索\n例27：查询最少选修了 201215122学生所选课程的学生学号。\n本例题的求解思路是，对Course中的所有课程依次检查每一门课程，看201215122是否选修了该课程，如果选修了，则再看某一个学生是否也选修了该门课。如果对于201215122所选的每门课程该学生都选修了，则该学生为满足要求的学生。把所有这样的学生全都找出来即完成了本题。\n\\(\\text{RANGE Course CX}\\)\n\\(\\hspace{51pt}\\text{SC SCX}\\)\n\\(\\hspace{51pt}\\text{SC SCY}\\)\n\\(\\text{GET W (Student.Sno): }\\forall\\text{CX(}\\exist\\text{SCX(SCX.Sno='201215122'}\\land\\text{SCX.Cno=CX.Cno)}\\)\n\\(\\hspace{120pt}\\Rarr\\exist\\text{SCY(SCY.Sno=Student.Sno }\\land\\text{SCY.Cno=CX.Cno))}\\)\n蕴涵（ \\(\\Rarr\\) ）见命题逻辑。\n11. 聚集函数\n用户在使用查询语言时经常要作一些简单的计算，例如要求符合某一查询要求的元组数，求某个关系中所有元组在某属性上的值的总和或平均值等。为了方便用户，关系数据语言中建立了有关这类运算的标准函数库供用户选用。这类函数通常称为聚集函数或内置函数（built-in function），关系演算中提供了\\(\\text{COUNT}\\)、\\(\\text{TOTAL}\\)、\\(\\text{MAX}\\)、\\(\\text{MIN}\\)、\\(\\text{AVG}\\)等聚集函数，其含义如表6所示。\n函数名 功能 \\(\\text{COUNT}\\) 对数据项计数 \\(\\text{TOTAL}\\) 计算总和 \\(\\text{MAX}\\) 查找最大值 \\(\\text{MIN}\\) 查找最小值 \\(\\text{AVG}\\) 计算平均值 表6\u0026emsp;关系演算中的聚集函数\n例28：查询学生所在系的数目。\n\\(\\text{GET W (COUNT(Student.Sdept))}\\)\n例29：查询信息系学生的平均年龄。\n\\(\\text{GET W (AVG(Student.Sage): Student.Sdept='IS')}\\)\n更新操作 1. 修改操作\n首先用\\(\\text{HOLD}\\)语句将要修改的元组从数据库中读到工作空间中： 然后用宿主语言修改工作空间中元组的属性值； 最后用\\(\\text{UPDATE}\\)语句将修改后的元组送回数据库中。 例30：把201215127学生从计算机科学系转到信息系。\n\\(\\text{HOLD W (Student.Sno,Student Sdept): Student.Sno='201215127'}\\)\n\\(\\hspace{157pt}\\text{(从Student关系中读出201215127学生的数据)}\\)\n\\(\\text{MOVE 'IS' TO W.Sdept}\\hspace{50pt}\\text{(用宿主语言进行修改)}\\)\n\\(\\text{UPDATE W}\\hspace{100pt}\\text{(把修改后的元组送回Student关系)}\\)\n在该例中用\\(\\text{HOLD}\\)语句来读201215127的数据，而不是用\\(\\text{GET}\\)语句。如果修改操作涉及两个关系的话，就要执行两次\\(\\text{HOLD-MOVE-UPDATE}\\)操作序列。\n在ALPHA语言中，修改关系主码的操作是不允许的，例如不能用UPDATE语句将学 号201215121改为201215122。如果需要修改主码值，只能先用删除操作删除该元组，然后再把具有新主码值的元组插入到关系中。\n2. 插入操作\n插入操作用\\(\\text{PUT}\\)语句实现。其步骤是：\n首先用宿主语言在工作空间中建立新元组； 然后用\\(\\text{PUT}\\)语句把该元组存入指定的关系中。 例31：学校新开设了一门2学分的课程\u0026quot;计算机组织与结构”，其课程号为8,直 接先行课为6号课程。插入该课程元组。\n\\(\\text{MOVE '8' TO W.Cno}\\)\n\\(\\text{MOVE '计算机组织与结构' TO W.Cname}\\)\n\\(\\text{MOVE '6' TO W.Cpno}\\)\n\\(\\text{MOVE '2' TO W.Ccredit}\\)\n\\(\\text{PUT W (Course)}\\hspace{2em}\\text{(把W中的元组插入指定关系Course中)}\\)\nPUT语句只对一个关系操作，也就是说表达式必须为单个关系名。\n3. 删除操作\n删除操作用\\(\\text{DELETE}\\)语句实现。其步骤为：\n用\\(\\text{HOLD}\\)语句把要删除的元组从数据库中读到工作空间中； 用\\(\\text{DELETE}\\)语句删除该元组。 例32：201215230学生因故退学，删除该学生元组。\n\\(\\text{HOLD W (Student): Student.Sno='201215230'}\\)\n\\(\\text{DELETE W}\\)\n例33：将学号201215121改为 201215122。\n\\(\\text{HOLD W (Student): Student.Sno='201215121'}\\)\n\\(\\text{DELETE W}\\)\n\\(\\text{MOVE '201215122' TO W.Sno}\\)\n\\(\\text{MOVE '李勇' TO W.Sname}\\)\n\\(\\text{MOVE '男' TO W.Ssex}\\)\n\\(\\text{MOVE '20' TO W.Sage}\\)\n\\(\\text{MOVE 'CS' TO W.Sdept}\\)\n\\(\\text{PUT W (Student)}\\)\n例34：删除全部学生。\n\\(\\text{HOLD W (Student)}\\)\n\\(\\text{DELETE W}\\)\n由于SC关系与Student关系之间具有参照关系，为保证参照完整性，删除Student中元组时相应地要删除SC中的元组（手工删除或由数据库管理系统自动执行）：\n\\(\\text{HOLD W (SC)}\\)\n\\(\\text{DELETE W}\\)\n元组关系演算 为了讨论方便，先允许关系（的基数）是无限的，然后再对这种情况下定义的演算做适当的修改，保证关系演算中各个公式表示的是有限关系。\n在元组关系演算系统中，称 \\(\\set{t|\\phi(t)}\\) 为元组演算表达式。其中， \\(t\\) 是元组变量， \\(\\phi(t)\\) 为元组关系演算公式，简称公式，它由原子公式和运算符组成。\n原子公式有以下三类：\n\\(R(t)\\) 。 \\(R\\) 是关系名， \\(t\\) 是元组变量。 \\(R(t)\\) 表示 \\(t\\) 是 \\(R\\) 中的元组。于是，关系 \\(R\\) 可表示为 \\(\\set{t|R(t)}\\) 。 \\(t[i]\\theta u[j]\\) 。 \\(t\\) 和 \\(u\\) 是元组变量， \\(\\theta\\) 是算数比较运算符。 \\(t[i]\\theta u[j]\\) 表示断言“元组 \\(t\\) 的第 \\(i\\) 个分量与元组 \\(u\\) 的第 \\(j\\) 个分量满足比较关系 \\(\\theta\\) ”。例如， \\(t[2] \u003c u[3] \\) 表示元组 \\(t\\) 的第 \\(2\\) 个分量小于元组 \\(u\\) 的第 \\(3\\) 个分量。 \\(t[i]\\theta c\\) 或 \\(c\\theta t[i]\\) 。这里 \\(c\\) 是常量，该公式表示“ \\(t\\) 的第 \\(i\\) 个分量与常量 \\(c\\) 满足比较关系 \\(\\theta\\) ”。例如， \\(t[4]=3\\) 表示元组 \\(t\\) 的第 \\(4\\) 个分量等于 \\(3\\) 。 在关系演算中定义了\u0026quot;自由元组变量”和\u0026quot;约束元组变量”的概念。这些概念和谓词演算中的概念完全一样。若公式中的一个元组变量前有“全称量词”或“存在量词\u0026quot;，则称该变量为约束元组变量，否则称自由元组变量。\n公式可以递归定义如下：\n每个原子公式是公式。 如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 是公式，则 \\(\\phi_1\\land\\phi_2\\) 、 \\(\\phi_1\\lor\\phi_2\\) 、 \\(\\lnot\\phi_1\\) 是公式。 如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 同时为真，则 \\(\\phi_1\\land\\phi_2\\) 才为真，否则为假。 如果 \\(\\phi_1\\) 和 \\(\\phi_2\\) 中一个或同时为真，则 \\(\\phi_1\\lor\\phi_2\\) 为真，仅当 \\(\\phi_1\\) 和 \\(\\phi_2\\) 同时为假时， \\(\\phi_1\\lor\\phi_2\\) 才为假。 若 \\(\\phi_1\\) 为真，则 \\(\\lnot\\phi_1\\) 为假。 若 \\(\\phi\\) 是公式，则 \\(\\exist t(\\phi)\\) 是公式，其中符号 \\(\\exist\\) 是全称量词符号， \\(\\exist t(\\phi)\\) 表示，如果对所有 \\(t\\) 都使 \\(\\phi\\) 为真，则 \\(\\exist t(\\phi)\\) 为真，否则 \\(\\exist t(\\phi)\\) 为假。 若 \\(\\phi\\) 是公式，则 \\(\\forall t(\\phi)\\) 是公式，其中符号 \\(\\forall\\) 是全称量词符号， \\(\\forall t(\\phi)\\) 表示，如果对所有 \\(t\\) 都使 \\(\\phi\\) 为真，则 \\(\\forall t(\\phi)\\) 为真，否则 \\(\\forall t(\\phi)\\) 为假。 在元组演算公式中，各种运算符的优先次序为： 算术比较运算符最高。 量词次之，且 \\(\\exist\\) 的优先级高于 \\(\\forall\\) 的优先级。 逻辑运算符最低，且 \\(\\lnot\\) 的优先级高于 \\(\\land\\) 的优先级， \\(\\land\\) 的优先级高于 \\(\\lor\\) 的优先级。 加括号时，括号中的运算符优先，同一括号内的运算符之优先级遵循1. 、2. 、3. 各项。 有限次地使用上述5条规则得到的公式是元组关系演算公式，其他公式不是元组关系演算公式。 一个元组演算表达式 \\(\\set{t|\\phi(t)}\\) 表示了使 \\(\\phi(t)\\) 真的元组集合。\n关系代数的运算均可以用关系演算表达式来表示（反之亦然）。下面用关系演算表达式来表示5种基本运算。\n","date":"2024-10-24T15:31:25+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/computer_science/database_system/relational_database_system/","title":"数据库系统（二）：关系数据库"},{"content":" 自然语言处理概论 本篇首先介绍了自然语言以及自然语言处理的基本概念，并总结了自然语言处理所面临的8个难点，即语言的抽象性、组合性、歧义性、进化性、非规范性、主观性、知识性及难移植性。正是由于这些难点的存在，导致自然语言处理任务纷繁复杂，并产生了多种划分方式，如按照任务层级,可以分为资源建设、基础任务、应用任务及应用系统四个层级；按照任务类型，可以分为回归、分类、匹配、解析及生成五大问题；按照研究对象的不同，可以分为形式、语义、推理及语用分析四个等级。从历史上看，自然语言处理经过了将近60年的发展，期间经历了理性主义和经验主义两大发展阶段。其中，经验主义又被分成了基于统计模型、深度学习模型及最新的预训练模型三个阶段，尤其是\u0026quot;预训练+精调\u0026quot;的方式，已成为自然语言处理的最新范式。\n自然语言处理的概念 自然语言通常指的是人类语言（本书特指文本符号，而非语音信号），是人类思维的载体和交流的基本工具，也是人类区别于动物的根本标志，更是人类智能发展的外在体现形式之一。自然语言处理（Natural Language Processing，简称NLP）‌主要研究用计算机理解和生成自然语言的各种理论和方法，属于人工智能领域的一个重要甚至核心分支，是计算机科学与语言学的交叉学科，又常被称为计算语言学(Computational Linguistics，简称CL）。随着互联网的快速发展，网络文本呈爆炸性增长，为自然语言处理提出了巨大的应用需求。同时，自然语言处理研究也为人们更深刻地理解语言的机理和社会的机制提供了一条重要的途径，因此具有重要的科学意义。\n目前，人们普遍认为人工智能的发展经历了从运算智能到感知智能，再到认知智能三个发展阶段。运算智能关注的是机器的基础运算和存储能力，在这方面，机器已经完胜人类。感知智能则强调机器的模式识别能力，如语音的识别以及图像的识别，目前机器在感知智能上的水平基本达到甚至超过了人类的水平。然而,在涉及自然语言处理以及常识建模和推理等研究的认知智能上，机器与人类还有很大的差距。\n自然语言处理的难点 为什么计算机在处理自然语言时会如此困难呢？这主要是因为自然语言具有高度的抽象性、近乎无穷变化的语义组合性、无处不在的歧义性和进化性，以及理解语言通常需要背景知识和推理能力等，下面分别进行具体的介绍。\n抽象性 语言是由抽象符号构成的，每个符号背后都对应着现实世界或人们头脑中的复杂概念，如\u0026quot;车”表示各种交通工具\u0026mdash;\u0026mdash;汽车、火车、自行车等，它们都具有共同的属性，有轮子、能载人或物等。\n组合性 每种语言的基本符号单元都是有限的，如英文仅有26个字母，中国国家标准GB2312《信息交换用汉字编码字符集•基本集》共收录6,763个汉字，即便是常用的单词，英文和中文也不过各几十万个。然而，这些有限的符号却可以组合成无限的语义，即使是相同的词汇，由于顺序不同，组合的语义也是不相同的，因此无法使用穷举的方法实现对自然语言的理解。\n歧义性 歧义性主要是由于语言的形式和语义之间存在多对多的对应关系导致的，如:“苹果”一词，既可以指水果，也可以指一家公司或手机、电脑等电子设备，这就是典型的一词多义现象。另外，对于两个句子，如“曹雪芹写了红楼梦”和\u0026quot;红楼梦的作者是曹雪芹\u0026quot;，虽然它们的形式不同，但是语义是相同的。\n进化性 任何一种“活着\u0026quot;的语言都是在不断发展变化的，即语言具有明显的进化性，也称创造性。这主要体现在两方面：一方面是新词汇层出不穷，如\u0026quot;超女”“非典”\u0026ldquo;新冠\u0026quot;等；另一方面则体现在旧词汇被赋予新的含义，如\u0026quot;腐败\u0026rdquo;“杯具”等。除了词汇，语言的语法等也在不断变化，新的用法层出不穷。\n非规范性 在互联网上，尤其是在用户产生的内容中，经常有一些有意或无意造成的非规范文本，为自然语言处理带来了不小的挑战，如音近词（\u0026ldquo;为什么” \\(\\to\\) “为森么\u0026rdquo;，\u0026ldquo;怎么了” \\(\\to\\) \u0026ldquo;肿么了\u0026rdquo;）、单词的简写或变形（please \\(\\to\\) pls、cool \\(\\to\\) coooooooool）、新造词（“喜大普奔”“不明觉厉”）和错别字等。\n主观性 和感知智能问题不同，属于认知智能的自然语言处理问题往往具有一定的主观性，这不但提高了数据标注的难度，还为准确评价系统的表现带来了一定的困难。如在分词这一最基本的中文自然语言处理任务中，关于什么是\u0026quot;词”的定义都尚不明确，比如\u0026quot;打篮球\u0026quot;是一个词还是两个词呢？所以，在标注自然语言处理任务的数据时，往往需要对标注人员进行一定的培训，使得很难通过众包的方式招募大量的标注人员，导致自然语言处理任务的标注数据规模往往比图像识别、语音识别的标注数据规模要小得多。此外，由于不同的分词系统往往标准都不尽相同，所以通过准确率等客观指标对比不同的分词系统本身就是不客观的。难以评价的问题在人机对话等任务中体现得更为明显，由于对话回复的主观性，很难有一个所谓的标准回复，所以如何自动评价人机对话系统仍然是一个开放的问题。\n知识性 理解语言通常需要背景知识以及基于这些知识的推理能力。例如，针对句子\u0026quot;张三打了李四,然后他倒了\u0026rdquo;，问其中的\u0026quot;他\u0026quot;指代的是\u0026quot;张三\u0026quot;还是\u0026quot;李四”？只有具备了“被打的人更容易倒”这一知识，才能推出\u0026quot;他”很可能指代的是“李四”。而如果将\u0026quot;倒”替换为\u0026quot;笑”，则\u0026quot;他”很可能指代的是“张三”，因为“被打的人不太容易笑\u0026quot;。但是，如何表示、获取并利用这些知识呢？目前的自然语言处理技术并没有提供很好的答案。\n难移植性 由于自然语言处理涉及的任务和领域众多，并且它们之间的差异较大，造成了难移植性的问题。如下一节将要介绍的，自然语言处理任务根据层级可以分为分词、词性标注、句法分析和语义分析等基础任务，以及信息抽取、问答系统和对话系统等应用任务，由于这些任务的目标和数据各不相同，很难使用统一的技术或模型加以解决，因此不得不针对不同的任务设计不同的算法或训练不同的模型。另外，由于不同领域的用词以及表达方式不尽相同，因此在一个领域上学习的模型也很难应用于其他领域，这也给提高自然语言处理系统的可移植性带来了极大的困难。\n综上所述，由于自然语言处理面临的众多问题，使其成为目前制约人工智能取得更大突破和更广泛应用的瓶颈之一。因此自然语言处理又被誉为\u0026quot;人工智能皇冠上的明珠”，并吸引了越来越多的人工智能研究者加入。\n自然语言处理任务体系 任务层级 如前所述，自然语言处理的一大特点是涉及的任务众多。按照从低层到高层的方式，可以划分为资源建设、基础任务、应用任务和应用系统四大类。其中，资源建设主要包括两大类任务，即语言学知识库建设和语料库资源建设。所谓语言学知识库，一般包括词典、规则库等。词典（Dictionary）‌也称辞典（Thesaurus），除了可以为词语提供音韵、句法或者语义解释以及示例等信息，还可以提供词语之间的关系信息，如上下位、同义反义关系等。语料库资源指的是面向某一自然语言处理任务所标注的数据。无论是语言学资源，还是语料库资源的建设，都是上层各种自然语言处理技术的基础，需要花费大量的人力和物力构建。基础任务包括分词、词性标注、句法分析和语义分析等，这些任务往往不直接面向终端用户，除了语言学上的研究价值，它们主要为上层应用任务提供所需的特征。应用任务包括信息抽取、情感分析、问答系统、机器翻译和对话系统等，它们往往可以作为产品直接被终端用户使用。本书第2章将对这些任务进行更详细的介绍。\n应用系统特指自然语言处理技术在某一领域的综合应用，又被称为NLP+，即自然语言处理技术加上特定的应用领域。如在智能教育领域，可以使用文本分类、回归等技术，实现主观试题的智能评阅，帮助教师减轻工作量，提高工作效率；在智慧医疗领域，自然语言处理技术可以帮助医生跟踪最新的医疗文献，帮助患者进行简单的自我诊断等；在智能司法领域，可以使用阅读理解、文本匹配等技术，实现自动量刑、类案检索和法条推荐等。总之，凡是涉及文本理解和生成的领域，自然语言处理技术都可以发挥巨大的作用。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用系 统 教 育 、 医 疗 、 司 法 、 金 融 、 机器人等 应用任务 信息抽 取 、 情感分 析 、 问答系 统 、 机器翻译和对话系统等 基础任务 分 词 、 词性标 注 、 句法分析和语义 分析等 资源建设 语言学知识库建设和语料资源建设 图1\u0026emsp;自然语言处理任务层级\n","date":"2024-10-15T19:05:40+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/computer_science/artificial_intelligence/natural_language_processing/introduction_to_natural_language_processing/","title":"自然语言处理（一）：自然语言处理概论"},{"content":" 数据库系统概论 数据库是数据管理的有效技术，是计算机科学的重要分支。今天，信息资源已成为各个部门的重要财富和资源。建立一个满足各级部门信息处理要求的行，之有效的信息系统也成为一个企业或组织生存和发展的重要条件。因此，作为信息系统核心和基础的数据库技术得到越来越广泛的应用，从小型单项事务处理系统到大型信息系统，从联机事务处理（On-Line Transaction Processing，OLTP）到联机分析处理（On-Line Analysis Processing，OLAP），从一般企业管理到计算机辅助设计与制造（CAD/CAM）、计算机集成制造系统（CIMS）、电子政务（e-Government）、电子商务（e-Commerce）、地理信息系统（GIS）等，越来越多的应用领域采用数据库技术来存储和处理信息资源。特别是随着互联网的发展，广大用户可以直接访问并使用数据库，例如通过网上订购图书、日用品、机票、火车票，通过网上银行转账存款取款、检索和管理赈户，等等。数据库已经成为每个人生活中不可缺少的部分。\n数据库系统概述 在系统地介绍数据库的基本概念之前，这里首先介绍一些数据库最常用的术语和基本概念。\n数据库的四个基本概念 数据、数据库、数据库管理系统和数据库系统是与数据库技术密切相关的4个基本概念。\n数据（Data） 数据是数据库中存储的基本对象。数据在大多数人头脑中的第一个反应就是数字，例如93、1000、99.5、-330.86、¥6880、$726等。其实数字只是最简单的一种数据，是数据的一种传统和狭义的理解。广义的理解认为数据的种类很多，例如文本（text）、图形（graph）、图像（image）、音频（audio）、视频（video）、学生的档案记录、货物的运输情况等，这些都是数据。\n可以对数据做如下定义：描述事物的符号记录称为数据。描述事物的符号可以是数字，也可以是文字、图形、图像、音频、视频等。数据有多种表现形式，它们都可以经过数字化后存入计算机。\n在现代计算机系统中数据的概念是广义的。早期的计算机系统主要用于科学计算，处理的数据是数值型数据，如整数、实数、浮点数等。现在计算机存储和处理的对象十分广泛，表示这些对象的数据也随之变得越来越复杂。\n数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的。例如，93是一个数据，可以是一个同学某门课的成绩，也可以是某个人的体重，还可以是计算机系2013级的学生人数。数据的解释是指对数据含义的说明，数据的含义称为数据的语义，数据与其语义是不可分的。\n在日常生活中，人们可以直接用自然语言（如汉语）来描述事物。例如，可以这样来描述某校计算机系一位同学的基本情况：李明同学，男，1995年5月生，江苏省南京市人，2013年入学。在计算机中常常这样来描述：\n（李明，男，199505，江苏省南京市，计算机系，2013）\n即把学生的姓名、性别、出生年月、出生地、所在院系、入学时间等组织在一起，构成一个记录。这里的学生记录就是描述学生的数据。这样的数据是有结构的。记录是计算机中表示和存储数据的一种格式或一种方法。\n数据库（DataBase,DB） 数据库，顾名思义，是存放数据的仓库。只不过这个仓库是在计算机存储设备上，而且数据是按一定的格式存放的。\n人们收集并抽取出一个应用所需要的大量数据之后，应将其保存起来，以供进一步加工处理，抽取有用信息。在科学技术飞速发展的今天，人们的视野越来越广，数据量急剧增加。过去人们把数据存放在文件柜里，现在人们借助计算机和数据库技术科学地保存和管理大量复杂的数据，以便能方便而充分地利用这些宝贵的信息资源。\n严格地讲，数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度（redundancy）、较高的数据独立性（data independency）和易扩展性（scalability）,并可为各种用户共享。\n概括地讲，数据库数据具有永久存储、有组织和可共享三个基本特点。\n数据库管理系统(DataBase Management System,DBMS) 了解了数据和数据库的概念，下一个问题就是如何科学地组织和存储数据，如何高效地获取和维护数据。完成这个任务的是一个系统软件\u0026mdash;\u0026mdash;数据库管理系统。数据库管理系统是位于用户与操作系统之间的一层数据管理软件。数据库管理系统和操作系统一样是计算机的基础软件，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面：\n1. 数据定义功能\n数据库管理系统提供数据定义语言（Data Definition Language,DDL），用户通过它可以方便地对数据库中的数据对象的组成与结构进行定义。\n2. 数据组织、存储和管理\n数据库管理系统要分类组织、存储和管理各种数据，包括数据字典、用户数据、数据的存取路径等。要确定以何种文件结构和存取方式在存储级上组织这些数据，如何实现数据之间的联系。数据组织和存储的基本目标是提高存储空间利用率和方便存取，提供多种存取方法（如索引查找、hash查找、顺序查找等）来提高存取效率。\n3. 数据操纵功能\n数据库管理系统还提供数据操纵语言（Data Manipulation Language,DML），用户可以使用它操纵数据，实现对数据库的基本操作，如查询、插入、删除和修改等。\n4. 数据库的事务管理和运行管理\n数据库在建立、运用和维护时由数据库管理系统统一管理和控制，以保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。\n5. 数据库的建立和维护功能\n数据库的建立和维护功能包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。这些功能通常是由一些实用程序或管理工具完成的。\n6. 其他功能\n其他功能包括数据库管理系统与网络中其他软件系统的通信功能，一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能，异构数据库之间的互访和互操作功能等。\n数据库系统 数据库系统是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator,DBA）组成的存储、管理、处理和维护数据的系统。应当指出的是，数据库的建立、使用和维护等工作只靠一个数据库管理系统远远不够，还要有专门的人员来完成，这些人被称为数据库管理员。\n数据库系统可以用图1.1表示。其中数据库提供数据的存储功能，数据库管理系统提供数据的组织、存取、管理和维护等基础功能，数据库应用系统根据应用需求使用数据库，数据库管理员负责全面管理数据库系统。图1.2是引入数据库后计算机系统的层次结构。\n在一般不引起混淆的情况下，人们常常把数据库系统简称为数据库。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 用户 ··· 用户 数据库管理系统 应用开发工具 应用系统 操作系统 数据库 数据库管理员 图1\u0026emsp;数据库系统\n‌\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 操作系统 硬件 数据库管理系统 应用开发工具 应用系统 图2\u0026emsp;引入数据库后计算机系统的层次结构\n数据管理技术的产生和发展 数据库技术是应数据管理任务的需要而产生的。数据管理是指对数据进行分类、组织、编码、存储、检索和维护，它是数据处理的中心问题。而数据的处理是指对各种数据进行收集、存储、加工和传播的一系列活动的总和。\n在应用需求的推动下，在计算机硬件、软件发展的基础上，数据管理技术经历了人工管理、文件系统、数据库系统三个阶段。这三个阶段的特点及其比较如下表所示。\n人工管理阶段 文件系统阶段 数据库系统阶段 背景 应用背景 科学计算 科学计算、数据管理 大规模数据管理 硬件背景 无直接存储设备 磁盘、磁鼓 大容量磁盘、磁盘阵列 软件背景 没有操作系统 有文件系统 有数据库管理系统 处理方式 批处理 联机实时处理、批处理 联机实时处理、分布处理、批处理 特点 数据的管理者 用户（程序员） 文件系统 数据库管理系统 数据面向的对象 某一应用程序 某一应用 现实世界（一个部门、企业、跨国组织等） 数据的共享程度 无共享，冗余度极大 共享性差，冗余度大 共享性高，冗余度小 数据的独立性 不独立，完全依赖于程序 独立性差 具有高度的物理独立性和一定的逻辑独立性 数据的结构化 无结构 记录内有结构，整体无结构 整体结构化，用数据模型描述 数据控制能力 应用程序自己控制 应用程序自己控制 由数据库管理系统提供数据安全性、完整性，并发控制和恢复能力 表1\u0026emsp;数据管理三个阶段的比较\n人工管理阶段 20世纪50年代中期以前，计算机主要用于科学计算。当时的硬件状况是，外存只有纸带、卡片、磁带，没有磁盘等直接存取的存储设备；软件状况是，没有操作系统，没有管理数据的专门软件；数据处理方式是批处理。人工管理数据具有如下特点：\n1. 数据不保存\n由于当时计算机主要用于科学计算，一般不需要将数据长期保存，只是在计算某一课题时将数据输入，用完就撤走。不仅对用户数据如此处置，对系统软件有时也是这样。\n2. 应用程序管理数据\n数据需要由应用程序自己设计、说明（定义）和管理，没有相应的软件系统负责数据的管理工作。应用程序中不仅要规定数据的逻辑结构，而且要设计物理结构，包括存储结构、存取方法、输入方式等。因此程序员负担很重。\n3. 数据不共享\n数据是面向应用程序的，一组数据只能对应一个程序。当多个应用程序涉及某些相同的数据时必须各自定义，无法互相利用、互相参照，因此程序与程序之间有大量的冗余数据。\n4. 数据不具有独立性\n数据的逻辑结构或物理结构发生变化后，必须对应用程序做相应的修改，数据完全依赖于应用程序，称之为数据缺乏独立性，这就加重了程序员的负担。\n在人工管理阶段，应用程序与数据之间的一一对应关系可用下图表示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用程序1 数据集1 应用程序2 数据集2 应用程序n 数据集n 图3\u0026emsp;人工管理阶段应用程序与数据之间的一一对应关系\n文件系统阶段 20世纪50年代后期到60年代中期，这时硬件方面已有了磁盘、磁鼓等直接存取存储设备：软件方面，操作系统中已经有了专门的数据管理软件，一般称为文件系统；处理方式上不仅有了批处理，而且能够联机实时处理。\n用文件系统管理数据具有如下特点：\n1. 数据可以长期保存\n由于计算机大量用于数据处理，数据需要长期保留在外存上反复进行查询、修改、插入和删除等操作。\n2. 由文件系统管理数据\n由专门的软件即文件系统进行数据管理，文件系统把数据组织成相互独立的数据文件，利用“按文件名访问，按记录进行存取”的管理技术，提供了对文件进行打开与关闭、对记录读取和写入等存取方式。文件系统实现了记录内的结构性。但是，文件系统仍存在以下缺点：\n数据共享性差，冗余度大。在文件系统中，一个(或一组)文件基本上对应于一个应用程序，即文件仍然是面向应用的。当不同的应用程序具有部分相同的数据时，也必须建立各自的文件，而不能共享相同的数据，因此数据的冗余度大，浪费存储空间。同时由于相同数据的重复存储、各自管理，容易造成数据的不一致性，给数据的修改和维护带来了困难。 数据独立性差。文件系统中的文件是为某一特定应用服务的，文件的逻辑结构是针对具体的应用来设计和优化的，因此要想对文件中的数据再增加一些新的应用会很困难。而且，当数据的逻辑结构改变时，应用程序中文件结构的定义必须修改，应用程序中对数据的使用也要改变,因此数据依赖于应用程序，缺乏独立性。可见，文件系统仍然是一个不具有弹性的无整体结构的数据集合，即文件之间是孤立的，不能反映现实世界事物之间的内在联系。 文件系统阶段应用程序与数据之间的关系如下图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用程序1 应用程序2 应用程序n 文件组1 文件组2 文件组n 存取方法 图4\u0026emsp;文件系统阶段应用程序与数据之间的对应关系\n数据库系统阶段 20世纪60年代后期以来，计算机管理的对象规模越来越大，应用范围越来越广泛，数据量急剧增长，同时多种应用、多种语言互相覆盖地共享数据集合的要求越来越强烈。\n这时硬件已有大容量磁盘，硬件价格下降；软件则价格上升，为编制和维护系统软件及应用程序所需的成本相对增加；在处理方式上，联机实时处理要求更多，并开始提出和考虑分布处理。在这种背景下，以文件系统作为数据管理手段已经不能满足应用的需求，于是为解决多用户、多应用共享数据的需求，使数据为尽可能多的应用服务，数据库技术便应运而生，出现了统一管理数据的专门软件系统\u0026mdash;\u0026mdash;数据库管理系统。\n用数据库系统来管理数据比文件系统具有明显的优点，从文件系统到数据库系统标志着数据管理技术的飞跃。\n数据库系统的特点 下面首先通过一个简单的例子\u0026mdash;\u0026ndash;学生学籍管理系统来比较文件系统和数据库系统的差异，从而阐述数据库系统的特点。\n例1：设一个学生的信息包括学号、姓名、性别、年龄、专业和奖励。部分学生的情况如表2所示。假设该学籍管理系统具有录入学生信息、根据学号可以找到一个学生信息等功能。\n学号 姓名 性别 年龄 专业 奖励 20100001 史玉明 女 20 计算机 2011校奖学金，2012国家奖学金 20100100 李明虎 男 21 机械 2012校优秀学生 20100234 张翔 男 21 化工 ··· ··· ··· ··· ··· ··· 表2\u0026emsp;学生一览表\n1. 采用文件系统实现学籍管理\n首先是如何存储学生数据。计算机操作系统实现了文件系统，可以把每个学生都具备的信息采用定长记录方式存放在一个“学生基本信息”文件中。有关奖励的数据有的学生较多，有的学生没有，因此采用变长记录方式把它存放在另外一个“奖励”文件中。“学生基本信息”文件的记录包括学号、姓名、性别、年龄、专业、位置和长度等字段，如表3所示。其中位置和长度描述的是另一个奖励文件（表4所示）中记录的开始位置和长度。文件系统管理的文件是流式文件，或者说只是一些字节流。因此，表3和表4是为了方便程序员理解的结构。程序员必须把它们在应用程序中加以说明和描述。\n学号 姓名 性别 年龄 专业 位置 长度 20100001 史玉明 女 20 计算机 0 30 20100100 李明虎 男 21 机械 30 15 20100234 张翔 男 21 化工 45 0 ··· ··· ··· ··· ··· ··· ··· 表3\u0026emsp;“学生基本信息”文件的结构和内容\n奖励 2011 校奖学金，2012 国家奖学金 2012 校优秀学生 ··· 表4\u0026emsp;“奖励”文件的结构内容\n确定了学生数据的存储方式后，需要编写程序来实现数据的录入功能和查询功能。录入功能的基本过程包括从键盘读入学生信息，把基本信息写到\u0026quot;学生基本信息”文件中，把奖励情况写到“奖励”文件中。特别要注意的是，为了能正确地表达“学生基本信息”文件中一条记录和“奖励”文件中记录的对应关系，在程序中要把奖励情况在文件中的开始位置和长度再写回\u0026quot;学生基本信息”文件中。\n查询功能采用顺序查找方法。首先从“学生基本信息”文件中读入第1条记录，然后比较学号字段的值是否和要查找的学号相同。如果相同，读出该学生的信息，并根据位置字段和长度字段的值到“奖励”文件中读出该学生的奖励信息，查找过程结束；如果不相同，则从“学生基本信息”文件中读入下一条记录，直到找到该学号的记录，或者读到文件末尾也没有该学号的学生为止。\n2. 采用数据库系统实现学籍管理\n首先在数据库中建立两张表：STUDENT存放学生的基本信息，AWARD存放学生的奖励情况。这可以用数据库管理系统的两条CREATE语句来实现：\n1 2 3 4 5 6 7 CREATE TABLE STUDENT( Sno CHAR(8), Sname CHAR(10), Ssex CHAR(2), Sage SMALLINT, Major CHAR(20)); CREATE TABLE AWARD( Sno CHAR(8), Details VARCHAR(2000)); 建立好表结构后，向数据库管理系统提交下面的两条插入命令就可以把学生的基本信 息和奖励情况保存到STUDENT和AWARD表中，完成录入功能。\n1 2 3 4 INSERT INTO STUDENT(Sno, Sname, Ssex,Sage, Major) VALUES(\u0026#39;2O1OOOO1\u0026#39;,\u0026#39;史玉明\u0026#39;,\u0026#39;女\u0026#39;,20,\u0026#39;计算机\u0026#39;) /*插入学生的基本信息*/ INSERT INTO AWARD(Sno, Deteils) VALUES(\u0026#39;20100001\u0026#39;,\u0026#39;2011校奖学金，2012国家奖学金\u0026#39;) /*插入学生获得的奖励*/ 查询功能可用一条查询语句实现：\n1 2 3 SELECT A.Sno, Sname, Ssex, Sage, Major, Details /*查询学号为20100001 学生的信息*/ FROM STUDENT A LEFT JOIN AWARD B ON A.Sno=B.Sno WHERE A.Sno = \u0026#39;20100001\u0026#39; 可以看出，无论采用文件系统还是数据库系统都可以实现本例中学籍管理的功能。但是，使用文件系统时，程序员要关注记录的结构和不同文件中记录之间的联系，使用文件系统提供的fopen（打开）、fread（读）、fwrite（写）、fseek（移动读写位置）、fclose（关闭）等操作来编程，工作量大、编程复杂，且开发速度慢；而数据库系统提供了功能强大的操作，如查询操作只需要写一条语句就可以实现，程序员的开发效率大大提高。\n与人工管理和文件系统相比，数据库系统的特点主要有一下几个方面。\n数据结构化 数据库系统实现整体数据的结构化，这是数据库的主要特征之一，也是数据库系统与文件系统的本质区别。\n在文件系统中，文件中的记录内部具有结构，但是记录的结构和记录之间的联系被固化在程序中，需要由程序员加以维护。这种工作模式既加重了程序员的负担，又不利于结构的变动。\n所谓“整体”结构化是指数据库中的数据不再仅仅针对某一个应用，而是面向整个组织或企业：不仅数据内部是结构化的，而且整体是结构化的，数据之间是具有联系的。也就是说，不仅要考虑某个应用的数据结构，还要考虑整个组织的数据结构。例如，一个学校的信息系统中不仅要考虑教务处的课程管理、学生选课管理、成绩管理，还要考虑学生处的学生学籍管理，同时还要考虑研究生院的研究生管理、人事处的教员人事管理、科研处的科研管理等。因此，学校信息系统中的学生数据就要面向各个处室的应用，而不仅仅是教务处的一个学生选课应用。可以参照下图为该校的信息系统组织其中的学生数据。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 日期 奖惩条目 姓名 与本人关系 详细情况 课程号 课程名称 家庭出身 籍贯 政治面貌 日期 学校 学历名 学号 课程号 学期 成绩 学号 姓名 性别 年龄 系 学生人事记录 奖惩情况记录 家庭成员记录 课程记录 学生学籍记录 学生选课记录 图5\u0026emsp;某学校信息系统中的学生数据\n图5的数据组织方式为各部门的应用提供了必要的记录，使整体数据结构化了。这就要求在描述数据时不仅要描述数据本身，还要描述数据之间的联系。在数据库系统中，记录的结构和记录之间的联系由数据库管理系统维护，从而减轻了程序员的工作量，提高了工作效率。\n在数据库系统中，不仅数据是整体结构化的，而且存取数据的方式也很灵活，可以存取数据库中的某一个或一组数据项、一个记录或一组记录；而在文件系统中，数据的存取单位是记录，粒度不能细到数据项。\n数据的共享性高、冗余度低且易扩充 数据库系统从整体角度看待和描述数据，数据不再面向某个应用而是面向整个系统，因此数据可以被多个用户、多个应用共享使用。数据共享可以大大减少数据冗余，节约存储空间。数据共享还能够避免数据之间的不相容性与不一致性。\n所谓数据的不一致性是指同一数据不同副本的值不一样。采用人工管理或文件系统管理时，由于数据被重复存储，当不同的应用使用和修改不同的副本时就很容易造成数据的不一致。在数据库中数据共享减少了由于数据冗余造成的不一致现象。\n由于数据面向整个系统，是有结构的数据，不仅可以被多个应用共享使用，而且容易增加新的应用，这就使得数据库系统弹性大，易于扩充，可以适应各种用户的要求。可以选取整体数据的各种子集用于不同的应用系统，当应用需求改变或增加时，只要重新选取不同的子集或加上一部分数据便可以满足新的需求。\n数据独立性高 数据独立性是借助数据库管理数据的一个显著优点，它已成为数据库领域中一个常用术语和重要概念，包括数据的物理独立性和逻辑独立性。\n物理独立性是指用户的应用程序与数据库中数据的物理存储是相互独立的。也就是说，数据在数据库中怎样存储是由数据库管理系统管理的，用户程序不需要了解，应用程序要处理的只是数据的逻辑结构，这样当数据的物理存储改变时应用程序不用改变。\n逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。也就是说，数据的逻辑结构改变时用户程序也可以不变。\n数据独立性是由数据库管理系统提供的二级映像功能来保证的，将在后面的内容中进行讨论。\n数据与程序的独立把数据的定义从程序中分离出去，加上存取数据的方法又由数据库管理系统负责提供，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n数据由数据库管理系统统一管理和控制 数据库的共享将会带来数据库的安全隐患，而数据库的共享是并发的（concurrency）‌共享，即多个用户可以同时存取数据库中的数据，甚至可以同时存取数据库中同一个数据，这又会带来不同用户间相互干扰的隐患。另外，数据库中数据的正确与一致也必须得到保障。为此，数据库管理系统还必须提供以下几方面的数据控制功能。\n数据的安全性（security）保护。数据的安全性是指保护数据以防止不合法使用造成的数据泄密和破坏。每个用户只能按规定对某些数据以某些方式进行使用和处理。 数据的完整性（integrity）检查。数据的完整性指数据的正确性、有效性和相容性。完整性检查将数据控制在有效的范围内，并保证数据之间满足一定的关系。 并发（concurrency）控制。当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果或使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。 数据库恢复（recovery）。计算机系统的硬件故障、软件故障、操作员的失误以及故意破坏也会影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失。数据库管理系统必须具有将数据库从错误状态恢复到某一己知的正确状态（亦称为完整状态或一致状态）的功能，这就是数据库的恢复功能。 数据库系统阶段应用程序与数据之间的对应关系可用图6表示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据库管理系统 应用程序1 应用程序2 数据库 图6\u0026emsp;数据库系统阶段应用程序与数据之间的对应关系\n综上所述，数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。\n数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段。这样既便于数据的集中管理，又能简化应用程序的研制和维护，提高了数据的利用率和相容性，提高了决策的可靠性。\n目前，数据库已经成为现代信息系统的重要组成部分。具有数百G、数百T、甚至数百P字节的数据库已经普遍存在于科学技术、工业、农业、商业、服务业和政府部门的信息系统中。\n数据模型 数据库技术是计算机领域中发展最快的技术之一。数据库技术的发展是沿着数据模型的主线推进的。模型，特别是具体模型对人们来说并不陌生。一张地图、一组建筑设计沙盘、一架精致的航模飞机都是具体的模型，一眼望去就会使人联想到真实生活中的事物。模型是对现实世界中某个对象特征的模拟和抽象。例如，航模飞机是对生活中飞机的一种模拟和抽象，它可以模拟飞机的起飞、飞行和降落，它抽象了飞机的基本特征——机头、机身、机翼、机尾。\n数据模型（data model）‌也是一种模型，它是对现实世界数据特征的抽象。也就是说数据模型是用来描述数据、组织数据和对数据进行操作的。由于计算机不可能直接处理现实世界中的具体事物，所以人们必须事先把具体事物转换成计算机能够处理的数据，也就是首先要数字化，把现实世界中具体的人、物、活动、概念用数据模型这个工具来抽象、表示和处理。通俗地讲，数据模型就是现实世界的模拟。\n现有的数据库系统均是基于某种数据模型的。数据模型是数据库系统的核心和基础。因此，了解数据模型的基本概念是学习数据库的基础。\n两类数据模型 数据模型应满足三方面要求：一是能比较真实地模拟现实世界，二是容易为人所理解，三是便于在计算机上实现。一种数据模型要很好地、全面地满足这三方面的要求在目前尚很困难。因此，在数据库系统中针对不同的使用对象和应用目的，采用不同的数据模型。\n如同在建筑设计和施工的不同阶段需要不同的图纸一样，在开发实施数据库应用系统中也需要使用不同的数据模型：概念模型、逻辑模型和物理模型。\n根据模型应用的不同目的，可以将这些模型划分为两大类，它们分别属于两个不同的层次。第一类是概念模型，第二类是逻辑模型和物理模型。 第一类概念模型（conceptual model），也称信息模型，它是按用户的观点来对数据和信息建模，主要用于数据库设计。\n第二类中的逻辑模型主要包括层次模型（hierarchical model）、网状模型（network model）、关系模型（relational model）、面向对象数据模型（object oriented data model）和对象关系数据模型（object relational data model)、半结构化数据模型（semistructured data model）等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。\n第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。物理模型的具体实现是数据库管理系统的任务，数据库设计人员要了解和选择物理模型，最终用户则不必考虑物理级的细节。\n数据模型是数据库系统的核心和基础。各种机器上实现的数据库管理系统软件都是基于某种数据模型或者说是支持某种数据模型的。\n为了把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型，人们常常首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。也就是说，首先把现实世界中的客观对象抽象为某一种信息结构，这种信息结构并不依赖于具体的计算机系统，不是某一个数据库管理系统支持的数据模型，而是概念级的模型；然后再把概念模型转换为计算机上某一数据库管理系统支持的数据模型，这一过程如图7所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 现实世界 认识抽象 概念模型 数据库管理系统支持的数据模型 信息世界 机器世界 图7\u0026emsp;现实世界中客观对象的抽象过程\n从现实世界到概念模型的转换是由数据库设计人员完成的；从概念模型到逻辑模型的转换可以由数据库设计人员完成，也可以用数据库设计工具协助设计人员完成；从逻辑模型到物理模型的转换主要是由数据库管理系统完成的。\n下面首先介绍概念模型，数据模型的组成要素，然后介绍三个常用的数据模型。\n概念模型 由图7可以看出，概念模型实际上是现实世界到机器世界的一个中间层次。\n概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有力工具，也是数据库设计人员和用户之间进行交流的语言，因此概念模型一方面应该具有较强的语义表达能力，能够方便、直接地表达应用中的各种语义知识，另一方面它还应该简单、清晰、易于用户理解。\n信息世界中的基本概念 信息世界主要涉及以下一些概念。\n实体（entity）。客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系，例如，一个职工、一个学生、一个部门、一门课、学生的一次选课、部门的一次订货、教师与院系的工作关系（即某位教师在某院系工作）等都是实体。 属性（attribute）。实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。例如，学生实体可以由学号、姓名、性别、出生年月、所在院系、入学时间等属性组成，属性组合(201315121，张山，男，199505，计算机系，2013)即表征了一个学生。 码（key）。唯一标识实体的属性集称为码。例如学号是学生实体的码。 实体型（entitytype）。具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。例如，学生（学号，姓名，性别，出生年月，所在院系，入学时间）就是一个实体型。 实体集（entityset）。同一类型实体的集合称为实体集。例如，全体学生就是一个实体集。 联系（relationship）。在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体内部的联系通常是指组成实体的各属性之间的联系，实体之间的联系通常是指不同实体集之间的联系。 实体之间的联系有一对一、一对多和多对多等多种类型。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集 \\(A\\) 与实体集 \\(B\\) 具有一对一联系。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中有 \\(n\\) 个实体（ \\(n \\ge 0\\) ）与之联系，反之，对于实体集 \\(B\\) 中的每一个实体，实体集 \\(A\\) 中至多只有一个实体与之联系，则称实体集 \\(A\\) 与实体集 \\(B\\) 有一对多联系。\n如果对于实体集 \\(A\\) 中的每一个实体，实体集 \\(B\\) 中有 \\(n\\) 个实体（ \\(n \\ge 0\\) ）与之联系，反之，对于实体集 \\(B\\) 中的每一个实体，实体集 \\(A\\) 中也有 \\(m\\) 个实体（ \\(m \\ge 0\\) ）与之联系，则称实体集 \\(A\\) 与实体集 \\(B\\) 具有多对多联系。例如一门课程可以同时有若干名学生选修，而一个学生可以同时选修多门课程，则课程实体与学生实体具有多对多联系。\n概念模型的一种表示方法：实体-联系方法 概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。概念模型的表示方法很多，其中最为常用的是P.P.S.Chen于1976年提出的实体-联系方法（Entity-Relationship approach）。该方法用E-R图（E-R diagram）‌来描述现实世界的概念模型，E-R方法也称为E-R模型。\n数据模型的组成要素 一般地讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件（integrity constraints）。因此数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。\n数据结构 数据结构描述数据库的组成对象以及对象之间的联系。也就是说，数据结构描述的内容有两类：一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等；一类是与数据之间联系有关的对象，如网状模型中的系型（set type）。\n数据结构是刻画一个数据模型性质最重要的方面。因此在数据库系统中，人们通常按照其数据结构的类型来命名数据模型。例如层次结构、网状结构和关系结构的数据模型分别命名为层次模型、网状模型和关系模型。\n总之，数据结构是所描述的对象类型的集合，是对系统静态特性的描述。\n数据操作 数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括（操作及有关的操作规则。\n数据库主要有查询和更新（包括插入、删除、修改）两大类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特性的描述。\n数据的完整性约束条件 数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容。\n数据模型应该反映和规定其必须遵守的基本的和通用的完整性约束条件。例如，在关系模型中，任何关系必须满足实体完整性和参照完整性两个条件。\n此外，数据模型还应该提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。例如，在某大学的数据库中规定学生成绩如果有6门以上不及格将不能授予学士学位，教授的退休年龄是65周岁，男职工的退休年龄是60周岁，女职工的退休年龄是55周岁等。\n常用数据模型 数据库领域中主要的逻辑数据模型有：\n层次模型(hierarchical model) 网状模型(network model) 关系模型(relational model) 面向对象数据模型(object oriented data model) 对象关系数据模型(object relational data model) 半结构化数据模型(semistructure data model) 其中层次模型和网状模型统称为格式化模型。\n格式化模型的数据库系统在20世纪70年代至80年代初非常流行，在数据库系统产品中占据了主导地位。层次数据库系统和网状数据库系统在使用和实现上都要涉及数据库物理层的复杂结构，现在已逐渐被关系模型的数据库系统取代。但在美国及欧洲的一些国家里，由于早期开发的应用系统都是基于层次数据库或网状数据库系统的，因此目前仍有一些层次数据库系统或网状数据库系统在继续使用。\n20世纪80年代以来，面向对象的方法和技术在计算机各个领域，包括程序设计语言、软件工程、信息系统设计、计算机硬件设计等方面都产生了深远的影响，也促进数据库中面向对象数据模型的研究和发展。许多关系数据库厂商为了支持面向对象模型，对关系模型做了扩展，从而产生了对象关系数据模型。\n随着Internet的迅速发展，Web上各种半结构化、非结构化数据源已经成为重要的信息来源，产生了以XML为代表的半结构化数据模型和非结构化数据模型。\n本篇简要介绍层次模型、网状模型和关系模型。其他新型的数据模型将在后续介绍。\n数据结构、数据操作和数据完整性约束条件这三个方面的内容完整地描述了一个数据模型，其中数据结构是刻画模型性质的最基本的方面。为了使读者对数据模型有一个基本认识，下面着重介绍三种模型的数据结构。\n注：这里讲的数据模型都是逻辑上的，也就是说是用户眼中看到的数据范围。同时它们又都是能用某种语言描述，使计算机系统能够理解，被数据库管理系统支持的数据视图。这些数据模型将以一定的方式存储于数据库系统中，这是数据库管理系统的功能，是数据库管理系统中的物理存储模型。\n在格式化模型中实体用记录表示，实体的属性对应记录的数据项（或字段）。实体之间的联系在格式化模型中转换成记录之间的两两联系。在格式化模型中数据结构的单位是基本层次联系。所谓基本层次联系是指两个记录以及它们之间的一对多（包括一对一）的联系，如图8所示。图中 \\(R_i\\) 位于联系 \\(L_{ij}\\) 的始点，称为双亲结点（parent）， \\(R_j\\) 位于联系 \\(L_{ij}\\) 的终点，称为子女结点（child）。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 双亲节点 一对多（包括一对一）联系名 子女节点 图8\u0026emsp;基本层次联系\n层次模型 层次模型是数据库系统中最早出现的数据模型，层次数据库系统采用层次模型作为数据的组织方式。层次数据库系统的典型代表是IBM公司的IMS（Information Management System），这是1968年IBM公司推出的第一个大型商用数据库管理系统，曾经得到广泛的使用。\n层次模型用树形结构来表示各类实体以及实体间的联系。现实世界中许多实体之间的联系本来就呈现出一种很自然的层次关系，如行政机构、家族关系等。\n1. 层次模型的数据结构\n在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：\n有且只有一个结点没有双亲结点，这个结点称为根结点。 根以外的其他结点有且只有一个双亲结点。 在层次模型中，每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。这就使得层次数据库系统只能处理一对多的实体联系。\n每个记录类型可包含若干个字段，这里记录类型描述的是实体，字段描述实体的属性。各个记录类型及其字段都必须命名。各个记录类型、同一记录类型中各个字段不能同名。每个记录类型可以定义一个排序字段，也称为码字段，如果定义该排序字段的值是唯一的，则它能唯一地标识一个记录值。\n一个层次模型在理论上可以包含任意有限个记录类型和字段，但任何实际的系统都会因为存储容量或实现复杂度而限制层次模型中包含的记录类型个数和字段的个数。\n在层次模型中，同一双亲的子女结点称为兄弟结点（twin或sibling），没有子女结点的结点称为叶结点。图9给出了一个层次模型的例子。其中， \\(R_1\\) 为根结点； \\(R_2\\) 和 \\(R_3\\) 为兄弟结点，是 \\(R_1\\) 的子女结点； \\(R_4\\) 和 \\(R_5\\) 为兄弟结点，是 \\(R_2\\) 的子女结点； \\(R_3\\) 、 \\(R_4\\) 和 \\(R_5\\) 为叶结点。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 根结点 兄弟结点 兄弟结点 叶节点 叶节点 叶节点 图9\u0026emsp;一个层次模型的示例\n从图9上可以看出层次模型像一棵倒立的树，结点的双亲是唯一的。\n层次模型的一个基本的特点是，任何一个给定的记录值只能按其层次路径查看，没有一个子女记录值能够脱离双亲记录值而独立存在。\n图10是一个教员学生层次模型。该层次模型有4个记录类型。记录类型系是根结点,由系编号、系名、办公地点三个字段组成。它有两个子女结点教研室和学生。记录类型教研室是系的子女结点，同时又是教员的双亲结点，它由教研室编号、教研室名两个字段组成。记录类型学生由学号、姓名、成绩三个字段组成。记录类型教员由职工号、姓名、研究方向三个字段组成。学生与教员是叶结点，它们没有子女结点。由系到教研室、由教研室到教员、由系到学生均是一对多的联系。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 系编号 系名 办公地点 系 教研室编号 教研室名 教研室 学号 姓名 成绩 学生 职工号 姓名 研究方向 教员 图10\u0026emsp;教员学生层次数据库模型\n图11是图10数据模型对应的一个值。该值是D02系（计算机科学系）记录值及其所有后代记录值组成的一棵树。D02系有三个教研室子女记录值R01、R02、R03和三个学生记录值S63871、S63874,S63876。教研室R01有三个教员记录值E2101、E1709,E3501；教研室R03有两个教员记录值E1101、E3102。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e D02 计算机 办公地点 系 教研室 S63871 文晓静 A 学生 E2101 王大明 数据库 教员 R02 信息系统 R01 数据库 R03 网络 S63874 刘华 C S63876 张君 A E1709 冯灵 数据仓库 E3501 孟勇 并行数据库 E1101 陈芝 网络安全 E3102 张豪 网络管理 图11\u0026emsp;教员学生层次数据库的一个值\n2. 层次模型的数据操纵和完整性约束\n层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。\n进行插入操作时，如果没有相应的双亲结点值就不能插入它的子女结点值。例如在图11的层次数据库中，若新调入一名教员，但尚未分配到某个教研室，这时就不能将新教员插入到数据库中。\n进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。例如在图10的层次数据库中，若删除网络教研室，则该教研室所有教员的数据将全部丢失。\n3. 层次模型的优缺点\n层次模型的优点主要有：\n层次模型的数据结构比较简单清晰。 层次数据库的查询效率高。因为层次模型中记录之间的联系用有向边表示，这种联系在DBMS中常常用指针来实现。因此这种联系也就是记录之间的存取路径。当要存取某个结点的记录值，DBMS就沿着这一条路径很快找到该记录值，所以层次数据库的性能优于关系数据库，不低于网状数据库。 层次数据模型提供了良好的完整性支持。 层次模型的缺点主要有：\n现实世界中很多联系是非层次性的，如结点之间具有多对多联系，不适合用层次模型表示。 如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂。 查询子女结点必须通过双亲结点。 由于结构严密，层次命令趋于程序化。 可见，用层次模型对具有一对多的层次联系的部门描述非常自然、直观，容易理解。这是层次数据库的突出优点。\n网状模型 在现实世界中事物之间的联系更多的是非层次关系的，用层次模型表示非树形结构是很不直接的，网状模型则可以克服这一弊病。\n网状数据库系统采用网状模型作为数据的组织方式。网状数据模型的典型代表是DBTG系统，亦称CODASYL系统。这是20世纪70年代数据系统语言研究会（Conference On Data System Language,CODASYL）下属的数据库任务组（Data Base Task Group,DBTG）提出的一个系统方案。DBTG系统虽然不是实际的数据库系统软件，但是它的基本概念、方法和技术具有普遍意义，对于网状数据库系统的研制和发展起了重大的影响。后来不少系统都采用DBTG模型或者简化的DBTG模型，如Cullinet Software公司的IDMS、Univac公司的DMS1100、Honeywell公司的IDS/2、HP公司的IMAGE等。\n1. 网状模型的数据结构\n在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：\n允许一个以上的结点无双亲。 一个结点可以有多于一个的双亲。 网状模型是一种比层次模型更具普遍性的结构。它去掉了层次模型的两个限制，允许多个结点没有双亲结点，允许结点有多个双亲结点；此外它还允许两个结点之间有多种联系（称之为复合联系）。因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。\n与层次模型一样，网状模型中每个结点表示一个记录类型（实体），每个记录类型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）之间一对多的父子联系。\n从定义可以看出，层次模型中子女结点与双亲结点的联系是唯一的，而在网状模型中这种联系可以不唯一。因此要为每个联系命名，并指出与该联系有关的双亲记录和子女记录。例如图12(a)中 \\(R_3\\) 有两个双亲记录 \\(R_1\\) 和 \\(R_2\\) ，因此把 \\(R_1\\) 与 \\(R_3\\) 之间的联系命名为 \\(L_1\\) ， \\(R_2\\) 与 \\(R_3\\) 之间的联系命名为 \\(L_2\\) 。图12(a)、(b)、(c)都是网状模型的例子。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e (a) (b) (c) 图12\u0026emsp;网状模型的例子\n下面以学生选课为例，看一看网状数据库是怎样来组织数据的。\n按照常规语义，一个学生可以选修若干门课程，某一课程可以被多个学生选修，因此学生与课程之间是多对多联系。因为DBTG模型中不能表示记录之间多对多的联系，为此引进一个学生选课的连接记录，它由三个数据项组成，即学号、课程号、成绩，表示某个学生选修某一门课程及其成绩。这样，学生选课数据库包括三个记录：学生、课程和选课。\n每个学生可以选修多门课程，显然对学生记录中的一个值，选课记录中可以有多个值与之联系，而选课记录中的一个值，只能与学生记录中的一个值联系。学生与选课之间的联系是一对多的联系，联系名为S-SC。同样，课程与选课之间的联系也是一对多的联系，联系名为C-SC。图1.13所示为学生选课数据库的网状数据模型。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 学号 姓名 系别 学生 课程号 课程名 学分 课程 学号 课程号 成绩 选课 S-SC C-SC 图13\u0026emsp;学生选课数据库的网状数据模型\n2. 网状模型的数据操纵与完整性约束\n网状模型一般来说没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。 例如，DBTG在模式数据定义语言中提供了定义DBTG数据库完整性的若干概念和语句，主要有：\n支持记录码的概念，码即唯一标识记录的数据项的集合。例如，学生记录（如图13）中学号是码，因此数据库中不允许学生记录中学号出现重复值。 保证一个联系中双亲记录和子女记录之间是一对多的联系。 可以支持双亲记录和子女记录之间的某些约束条件。例如，有些子女记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。例如图13中选课记录就应该满足这种约束条件，学生选课记录值必须是数据库中存在的某一学生选修存在的某一门课的记录。 DBTG提供了\u0026quot;属籍类别”的概念来描述这类约束条件。 3. 网状模型的主要优点\n网状模型的优点主要有：\n能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多 种联系。 具有良好的性能，存取效率较高。 网状模型的缺点主要有：\n结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不 利于最终用户掌握。 网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C）中。用户不容易掌握，不容易使用。 由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，加重了编写应用程序的负担。 关系模型 关系模型是最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式。\n1970年，美国IBM公司SanJose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型，开创了数据库关系方法和关系数据理论的研究，为数据库技术奠定了理论基础。由于E.F.Codd的杰出工作，他于1981年获得ACM图灵奖。\n20世纪80年代以来，计算机厂商新推出的数据库管理系统几乎都支持关系模型，非关系系统的产品也大都加上了关系接口。数据库领域当前的研究工作也都是以关系方法为基础。因此本书的重点也将放在关系数据库上，后面各章将详细介绍关系数据库。\n1. 关系模型的数据结构\n关系模型与以往的模型不同，它是建立在严格的数学概念的基础上的。严格的定义将在第二章“关系数据库”中给出。这里只简单勾画一下关系模型。从用户观点看，关系模型由一组关系组成。每个关系的数据结构是一张规范化的二维表。下面以学生登记表（如表5所示）为例，介绍关系模型中的一些术语。\n学生登记表\n学号 姓名 年龄 性别 系名 年级 2013004 王小明 19 女 社会学 2013 2013006 黄大鹏 20 男 商品学 2013 2013008 张文斌 18 女 法律 2013 \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; 表5\u0026emsp;关系模型的数据结构\n关系（relation）： 一个关系对应通常说的一张表，例如图1.14中的这张学生登记表。 元组（tuple）：表中的一行即为一个元组。 属性（attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名。 如表5所示的表有6列，对应6个属性（学号，姓名，年龄，性别，系名和年级）。 码（key）：也称为码键。表中的某个属性组，它可以唯一确定一个元组，如图1.14 中的学号可以唯一确定一个学生，也就成为本关系的码。 域（domain）：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。 如人的年龄一般在1〜120岁之间，大学生年龄属性的域是（15〜45岁），性别的域是（男，女），系名的域是一个学校所有系名的集合。 分量：元组中的一个属性值。 关系模式：对关系的描述，一般表示为\n\\[ 关系名（属性1、属性2、···、属性n） \\tag{1} \\] 例如，上面的关系可描述为\n\\[ 学生（堂号，姓名，年龄，性别，系名，年级） \\tag{2} \\] 关系模型要求关系必须是规范化的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项，也就是说，不允许表中还有表。例如，图1.15中工资和扣除是可分的数据项，工资又分为基本工资、岗位津贴和业绩津贴，扣除又分为三险和个人所得税。因此，图1.15的表就不符合关系模型要求。 职工号 姓名 职称 工资 扣除 实发 基本工资 岗位津贴 业绩津贴 三险 个人所得税 86051 陈平 讲师 1305 1200 2850 160 112 4083 表6\u0026emsp;一个工资表（表中有表）示例\n可以把关系和现实生活中的表格所使用的术语做一个粗略的对比，如表L5所示。\n关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 （一张）二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 表中有表（大表中嵌有小表） 表7\u0026emsp;术语对比\n2. 关系模型的数据操纵与完整性约束\n关系模型的数据操纵主要包括查询、插入、删除和更新数据。这些操作必须满足关系的完整性约束条件。关系的完整性约束条件包括三大类：实体完整性、参照完整性和用户定义的完整性。其具体含义将在后续内容中介绍。\n关系模型中的数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集 合，而不像格式化模型中那样是单记录的操作方式。另一方面，关系模型把存取路径向用 户隐蔽起来，用户只要指出“干什么”或\u0026quot;找什么”，不必详细说明\u0026quot;怎么干”或\u0026quot;怎么找”, 从而大大地提高了数据的独立性，提高了用户生产率。\n3. 关系模型的优缺点\n关系模型具有下列优点：\n关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。 关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。 关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。 所以关系模型诞生以后发展迅速，深受用户的喜爱。\n当然，关系模型也有缺点，例如，由于存取路径对用户是隐蔽的，查询效率往往不如 格式化数据模型。为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。不过用户不必考虑这些系统内部的优化技术细节。\n数据库系统的结构 考察数据库系统的结构可以有多种不同的层次或不同的角度。从数据库应用开发人员角度看，数据库系统通常采用三级模式结构，这是数据库系统内部的系统结构。从数据库 最终用户角度看，数据库系统的结构分为单用户结构、主从式结构、分布式结构、客户\u0026mdash;服务器、浏览器\u0026mdash;应用服务器/数据库服务器多层结构等。这是数据库系统外部的体系结构。\n本篇介绍数据库系统的模式结构。\n数据库模式的概念 在数据模型中有“型”（type）和“值”（value）的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。例如，学生记录定义为（学号，姓名，性别，系别，年龄，籍贯）这样的记录型，而（201315130,李明，男，计算机系，19,江苏南京市）则是该记录型的一个记录值。\n模式（schema）是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述,不涉及具体的值。模式的一个具体值称为模式的一个实例（instance）。同一个模式可以有很多实例。\n例如，在学生选课数据库模式中包含学生记录、课程记录和学生选课记录，现有一个具体的学生选课数据库实例，该实例包含了2013年学校中所有学生的记录（如果某校有10000个学生，则有10000个学生记录）、学校开设的所有课程的记录和所有学生选课的记录。2012年度学生选课数据库模式对应的实例与2013年度学生选课数据库模式对应的实例是不同的。实际上2013年度学生选课数据库的实例也会随时间变化，因为在该年度有的学生可能退学，有的学生可能转系。各个时刻学生选课数据库的实例是不同的、在变化的，不变的是学生选课数据库模式。\n模式是相对稳定的，而实例是相对变动的，因为数据库中的数据是在不断更新的。模式反映的是数据的结构及其联系，而实例反映的是数据库某一时刻的状态。 虽然实际的数据库管理系统产品种类很多，它们支持不同的数据模型，使用不同的数据库语言，建立在不同的操作系统之上，数据的存储结构也各不相同，但它们在体系结构上通常都具有相同的特征，即采用三级模式结构（早期微机上的小型数据库系统除外）并提供两级映像功能。\n数据库的三级模式模式结构 数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成，如图14所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 应用A 应用B 应用C 应用D 应用E 外模式1 外模式3 外模式2 内模式 模式 数据库 外模式/模式映像 内模式/模式映像 图14\u0026emsp;数据库系统的三级模式结构\n模式（shema） 模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。它是数据库系统模式结构的中间层，既不涉及数据的物理存储细节和硬件环境，又与具体的应用程序、所使用的应用开发工具及高级程序设计语言无关。\n模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。定义模式时不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等；而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。\n外模式（external schema） 外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。\n外模式通常是模式的子集。一个数据库可以有多个外模式。由于它是各个用户的数据视图，如果不同的用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，则其外模式描述就是不同的。即使对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。另一方面，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。\n外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据是不可见的。\n数据库管理系统提供外模式数据定义语言（外模式DDL）‌来严格地定义外模式。\n内模式（internal schema） 内模式也称存储模式（storageschema）,一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储还是按照某个（些）属性值的升（降）序存储，或按照属性值聚簇（cluster）存储：索引按照什么方式组织，是B+树索引还是hash索引；数据是否压缩存储，是否加密；数据的存储记录结构有何规定，如定长结构或变长结构，一个记录不能跨物理页存储；等等。\n数据库的二级映像功能与数据独立性 数据库系统的三级模式是数据的三个抽象级别，它把数据的具体组织留给数据库管理系统管理，使用户能逻辑地、抽象地处理数据，而不必关心数据在计算机中的具体表示方式与存储方式。为了能够在系统内部实现这三个抽象层次的联系和转换，数据库管理系统在这三级模式之间提供了两层映像：外模式/模式映像和模式/内模式映像。正是这两层映像保证了数据库系统中的数据能够具有较高的逻辑独立性和物理独立性。\n外模式/模式映像 模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映像，它定义了该外模式与模式之间的对应关系。这些映像定义通常包含在各自外模式的描述中。\n当模式改变时（例如增加新的关系、新的属性、改变属性的数据类型等），由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。\n模式/内模式映像 数据库中只有一个模式，也只有一个内模式，所以模式/内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的。该映像定义通常包含在模式描述中。当数据库的存储结构改变时（例如选用了另一种存储结构），由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。\n在数据库的三级模式结构中，数据库模式即全局逻辑结构是数据库的中心与关键，它独立于数据库的其他层次。因此设计数据库模式结构时应首先确定数据库的逻辑模式。\n数据库的内模式依赖于它的全局逻辑结构，但独立于数据库的用户视图，即外模式，也独立于具体的存储设备。它是将全局逻辑结构中所定义的数据结构及其联系按照一定的物理存储策略进行组织，以达到较好的时间与空间效率。\n数据库的外模式面向具体的应用程序，它定义在逻辑模式之上，但独立于存储模式和存储设备。当应用需求发生较大变化，相应的外模式不能满足其视图要求时，该外模式就得做相应改动，所以设计外模式时应充分考虑到应用的扩充性。\n特定的应用程序是在外模式描述的数据结构上编制的，它依赖于特定的外模式，与数据库的模式和存储结构独立。不同的应用程序有时可以共用同一个外模式。数据库的二级映像保证了数据库外模式的稳定性，从而从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改。\n数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。\n数据库系统的组成 在本章一开始介绍了数据库系统一般由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员构成。下面分别介绍这几个部分的内容。\n硬件平台数据库 由于数据库系统的数据量都很大，加之数据库管理系统丰富的功能使得其自身的规模也很大，因此整个数据库系统对硬件资源提出了较高的要求，这些要求是：\n要有足够大的内存，存放操作系统、数据库管理系统的核心模块、数据缓冲区和应用程序。 有足够大的磁盘或磁盘阵列等设备存放数据库，有足够大的磁带（或光盘）作数据备份。 要求系统有较高的通道能力，以提高数据传送率。 软件 数据库系统的软件主要包括：\n数据库管理系统。数据库管理系统是为数据库的建立、使用和维护配置的系统软件。 支持数据库管理系统运行的操作系统。 具有与数据库接口的高级语言及其编译系统，便于开发应用程序。 以数据库管理系统为核心的应用开发工具。应用开发工具是系统为应用开发人员和最终用户提供的高效率、多功能的应用生成器、第四代语言等各种软件工具。它们为数据库系统的开发和应用提供了良好的环境。 为特定应用环境开发的数据库应用系统。 人员 开发、管理和使用数据库系统的人员主要包括数据库管理员、系统分析员和数据库设计人员、应用程序员和最终用户。不同的人员涉及不同的数据抽象级别，具有不同的数据视图，如图15所示。这些人员分别包括如下职责。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 外模式 模式 内模式 数据库 客户端 应用系统 数据库管理系统 操作系统 用户 应用程序员 数据库管理员系统分析员 图15\u0026emsp;各种人员的数据视图\n1. 数据库管理员（Database Administrator,DBA）\n在数据库系统环境下有两类共享资源，一类是数据库，另一类是数据库管理系统软件。因此需要有专门的管理机构来监督和管理数据库系统。数据库管理员则是这个机构的一个（组）人员，负责全面管理和控制数据库系统。具体包括如下职责。\n决定数据库中的信息内容和结构。数据库中要存放哪些信息，数据库管理员要参与决策。因此，数据库管理员必须参加数据库设计的全过程，并与用户、应用程序员、系统分析员密切合作、共同协商，做好数据库设计。 决定数据库的存储结构和存取策略。数据库管理员要综合各用户的应用要求，和数据库设计人员共同决定数据的存储结构和存取策略，以求获得较高的存取效率和存储空间利用率。 定义数据的安全性要求和完整性约束条件。数据库管理员的重要职责是保证数据库的安全性和完整性。因此，数据库管理员负责确定各个用户对数据库的存取权限、数据的保密级别和完整性约束条件。 监控数据库的使用和运行。数据库管理员还有一个重要职责就是监视数据库系统的运行情况，及时处理运行过程中出现的问题。比如系统发生各种故障时，数据库会因此遭到不同程度的破坏，数据库管理员必须在最短时间内将数据库恢复到正确状态，并尽可能不影响或少影响计算机系统其他部分的正常运行。为此，数据库管理员要定义和实施适当的后备和恢复策略，如周期性的转储数据、维护日志文件等。 数据库的改进和重组、重构。数据库管理员还负责在系统运行期间监视系统的空间利用率、处理效率等性能指标，对运行情况进行记录、统计分析，依靠工作实践并根据实际应用环境不断改进数据库设计。不少数据库产品都提供了对数据库运行状况进行监视和分析的工具，数据库管理员可以使用这些软件完成这项工作。 另外，在数据运行过程中，大量数据不断插入、删除、修改，时间一长，数据的组织结构会受到严重影响，从而降低系统性能。因此，数据库管理员要定期对数据库进行重组织，以改善系统性能。当用户的需求增加和改变时，数据库管理员还要对数据库进行较大的改造，包括修改部分设计，即数据库的重构。\n2. 系统分析员和数据库设计人员\n系统分析员负责应用系统的需求分析和规范说明，要和用户及数据库管理员相结合，确定系统的硬件软件配置，并参与数据库系统的概要设计。\n数据库设计人员负责数据库中数据的确定及数据库各级模式的设计。数据库设计人员必须参加用户需求调查和系统分析，然后进行数据库设计。在很多情况下，数据库设计人员就由数据库管理员担任。\n3. 应用程序员\n应用程序员负责设计和编写应用系统的程序模块，并进行调试和安装。\n4. 用户\n这里用户是指最终用户（end user）。最终用户通过应用系统的用户接口使用数据库。常用的接口方式有浏览器、菜单驱动、表格操作、图形显示、报表书写等。\n最终用户可以分为如下三类。\n偶然用户。这类用户不经常访问数据库，但每次访问数据库时往往需要不同的数据库信息，这类用户一般是企业或组织机构的高中级管理人员。 简单用户。数据库的多数最终用户都是简单用户，其主要工作是查询和更新数据库，一般都是通过应用程序员精心设计并具有友好界面的应用程序存取数据库。银行的职员、航空公司的机票预订工作人员、宾馆总台服务员等都属于这类用户。 复杂用户。复杂用户包括工程师、科学家、经济学家、科学技术工作者等具有较高科学技术背景的人员。这类用户一般都比较熟悉数据库管理系统的各种功能，能够直接使用数据库语言访问数据库，甚至能够基于数据库管理系统的应用程序接口编制自己的应用程序。 健康的人才有资格谈恋爱，把爱情拿来治病只会病得更严重。 ― 邱妙津, 《鳄鱼手记》 ","date":"2024-10-15T16:49:13+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/computer_science/database_system/introduction_to_database_system/","title":"数据库系统（一）：数据库系统概论"},{"content":" 拓扑空间 拓扑空间 拓扑空间的定义 定义1（拓扑空间）：设 \\(X\\) 是一非空集合， \\(X\\) 的一个子集族 \\(\\tau\\) 称为 \\(X\\) 的一个拓扑，如果它满足\n\\(X,\\varnothing\\) 都包含在 \\(\\tau\\) 中。 \\(\\tau\\) 中任意多个成员的并集仍在 \\(\\tau\\) 中。 \\(\\tau\\) 中有限多个成员的交集仍在 \\(\\tau\\) 中。 集合 \\(X\\) 和它的一个拓扑 \\(\\tau\\) 一起称为一个拓扑空间，记作 \\((X,\\tau)\\) 。称 \\(\\tau\\) 中的成员为这个拓扑空间的开集。\n定义中的三个条件称为拓扑公理。3. 可等价地换为\n3\\('\\). \\(\\tau\\) 中两个成员的交集仍在 \\(\\tau\\) 中。\n3. 蕴含 3\\('\\). ，另一方面易用归纳法从3\\('\\). 推出 3. 。\n从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。这种规定不是任意的，必须满足三条拓扑公理。但一般来说一个集合上可以规定许多不相同的拓扑，因此说到一个拓扑空间时，要同时指明集合及所规定的拓扑，以后在不会引起误解的情况下，也常常只用集合来称呼一个拓扑空间，如拓扑空间 \\(X\\) ，拓扑空间 \\(Y\\) 等。\n设 \\(X\\) 是一非空集合，显然 \\(2^X\\) 满足三个拓扑公理（见幂集），构成 \\(X\\) 上的拓扑，称为 \\(X\\) 上的离散拓扑；\\(\\set{X,\\varnothing}\\) 也是 \\(X\\) 上的拓扑，称为 \\(X\\) 上的平凡拓扑。当 \\(X\\) 中包含多余一个点时，这两个拓扑不相同，并且 \\(X\\) 还有许多别的拓扑。例如设 \\(X=\\set{a,b,c}\\) ，则 \\(\\set{X,\\varnothing,\\set{a}}\\) 、 \\(\\set{X,\\varnothing,\\set{a,b}}\\) 、 \\(\\set{X,\\varnothing,\\set{a},\\set{a,b}}\\) 都是 \\(X\\) 上的拓扑；但 \\(\\set{X,\\varnothing,\\set{a},\\set{b}}\\) 不是拓扑，因为条件2. 不满足。\n设 \\(\\tau_1,\\tau_2\\) 是集合 \\(X\\) 上的两个拓扑，如果 \\(\\tau_1 \\subset \\tau_2\\) ，则说 \\(\\tau_2\\) 比 \\(\\tau_1\\) 大（或者说 \\(\\tau_2\\) 比 \\(\\tau_1\\) 精细）。离散拓扑比任何别的拓扑都大，而平凡拓扑比任何拓扑都小。\n下面给出几个拓扑的例子。\n例1：设 \\(X\\) 是无穷集合， \\(\\tau_f=\\set{A^c|A是X的有限子集}\\bigcup\\set{\\varnothing}\\) ，则不难验证 \\(\\tau_f\\) 是 \\(X\\) 上的一个拓扑，成为 \\(X\\) 上的余有限拓扑。\n例2：设 \\(X\\) 是不可数无穷集合， \\(\\tau_c=\\set{A^c|A是X的可数子集}\\bigcup\\set{\\varnothing}\\) ，则 \\(\\tau_c\\) 也是 \\(X\\) 的拓扑，成为余可数拓扑。\n例3：\n","date":"2024-10-15T14:00:15+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/mathematics/topology/point_set_topology/topological_space/","title":"点集拓扑（一）：拓扑空间"},{"content":" 函数的无穷级数和无穷乘积展开 在本文中，我们介绍一些在初等数学课程里不常讲到的关于函数的无穷级数展开，无穷乘积展开和渐近展开。\nBernoulli多项式和Bernoulli数 定义1（Bernoulli多项式）：称下列展开式给出的 \\(\\varphi_n(x)(n=0,1,2,\\cdots)\\) 为Bernoulli多项式\n\\[ \\frac{te^{xt}}{e^t-1}=\\sum_{n=0}^{\\infin}\\frac{t^n}{n!}\\varphi_n(x) \\tag{1} \\] 左方的函数称为Bernoulli多项式的生成函数。级数在 \\(|t|\u003c2\\pi\\) 时收敛，因为左方函数离 \\(t=0\\) 最近的奇点是 \\(t=\\pm 2\\pi i\\) （ \\(|t|\u003c2\\pi\\) 时没有奇点故值有限）。\n","date":"2024-10-06T22:21:34+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/mathematics/analysis/special_functions/infinite_expansions/","title":"特殊函数（一）：函数的无穷级数和无穷乘积展开"},{"content":" Legendre函数 Legendre函数是一类特殊函数，在数学和物理学中扮演着重要的角色，特别是在涉及到球面和多项式近似的领域。作为一类正交多项式，勒让德多项式具有独特的性质，使其在数值分析、量子力学和电磁学等多个领域中广泛应用。尽管勒让德函数的应用十分广泛，但它们的理论基础及其数学性质同样值得深入研究。本篇文篇将重点探讨勒让德函数的定义、性质以及相关的数学工具，旨在为读者提供对这一重要数学对象的全面理解。\nLegendre函数 普通Legendre函数 定义1（Legendre方程）：将如下方程定义为Legendre方程（普通Legendre方程）\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+\\nu(\\nu+1)y=0 \\tag{1} \\] \\(\\nu\\) 和 \\(x\\) 可以是任何复数。该方程的解称为Legendre函数（普通Legendre函数）。\n连带Legendre函数 定义2（连带Legendre方程）：将如下方程定义为连带Legendre方程\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+\\left(\\nu(\\nu+1)-\\frac{\\mu}{1-x^2}\\right)y=0 \\tag{2} \\] 该方程的解称为连带Legendre函数。可以看到，Legendre方程是连带Legendre方程在 \\(\\mu=0\\) 时的特殊情况。\n该方程有三个奇点： \\(-1,1,\\infin\\) ，而且都是正则奇点，指标分别为 \\(\\displaystyle\\left(\\frac{\\mu}{2},-\\frac{\\mu}{2}\\right),\\left(\\frac{\\mu}{2},-\\frac{\\mu}{2}\\right),\\left(\\nu+1,\\nu\\right)\\) ，因此这个方程属于超几何方程类型。它的解也可以用超几何方程表达。由《特殊函数概论》2.9节(12)和(16)有该方程解为\n\\[ P \\begin{Bmatrix} -1 \u0026 1 \u0026 \\infin \u0026 \\\\[10pt] \\displaystyle\\frac{\\mu}{2} \u0026 \\displaystyle\\frac{\\mu}{2} \u0026 \\nu+1; \u0026 x\\\\[10pt] \\displaystyle-\\frac{\\mu}{2} \u0026 \\displaystyle-\\frac{\\mu}{2} \u0026 -\\nu \u0026 \\end{Bmatrix} =P \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] \\displaystyle\\frac{\\mu}{2} \u0026 \\displaystyle\\frac{\\mu}{2} \u0026 \\nu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] \\displaystyle-\\frac{\\mu}{2} \u0026 \\displaystyle-\\frac{\\mu}{2} \u0026 -\\nu \u0026 \\end{Bmatrix} \\\\[10pt] =\\left(\\frac{1-x}{2}\\right)^{\\frac{\\mu}{2}}\\left(1-\\frac{1-x}{2}\\right)^{\\frac{\\mu}{2}} \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] 0 \u0026 0 \u0026 \\nu+\\mu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] -\\mu \u0026 -\\mu \u0026 -\\nu+\\mu \u0026 \\end{Bmatrix} \\\\[10pt] =2^{-\\mu}(1-x^2)^{\\frac{\\mu}{2}}P \\begin{Bmatrix} 1 \u0026 0 \u0026 \\infin \u0026 \\\\[10pt] 0 \u0026 0 \u0026 \\nu+\\mu+1; \u0026 \\displaystyle\\frac{1-x}{2}\\\\[10pt] -\\mu \u0026 -\\mu \u0026 -\\nu+\\mu \u0026 \\end{Bmatrix} \\tag{3} \\] 在实际应用中最常见的是 \\(\\mu\\) 和 \\(\\nu\\) 都等于整数的情形。当 \\(\\mu\\) 和 \\(\\nu\\) 不是整数时，需要较多地用到超几何函数理论。\nLegendre多项式 Legendre多项式的定义 定义3（Legendre多项式）：Legendre多项式是如下Legendre方程的多项式解\n\\[ (1-x^2)\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}-2x\\frac{\\mathrm{d}y}{\\mathrm{d}x}+n(n+1)y=0\\quad(n=0,1,2,\\cdots) \\tag{4} \\] ","date":"2024-10-01T13:25:22+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/mathematics/analysis/special_functions/legendre_functions/","title":"特殊函数（五）：Legendre函数"},{"content":" 3D高斯泼溅算法 在三维重建领域，随着计算机图形学和相关技术的飞速发展，各种创新算法不断涌现，为精准、高效地构建三维场景提供了强大支持。其中，3D高斯泼溅算法（3D Gaussian Splatting，简称3DGS）‌作为一种新兴的、具有革命性的三维重建技术，正逐渐受到广泛关注。\n3D高斯泼溅算法的创新在于其独特的表示和渲染方法。它通过将场景中的每个点视为一个高斯球，利用三维高斯函数的数学性质，将离散的数据点或体素转换为可视化的效果。这一过程中，三维高斯球的叠加不仅实现了数据的平滑过渡，还保留了场景中的细粒度细节。同时，结合快速的可见性感知渲染算法，3D高斯泼溅算法能够在保证高质量渲染效果的同时，实现实时的新视图合成。\n对比NeRF和传统的Mesh：一个是纯连续的、隐式表达在可微空间内；一个是纯离散的（虽然可以插值）、显式表达在三维空间内，3D高斯是在离散和连续间的一个平衡：在高斯球内部是连续的、可微的；在整个空间中，每个高斯球又是离散的。\n本文将深入探讨3D高斯泼溅算法的基本原理，从其数学基础、实现步骤到应用场景，全面解析这一先进技术的核心优势和技术特点。通过本文的介绍，读者将能够更深入地理解3D高斯泼溅算法的工作原理，并探索其在三维重建、点云渲染、体数据可视化等领域的广泛应用前景。\n算法框架 3DGS的主要任务有两个：三维重建和渲染。简单来说，就是提供一组某个场景的照片，然后将这个场景实时渲染出来。算法的主要框架如下图所示。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e SfM Points Initialization 3D Gaussians Projection Adaptive Density Control Differentiable Tile Rasterizer Image Camera Operation Flow Gradient Flow 图1\u0026emsp;3D Gaussian Splatting整体框架\n由上图可以看出，当拿到一组场景照片以后，我们需要先使用某种SfM（Structure from Motion）算法估计出这一组照片的结构（位置）和姿态（摄像机方向）和一组稀疏点云（SfM Points）。然后交给3DGS进行初始化（Initialization）‌得到一组初始的3D高斯球（3D Gaussians）。然后，我们借助相机外参（结构和姿态）将这一组3D高斯球投影到相机平面上（Projection），接着再使用可微分块光栅化（Differentiable Tile Rasterizer）‌渲染得到图像（Image）。得到渲染图像后将其与相机原始的图像（Ground Truth）进行loss比对，然后沿着虚线箭头进行梯度回传。虚线箭头从上回传的时候，更新3D高斯球中的参数，从下回传时会经过自适应密度控制（Adaptive Density Control）‌的处理，而后更新3D高斯球中的点云。\n接下来，我们详细讲解算法中的每一个步骤，并给出具体的实现方式。\n算法内容 运动结构恢复 由于该步骤并不是3D Gaussian Splatting的主要内容（详细请见运动结构恢复），而且已经有较成熟的算法和软件可以实现这部分内容（例如COLMAP），因此在此不做过多介绍。\n3D高斯椭球集的创建及描述 拿到相机的位置、姿态和稀疏点云后，就可以开始创建初始的3D高斯椭球集。描述一个3D高斯椭球需要四种信息：位置、形状、颜色和不透明度。\n3D高斯椭球 在概率论中我们已经学到了多维高斯分布的表达式如下：\n\\[ f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^{T}\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right) \\tag{1} \\] 其中 \\(\\bm{\\mu}\\) 是均值， \\(\\bm{\\Sigma}\\) 是协方差矩阵，它是对称且正定的。在三维空间中，我们将这么一个三维高斯分布叫做一个3D高斯椭球。\n位置 3D高斯椭球的均值 \\(\\bm{\\mu}\\) 就是这个3D高斯椭球的位置，也就是其中心点。初始化3D高斯椭球的时候，这个中心点就是由SfM算法得到的稀疏点云。\n形状 3D高斯椭球的协方差 \\(\\bm{\\Sigma}\\) 就是代表它的形状。由实对称矩阵的正交相似对角化和 \\(\\bm{\\Sigma}\\) 的对称性和正定性， \\(\\bm{\\Sigma}\\) 可以被分解成 \\(\\bm{\\Sigma}=\\bm{R}\\bm{\\Lambda}\\bm{R}^T\\) ，其中 \\(\\bm{R}\\) 是一个正交矩阵， \\(\\bm{\\Lambda}\\) 是由 \\(\\bm{\\Sigma}\\) 的特征值构成的对角矩阵。注意正定矩阵的特征值都是正的，因此 \\(\\bm{\\Lambda}\\) 还可以被分解成 \\(\\bm{\\Lambda}=\\bm{S}\\bm{S}^T\\) ，其中 \\(\\bm{S}\\) 也是一个正的对角矩阵，且其对角线上的值其实就是对应的 \\(\\bm{\\Sigma}\\) 特征值的平方根。因此有\n\\[ \\bm{\\Sigma}=\\bm{R}\\bm{S}\\bm{S}^T\\bm{R}^T \\tag{2} \\] 我们注意看这个式子的几何意义。由于 \\(\\bm{S}\\) 是一个对角矩阵，因此其可以被看成一个放缩变换，而 \\(\\bm{R}\\) 是一个正交矩阵，因此可以看成一个旋转变换（见旋转变换）。将其代回式(1)，易得实际上这个操作就是把正交基先拉伸后旋转，再将去均值的随机向量 \\(\\bm{x}-\\bm{\\mu}\\) 投影到新的正交基上的操作。\n对于三维对角矩阵 \\(\\bm{S}\\) ，只需要一个三维向量 \\(\\bm{s}\\) 描述即可，该向量的每个分量对应对角矩阵 \\(\\bm{S}\\) 的每个对角分量。即\n\\[ \\bm{S}\\left(\\bm{s}\\right)= \\begin{pmatrix} s_1 \u0026 0 \u0026 0 \\\\[5pt] 0 \u0026 s_2 \u0026 0 \\\\[5pt] 0 \u0026 0 \u0026 s_3 \\end{pmatrix} \\tag{3} \\] 对于正交矩阵 \\(\\bm{R}\\) ，可以用一个四元数 \\(\\bm{q}\\) 来表示（见四元数与旋转）。在机器学习中，直接对 \\(\\bm{\\Sigma}\\) 进行学习很难保证其正定性。因此，3DGS采用的方法是对 \\(\\bm{s}\\) 和 \\(\\bm{q}\\) 进行学习，再用公式间接计算 \\(\\bm{\\Sigma}\\) 。这里，我们先给出四元数到旋转矩阵的计算关系（具体推导见四元数与旋转）：\n\\[ \\bm{R}\\left(\\bm{q}\\right)= \\begin{pmatrix} 1-2\\left(q_2^2+q_3^2\\right) \u0026 2\\left(q_1q_2-q_0q_3\\right) \u0026 2\\left(q_1q_3+q_0q_2\\right) \\\\[5pt] 2\\left(q_1q_2+q_0q_3\\right) \u0026 1-2\\left(q_1^2+q_3^2\\right) \u0026 2\\left(q_2q_3-q_0q_1\\right) \\\\[5pt] 2\\left(q_1q_3-q_0q_2\\right) \u0026 2\\left(q_2q_3+q_0q_1\\right) \u0026 1-2\\left(q_1^2+q_2^2\\right) \\end{pmatrix} \\tag{4} \\] 在初始化的时候，3DGS会利用KNN算法计算点云中每个点到与其最近的3个点的平均距离，然后取对数，将其同时作为 \\(\\bm{s}\\) 中的三个分量的值。对于 \\(\\bm{q}\\) ，3DGS将其初始化为 \\(\\bm{q}=\\left(1,0,0,0\\right)\\) ，也就是不进行旋转。\n颜色 对于一个3D高斯球，它的不同方向会呈现不同的颜色，那么这种各向异性的颜色该如何描述呢？这里需要运用到数学中的一个重要的展开工具：实球谐函数（Real Spherical Harmonics）（见球谐函数）。\n计算机图形学中常用的实球谐函数的定义如下：\n\\[ \\mathcal{Y}_l^m\\left(\\theta,\\varphi\\right)= \\begin{cases} \\displaystyle\\sqrt{2}K_l^mP^m_l\\left(\\cos\\theta\\right)\\cos m\\varphi\\quad \u0026(m\u003e0)\\\\[5pt] \\displaystyle K_l^mP^{m}_{l}\\left(\\cos\\theta\\right)\\quad \u0026(m=0)\\\\[5pt] \\displaystyle\\sqrt{2}K_l^mP^{-m}_{l}\\left(\\cos\\theta\\right)\\sin (-m\\varphi)\\quad \u0026(m\u003c0) \\end{cases} \\tag{5} \\] 其中\n\\[ K_l^m=\\sqrt{\\frac{2l+1}{4\\pi}\\frac{\\left(l-|m|\\right)!}{\\left(l+|m|\\right)!}} \\tag{6} \\] 是归一化系数。 \\(P^m_l\\left(\\cos\\theta\\right)\\) 是连带Legendre多项式（见连带Legendre多项式），定义如下：\n\\[ P^m_l\\left(x\\right)=\\left(-1\\right)^m\\frac{\\left(1-x^2\\right)^{\\frac{m}{2}}}{2^ll!}\\frac{\\mathrm{d}^{l+m}}{\\mathrm{d}x^{l+m}}(x^2-1)^l \\tag{7} \\] 类似于Tayler展开和Fourier展开，任何一个在球面上连续的实函数 \\(f(\\theta,\\varphi)\\) 可以用 \\(Y_{lm}(\\theta,\\varphi)\\) 展开为一平均收敛的级数\n\\[ f(\\theta,\\varphi)=\\sum_{l=0}^{\\infin}\\sum_{-l}^{l}C_l^m\\mathcal{Y}_l^m(\\theta,\\varphi) \\tag{8} \\] 其中\n\\[ C_l^m=\\int_0^\\pi\\int_0^{2\\pi}\\mathcal{Y}_l^m(\\theta,\\varphi)f(\\theta,\\varphi)\\sin\\theta d\\theta d\\varphi \\tag{9} \\] 3DGS算法使用 \\(3\\) 阶球函数近似，使用RGB颜色来进行渲染。也就是，一共有三个通道，每个通道由区间 \\([0,1]\\) 的一个数来映射到每个通道表示颜色的 \\(0\\text{\\textasciitilde}255\\) 的一个数字。将每个RGB通道展开成一个 \\(3\\) 阶球函数需要 \\((3+1)^2=16\\) 个系数。由此可得，要想表示一个3D高斯椭球的颜色信息，需要 \\(3\\times (3+1)^2=48\\) 个参数。\n具体的，当我们拿到这 \\(48\\) 个参数和一个方向向量 \\(\\bm{n}=(x,y,z)\\) 以后，利用式(8)，我们可以通过如下推导得到该方向的球谐函数值\n\\[ \\begin{aligned} f_i(\\bm{n})_{SH}=\u0026\\sum_{l=0}^{3}\\sum_{-l}^{l}C_l^m(i)\\mathcal{Y}_l^m(\\bm{n})\\\\[5pt] =\u0026C_0^0(i)\\mathcal{Y}_0^0(\\bm{n})+\\\\[5pt] \u0026C_1^{-1}(i)\\mathcal{Y}_1^{-1}(\\bm{n})+C_1^0\\mathcal{Y}_1^0(\\bm{n})+C_1^1\\mathcal{Y}_1^1(\\bm{n})+\\\\[5pt] \u0026C_2^{-2}(i)\\mathcal{Y}_2^{-2}(\\bm{n})+C_2^{-1}(i)\\mathcal{Y}_2^{-1}(\\bm{n})+C_{20}\\mathcal{Y}_{20}(\\bm{n})+C_{21}\\mathcal{Y}_{21}(\\bm{n})+C_{22}(i)\\mathcal{Y}_{22}(\\bm{n})+\\\\[5pt] \u0026C_3^{-3}(i)\\mathcal{Y}_3^{-3}(\\bm{n})+C_3^{-2}(i)\\mathcal{Y}_3^{-2}(\\bm{n})+C_3^{-1}(i)\\mathcal{Y}_3^{-1}(\\bm{n})+C_3^0\\mathcal{Y}_3^0(\\bm{n})+C_3^1\\mathcal{Y}_3^1(\\bm{n})+C_3^2(i)\\mathcal{Y}_3^2(\\bm{n})+C_3^3(i)\\mathcal{Y}_3^3(\\bm{n}) \\end{aligned} \\tag{10} \\] \\(i\\) 取 \\(1,2,3\\) 表示 \\(3\\) 个RGB通道， \\(C_{00}(i)\\text{\\textasciitilde}C_{33}(i)\\) 均已知，下面给出 \\(\\mathcal{Y}_{00}(\\bm{n})\\text{\\textasciitilde}\\mathcal{Y}_{33}(\\bm{n})\\) 的表达式（可直接根据式(5)得到）\n实球谐函数 表达式 值 \\(\\mathcal{Y}_0^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{1}{\\pi}}\\) \\(0.28209479177387814\\) \\(\\mathcal{Y}_1^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}y\\) \\(-0.4886025119029199\\times y\\) \\(\\mathcal{Y}_1^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}z\\) \\(0.4886025119029199\\times z\\) \\(\\mathcal{Y}_1^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{3}{2\\pi}}x\\) \\(-0.4886025119029199\\times x\\) \\(\\mathcal{Y}_2^{-2}(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}xy\\) \\(1.0925484305920792\\times xy\\) \\(\\mathcal{Y}_2^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}yz\\) \\(-1.0925484305920792\\times yz\\) \\(\\mathcal{Y}_2^0(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{4}\\sqrt{\\frac{5}{\\pi}}(3z^2-1)\\) \\(0.31539156525252005\\times (3z^2-1)\\) \\(\\mathcal{Y}_2^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{2}\\sqrt{\\frac{15}{\\pi}}xz\\) \\(-1.0925484305920792\\times xz\\) \\(\\mathcal{Y}_2^2(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{15}{\\pi}}(x^2-y^2)\\) \\(0.5462742152960396\\times (x^2-y^2)\\) \\(\\mathcal{Y}_3^{-3}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{70}{\\pi}}y(3x^2-y^2)\\) \\(-0.5900435899266435\\times y(3x^2-y^2)\\) \\(\\mathcal{Y}_3^{-2}(\\bm{n})\\) \\(\\displaystyle\\frac{1}{2}\\sqrt{\\frac{105}{\\pi}}xyz\\) \\(2.890611442640554\\times xyz\\) \\(\\mathcal{Y}_3^{-1}(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{42}{\\pi}}y(5z^2-1)\\) \\(-0.4570457994644658\\times y(5z^2-1)\\) \\(\\mathcal{Y}_3^0(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{7}{\\pi}}z(5z^2-3)\\) \\(0.3731763325901154\\times z(5z^2-3)\\) \\(\\mathcal{Y}_3^1(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{42}{\\pi}}x(5z^2-1)\\) \\(-0.4570457994644658\\times x(5z^2-1)\\) \\(\\mathcal{Y}_3^2(\\bm{n})\\) \\(\\displaystyle\\frac{1}{4}\\sqrt{\\frac{105}{\\pi}}z(x^2-y^2)\\) \\(1.445305721320277\\times z(x^2-y^2)\\) \\(\\mathcal{Y}_3^3(\\bm{n})\\) \\(-\\displaystyle\\frac{1}{8}\\sqrt{\\frac{70}{\\pi}}x(x^2-3y^2)\\) \\(-0.5900435899266435\\times x(x^2-3y^2)\\) 表1\u0026emsp;球谐函数表达式及值\n这是在实球谐函数一侧进行合成的方法。但是我们还需要将其换算到RGB通道参数。为了方便合成与分解（减少精度损失）和让展开更对称，3DGS采用如下变换联系实球谐函数和RGB通道参数：\n\\[ f_i(\\bm{n})_{SH}=f_i(\\bm{n})_{RGB}-0.5 \\tag{11} \\] 在初始化的时候，3DGS将 \\(C_0^0(i)\\) 初始化成稀疏点云中的RGB通道值（需要通过上式变换到球谐函数侧），其他参数均初始化为0。\n不透明度 除了位置、形状和颜色，每个3D高斯椭球还有一个不透明度参数 \\(\\omicron\\) 。此时对于某个点 \\((x,y,z)\\) ，其不透明度为：\n\\[ \\alpha(x,y,z)=\\omicron\\cdot\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^{T}\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right) \\tag{12} \\] 这个不透明度会在下文渲染部分仔细讲解。初始化的时候，每个3D高斯椭球的透明度均被初始化成 \\(0.1\\) 。\n渲染 得到一组3D高斯椭球集之后，我们需要把他渲染出来。渲染操作的输入是3D高斯椭球集的各个参数和相机参数，输出是相机看到的图片。首先，我们需要将3D高斯椭球集投影到相机对应的2D平面内，然后再采用可微分块光栅化的办法进行渲染。\n投影 如何将3D高斯椭球投影到2D平面进行渲染是3DGS中非常重要的关键点。首先我们来证明一个重要的结论：\n结论1：多维高斯分布的概率分布函数 \\(\\displaystyle f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)\\) ，对仿射变换 \\(\\bm{u}=\\phi(\\bm{x})=\\bm{M}\\bm{x}+\\bm{c}\\) ，有\n\\[ f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right)=\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right) \\tag{13} \\] 证明（结论1）：由上式和式(1)可得\n\\[ \\begin{aligned} \u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\phi(\\bm{x})|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{M}\\bm{x}+\\bm{c}|\\bm{M}\\bm{\\mu}+\\bm{c},\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)\\\\ =\u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)^{T}(\\bm{M}\\bm{\\Sigma}\\bm{M}^T)^{-1}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)\\right)\\\\ \\end{aligned} \\tag{14} \\] 由 \\(|AB|=|A||B|\\) 和 \\(|A^T|=|A|\\) ，对系数部分有\n\\[ \\begin{aligned} \u0026\\frac{1}{\\left|\\bm{M}^{-1}\\right|}\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left|\\bm{M}^{-1}\\right|^2\\left(2\\pi\\right)^3\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^T\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left|\\bm{M}^{-1}\\right|^2\\left(2\\pi\\right)^3\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}^{-1}\\right|\\left|\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^{-1}\\right|\\left|\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{M}^{-1}\\bm{M}\\right|\\left|\\bm{\\Sigma}\\right|\\left|\\bm{M}^{-1}\\bm{M}\\right|}}\\\\ =\u0026\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}} \\end{aligned} \\tag{15} \\] 由 \\((AB)^{-1}=B^{-1}A^{-1}\\) 和 \\((AB)^T=B^TA^T\\) ，对指数部分有\n\\[ \\begin{aligned} \u0026\\exp\\left(-\\frac{1}{2}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)^{T}(\\bm{M}\\bm{\\Sigma}\\bm{M}^T)^{-1}\\left(\\left(\\bm{M}\\bm{x}+\\bm{c}\\right)-\\left(\\bm{M}\\bm{\\mu}+\\bm{c}\\right)\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)^{T}\\left(\\bm{M}^T\\right)^{-1}\\bm{\\Sigma}^{-1}\\bm{M}^{-1}\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{M}^T\\left(\\bm{M}^T\\right)^{-1}\\bm{\\Sigma}^{-1}\\bm{M}^{-1}\\bm{M}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ =\u0026\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)\\\\ \\end{aligned} \\tag{16} \\] 综上可得\n\\[ \\frac{1}{\\left|\\bm{M}^{-1}\\right|}f\\left(\\bm{u}|\\phi(\\bm{\\mu}),\\bm{M}\\bm{\\Sigma}\\bm{M}^T\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}-\\bm{\\mu}\\right)^T\\bm{\\Sigma}^{-1}\\left(\\bm{x}-\\bm{\\mu}\\right)\\right)=f\\left(\\bm{x}|\\bm{\\mu},\\bm{\\Sigma}\\right) \\tag{17} \\] 证毕。\n我们先将3D高斯椭球从世界坐标系下变换到相机坐标系下（只是平移和旋转）。这个变换可以写为\n\\[ \\bm{x}^{\\prime\\prime}=\\phi^{\\prime\\prime}(\\bm{x})=\\bm{W}\\bm{x}+\\bm{b} \\tag{18} \\] 其中 \\(\\bm{W}\\) 和 \\(\\bm{b}\\) 可以由相机坐标系的旋转矩阵 \\(\\bm{R}\\) 和位置坐标 \\(\\bm{t}\\) 得来。\n\\[ \\bm{W}=\\bm{R}^T\\\\[5pt] \\bm{b}=-\\bm{R}^T\\bm{t} \\tag{19} \\] 使用结论1，我们可以得到经过该变换后的期望值 \\(\\bm{\\mu}^{\\prime\\prime}\\) 协方差矩阵 \\(\\bm{\\Sigma}^{\\prime\\prime}\\)\n\\[ \\bm{\\mu}^{\\prime\\prime}=\\phi(\\bm{\\mu})\\\\[5pt] \\bm{\\Sigma}^{\\prime\\prime}=\\bm{W}\\bm{\\Sigma}\\bm{W}^T \\tag{20} \\] 然后，在相机坐标系下，我们需要使用一个透视变换将其变换到图像坐标系（见透视变换）。注意3DGS使用了和UnrealEngine相同的左手坐标系。\n\\[ \\bm{M}= \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}} \u0026 0 \u0026 \\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}} \u0026 0 \\\\[20pt] 0 \u0026 \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}} \u0026 \\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}} \u0026 0\\\\[20pt] 0 \u0026 0 \u0026 \\displaystyle\\frac{z_{far}}{z_{far}-z_{near}} \u0026 \\displaystyle-\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\\\[20pt] 0 \u0026 0 \u0026 1 \u0026 0 \\end{pmatrix} \\tag{21} \\] 该矩阵是在齐次坐标下的变换矩阵，所以是4维的。其中， \\(z_{near}\\) 是近平面， \\(z_{far}\\) 是远平面， \\(y_{top},y_{bottom},x_{left},x_{right}\\) 分别是相机取景框的上下左右边框。可以将其用 \\(x,y\\) 轴的视场角表示\n\\[ \\begin{aligned} \u0026x_{right}=z_{near}\\tan\\left(\\frac{fov_x}{2}\\right)\\\\[5pt] \u0026x_{left}=-x_{right}\\\\[5pt] \u0026y_{top}=z_{near}\\tan\\left(\\frac{fov_y}{2}\\right)\\\\[5pt] \u0026y_{bottom}=-y_{top} \\end{aligned} \\tag{22} \\] 透视变换的三维形式不是仿射变换，但我们可以尝试写出它。对于 \\(\\bm{P}^{\\prime\\prime}=(x^{\\prime\\prime},y^{\\prime\\prime},z^{\\prime\\prime},1)^T\\) ，由 \\(\\bm{P}^{\\prime}=\\bm{M}\\bm{P}^{\\prime\\prime}\\) 得\n\\[ \\bm{P}^{\\prime}= \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}x^{\\prime\\prime}+\\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}}z^{\\prime\\prime}\\\\[20pt] \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}y^{\\prime\\prime}+\\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}}z^{\\prime\\prime}\\\\[20pt] \\displaystyle\\frac{z_{far}}{z_{far}-z_{near}}z^{\\prime\\prime}\\displaystyle-\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\\\[20pt] z^{\\prime\\prime} \\end{pmatrix} \\tag{23} \\] 将其齐次化后可得\n\\[ \\begin{aligned} x^{\\prime}=\u0026\\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{x^{\\prime\\prime}}{z^{\\prime\\prime}}+\\displaystyle\\frac{x_{right}+x_{left}}{x_{right}-x_{left}}\\\\[20pt] y^{\\prime}=\u0026\\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{y^{\\prime\\prime}}{z^{\\prime\\prime}}+\\displaystyle\\frac{y_{top}+y_{bottom}}{y_{top}-y_{bottom}}\\\\[20pt] z^{\\prime}=\u0026\\displaystyle\\frac{z_{far}}{z_{far}-z_{near}}-\\displaystyle\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\frac{1}{z^{\\prime\\prime}} \\end{aligned} \\tag{24} \\] 这不是一个仿射变换。但是，考虑到3D高斯椭球都很小，我们可以将右端的式子在 \\(\\bm{\\mu}^{\\prime\\prime}=\\phi(\\bm{\\mu})\\) 处展开。由多元函数展开\n\\[ \\begin{pmatrix} x^{\\prime}\\\\ y^{\\prime}\\\\ z^{\\prime} \\end{pmatrix} =\\bm{\\mu}^{\\prime\\prime}+\\bm{J}(\\bm{\\mu}^{\\prime\\prime}) \\begin{pmatrix} x^{\\prime\\prime}\\\\ y^{\\prime\\prime}\\\\ z^{\\prime\\prime} \\end{pmatrix} \\tag{25} \\] 其中 \\(\\bm{J}(\\bm{\\mu}^{\\prime\\prime})\\) 是上述变换的Jacobi矩阵。具体来说对式(24)\n\\[ \\begin{aligned} \\bm{J}(\\bm{\\mu}^{\\prime\\prime})=\u0026 \\left. \\begin{pmatrix} \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial x^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial y^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial x^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial y^{\\prime\\prime}} \u0026 \\displaystyle\\frac{\\partial z^{\\prime}}{\\partial z^{\\prime\\prime}}\\\\[10pt] \\end{pmatrix} \\right._{\\bm{x}^{\\prime\\prime}=\\bm{\\mu}^{\\prime\\prime}} \\\\[50pt] =\u0026 \\begin{pmatrix} \\displaystyle\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{1}{\\mu_z^{\\prime\\prime}} \u0026 \\displaystyle-\\frac{2z_{near}}{x_{right}-x_{left}}\\frac{\\mu_x^{\\prime\\prime}}{\\left(\\mu_z^{\\prime\\prime}\\right)^2} \u0026 0\\\\[20pt] 0 \u0026 \\displaystyle\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{1}{\\mu_z^{\\prime\\prime}} \u0026 \\displaystyle-\\frac{2z_{near}}{y_{top}-y_{bottom}}\\frac{\\mu_y^{\\prime\\prime}}{\\left(\\mu_z^{\\prime\\prime}\\right)^2}\\\\[20pt] 0 \u0026 0 \u0026 \\displaystyle\\frac{z_{far}z_{near}}{z_{far}-z_{near}}\\frac{1}{\\left(\\mu_z^{\\prime\\prime}\\right)^2} \\end{pmatrix} \\end{aligned} \\tag{26} \\] 这样就可以把透视变换近似为一个仿射变换。因此可以使用结论1\n\\[ \\bm{\\Sigma}^{\\prime}=\\bm{J}\\bm{\\Sigma}^{\\prime\\prime}\\bm{J}^T \\tag{27} \\] 综合式(20)和式(27)可得在相机视角下\n\\[ \\bm{\\Sigma}^{\\prime}==\\bm{J}\\bm{W}\\bm{\\Sigma}\\bm{W}^T\\bm{J}^T \\tag{28} \\] \\(\\bm{\\mu}\\) 按照点坐标规则变换就行。这样我们就将3D高斯椭球变换到了图像坐标系内。但是，在3DGS算法中， \\(\\bm{\\Sigma}^{\\prime}\\) 实际上是 \\(2\\times 2\\) 的2D形式，也就是忽略 \\(z\\) 坐标而直接投影到了 \\(xy\\) 平面。这也很简单，把式(28)中的 \\(\\bm{J}\\) 的第三行去掉，变成 \\(2 \\times 3\\) 的矩阵，此时容易验证结论1仍然适用。此时得到的 \\(\\bm{\\Sigma}^{\\prime}\\) 就是投影到 \\(xy\\) 平面上的2D矩阵了。\n着色 3DGS采用的是Alpha-Blending和体渲染光线行进着色算法。假设我们让视图平面某个点 \\((x,y)\\) 对N个高斯进行采样，那么该点的颜色为\n\\[ C(x,y)=\\sum_{i=1}^{N}c_i(x,y)\\alpha_i(x,y)\\prod_{j=1}^{i-1}(1-\\alpha_j(x,y)) \\tag{29} \\] 这N个高斯按照世界坐标系下与 \\((x,y)\\) 的距离（深度）由近到远的顺序排序。 \\(c_i(x^{\\prime},y^{\\prime})\\) 是第 \\(i\\) 个高斯在 \\((x^{\\prime},y^{\\prime})\\) 处的颜色（在世界坐标系下用式(10)和式(11)求出）。 \\(\\alpha_i(x^{\\prime},y^{\\prime})\\) 是第 \\(i\\) 个高斯在 \\((x^{\\prime},y^{\\prime})\\) 处的不透明度，在二维平面中式(12)也适用，因此有\n\\[ \\alpha_i(x^{\\prime},y^{\\prime})=\\omicron_i\\cdot\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)^{T}\\left(\\bm{\\Sigma}^{\\prime}\\right)^{-1}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)\\right) \\tag{30} \\] \\(\\omicron_i\\) 就是由不透明度定义的第 \\(i\\) 个3D高斯椭球的不透明度。注意，式(29)中的 \\(C(x,y)\\) 是三个RGB通道各自的颜色值，取值范围为 \\([0,1]\\) 。也就是三个RGB通道各自独立混合后，再一起作为 \\((x,y)\\) 点处的颜色。\n分块 如果对于每个像素，相对所有高斯（2D）都进行一次光线行进，那这将耗费巨大的计算资源而且还不一定能起到很好的效果。因此，3DGS提出了一种分块渲染的方法。其思想是将屏幕分成每个大小为 \\(16\\times 16\\) 像素的块，在渲染每个块中的像素的时候只考虑和这个块有交叠的高斯。对于不同的块，可以采用并行计算的方法加快渲染速度。\n那么该如何判断某个高斯与某个块是否有交叠呢？首先得确定它的边界。3DGS采用 \\(99\\\\%\\) 作为置信区间，也就是以概率为 \\(99\\\\%\\) 作为边界。即\n\\[ f\\left(\\bm{x}^\\prime|\\bm{\\mu}^\\prime,\\bm{\\Sigma}^\\prime\\right)=\\frac{1}{\\sqrt{\\left(2\\pi\\right)^3\\left|\\bm{\\Sigma}^\\prime\\right|}}\\exp\\left(-\\frac{1}{2}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)^{T}\\left(\\bm{\\Sigma}^{\\prime}\\right)^{-1}\\left(\\bm{x}^{\\prime}-\\bm{\\mu}^{\\prime}\\right)\\right)=0.99 \\tag{31} \\] 由于 \\(\\bm{\\Sigma}^\\prime\\) 是正定矩阵，因此这是一个椭圆。椭圆方程可以被求出来，再结合某个块的四条边的参数，就可以判断出是否交叠。（当然，在实际代码中并没有采用上述椭圆方程的求法，也没有采用传统的椭圆和矩形的碰撞检测算法，因为这样会增加不必要的计算量，因此在3DGS的代码实现中将2D高斯的碰撞箱简化为了一个矩形，再用这个矩形做碰撞判断，具体见代码）。\n我们先对所有高斯做一个预处理。对于我们需要处理的高斯，首先，这个高斯必须位于相机的视锥内部（或与其相交），这样可以预先排除掉很大一部分高斯。然后，这个高斯不能距离摄像机过近或过远（一般来说，会将 \\(z^\\prime\\) 控制在某一个区间内）。最后再执行判断这个高斯与某个块是否有交叠的操作。\n接下来的问题是如何得到与某个块有交叠的所有高斯，并按照深度进行排序方便进行着色。\n","date":"2024-09-23T19:43:18+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/computer_science/artificial_intelligence/computer_vision/3d_gaussian_splatting/","title":"三维重建（一）：3D高斯泼溅算法"},{"content":" 操作系统引论 操作系统（Operating System，OS） 是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充，其主要作用是管理好这些设备，提高它们的利用率和系统的吞吐量，并为用户和应用程序提供一个简单的接口，便于用户使用。OS是现代计算机系统中最基本和最重要的系统软件，而其他的诸如编译程序、数据库管理系统等系统软件，以及大量的应用软件，都直接依赖于操作系统的支持，取得它所提供的服务。事实上OS已经成为现代计算机系统、多处理机系统、计算机网络中都必须配置的系统软件。\n操作系统的目标和作用 操作系统的目标与应用环境有关。例如在查询系统中所用的OS，希望能提供良好的人机交互性；对于工业控制、武器控制以及多媒体环境下的OS，要求其具有实时性。而对于微机上配置的OS，则更看重的是其使用的方便性。\n操作系统的目标 在计算机系统上配置操作系统，其主要目标是：方便性、有效性、可扩充性和开放性。\n方便性 一个未配置OS的计算机系统是极难使用的。用户如果想直接在计算机硬件（裸机）上运行自己的程序，就必须用机器语言书写；但是如果配置了OS，系统就可以使用编译命令将用户采用高级语言书写的程序翻译成机器代码，或直接通过OS所提供的各种命令操纵计算机系统，极大地方便了用户，使计算机变得易学易用。\n有效性 有效性所包含的第一层含义是提高系统资源的利用率。在早期未配置OS的计算机系统中，诸如处理机、I/O设备等都经常处于空闲状态，各种资源无法得到充分利用，所以在当时，提高系统资源利用率是推动OS发展最主要的动力。有效性的另一层含义是提高系统的吞吐量。OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量。\n方便性和有效性是设计OS时最重要的两个目标。在过去很长的一段时间内，由于计算机系统非常昂贵，有效性显得特别重要。然而，近十多年来，随着硬件越来越便宜，在设计配置在微机上的OS时，似乎更加重视如何提高用户使用计算机的方便性。因此，在微机操作系统中都配置了深受用户欢迎的图形用户界面，以及为程序员提供了大量的系统调用，方便了用户对计算机的使用和编程。\n可扩充性 为适应计算机硬件、体系结构以及计算机应用发展的要求，OS必须具有很好的可扩充性。可扩充性的好坏与OS的结构有精密的联系，由此推动了OS结构的不断发展。从早期的无结构发展成模块化结构，进而又发展成层次化结构，近年来OS已广泛采用了微内核结构。微内核结构能方便地增添新的功能和模块，以及对原有的功能和模块进行修改，具有良好的可扩充性。\n开放性 随着计算机应用的日益普及，计算机硬件和软件的兼容性问题便提到了议事日程上来。世界各国相应地制定了一系列的软、硬件标准，使得不同厂家按照标准生产的软、硬件都能在本国范围内很好地相互兼容。这无疑给用户带来了极大的方便，也给产品的推广、应用铺平了道路。近年来，随着Internet的迅速发展，使得计算机OS的应用环境由单机环境转向了网络环境，其应用环境就必须更为开放，进而对OS的开放性提出了更高的要求。\n所谓开放性，是指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准。事实上，凡遵循国际标准所开发的硬件和软件，都能彼此兼容，方便地实现互连。开放性已称为20世纪90年代以后计算机技术的一个核心问题，也是衡量一个新推出的系统或软件能否被广泛应用的至关重要的因素。\n操作系统的作用 操作系统在计算机系统中所起的作用，可以从用户、资源管理及资源抽象等多个不同的角度来进行分析和讨论。\nOS作为用户与计算机硬件系统之间的接口 OS作为用户与计算机硬件系统之间的接口的含义是：OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。或者说，用户在OS帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。图1是OS作为接口的示意图。由图可看出，用户可通过三种方式使用计算机，即通过命令方式、系统调用方式和图标\u0026mdash;窗口方式来实现与操作系统的通信，并取得它的服务。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户 应用程序 命令 系统调用 图标—窗口 操作系统 计算机硬件 图1\u0026emsp;OS作为接口的示意图\nOS作为计算机系统资源的管理者 在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为四类：处理机、存储器、I/O设备以及文件（数据和程序）。相应地，OS的主要功能也正是对这四类资源进行有效的管理。处理机管理适用于分配和控制处理机；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配（回收）与操纵；文件管理适用于实现对文件的存取、共享和保护。可见，OS的确是计算机系统资源的管理者。\n当一台计算机系统供多个用户使用时，诸多用户对系统中共享资源的需求（包括数量和时间）有可能发生冲突。为此，操作系统必须对使用资源的请求进行授权，以协调诸用户对共享资源的使用。\nOS实现了对计算机资源的抽象 对一台完全无软件的计算机系统（即裸机），由于它向用户提供的仅是硬件接口（物理接口），因此，用户必须对物理接口的实现细节有充分的了解，这就致使该物理机器难于广泛使用。为了方便用户使用I/O设备，人们在裸机上覆盖上一层I/O设备管理软件，如图2所示，由它来实现对I/O设备操作的细节，并向上将I/O设备抽象为一组数据结构以及一组I/O操作命令，如read或write命令，这样用户即可利用这些数据结构及操作命令来进行数据输入或输出，而无需关心I/O是如何具体实现的。此时用户所看到的机器是一台比裸机功能更强、使用更方便的机器。换言之，在裸机上铺设的I/O软件隐藏了I/O设备的具体细节，向上提供了一组抽象的I/O设备。\nSVG文件/posts/computer_science/operating_system/introduction_to_operating_system/io_software_abstracts_io_implementation_details未找到或读取失败。\n图2\u0026emsp;I/O软件隐藏了I/O操作实现的细节\n通常把覆盖了上述软件的机器称为扩充机器或者虚机器。它向用户提供了一个对硬件操作的抽象模型。用户可利用该模型的接口使用计算机，无需了解物理接口的实现细节，从而使用户更容易地使用计算机硬件资源。亦即，I/O设备管理软件实现了对计算机硬件操作的第一个层次的抽象。\n同理，为了方便用户使用文件系统，又可在第一层软件（I/O管理软件）上再覆盖一层用于文件管理的软件，由它来实现对文件操作的细节，并向上层提供一组实现对文件进行存取操作的数据结构和命令。这样，用户可利用该软件提供的数据结构及命令对文件进行存取。此时用户所看到的是一台功能更强、使用更方便的虚机器。亦即，文件管理软件实现了对硬件资源操作的第二个层次的抽象。以此类推，如果文件管理软件上再覆盖一层面向用户的窗口软件，则用户便可在窗口环境下方便地使用计算机，从而形成一台功能更强的虚机器。\n由此可知，OS是铺设在计算机硬件上的多层软件的集合，它们不仅增强了系统的功能，还隐藏了对硬件操作的具体细节，实现了对计算机硬件操作的多个层次的抽象模型。值得说明的是，不仅可在底层对一个硬件资源加以抽象，还可以在高层对该资源底层已抽象的模型再次进行抽象，称为更高层的抽象模型。随着抽象层次的提高，抽象接口所提供的功能就越强，用户使用起来也越方便。\n推动操作系统发展的主要动力 OS自20世纪50年代产生后，经历了由简单到复杂，由低级到高级的发展。在短短60多年间，OS在各方面都有了长足的进步，能够很好地适应计算机硬件和体系结构的快速发展，以及应用需求的不断变化。下面我们对推动OS发展的主要推动力做具体阐述。\n不断提高计算机资源利用率 在计算机发展的初期，计算机系统特别昂贵，人们必须千方百计地提高计算机系统中各种资源的利用率，这就是OS最初发展的推动力。由此形成了能自动地对一批作业进行处理的多道批处理系统。20世纪60年代和70年代有分别出现了能够有效提高I/O设备和CPU利用率的SPOOLing系统，以及极大地改善了存储器系统利用率的虚拟存储器技术。此后在网络环境下，通过在服务器上配置网络文件系统和数据库系统算法，将资源提供给全网络用户共享，又进一步提高了资源的利用率。\n方便用户 当资源利用率不高的问题得到基本解决后，用户在上机、调试程序时的不方便行便成为主要矛盾，这又成为继续推动OS发展的主要因素。20世纪60年代分时系统的出现，不仅提高了系统资源的利用率，还能实现人\u0026mdash;机交互，使用户能像早期使用计算机时一样，感觉自己是独占全机资源，对其进行直接操控，极大地方便了程序员对程序进行调试和修改的操作。90年代初，图形用户界面的出现收到用户的广泛欢迎，进一步方便了用户对计算机的使用，这无疑又加速推动了计算机的迅速普及和广泛使用。\n器件的不断更新换代 随着IT技术的飞讯发展，尤其是微机芯片的不断更新换代，使得计算机的性能快速提高，从而也推动了OS的功能和性能迅速增强和提高。例如当微机芯片由8位发展到16位、32位，进而又发展到64位时，相应的微机OS也就由8位OS发展到16位和32位，进而又发展到64位，此时，相应OS的功能和性能也有了显著的增强和提高。\n与此同时，外部设备也在迅速发展。OS所能支持的外部设备也越来越多，如现在的微机OS已能够支持种类繁多的外部设备，除了传统的外设外，还可以支持光盘、移动硬盘、闪存盘、扫描仪、数码相机等。\n计算机体系结构的不断发展 计算机体系结构的发展，也不断推动着OS的发展，并产生新的OS类型。例如当计算机由单处理机系统发展为多处理机系统时，相应地，OS也就由单处理机OS发展为多处理机OS。又如当出现了计算机网络后，配置在计算机网络上的操作系统也就应运而生。它不仅能有效地管理好网络中的共享资源，而且还向用户提供了许多网络服务。\n不断提出新的应用需求 操作系统能如此迅速发展的另一个重要原因是，人们不断提出新的应用需求，例如，为了提高产品的质量和数量，需要将计算机应用于工业控制中，此时在计算机上就需要配置能进行实时控制的OS，由此产生了实时系统。此后，为了能满足用户在计算机上听音乐、看电影和玩游戏等需求，又在OS中添加了多媒体功能。另外，由于在计算机系统中保存了越来越多的宝贵信息，致使能够确保系统安全性也成为OS必须具备的功能。尤其是随着VLSI（超大规模集成电路） 的发展，计算机芯片的体积越来越小，价格也越来越便宜，大量智能设备应运而生，这样，微机操作系统的产生和发展也成了一种必然。\n操作系统的发展过程 在20世纪50年代中期，出现了第一个简单的批处理OS；60年代中期开发出多道程序批处理系统；不久又推出分时系统，与此同时，用于工业和武器控制的实时OS也相继问世。20世纪70到90年代，是VLSI和计算机体系结构大发展的年代，导致了卫星及、多处理机和计算机网络的诞生和发展，与与此相应地，也相继开发出了微机OS，多处理机OS和网络OS，并得到极为迅猛的发展。\n未配置操作系统的计算机系统 从1945年诞生的第一台计算机，到50年代中期的计算机，都属于第一代计算机。这时还未出现OS，对计算机的全部操作都是由用户采取人工操作方式进行的。\n人工操作方式 早期的操作方式是由程序员将事先已穿孔的纸带（或卡片），装入纸带输入机（或卡片输入机），再启动它们将纸带（或卡片）上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面缺点：\n用户独占全机，即一台计算机的全部资源由上级用户所独占。 CPU等待人工操作。当用户进行装带（卡），卸带（卡）等人工操作时，CPU及内存等资源是空闲的。\n可见，人工操作方式严重降低了计算机资源的利用率，此即所谓的人机矛盾。虽然CPU的速度在迅速提高，但I/O设备的速度却提高缓慢，这使CPU与I/O设备之间速度不匹配的矛盾更加突出。为此，曾先后出现了通道技术、缓冲技术，然而都未能很好地解决上述矛盾，直到后来引入了脱机输入/输出技术，才获得了相对较为满意的结果。 脱机输入/输出（Off-Line IO）方式 为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。该技术是实现将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。\n类似地，当CPU需要输出时，可先由CPU把数据直接从内存高速地输送到磁带上，然后在另一台外围机的控制下，再将此大地上的结果通过相应地输出设备输出。图3示出了脱机输入/输出的过程。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 输入设备 外围机 磁盘 磁盘 主机 磁盘 磁盘 外围机 输出设备 图3\u0026emsp;脱机I/O示意图\n由于程序和数据的输入和输出都是在外围机的控制下完成的，或者说，它们是在脱离主机的情况下进行的，故称为脱机输入/输出方式。反之，把在主机的直接控制下进行输入/输出的方式称为联机输入/输出（On-Line I/O） 方式。这种脱机I/O方式的主要优点为：\n减少了CPU的空闲时间。装带、卸带，以及将数据从低俗I/O设备送到高速磁带上（或反之）的操作，都是在脱机情况下由外围机万郴个，并不占用主机时间，从而有效地减少了CPU的空闲时间。 提高了I/O速度。当CPU在运行中需要输入数据时，是直接从高速的磁带上将数据输入到内存的，这便极大地提高了I/O速度，从而进一步减少了CPU的空闲时间。 单道批处理系统（Simple Batch Processing System） 20世纪50年代中期出现了第二代晶体管计算机，此时计算机虽已具有推广应用的价值，但计算机系统仍然非常昂贵，为了能充分地提高它的利用率，应尽量保持系统的连接运行，即在处理完一个作业后，紧接着处理下一个作业，以减少机器的空闲等待时间。\n单道批处理系统的处理过程 为了实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序（Monitor），在它的控制下，使这批作业能一个接一个连续处理。其处理过程是：首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给该作业；当该作业处理完成时，又把控制权交给监督程序，再由监督程序把磁带上的第二个作业调入内存。计算机系统就这样自动地一个作业紧接着一个作业地进行处理，直至磁带上的所有作业全部完成，这样便形成了早期的批处理系统。虽然系统对作业的处理是成批进行的，但在内存中时终止保持一道作业，故称为单道批处理系统。图4示出了单道批处理系统的处理流程。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 还有下一个作业？ 把下一个作业的源程序转换为目标程序 是 源程序有错吗？ 开始 否 装配目标程序 运行目标程序 是 否 停止 图4\u0026emsp;单道批处理系统的处理流程\n单道批处理系统的缺点 单道批处理系统最主要的缺点是，系统中的资源得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。图5示出了单道程序的运行情况，从图可以看出：在 $t_2$ ~ $t_3$ 、 $t_6$ ~ $t_7$ 时间间隔内CPU空闲。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 用户程序 监督程序 I/O操作 I/O中断请求 启动I/O I/O完成 结束中断 I/O中断请求 启动I/O I/O完成 结束中断 图5\u0026emsp;单道程序的运行情况\n为了能在系统中运行较大的作业，通常在计算机中都配置了较大容量的内存，但实际情况是有80%以上的作业都属于中小型，因此在单道程序环境下，也必定造成内存的浪费。类似地，为了满足各种类型的作业需要，在系统中将会配置多种类型的I/O设备。显然在单道程序环境下也不能充分利用系统资源。\n多道批处理系统（Multiprogrammed Batch Processing System） 20世纪60年代中期，IBM公司生产了第一台小规模集成电路计算机IBM 360（第三代计算机系统）。由于它较之于晶体管计算机无论在体积、功耗、速度和可靠性上都有了显著的改善，因而获得了极大的成功。IBM公司为该机开发的OS/360操作系统是第一个能运行多道程序的批处理系统。\n多道程序设计的基本概念 为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。在该系统中，用户所提交的作业先存放在外存上，并排成一个队列，称为“后备队列”。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。由于同时在内存中装有若干道程序，这样便可以在运行程序A时，利用其因I/O操作而暂停执行时的CPU空挡时间，再调度另一道程序B运行，同样可以利用程序B在I/O操作时的空档时间，再调度程序C运行，使多道程序交替地运行，这样便可以保持CPU处于忙碌状态。图6示出了四道程序时的运行情况。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 程序A 程序B 程序C 程序D 调度程序 程序B 程序AI/O请求 程序BI/O请求 程序A 程序A IO处理 程序B I/O处理 程序C 程序C I/O处理 程序D 程序CI/O请求 程序DI/O请求 程序A I/O完成 程序A再被调度 程序C I/O完成 程序A 完成 程序C 再被调度 程序D I/O处理 程序B被调度 程序C 程序C被调度 程序D被调度 CPU执行线 程序A 调度 调度 调度 调度 调度 图6\u0026emsp;多道程序的运行情况\n多道批处理系统的优缺点 多道批处理系统的优点如下：\n资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。 系统吞吐量大。能提高系统吞吐量的主要原因可归结为： CPU和其他资源保持“忙碌状态”； 仅当作业完成时或运行不下去时才进行切换，系统开销小。 多道批处理系统的缺点如下：\n平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极不方便。 多道批处理系统需要解决的问题 多道批处理系统是一种十分有效，但又非常复杂的系统，为使系统中的多道程序间能协调地运行，系统必须解决下述一系列问题：\n处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。 内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使它们各得其所，且不会因某道程序出现异常情况而破坏其他程序。 I/O设备分配问题。系统应采取适当的策略来分配系统中的I/O设备，以达到既能方便用户对设备的使用，又能提高设备利用率的目的。 文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便于用户使用，又能保证数据的安全性。 作业管理问题。系统中存在着各种作业（应用程序），系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同需求。 用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供用户与OS之间的接口。\n为此，应在计算机系统中增加一组软件，用以对上述问题进行妥善、有效的处理。这组软件应包括：能有效地组织和管理四大资源的软件、合理地对各类作业进行调度和控制它们运行的软件，以及方便用户使用计算机的软件。正是这样一组软件构成了操作系统。据此，我们可以把操作系统定义为：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。 分时系统（Time Sharing System） 分时系统的引入 如果说推动多道批处理系统形成和发展的主要动力是提高资源利用率和系统吞吐量，那么，推动分时系统的形成和发展的主要动力，则是为了满足用户对人\u0026mdash;机交互的需求，由此形成了一种新型OS，用户的需求具体表现在以下几个方面：\n人\u0026mdash;机交互。每当程序员写好一个新程序时，都需要上机进行调试。由于新编程序难免存在一些错误或不当之处，需要进行修改，因此用户希望能像早期使用计算机时一样，独占权及并对它进行直接控制，宜宾能方便地对程序中的错误进行修改。亦即，用户希望能进行人\u0026mdash;机交互。 共享主机。在20世纪60年代，计算机还十分昂贵，一台计算机要同时供很多用户共享使用。显然，用户们在共享一台计算机时，每个人都希望能像独占时一样，不仅可以随时与计算机进行交互，而且还不会感觉到其他用户的存在。\n由上述不难得知，分时系统是指，在一台主机上连接了多个配有显示器和键盘的终端并由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。 分时系统实现中的关键问题 在多道批处理系统中，用户无法与自己的作业进行交互的主要原因是：作业都先驻留在外存上，即使以后被调入内存，也要经过较长时间的等待后方能运行。用户无法与自己的作业进行交互。为了能够实现人机交互，必须解决的关键问题是，如何使用户能与自己的作业进行交互。为此，系统首先必须能提供多个终端，同时给多个用户使用。其次，当用户在自己的终端上键入命令时，系统应能及时接收，并及时处理该命令，再将结果返回给用户。此后，用户可根据系统返回的响应情况，再继续键入下一条命令，此即人\u0026mdash;机交互。亦即，允许有多个用户同时通过自己的键盘键入命令，系统也应能全部及时接收并处理。\n及时接收。要做到及时接收多个用户键入的命令或数据，只需在系统中配置一个多路卡即可。例如当主机上要连接64个终端时，就配置一个64用户的多路卡。多路卡的作用是，实现分时多路复用。即主机以很快的速度周期性地扫描各个终端，在每个终端处停留很短的时间，如30ms，用于接收从终端发来的数据。对于64用户的多路卡，用不到2秒的时间便可完成一次扫描，即主机能用不到2秒的时间分时接收哥哥用户从终端上输入的数据一次。此外，为了能使从终端上输入的数据被依次逐条地进行处理，还需要为每个终端配置一个缓冲区，用来暂存用户键入的命令（或数据）。 及时处理。人\u0026mdash;机交互的关键在于，用户键入命令后，能对自己的作业及其运行及时地实时控制，或进行修改。因此，各个用户的作业都必须驻留在内存中，并能频繁地获得处理机运行。否则，用户键入的命令将无法作用到自己的作业上。由此可见，为了实现人\u0026mdash;机交互，必须彻底地改变原来批处理系统的运行方式，转而采用下面的方式： 作业直接进入内存。因为作业在磁盘上是不能运行的，所以作业应该直接进入内存。 采用轮转运行方式。如果一个作业独占CPU连续运行，那么其他作业就没有机会被调度运行。为避免一个作业长期独占处理机，引入了时间片的概念。一个时间片，就是一段很短的时间（例如30ms）。系统规定每个作业每次只能运行一个时间片，然后就暂停该作业的运行，并立即调度下一个作业的运行。如果在不长时间内能使所有的作业都执行一个时间片的时间，便可以使每个用户都能及时地与自己的作业进行交互，从而可使用户的请求得到及时相应。 分时系统的特征 分时系统与多道批处理系统相比，具有非常明显的不同特性，可归纳成以下四个方面。\n多路性。该特性是指系统允许将堕胎终端同时连接到一台主机上，并按分时原则为每个用户服务。多路性允许多个用户共享一台计算机，显著地提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。 独立性。该特性是指系统提供了这样的用机环境，即每个用户在各自的终端上进行操作，彼此之间互不干扰，给用户的感觉就像是他一人独占主机进行操作。 及时性。及时性是指用户的请求能在很短时间内获得响应。这一时间间隔是根据人们所能接受的等待时间确定的，通常仅为1~3秒钟。 交互性。交互性是指用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务，如进行文件编辑和数据处理，访问系统中的文件系统和数据库系统，请求提供打印服务等。 实时系统（Real Time System） 所谓实时，是表示“及时”。而“实时计算”，则可定义为这样一类计算：系统的正确性，不仅由计算的逻辑结果来确定，而且还取决于产生结果的时间。事实上实时系统最主要的特征，是将时间作为关键参数，它必须对所接收到的某些信号做出“及时”或“实时”的反应。由此得知，实时系统是指系统能及时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。\n实时系统的类型 随着计算机应用的普及，实时系统的类型也相应增多，下面列出当前常见的几种：\n工业（武器）控制系统。当计算机被用于生产过程的控制，形成以计算机为中心的控制系统时，该系统应具有能实时采集现场数据，并对所采集的数据进行及时处理，进而能够自动地控制相应的执行机构，使之具有按预定的规律变化的功能，确保产品的质量和产量。类似地，也可将计算机用于对武器的控制，如火炮的自动控制系统、飞机的自动驾驶系统、以及导弹的制导系统等。 信息查询系统。该系统接受从远程终端上发来的服务请求，根据用户提出的请求，对信息进行检索和处理，并能及时对用户做出正确的回答。实时信息处理系统由飞机或火车的订票系统等。 多媒体系统。随着计算机硬件和软件的快速发展，已可将文本、图像、音频和视频等信息集成在一个文件中，形成一个多媒体文件。如在用DVD播放器所播放的数字电影中就包含了音频、适配和横向滚动的文字等信息。为了保证有好的听觉和视觉感受，用于播放音频和视频的多媒体系统等，也必须是实时信息处理系统。 嵌入式系统。随着集成电路的发展，已制作出各种类型的芯片，可将这些芯片嵌入到各种一起和设备中，用于对设备进行控制或对其中的信息作出处理，这样就构成了所谓的智能仪器和设备。此时还需要配置嵌入式OS，它同样需要具有实时控制或处理的功能。 实时任务的类型 周期性实时任务和非周期性实时任务。周期性实时任务是指这样一类任务，外部设备周期性地发出激励信号给计算机，要求它按指定周期循环执行，以便周期性地控制某我i不设备。反之，非周期性实时任务并无明显的周期性，但都必须联系着一个截止时间（Deadline），或称为最后期限。它又可分为：1. 开始截止时间：指某个任务在某时间以前必须开始执行；2. 完成截止时间：指某任务在某时间以前必须完成。 硬实时任务和软实时任务。硬实时任务（Hard Real-time Task，HRT） 是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果。用于工业和武器控制的实时系统，通常它所执行的是硬实时任务。软实时任务（Soft Real-time Task, SRT） 也联系着一个截止时间，但并不严格，若偶尔错过了截止时间，对系统产生的影响也不会太大。诸如用于信息查询系统和多媒体系统中的实时系统，通常是软实时任务。 实时系统与分时系统特征的比较 多路性。信息查询系统和分时系统中的多路性都表现为系统按分时原则为多个终端用户服务；实时控制系统的多路性则是指系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。 独立性。信息查询系统中的每个终端用户在与系统交互时，彼此相互独立互不干扰，同样在实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰的。 及时性。信息查询系统对实时性的要求是依据人所能接受的等待时间确定的。而多媒体系统实时性的要求是，播放出来的音乐和电视能令人满意。实时控制系统的实时性则是以控制对象所要求的截止时间来确定的，一般为秒级到毫秒级。 交互性。在信息查询系统中，人与系统的交互性仅限于访问系统中某些特定的专用服务程序，它并不像分时系统那样，能向终端用户提供数据处理、资源共享等服务。而多媒体系统的交互性也仅限于用户发送某些特定的命令，如开始、停止、快进等，由系统立即响应。 可靠性。分时系统要求系统可靠，实时系统要求系统高度可靠，因为任何差错都可能带来无法预料的灾难性的后果。因此，在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。 微机操作系统 随着VLSI和计算机体系结构的发展，以及应用需求的不断扩大，操作系统仍在继续发展。由此先后形成了微机操作系统、网络操作系统等。本小节对微机操作系统的发展作扼要的介绍。\n配置在微型机上的操作系统称为微机操作系统，最早诞生的危机操作系统是配置在8位微机上的CP/M，后来出现了16位微机，相应地，16位微机操作系统也就应运而生。当微机发展为32位、64位时，32位和64位微机操作系统也应运而生。可见微机操作系统可按微机的字长来分，但也可以将它按运行方式分为如下几类：\n单用户单任务操作系统 单用户单任务操作系统的含义是：只允许一个用户上机，且只允许用户程序作为一个任务运行，这是最简单的微机操作系统，主要配置在8位和16位微机上，最有代表性的单用户单任务微机操作系统时CP/M和MS-DOS。\nCP/M\n1974年第一代通用8位微处理机芯片Intel 8080出现后的第二年，Digital Research公司就开发出带有软盘系统的8位微机操作系统CP/M。1977年Digital Research公司对CP/M进行了重写，使其剋配置在以Intel 8080、8085、Z80等8位芯片为基础的多种微机上。1979年又推出带有硬盘管理功能的CP/M 2.2版本。由于CP/M具有较好的体系结构，可适应性强，可以执行以及易学易用等优点，使之在8位微机中占据了统治地位。 MS-DOS\n1981年IBM公司首次推出了IBM-PC个人计算机（16位微机），在微机中采用了微软公司开发的MS-DOS（Disk Operating System） 操作系统，该操作系统在CP/M的基础上进行了较大的扩充，使其在功能上有很大的提高。1983年IBM退出PC/AT（配有Intel 80286芯片），相应地微软又开发出MS-DOS 2.0版本，它不仅能支持硬盘设备，还采用了树形目录结构的文件系统。1987年又宣布了MS-DOS 3.3版本。从MS-DOS 1.0到3.3位置的版本都属于单用户单任务操作系统，内存被限制在640KB。从1989到1993年又先后推出了多个MS-DOS版本，它们都可以配置在Intel 80386、80486等32位微机上。从80年代到90年代初，由于MS-DOS性能优越受到当时用户的广泛欢迎，称为事实上的16位单用户单任务操作系统标准。 单用户多任务操作系统 单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发，从而有效地改善了系统的性能。目前在32位维基上配置的操作系统，基本上都是单用户多任务操作系统。其中最有代表性的是由微软公司推出的Windows。1985年和1987年微软公司先后推出了Windows 1.0和Windows 2.0版本操作系统，由于当时的硬件平台还只是16位微机，对1.0和2.0版本不能很好地支持。1990年微软公式又发布了Windows 3.0版本，随后又宣布了Windows 3.1版本，它们主要是针对386和486等32位微机开发的，它较之以前的操作系统有着很重大的改进，引入了友善的图形用户界面，支持多任务和扩展内存的功能。使计算机更好使用，从而称为386和486等微机的主流操作系统。\n1995年微软公司推出了Windows 95，它较之以前的Windows 3.1有许多重大改进，采用了全32位的处理技术，并兼容以前的16位应用程序，在该系统中还集成了支持Internet的网络功能。1998年微软公司又推出了Windows 95的改进版Windows 98，它已是最后一个仍然兼容以前16位应用程序的Windows。其最主要的改进是把微软公司自己开发的Internet浏览器整合到系统中，大大方便了用户上网浏览；另一个改进是增加了对多媒体的支持。2001年微软又发布了Windows XP，同时提供了家用和商业工作站两种版本，在此后相当长的一段时间，称为使用最广泛的个人操作系统之一。在开发上述Windows操作系统的同时，微软公司又开始对网络操作系统Windows NT进行开发，它是针对网络开发的操作系统，在系统中融入许多面向网络的功能，从2006年后推出的一系列内核版本号为NT6.X的桌面操作系统，包括Windows Vista、Windows 7、Windows 8等，这里就不对它们进行介绍。\n多用户多任务操作系统 多用户多任务操作系统的含义是，允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中配置的大多是多用户多任务操作系统，而在32位微机上，也有不少配置的是多用户多任务操作系统，其中最有代表性的是UNIX OS。\nUNIX OS是美国电报电话公司的Bell实验室在1969~1970年期间开发的，1979年推出来的UNIX V.7已被广泛应用于多种小型机上。随着微机性能的提高，人们又将UNIX移植到微机上。在1980年后，将UNIX第7版本移植到Motorola公司的MC 680xx微机上，后来又将UNIX V7.0版本进行简化后，移植到Intel 8080上，把它称为Xenix。现在最有影响的两个能运行在微机上的UNIX操作系统变形是Solaris OS和Linux OS。\nSolaris OS：SUN公司于1982年推出的SUN OS 1.0，是一个运行在MOTOROLA 680X0平台上的UNIX OS，在1988年宣布的SUN OS 4.0，把运行平台从早期的MOTOROLA 680X0平台迁移到SPARC平台，并开始支持Intel公司的80X86；1992年SUN发布了Solaris 2.0。从1998年开始，Sun公司推出64位操作系统Solaris 2.7和2.8，这几款操作系统在网络特性、互操作性、兼容性以及易于配置和管理方面均有很大的提高。 Linux OS：Linux是UNIX的一个重要变种，最初是由芬兰学生Linus Torvalds针对Intel 8086开发的，1991年，在Internet网上发布第一个Linux版本，由于源代码公开，因此有很多人通过Internet与之合作，使Linux的性能迅速提高，其应用范围也日益扩大，相应地，源代码而急剧膨胀，此时它已是具有全面功能的UNIX系统，大量在UNIX上运行的软件（包括1000多种使用工具软件和大量网络软件），被移植到Linux上，而且可以在主要的微机上运行，如Intel 80X86 Pentium等。 操作系统的基本特性 前面所介绍的多道批处理系统、分时系统和实时系统这三种基本草祖宗系统都具有各自不同的特征，如批处理系统有着高的资源利用率和系统吞吐量；分时系统能获得及时响应；实时系统具有实时特征。除此之外，它们还共同具有并发、共享、虚拟和异步四个基本特征。\n并发（Concurrence） 正是系统中的程序能并发执行这一特征，才使得OS能有效地提尕奥系统中的资源利用率，增加系统的吞吐量。\n并行与并发 并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却只能有一道程序执行，故微观上这些程序只能是分时地交替进行。例如，在1秒钟时间内，0~15ms程序A运行；15~30ms程序B运行；30~45ms程序C运行；45~60ms程序D运行，因此可以说，在1秒钟时间间隔内，宏观上有四道程序在同时运行，但微观上，程序A、B、C、D是分时地交替执行的。\n倘若在计算机系统中有多个处理机，这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序。这样，多个程序便可同时执行。\n引入进程 在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O程序之间只能是顺序执行，即只有在计算程序执行告一段落后，才允许I/O程序执行；反之，在程序执行I/O操作时,计算程序也不能执行。但在为计算程序和1/0程序分别建立一个进程（Process）‌后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。\n所谓进程，是指在系统中能独立运行并作为资源分配的基本单位。它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。事实上，进程和并发是现代操作系统中最重要的基本概念，也是操作系统运行的基础。\n共享（Sharing） 一般情况下的共享与操作系统环境下的共享其含义并不完全相同。前者只是说明某种资源能被大家使用，如图书馆中的图书能提供给大家借阅，但并未限定借阅者必须在同一时间（间隔）和同一地点阅读。又如，学校中的计算机机房供全校学生上机，或者说，全校学生共享该机房中的计算机设备，虽然所有班级的上机地点是相同的，但各班的上机时间并不相同。对于这样的资源共享方式，只要通过适当的安排，用户之间并不会产生对资源的竞争，因此资源管理是比较简单的。\n而在OS环境下的资源共享或称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。这里在宏观上既限定了时间（进程在内存期间），也限定了地点（内存）。对于这种资源共享方式，其管理就要复杂得多，因为系统中的资源远少于多道程序需求的总和，会形成它们对共享资源的争夺。所以，系统必须对资源共享进行妥善管理。由于资 源属性的不同，进程对资源复用的方式也不同，目前主要实现资源共享的方式有如下两种。\n互斥共享方式 系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程（线程）使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，在系统中应建立一种机制，以保证多个进程对这类资源的互斥访问。当进程A要访问某资源时，必须先提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。此后若再有其它进程也要访问该资源，只要A未用完就必须等待。仅当A进程访问完并释放系统资源后，才允许另一进程对该资源进行访问。这种资源共享方式称为互斥式共享，把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。系统中的大多数物理设备，以及栈、变量和表格，都属于临界资源，都只能被互斥地共享。为此，在系统中必须配置某种机制，用于保证诸进程互斥地使用临界资源。\n同时访问方式 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行的。典型的可供多个进程“同时”访问的资源是磁盘设备。一些用重入码编写的文件也可以被“同时”共享，即允许若干个用户同时访问该文件。\n并发和共享是多用户（多任务）OS的两个最基本的特征。它们又是互为存在的条件。即一方面资源共享是以进程的并发执行为条件的，若系统不允许并发执行也就不存在资源共享问题：另一方面，若系统不能对资源共享实施有效管理，以协调好诸进程对共享资源的访问，也必然会影响到诸进程间并发执行的程度，甚至根本无法并发执行。\n虚拟（Virtual） 用于实现“虚拟”的技术最早出现在通信系统中。在早期，每一条物理信道只能供一对用户通话，为了提高通信信道的利用率而引入了\u0026quot;虚拟”技术。该技术是通过\u0026quot;空分复用”或“时分复用”技术，将一条物理信道变为若干条逻辑信道，使原来只能供一对用户通话的物理信道，变为能供多个用户同时通话的逻辑信道。\n在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为\u0026quot;虚拟”。前者是实的，即实际存在的，而后者是虚的，是用户感觉上的东西。相应地，把用于实现虚拟的技术称为虚拟技术。在OS中也是利用时分复用和空分复用技术来实现\u0026quot;虚拟”的。\n时分复用技术 在计算机领域中，广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，使资源的利用率得以提高。时分复用技术能提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。\n1.虚拟处理机技术。利用多道程序设计技术，为每道程序建立至少一个进程，让多道程序并发执行。此时虽然系统中只有一台处理机，但通过分时复用的方法，能实现同时（宏观上）为多个用户服务，使每个终端用户都认为是有一个处理机在专门为他服务。亦即，利用多道程序设计技术，可将一台物理上的处理机虚拟为多台逻辑上的处理机，在每台逻辑处理机上运行一道程序，我们把用户所感觉到的处理机称为虚拟处理器。\n2.虚拟设备技术。我们还可以利用虚拟设备技术，也通过分时复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备，并允许每个用户占用一台逻辑上的I/O设备。 这样便可使原来仅允许在一段时间内由一个用户访问的设备（即临界资源），变为允许多个用户\u0026quot;同时”访问的共享设备，既宏观上能\u0026quot;同时”为多个用户服务。例如原来的打印机属于临界资源，而通过虚拟设备技术又可以把它变为多台逻辑上的打印机，供多个用户\u0026quot;同时”打印。\n空分复用技术 20世纪初，电信业中就已使用频分复用技术来提高信道的利用率。它是指将一个频率范围比较宽的信道划分成多个频率范围较窄的信道（称为频带），其中的任何一个频带都仅供一对用户通话。早期的频分复用技术只能将一条物理信道划分为几条到几十条话路，后来又很快发展到成千上万条话路，每条话路供一对用户通话。再后来在计算机中也把空分复用技术用于对存储空间的管理，用以提高存储空间的利用率。\n如果说，多道程序技术（时分复用技术）是通过利用处理机的空闲时间运行其它程序，提高了处理机的利用率，那么，空分复用技术则是利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率。\n但是，单纯的空分复用存储器只能提高内存的利用率，并不能实现在逻辑上扩大存储器容量的功能，还必须引入虚拟存储技术才能达到此目的。虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。例如，一个100MB的应用程序之所以可以运行在30MB的内存空间，实质上就是每次只把用户程序的一部分调入内存运行，运行完成后将该部分换出，再换入另一部分到内存中运行，通过这样的置换功能，便实现了用户程序的各个部分分时地进入内存运行。应当着重指出：虚拟的实现，如果是采用分时复用的方法，即对某一物理设备进行分时使用，设N是某物理设备所对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或低于物理设备速度的1/N。类似地，如果是利用空分复用方法来实现虚拟，此时一台虚拟设备平均占用的空间必然也等于或低于物理设备所拥有空间的1/N。\n异步（Asynchronism） 在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不可能\u0026quot;一气呵成”，而是以\u0026quot;停停走走”的方式运行。\n对于内存中的每个进程，在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需要多少时间才能完成等等，都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要I/O；而有的程序其计算少而I/O多，这样，很可能是先进入内存的作业后完成，而后进入内存的作业先完成。或者说，进程是以人们不可预知的速度向前推进的，此即进程的异步性。尽管如此,但只要在OS中配置有完善的进程同步机制，且运行环境相同，则作业即便经过多次运行，也都会获得完全相同的结果。因此异步运行方式是允许的，而且是操作系统的一个重要特征。\n操作系统的主要功能 引入OS的主要目的是，为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率，方便用户的使 用。为此，在传统的OS中应具有处理机管理、存储器管理、设备管理和文件管理等基本功能。此外，为了方便用户使用OS,还需向用户提供方便的用户接口。\n处理机管理功能 在传统的多道程序系统中，处理机的分配和运行都是以进程为基本单位的，因而对处理机的管理可归结为对进程的管理。处理机管理的主要功能有：创建和撤消进程，对诸进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理机分配给进程。\n进程控制 在多道程序环境下为使作业能并发执行，必须为每道作业创建一个或几个进程，并为之分配必要的资源。当进程运行结束时，应立即撤消该进程，以便能及时回收该进程所占用的各类资源，供其它进程使用。在设置有线程的OS中，进程控制还应包括为一个进程创建若干个线程，以提高系统的并发性。因此，进程控制的主要功能也就是为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换。\n进程同步 为使多个进程能有条不紊地运行，系统中必须设置相应的进程同步机制。该机制的主要任务是为多个进程（含线程）的运行进行协调。常用的协调方式有两种：1. 进程互斥方式,这是指诸进程在对临界资源进行访问时，应采用互斥方式；2. 进程同步方式，指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。最简单的用于实现进程互斥的机制是为每一个临界资源配置一把锁W,当锁打开时，进程可以对该临界资源进行访问:而当锁关上时，则禁止进程访问该临界资源。而实现进程同步时，最常用的机制是信号量机制。\n进程通信 当有一组相互合作的进程去完成一个共同的任务时，在它们之间往往需要交换信息。例如，有输入进程、计算进程和打印进程三个相互合作的进程，输入进程负责将所输入的数据传送给计算进程；计算进程利用输入数据进行计算，并把计算结果传送给打印进程；最后由打印进程把计算结果打印出来。进程通信的任务是实现相互合作进程之间的信息交换。\n当相互合作的进程处于同一计算机系统时，通常在它们之间采用直接通信方式，即由源进程利用发送命令直接将消息（message）‌挂到目标进程的消息队列上，以后由目标进程利用接收命令从其消息队列中取出消息。\n调度 在传统OS中，调度包括作业调度和进程调度两步。\n作业调度。作业调度的基本任务是从后备队列中按照一定的算法选择出若干个作业，为它们分配运行所需的资源，在将这些作业调入内存后，分别为它们建立进程，使它们都成为可能获得处理机的就绪进程，并将它们插入就绪队列中。 进程调度。进程调度的任务是从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给它，并为它设置运行现场，使其投入执行。 存储器管理功能 存储器管理的主要任务，是为多道程序的运行提供良好的环境，提高存储器的利用率， 方便用户使用，并能从逻辑上扩充内存。为此，存储器管理应具有内存分配和回收、内存 保护、地址映射和内存扩充等功能。\n内存分配 内存分配的主要任务是：\n为每道程序分配内存空间，使它们\u0026quot;各得其所”。 提高存储器的利用率，尽量减少不可用的内存空间(碎片)。 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 OS在实现内存分配时，可采取静态和动态两种方式：\n静态分配方式。每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间，也不允许作业在内存中“移动”。 动态分配方式。每个作业所要求的基本内存空间虽然也是在装入时确定的，但允 许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动\u0026quot;。 内存保护 内存保护的主要任务是：\n确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。 绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。 为了确保每道程序都只在自己的内存区中运行，必须设置内存保护机制。一种比较简单的内存保护机制是设置两个界限寄存器，分别用于存放正在执行程序的上界和下界。在程序运行时，系统须对每条指令所要访问的地址进行检查，如果发生越界，便发出越界中断请求，以停止该程序的执行。\n地址映射 在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其地址都是从0开始的，但不可能将它们从\u0026quot;0”地址(物理)开始装入内存，致使(各程序段的)地址空间内的逻辑地址与其在内存空间中的物理地址并不相一致。为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成。\n内存扩充 内存扩充并非是从物理上去扩大内存的容量，而是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。这样既满足了用户的需要，又改善了系统的性能。为了能在逻辑上扩充内存，系统必须设置内存扩充机制(包含少量的硬件)，用于实现下述各功能：\n请求调入功能，系统允许在仅装入部分用户程序和数据的情况下，便能启动该程序运行。在程序运行过程中，若发现要继续运行时所需的程序和数据尚未装入内存，可向OS发出请求，由OS从磁盘中将所需部分调入内存，以便继续运行。 置换功能，若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至硬盘上，以腾出内存空间，然后再将所需调入的部分装入内存。 设备管理功能 设备管理的主要任务如下：\n完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。 为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。\n缓冲管理 如果在I/O设备和CPU之间引入缓冲，则可有效地缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量。因此在现代OS中，无一例外地在内存中设置了缓冲区，而且还可通过增加缓冲区容量的方法来改善系统的性能。不同的系统可采用不同的缓冲区机制。最常见的缓冲区机制有：单缓冲机制、能实现双向同时传送数据的双缓冲机制、能供多个设备同时使用的公用缓冲池机制。上述这些缓冲区都由OS缓冲 管理机制将它们管理起来。\n设备分配 设备分配的基本任务是根据用户进程的I/O请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。如果在I/O设备和CPU之间还存在着设备控制器和I/O通道，则还需为分配出去的设备分配相应的控制器和通道。为实现设备分配，系统中应设置设备控制表、控制器控制表等数据结构，用于记录设备及控制器等的标识符和状态。根据这些表格可以了解指定设备当前是否可用，是否忙碌，以供进行设备分配时参考。在进行设备分配时，应针对不同的设备类型而采用不同的设备分配方式。对于独占设备的分配还应考虑到该设备被分配出去后系统是否安全。在设备使用完后，应立即由系统回收。\n设备处理 设备处理程序又称为设备驱动程序。其基本任务是用于实现CPU和设备控制器之间的通信，即由CPU向设备控制器发出I/O命令，要求它完成指定的I/O操作：反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的处理。\n设备处理过程是：首先检查I/O请求的合法性，了解设备状态是否是空闲的，读取有关的传递参数及设置设备的工作方式。然后向设备控制器发出I/O命令，启动I/O设备完成指定的I/O操作。此外设备驱动程序还应能及时响应由控制器发来的中断请求，并根据该中断请求的类型，调用相应的中断处理程序进行处理。对于设置了通道的计算机系统，设备处理程序还应能根据用户的I/O请求自动地构成通道程序。\n文件管理功能 文件管理的主要任务是对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。为此，文件管理应具有对文件存储空间的管理、目录管理、文件的读/写管理以及文件的共享与保护等功能。\n文件存储空间的管理 在多用户环境下，若由用户自己对文件的存储进行管理，不仅非常困难，而且也必然十分低效。因而需要由文件系统对诸多文件及文件的存储空间实施统一的管理。其主要任务是：为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存、取速度。为此，系统中应设置相应的数据结构，用于记录文件存储空间的使用情况，以供分配存储空间时参考。还应具有对存储空间进行分配和回收的功能。\n目录管理 目录管理的主要任务是为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名存取。即用户只需提供文件名，即可对该文件进行存取。目录管理还应能实现文件共享，这样，只需在外存上保留一份该共享文件的副本。此外，还应能提供快速的目录查询手段，以提高对文件检索的速度。\n文件的读/写管理和保护 文件的读/写管理。该功能是根据用户的请求，从外存中读取数据，或将数据写入外存。在进行文件读/写时，系统先根据用户给出的文件名去检索文件目录，从中获得文件在外存中的位置。然后，利用文件读/写指针，对文件进行读/写。一旦读/写完成，便修改读/写指针，为下一次读/写做好准备。由于读和写操作不会同时进行，故可合用一个读/写指针。 文件保护。为了防止系统中的文件被非法窃取和破坏，在文件系统中必须提供有效的存取控制功能，以实现下述目标：①防止未经核准的用户存取文件；②防止冒名顶替存取文件：③防止以不正确的方式使用文件。 操作系统与用户之间的接口 为了方便用户对操作系统的使用，操作系统向用户提供了 \u0026ldquo;用户与操作系统的接口二 该接口通常可分为如下两大类：\n用户接口 为了便于用户直接或间接地控制自己的作业，操作系统向用户提供了命令接口。用户可通过该接口向作业发出命令以控制作业的运行。该接口又进一步分为联机用户接口、脱机用户接口和图形用户接口三种。\n联机用户接口。这是为联机用户提供的，它由一组键盘操作命令及命令解释程序组成。当用户在终端或控制台上键入一条命令后，系统便立即转入命令解释程序，对该命令加以解释执行。在完成指定功能后系统又返回到终端或控制台上，等待用户键入下一条命令。这样，用户便可通过先后键入不同命令的方式来实现对作业的控制，直至作业完成。 脱机用户接口。这是为批处理作业的用户提供的。用户用作业控制语言JCL把需要对作业进行的控制和干预的命令事先写在作业说明书上，然后将它与作业一起提供给系统。当系统调度到该作业运行时，通过调用命令解释程序去对作业说明书上的命令逐条解释执行，直至遇到作业结束语句时系统才停止该作业的运行。 图形用户接口。通过联机用户接口取得OS的服务既不方便又花时间，用户必须熟 记所有命令及其格式和参数，并逐个字符地键入命令，于是图形用户接口便应运而生。图 形用户接口采用了图形化的操作界面，用非常容易识别的各种图标（icon）来将系统的各项功能、各种应用程序和文件直观、逼真地表示出来。用户可通过菜单（和对话框）用移动鼠标选择菜单项的方式取代命令的键入，以方便、快捷地完成对应用程序和文件的操作，从而把用户从繁琐且单调的操作中解脱出来。 程序接口 程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。每当应用程序要求OS提供某种服务（功能）时，便调用具有相应功能的系统调用（子程序）。早期的系统调用都是用汇编语言提供的，只有在用汇编语言书写的程序中才能直接使用系统调用。但在高级语言以及C语言中，往往提供了与各系统调用一一对应的库函数，这样，应用程序便可通过调用对应的库函数来使用系统调用。但在近几年所推出的操作系统中，如UNIX、OS/2版本中，其系统调用本身已经采用C语言编写，并以函数形式提供，故在用C语言编制的程序中，可直接使用系统调用。\n现代操作系统的新功能 现代操作系统是在传统操作系统基础上发展起来的，它除了具有传统操作系统的功能外，还增加了面向安全、面向网络和面向多媒体等功能。\n系统安全 通常，政府机关和企事业单位有大量的、重要的信息，必须高度集中地存储在计算机系统中。这样，如何确保在计算机系统中存储和传输数据的保密性、完整性和系统可用性，便成为信息系统亟待解决的重要问题，而保障系统安全性的任务也责无旁贷地落到了现代OS的身上。\n虽然在传统的OS中也采取了一些保障系统安全的措施，但随着计算技术的进步和网络的普及，传统的安全措施已远不能满足要求。为此，在现代OS中采取了多种有效措施来确保系统的安全。在本书中我们仅局限于介绍保障系统安全的几个技术问题，包括：\n认证技术。这是一个用来确认被认证的对象是否名副其实的过程，以确定对象的真实性，防止入侵者进行假冒和篡改等。如身份认证，是通过验证被认证对象的一个或多个参数的真实性和有效性来确定被认证对象是否名副其实；因此，在被认证对象与要验证的那些参数之间应存在严格的对应关系。 密码技术。即对系统中所需存储和传输的数据进行加密，使之成为密文，这样，攻击者即使截获到数据，也无法了解到数据的内容。只有指定的用户才能对该数据予以解密，了解其内容，从而有效地保护了系统中信息资源的安全性。近年来，国内外广泛应用数据加密技术来保障计算机系统的安全性。 访问控制技术，可通过两种途径来保障系统中资源的安全：①通过对用户存取权限的设置，可以限定用户只能访问被允许访问的资源，这样也就限定了用户对系统资源的访问范围；②访问控制还可以通过对文件属性的设置来保障指定文件的安全性，如设置文件属性为只读时，该文件就只能被读而不能被修改等。 反病毒技术。对于病毒的威胁，最好的解决方法是预防，不让病毒侵入系统，但要完全做到这一点是十分困难的，因此还需要非常有效的反病毒软件来检测病毒。在反病毒软件被安装到计算机后，便可对硬盘上所有的可执行文件进行扫描，检查盘上的所有可执行文件，若发现有病毒，便立即将它清除。 网络功能和服务 在现代OS中，为支持用户联网取得各类网络所提供的服务，如电子邮件服务、Web服务等，应在操作系统中增加面向网络的功能，用于实现网络通信和资源管理，以及提供用户取得网络服务的手段。作为一个网络操作系统，应当具备多方面的功能：\n网络通信，用于在源主机和目标主机之间，实现无差错的数据传输，如建立和拆除通信链路、传输控制、差错控制和流量控制等。 资源管理，即对网络中的共享资源(硬件和软件)实施有效的管理，协调诸用户对共享资源的使用，保证数据的安全性和一致性。典型的共享硬件资源有硬盘、打印机等，软 件资源有文件和数据。 应用互操作，即在一个由若干个不同网络互连所构成的互连网络中，必须提供应 用互操作功能，以实现信息的互通性和信息的互用性。信息的互通性是指在不同网络中的用户之间，能实现信息的互通。信息的互用性是表示用户可以访问不同网络中的文件系统 和数据库系统中的信息。 支持多媒体 一个支持多媒体的操作系统必须能像一般OS处理文字、图形信息那样去处理音频和视频信息等多媒体信息，为此，现代操作系统增加了多媒体的处理功能：\n接纳控制功能。在多媒体系统中，为了保证同时运行多个实时进程的截止时间，需要对在系统中运行的软实时任务，即SRT任务的数目、驻留在内存中的任务数目加以限制，为此设置了相应的接纳控制功能，如媒体服务器的接纳控制、存储器接纳控制和进程接纳控制。 实时调度。多媒体系统中的每一个任务，往往都是一些要求较严格的、周期性的软实时任务SRT,如为了保证动态图像的连续性，图像更新的周期必须在40ms之内，因此在SRT调度时，不仅需要考虑进程的调度策略，还要考虑进程调度的接纳度等，相比传统的OS这就要复杂得多。 多媒体文件的存储。为了存放多媒体文件，对OS最重要的要求是能把硬盘上的数据快速地传送到输出设备上。因此，对于在传统文件系统中数据的离散存放方式以及磁盘寻道方式都要加以改进。 OS结构设计 早期OS的规模很小，如只有几十KB,完全可以由一个人以手工方式，用几个月的时间编制出来。此时，编制程序基本上是一种技巧，OS是否是有结构的并不那么重要，重要的是程序员的程序设计技巧。但随着OS规模的愈来愈大，其所具有的代码也愈来愈多，往往需要由数十人或数百人甚至更多的人参与，分工合作，共同来完成操作系统的设计。这意味着，应采用工程化的开发方法对大型软件进行开发。由此产生了\u0026quot;软件工程学”。\n软件工程的目标是十分明确的，所开发出的软件产品应具有良好的软件质量和合理的费用。整个费用应能为用户所接受：软件质量可用这样几个指标来评价：功能性、有效性、可靠性、易使用性、可维护性和易移植性。为此，先后产生了多种操作系统的开发方法，如模块化方法、结构化方法和面向对象的方法等。利用不同的开发方法所开发出的操作系统将具有不同的操作系统结构。\n传统操作系统的结构 软件开发技术的不断发展，促进了 OS结构的更新换代。这里，我们把早期的无结构的OS（第一代）、模块化结构的OS（第二代）和分层式结构的OS（第三代），都统称为传统结构的OS,而把微内核结构的OS称为现代结构的OS。\n无结构操作系统 在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。\n此时程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。当系统不太大，在一个人能够完全理解和掌握的情况下问题还不是太大，但随着系统的不断扩大，所设计出的操作系统就会变得既庞大又杂乱。这一方面会使所编制出的程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。\n模块化结构操作系统 1. 模块化程序设计技术的基本概念\n模块化程序设计技术是20世纪60年代出现的一种结构化程序设计技术。该技术基于\u0026quot;分解\u0026quot;和“模块化”的原则来控制大型软件的复杂度。为使OS具有较清晰的结构，OS不再是由众多的过程直接构成的，而是按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，如进程管理模块、存储器管理模块、I/O设备管理模块等，并仔细地规定好各模块间的接口，使各模块之间能通过接口实现交互。然后再进一步将各模块细分为若干个具有一定功能的子模块，如把进程管理模块又分为进程控制、进程同步等子模块，同样也规定好各子模块之间的接口。若子模块较大，可再进一步将它细分。我们把这种设计方法称为模块-接口法，由此构成的操作系统就是具有模块化结构的操作系统。图7示出了由模块、子模块等组成的模块化OS结构。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 操作系统 模块 进程控制 进程调度 ··· 进程管理 存储器管理 文件管理 ··· ··· 内存分配 内存保护 ··· 磁盘管理 目录管理 ··· 子模块 图7\u0026emsp;模块化结构的操作系统\n2. 模块独立性\n在模块\u0026mdash;接口法中，关键问题是模块的划分和规定好模块之间的接口。如果我们在划分模块时将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，从而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加，因此在划分模块时，应在两者间进行权衡。\n另外，在划分模块时，必须充分注意模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性有以下两个标准：\n内聚性。指模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越强。 耦合度。指模块间相互联系和相互影响的程度。显然，耦合度越低，模块独立性越好。 3. 模块接口法的优缺点\n利用模块\u0026mdash;接口法开发的OS,较之无结构OS具有以下明显的优点：\n提高OS设计的正确性、可理解性和可维护性。 增强OS的可适应性。 加速OS的开发过程。 模块化结构设计仍存在下述问题：\n在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。 在OS设计阶段，设计者必须做出一系列的决定（决策），每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为“无序模块法”。 分层式结构操作系统 1. 分层式结构的基本概念\n为了将模块\u0026mdash;接口法中“决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统 \\(A_n\\) 和裸机系统（又称宿主系统） \\(A_0\\) 之间，铺设若干个层次的软件 \\(A_1,A_2,A_3,\\cdot,A_{n-1}\\) ，使 \\(A_n\\) 通过 \\(A_{n-1},A_{n-2},\\cdots,A_2,A_1\\) 层，最终能在 \\(A_0\\) 上运行。在操作系统中，常采用自底向上法来铺设这些中间层。\n自底向上的分层设计的基本原则是：每一步设计都建立在可靠的基础上。为此规定，每一层仅能使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得更容易。例如，在调试第一层软件 \\(A_1\\) 时，由于它使用的是一个完全确定的物理机器（宿主系统）所提供的功能，在对 \\(A_1\\) 软件经过精心设计和几乎是穷尽无遗的测试后，可以认为 \\(A_1\\) 是正确的，而且它与其所有的高层软件 \\(A_2,\\cdots,A_n\\) 无关；同样在调试第二层软件 \\(A_2\\) 时，它也只使用了软件 \\(A_1\\) 和物理机器所提供的功能，而与其高层软件 \\(A_3,\\cdots,A_n\\) 无关，如此一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。在用这种方法构成操作系统时，已将一个操作系统分为若干个层次，每层又由若干个模块组成，各层之间只存在着单向的依赖关系，即高层仅依赖于紧邻它的低层。\n2. 分层结构的优缺点\n分层结构的主要优点有：\n易保证系统的正确性。自下而上的设计方式使所有设计中的决定都是有序的，或 者说是建立在较为可靠的基础上的，这样比较容易保证整个系统的正确性。 易扩充和易维护性。在系统中增加、修改或替换一个层次中的模块或整个层次时，只要不改变相应层次间的接口，就不会影响其他层次，这必将使系统维护和扩充变得更加容易。分层结构的主要缺点是系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。 客户/服务器模式（Client/Server Model）简介 客户/服务器(Client/Server)模式可简称为C/S模式。其在20世纪90年代已风靡全球，不论是LAN,还是企业网，以及Internet所提供的多种服务，都广泛采用了客户/服务器的模式。\n客户/服务器模式的由来、组成和类型 客户/服务器系统主要由三部分组成。\n客户机：通常在一个LAN网络上连接有多台网络工作站（简称客户机），每台客户机都是一个自主计算机，具有一定的处理能力，客户进程在其上运行，平时它处理一些本 地业务，也可发送一个消息给服务器，以请求某项服务。 服务器：通常是一台规模较大的机器，在其上驻留有网络文件系统或数据库系统等，它应能为网上所有的用户提供一种或多种服务。平时它一直处于工作状态，被动地等待来自客户机的请求，一旦检查到有客户提出服务请求，便去完成客户的请求，并将结果送回客户，这样，工作站中的用户进程与服务器进程就形成了客户/服务器关系。 网络系统：是用于连接所有客户机和服务器，实现它们之间通信和网络资源共享的系统。 客户/服务器之间的交互 在采用客户/服务器的系统中，通常是客户机和服务器共同完成对应用（程序）的处理。这时，在客户机和服务器之间就需要进行交互，即必须利用消息机制在这两者之间进行多次通信。一次完整的交互过程可分成以下四步：\n客户发送请求消息。当客户机上的用户要请求服务器进行应用处理时，应输入相应的命令和有关参数。由客户机上的发送进程先把这些信息装配成请求消息，然后把它发往服务器；客户机上的接收进程则等待接收从服务器发回来的响应消息。 服务器接收消息。服务器中的接收进程平时处于等待状态，一旦有客户机发来请 求，接收进程就被激活，根据请求信息的内容，将之提供给服务器上的相应软件进行处理。 服务器回送消息。服务器的软件根据请求进行处理，在完成指定的处理后，把处 理结果装配成一个响应消息，由服务器中的发送进程将之发往客户机。 客户机接收消息。客户机中的接收进程把收到的响应消息转交给客户机软件，再 由后者做出适当处理后提交给发送该请求的客户。 客户/服务器模式之间的优点 C/S模式之所以能成为在分布式系统和网络环境下软件的一种主要工作模式，是由于该模式具有传统集中模式所无法比拟的一系列优点。\n数据的分布处理和存储。由于客户机具有相当强的处理和存储能力，可进行本地处理和数据的分布存储，从而摆脱了由于把一切数据都存放在主机中而造成的既不可靠又容易产生瓶颈现象的困难局面。 便于集中管理。尽管C/S模式具有分布处理功能，但公司(单位)中的有关全局的重 要信息、机密资料、重要设备以及网络管理等，仍可采取集中管理方式，这样可较好地保障系统的“可靠”和\u0026quot;安全”。 灵活性和可扩充性。C/S模式非常灵活，极易扩充。理论上，客户机和服务器的数 量不受限制，其灵活性还表现在可以配置多种类型的客户机和服务器上。 易于改编应用软件。在客户/服务器模式中，对于客户机程序的修改和增删，比传 统集中模式要容易得多，必要时也允许由客户进行修改。 基本客户/服务器模式的不足之处是存在着不可靠性和瓶颈问题。在系统仅有一个服务器时，一旦服务器故障，将导致整个网络瘫痪。当服务器在重负荷下工作时，会因忙不过来而显著地延长对用户请求的响应时间。如果在网络中配置多个服务器，并采取相应的安全措施，则这种不足可加以改善。\n面向对象的程序设计（Object-Orientated Programming）技术简介 面向对象技术的基本概念 面向对象技术是20世纪80年代初提出并很快流行起来的。该技术是基于\u0026quot;抽象\u0026quot;和\u0026quot;隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物（事物可以是一个物理实体、一个概念或一个软件模块等）的抽象，而把其中的具体事物称为对象的实例。如果在OS中的各类实体如进程、线程、消息、存储器和文件等都使用了对象这一概念，相应地，便有了进程对象、线程对象、消息对象、存储器对象和文件对象等。\n1. 对象\n在面向对象的技术中，是利用被封装的数据结构（变量）和一组对它进行操作的过程（方法）来表示系统中的某个对象的，如图8所示。对象中的变量（数据）也称为属性，它可以是单个标量或一张表。面向对象中的方法是用于执行某种功能的过程，它可以改变对象的状态，更新对象中的某些数据值或作用于对象所要访问的外部资源。如果把一个文件作为一个对象图9,该对象的变量便是文件类型、文件大小、文件的创建者等。对象中的方法包含对文件的操作，如创建文件、打开文件、读文件、写文件、关闭文件等。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 数据结构 过程 1 过程 2 过程 3 图8\u0026emsp;一个对象的示意图\n对象中的变量（数据）对外是隐蔽的，因而外界不能对它直接进行访问，必须通过该对象中的一组方法（操作函数）对它进行访问。例如要想对图9所示的文件A执行打开操作，必须用该对象中的打开过程去打开它。同样地，对象中的一组方法的实现细节也是隐蔽的，因此对象中的变量可以得到很好的保护，而不会允许未经受权者使用和对它进行不正确的操作。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 类名 属性 操作 类 (类名)对象名 属性值 操作 类的实例 文件 类型 打开() 大小 创建者 读() 写() 关闭() （文件）文件 图表 打开() 20K X用户 读() 写() 关闭() 图9\u0026emsp;类和对象的关系\n2. 对象类\n在实践中，有许多对象可能表示的是同一类事物，每个对象具有自己的变量集合，而它们所具有的方法是相同的。如果为每一个相似的对象都定义一组变量和方法，显然是低效的，由此产生了“对象类”的概念，利用\u0026quot;对象类”来定义一组大体相似的对象。一个类同样定义了一组变量和针对该变量的一组方法，用它们来描述一组对象的共同属性和行为。类是在对象上的抽象，对象则是类的实例。对象类中所定义的变量在实例中均有具体的值。\n例如，我们将文件设计成一个类，类的变量同样是文件类型、文件大小和创建者等。类中的方法是文件的创建、打开、读写、关闭等。图9示出了一个文件类，在类的变量中没有具体数值，一旦被赋予了具体数值就成了文件A对象。对象类的概念非常有用，因为它极大地提高了创建多个相似对象的效率。\n3. 继承\n在面向对象的技术中，可以根据已有类来定义一个新的类，新类被称为子类（B）,原来的类被称为父类（A）,见图10所示。继承是父类和子类之间共享变量和方法的机制，该机制规定子类自动继承父类中定义的变量和方法，并允许子类再增加新的内容。继承特性可使定义子类变得更容易。一个父类可以定义多个子类，它们分别是父类的某种特例，父类描述了这些子类的公共变量和方法。类似地，这些子类又可以定义自己的子类，通过此途经可以生成一个继承的层次。另外，也允许一个子类有两个父类或多个父类，它可以从多个父类获得继承，此时称为\u0026quot;多重继承”。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 继承部分 A 增加部分 B 从A继承 图10\u0026emsp;类和继承的关系\n面向对象技术的优点 在操作系统设计时，将计算机中的实体作为对象来处理，可带来如下好处:\n通过“重用”提高产品质量和生产率。在面向对象技术中可通过“重用”以前项目中经过精心测试的对象或“重用”由其他人编写、测试和维护的对象类来构建新的系统，这不仅可大大降低开发成本，而且能获得更好的系统质量。 使系统具有更好的易修改性和易扩展性。通过封装，可隐蔽对象中的变量和方法，因而当改变对象中的变量和方法时，不会影响到其它部分，从而可方便地修改老的对象类。另外，继承是面向对象技术的重要特性，在创建一个新对象类时，通过利用继承特性可显著减少开发的时空开销，使系统具有更好的易扩展性和灵活性。 更易于保证系统的\u0026quot;正确性”和\u0026quot;可靠性”。对象是构成操作系统的基本单元，由于可以独立地对它进行测试，易于保证每个对象的正确性和可靠性，因此也就比较容易保证整个系统的正确性和可靠性。此外，封装对对象类中的信息进行了隐蔽，这样又可有效地防止未经授权者的访问和用户不正确的使用，有助于构建更为安全的系统。 微内核操作系统 微内核（MicroKernel）操作系统结构是20世纪80年代后期发展起来的。由于它能有效地支持多处理机运行，故非常适用于分布式系统环境，当前比较流行的、能支持多处理机运行的OS,几乎全部都采用了微内核结构，如CarngieMellon大学研制的MachOS,便属于微内核结构OS；又如当前广泛使用的Windows2000/XP操作系统，也采用了微内核结构。\n微内核操作系统的基本概念 为了提高操作系统的\u0026quot;正确性”、“灵活性”、\u0026ldquo;易维护性”和“可扩充性”，在进行现代操作系统结构设计时，即使在单计算机环境下，大多也采用基于客户/服务器模式的微内核结构，将操作系统划分为两大部分：微内核和多个服务器。至于什么是微内核操作系统结构,现在尚无一致公认的定义，但我们可以从下面四个方面对微内核结构的操作系统进行描述。\n1. 足够小的内核\n在微内核操作系统中，内核是指精心设计的、能实现现代OS最基本核心功能的小型内核，微内核并非是一个完整的OS,而只是将操作系统中最基本的部分放入微内核，通常包含有：①与硬件处理紧密相关的部分：②一些较基本的功能；③客户和服务器之间的通信。这些OS最基本的部分只是为构建通用OS提供一个重要基础，这样就可以确保把操作系统内核做得很小。\n2. 基于客户/服务器模式\n由于客户/服务器模式具有非常多的优点，故在单机微内核操作系统中几乎无一例外地都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供I/O设备管理的I/O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图11示出了在单机环境下的客户/服务器模式。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 客户进程 客户进程 进程服务器 终端服务器 ··· 文件服务器 存储器服务器 核心 请求 回答 用户方式 核心方式 图11\u0026emsp;在单机环境下的客户/服务器模式\n3. 应用“机制与策略分离”原理\n在现在操作系统的结构设计中，经常利用“机制与策略分离”的原理来构造OS结构。所谓机制，是指实现某一功能的具体执行机构。而策略，则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。通常，机制处于一个系统的基层，而策略则处于系统的高层。在传统的OS中，将机制放在OS的内核的较低层，把策略放在内核的较高层次中。而在微内核操作系统中，通常将机制放在OS的微内核中。正因为如此，才有可能将内核做得很小。\n4. 采用面向对象技术\n操作系统是一个极其复杂的大型软件系统，我们不仅可以通过结构设计来分解操作系统的复杂度，还可以基于面向对象技术中的\u0026quot;抽象”和\u0026quot;隐蔽”原则控制系统的复杂性，再进一步利用\u0026quot;对象”、\u0026ldquo;封装”和“继承”等概念来确保操作系统的\u0026quot;正确性”、\u0026ldquo;可靠性\u0026rdquo;、“易修改性\u0026rdquo;、\u0026ldquo;易扩展性”等，并提高操作系统的设计速度。正因为面向对象技术能带来如此多的好处，故面向对象技术被广泛应用于现代操作系统的设计中。\n微内核的基本功能 微内核应具有哪些功能，或者说哪些功能应放在微内核内，哪些应放在微内核外，目前尚无明确的规定。现在一般都采用“机制与策略分离”的原理，将机制部分以及与硬件紧密相关的部分放入微内核中。由此可知微内核通常具有如下几方面的功能：\n1. 进程（线程）管理\n大多数的微内核OS,对于进程管理功能的实现，都采用“机制与策略分离”的原理，例如，为实现进程（线程）调度功能，须在进程管理中设置一个或多个进程（线程）优先级队列;能将指定优先级进程（线程）从所在队列中取出，并将其投入执行。由于这一部分属于调度功能的机制部分，应将它放入微内核中。而对于用户（进程）如何进行分类，以及其优先级的确认方式或原则，则都是属于策略问题。可将它们放入微内核外的进程（线程）管理服务器中。由于进程（线程）之间的通信功能是微内核OS最基本的功能，被频繁使用，因此几乎所有的微内核OS都是将进程（线程）之间的通信功能放入微内核中。此外，还将进程的切换、线程的调度，以及多处理机之间的同步等功能也放入微内核中。\n2. 低级存储器管理。\n通常在微内核中，只配置最基本的低级存储器管理机制，如用于实现将用户空间的逻辑地址变换为内存空间的物理地址的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法、采用何种内存分配与回收的策略等，应将这部分放在微内核外的存储器管理服务器中去实现。\n3. 中断和陷入处理\n大多数微内核操作系统都是将与硬件紧密相关的一小部分放入微内核中处理，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行相应的前期处理，如进行中断现场保护，识别中断和陷入的类型，然后将有关事件的信息转换成消息后，把它发送给相关的服务器。由服务器根据中断或陷入的类型调用相应的处理程序来进行后期处理。在微内核OS中是将进程管理、存储器管理以及I/O管理这些功能-分为二，属于机制的很小一部分放入微内核中，另外绝大部分放在微内核外的各种服务器中来实现。事实上，其中大多数服务器都要比微内核大。这进一步说明了为什么能在采用客户/服务器模式后，还能把微内核做得很小的原因。\n微内核操作系统的优点 由于微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的操作系统是集各种技术优点之大成，因而使之具有如下优点：\n提高了系统的可扩展性。由于微内核OS的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核OS只需在相应的服务器中增加新的功能， 或再增加一个专门的服务器。与此同时，也必然改善系统的灵活性，不仅可在操作系统中增加新的功能,还可修改原有的功能，以及删除已过时的老功能，以形成一个更为精干的有效的操作系统。 增强了系统的可靠性。这一方面是由于微内核是通过精心设计和严格测试的，容易保证其正确性，另一方面，它提供了规范而精简的应用程序接口（API）,为微内核外部的 程序编制高质量的代码创造了条件。此外，由于所有服务器都是运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，当某个服务器出现错误时，不会影响内核，也不会影响其它服务器。 可移植性强。随着硬件的快速发展，出现了各种各样的硬件平台，作为一个好的 操作系统，必须具备可移植性，使其能较容易地运行在不同的计算机硬件平台上。在微内 核结构的操作系统中，所有与特定CPU和I/O设备硬件有关的代码，均放在内核和内核下 面的硬件隐藏层中，而操作系统其它绝大部分——各种服务器，均与硬件平台无关，因而， 把操作系统移植到另一个计算机硬件平台上所需作的修改是比较小的。 提供了对分布式系统的支持。由于在微内核0S中，客户和服务器之间、服务器和服务器之间的通信采用消息传递通信机制，致使微内核OS能很好地支持分布式系统和网络系统。事实上，只要在分布式系统中赋予所有进程和服务器唯一的标识符，在微内核中再配置一张系统映射表（即进程和服务器的标识符与它们所驻留的机器之间的对应表），在进行客户与服务器通信时，只需在所发送的消息中标上发送进程和接收进程的标识符，微内核便可利用系统映射表将消息发往目标，而无论目标是驻留在哪台机器上。 融入了面向对象技术。在设计微内核OS时采用了面向对象的技术，其中的“封装”，\u0026ldquo;继承”，\u0026ldquo;对象类”和“多态性\u0026rdquo;，以及在对象之间采用消息传递机制等，都十分有利于提高系统的正确性、可靠性、易修改性、易扩展性等，而且还能显著地减少开发系统所付出的开销。 微内核操作系统存在的问题 应当指出，在微内核操作系统中，由于采用了非常小的内核，客户/服务器模式和消息传递机制虽给微内核操作系统带来了许多优点，但由此也使微内核OS存在着潜在缺点，其中最主要的是，较之早期的操作系统，微内核操作系统的运行效率有所降低。\n效率降低最主要的原因是，在完成一次客户对操作系统提出的服务请求时，需要利用消息实现多次交互和进行用户/内核模式与上下文的多次切换。然而，在早期的OS中，用户进程在请求取得OS服务时，一般只需进行两次上下文的切换：一次是在执行系统调用后由用户态转向系统态时：另一次是在系统完成用户请求的服务后，由系统态返回用户态时。\n在微内核OS中，由于客户和服务器、服务器和服务器之间的通信都需通过微内核，致使同样的服务请求至少需要进行四次上下文切换。第一次是发生在客户发送请求消息给内核，以请求取得某服务器特定的服务时；第二次是发生在由内核把客户的请求消息发往服务器时；第三次是当服务器完成客户请求后，把响应消息发送到内核时；第四次是在内核将响应消息发送给客户时。\n实际情况是往往还会引起更多的上下文切换。例如，当某个服务器自身尚无能力完成客户请求而需要其它服务器的帮助时，如图1-12所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行8次上下文的切换。\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 客户机应用 OS内核 (a)在整体式内核文件操作中的上下文切换 客户机应用 文件服务器 磁盘设备驱动器 微内核 (b)在微内核中等价操作中的上下文切换 图12\u0026emsp;在传统OS和微内核OS中的上下文切换\n为了改善运行效率，可以重新把一些常用的操作系统基本功能由服务器移入微内核中。这样可使客户对常用操作系统功能的请求所发生的用户/内核模式和上下文的切换的次数由4次或8次降为2次。但这又会使微内核的容量明显地增大，在小型接口定义和适应性方面的优点也有所下降，并提高了微内核的设计代价。\n我想念她。罪有应得。 ― 邱妙津, 《鳄鱼手记》 ","date":"2024-09-19T22:28:10+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/computer_science/operating_system/introduction_to_operating_system/","title":"操作系统（一）：操作系统概论"},{"content":" Markov过程 有一类随机过程，它具备所谓的“无后效性”（Markov性），即，要确定过程将来的状态，知道它此刻的情况就足够了，并不需要对它以往的情况的认识，这类过程称为Markov过程。本文将介绍Markov过程中最简单的两种类型：离散时间Markov链（简称马氏链）及连续时间的Markov链。\n基本概念 Markov链的定义 Markov链 定义1（Markov链）：给定随机过程 \\(\\set{X_n,n=0,1,2,\\cdots}\\) ，若它只取有限或可列个值 \\(E_0,E_1,E_2,\\cdots\\) （我们以 \\(\\set{0,1,2,\\cdots}\\) 来标记 \\(E_0,E_1,E_2\\) 并称他们是过程的状态， \\(\\set{0,1,2\\cdots}\\) 或者其子集记为 \\(S\\) ，称为过程的状态空间）。若对 \\(\\set{X_n,n=0,1,2,\\cdots}\\) （一般就认为它的状态是非负整数）和任意的 \\(n\\ge0\\) 及状态 \\(i,j,i_0,i_1\\cdots,i_{n-1}\\) ，有\n\\[ \\begin{aligned} \u0026P\\set{X_{n+1}=j|X_0=i_0,X_1=i_1,X_2=i_2,\\cdots,X_{n-1}=i_{n-1},X_n=i}\\\\[5pt] =\u0026P\\set{X_{n+1}=j|X_n=i} \\end{aligned} \\tag{1} \\] 则称随机过程 \\(\\set{X_n,n=0,1,2,\\cdots}\\) 为Markov链。\nMarkov性 式(1)刻画了Markov链的特性，故称为Markov性。\n转移概率 转移概率的定义 定义2（一步转移概率）：称式(1)中的条件概率 \\(P\\set{X_{n+1}=j|X_n=i}\\) 为Markov链 \\(\\set{X_n\\left(n=0,1,2,\\cdots\\right)}\\) 的一步转移概率，简称转移概率。\n一般情况下，转移概率与状态 \\(i,j\\) 和时刻 \\(n\\) 有关。\n时齐Markov链 定义3（时齐）：当Markov链的转移概率只与状态 \\(i,j\\) 有关，而与 \\(n\\) 无关时，称Markov链为时齐的，并记 \\(p_{ij}=P\\set{X_{n+1}=j|X_n=i}\\left(n \\ge 0\\right)\\) ；否则，就称之为非时齐的。\n本文只讨论时齐Markov链并将其简称为Markov链。\n有限链和无限链 定义4（有限链和无限链）：当Markov链的状态为有限时，成为有限链，否则成为无限链。但无论状态有限还是无限，我们都可以将 \\(p_{ij}\\left(i,j\\in S\\right)\\) 排成一个矩阵的形式，令\n\\[ \\bm{P}=\\left(p_{ij}\\right)= \\begin{pmatrix} p_{00} \u0026 p_{01} \u0026 p_{02} \u0026 p_{03} \u0026 \\cdots \\\\[5pt] p_{10} \u0026 p_{11} \u0026 p_{12} \u0026 p_{13} \u0026 \\cdots \\\\[5pt] p_{20} \u0026 p_{21} \u0026 p_{22} \u0026 p_{23} \u0026 \\cdots \\\\[5pt] p_{30} \u0026 p_{31} \u0026 p_{32} \u0026 p_{33} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \\\\[5pt] \\end{pmatrix} \\tag{2} \\] 则称 \\(\\bm{P}\\) 为转移概率矩阵，一般称为转移矩阵。容易看出 \\(p_{ij}\\left(i,j\\in S\\right)\\) 有性质\n\\[ p_{ij} \\ge 0, i,j\\in S \\tag{3} \\] \\[ \\sum_{j \\in S}{p_{ij}} = 1, \\forall i \\in S \\tag{4} \\]\nn步转移概率与C-K方程 n步转移概率 定义5（n步转移概率）：称条件概率\n\\[ p_{ij}^{\\left(n\\right)}=P\\set{X_{m+n}=j|X_m=i}\\quad i,j\\in S,m \\ge 0, n \\ge 1 \\tag{5} \\] 为Markov链的n步转移概率，相应地称 \\(\\bm{P}^{\\left(n\\right)}=\\left(p_{ij}^{\\left(n\\right)}\\right)\\) 为n步转移矩阵。\n当 \\(n=1\\) 时， \\(p_{ij}^{\\left(1\\right)}=p_{ij}\\) ， \\(\\bm{P}^{\\left(1\\right)}=\\bm{P}\\) 。此外规定\n\\[ p_{ij}^{\\left(0\\right)}= \\begin{cases} 0, \\quad i \\ne j\\\\[5pt] 1, \\quad i=j \\end{cases} \\tag{6} \\] 显然，n步转移概率 \\(p_{ij}^{\\left(n\\right)}\\) 指的就是系统从状态 \\(i\\) 经过 \\(n\\) 步后转移到了 \\(j\\) 的概率，它对中间的 \\(n-1\\) 步转移经过的状态无要求。下面的定理给出了 \\(p_{ij}^{\\left(n\\right)}\\) 和 \\(p_{ij}\\) 的关系。\nC-K方程 定理1（Charpman-Kolmogorov方程，简称C-K方程）：对一切 \\(n,m \\ge 0\\) ， \\(i,j \\in S\\) 有\n\\[ p_{ij}^{\\left(m+n\\right)}=\\sum_{k \\in S}{p_{ik}^{\\left(m\\right)}}p_{kj}^{\\left(n\\right)} \\tag{7} \\] \\[ \\bm{P}^{\\left(n\\right)}=\\bm{P} \\cdot \\bm{P}^{\\left(n-1\\right)} = \\bm{P} \\cdot \\bm{P} \\cdot \\bm{P}^{\\left(n-2\\right)} = \\cdots = \\bm{P}^n \\tag{8} \\] 证明（C-K方程）‌：由全概率公式可得\n\\[ \\begin{aligned} p_{ij}^{\\left(m+n\\right)}\u0026=P\\set{X_{m+n}=j|X_0=i}\\\\[5pt] \u0026=\\frac{P\\set{X_{m+n}=j,X_0=i}}{P\\set{X_0=i}}\\\\[10pt] \u0026=\\sum_{k \\in S}{\\frac{P\\set{X_{m+n}=j,X_m=k,X_0=i}}{P\\set{X_0=i}}}\\text{（全概率公式）}\\\\ \u0026=\\sum_{k \\in S}{\\frac{P\\set{X_{m+n}=j,X_m=k,X_0=i}}{P\\set{X_m=k,X_0=i}}\\frac{P\\set{X_m=k,X_0=i}}{P\\set{X_0=i}}}\\\\ \u0026=\\sum_{k \\in S}{P\\set{X_{m+n}=j|X_m=k,X_0=i}}P\\set{X_m=k|X_0=i}\\\\ \u0026=\\sum_{k \\in S}{p_{kj}^{\\left(n\\right)}p_{ik}^{\\left(m\\right)}}\\\\ \u0026=\\sum_{k \\in S}{p_{ik}^{\\left(m\\right)}p_{kj}^{\\left(n\\right)}} \\end{aligned} \\tag{9} \\] 由矩阵乘法易得式(8)是式(7)的矩阵形式。\n结论1：对任意 \\(n_1,n_2,n_3,\\cdots,n_m\\left(n_i\\ge0\\right)\\) 和 \\(k_1,k_2,k_3,\\cdots,k_m\\left(k_j \\in S\\right)\\) ，有\n\\[ p_{ij}^{\\left(n_1+n_2+n_3+\\cdots+n_m\\right)}\\ge p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2k_3}^{\\left(n_3\\right)}\\cdots p_{k_{m-1}j}^{\\left(n_m\\right)} \\tag{10} \\] 证明（结论1）‌：由C-K方程和概率的非负性可得\n\\[ \\begin{aligned} p_{ij}^{\\left(n_1+n_2+n_3+\\cdots+n_m\\right)}=\u0026\\sum_{k \\in S}p_{ik}^{\\left(n_1\\right)}p_{kj}^{\\left(n_2+n_3+\\cdots+n_m\\right)}\\\\[5pt] \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1j}^{\\left(n_2+n_3+\\cdots+n_m\\right)}\\\\[5pt] \\ge\u0026\\sum_{k \\in S}p_{ik_1}^{\\left(n_1\\right)}p_{k_1k}^{\\left(n_2\\right)}p_{kj}^{\\left(n_3+\\cdots+n_m\\right)}\\\\ \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2j}^{\\left(n_3+\\cdots+n_m\\right)}\\\\ \\vdots\\\\ \\ge\u0026p_{ik_1}^{\\left(n_1\\right)}p_{k_1k_2}^{\\left(n_2\\right)}p_{k_2k_3}^{\\left(n_3\\right)}\\cdots p_{k_{m-1}j}^{\\left(n_m\\right)} \\end{aligned} \\tag{11} \\] 状态的分类及性质 可达、互通、类、可约 定义6（可达与互通）：称状态 \\(i\\) 可达状态 \\(j\\left(i,j \\in S\\right)\\) ，若存在 \\(n \\ge 0\\) 使得 \\(p_{ij}^{\\left(n\\right)} \\ge 0\\) ，记为 \\(i \\rightarrow j\\) 。若同时有状态 \\(j \\rightarrow i\\) ，则称 \\(i\\) 与 \\(j\\) 互通，记为 \\(i \\leftrightarrow j\\) 。\n定理2：互通是一种等价关系，即满足：\n1. 自反性： \\(i \\leftrightarrow i\\) ；\n2. 对称性： \\(i \\leftrightarrow j\\) ，则 \\(j \\leftrightarrow i\\) ；\n3. 传递性： \\(i \\leftrightarrow j\\) , \\(j \\leftrightarrow k\\) ，则 \\(i \\leftrightarrow k\\) 。\n证明（定理2）‌：从互通的定义可知1. 2. 是显然的，只证3. 。由互通定义可知，需证 \\(i \\rightarrow k\\) 且 \\(k \\rightarrow i\\) 。首先，由 \\(i \\rightarrow j\\) ， \\(j \\rightarrow k\\) 可知存在 \\(m\\) ， \\(n\\) 使得 \\(p_{ij}^{\\left(m\\right)}\u003e0\\) ， \\(p_{jk}^{\\left(n\\right)}\u003e0\\) 。再由结论1可知 \\(p_{ik}^{\\left(m+n\\right)}\\ge {p_{ij}^{\\left(m\\right)}p_{jk}^{\\left(n\\right)}}\u003e0\\) ，故 \\(i \\rightarrow k\\) 。反过来同样有 \\(k \\rightarrow i\\) ，即证 \\(i \\leftrightarrow k\\) 。\n定义7（类）：我们把任何两个相通状态归为一个类，由上述定理可知，同在一类的状态应该都是互通的，并且任何一个状态不能同时属于两个不同的类。\n定义8（可约）：若Markov链只存在一个类，就称它是不可约的。否则称为可约的。\n周期 定义9（周期）：若集合 \\(\\set{n|n \\ge 1,p_{ii}^{\\left(n\\right)} \\ge 0}\\) 非空，则称它的最大公约数 \\(d=d\\left(i\\right)\\) 为状态 \\(i\\) 的周期。若 \\(d \\ge 1\\) ，则称 \\(i\\) 是周期的；若 \\(d=1\\) ，则称 \\(i\\) 是非周期的。并特别规定上述集合为空集时，称 \\(i\\) 的周期为无穷大。 。\n定理3：若状态 \\(i,j\\) 同属一类，则 \\(d\\left(i\\right)=d\\left(j\\right)\\) 。\n证明（定理3）‌：由类的定义可知 \\(i \\leftrightarrow j\\) ，即存在 \\(m,n\\) 使 \\(p_{ij}^{\\left(m\\right)}\u003e0,p_{ji}^{\\left(n\\right)}\u003e0\\) 。则由结论1知 \\(p_{ii}^{\\left(m+n\\right)}\\ge p_{ij}^{\\left(m\\right)}p_{ji}^{\\left(n\\right)}\u003e0\\) ，同时对所有使得 \\(p_{jj}^{\\left(s\\right)} \u003e 0\\) 的 \\(s\\) ，有\n\\[ p_{ii}^{\\left(m+s+n\\right)} \\ge p_{ij}^{\\left(m\\right)}p_{jj}^{\\left(s\\right)}p_{ji}^{\\left(n\\right)}\u003e0 \\tag{12} \\] 由周期的定义可知，由于 \\(p_{ii}^{\\left(m+n\\right)}\u003e0\\) 且 \\(p_{ii}^{\\left(m+s+n\\right)}\u003e0\\) ， \\(d\\left(i\\right)\\) 必然同时整除 \\(n+m\\) 和 \\(n+m+s\\) ，因此，它也必然整除 \\(s\\) （见整除的基本性质）。同时我们还需注意我们已经假设了 \\(p_{jj}^{\\left(s\\right)} \u003e 0\\) ，因此 \\(d\\left(j\\right)\\) 必定也整除 \\(s\\) 。注意 \\(s\\) 的任意性，不妨直接令 \\(s=d\\left(j\\right)\\) ，由此可得 \\(d\\left(i\\right)\\) 整除 \\(d\\left(j\\right)\\) 。我们把上述证明的 \\(i\\) 和 \\(j\\) 交换一下，就也能得到 \\(d\\left(j\\right)\\) 整除 \\(d\\left(i\\right)\\) ，于是 \\(d\\left(i\\right)=d\\left(j\\right)\\) （见 整除的基本性质）。\n常返 首达概率、常返与非常返（瞬过） 定义10（首达概率）：对于任何状态 \\(i,j\\) ，以 \\(f_{ij}^{\\left(n\\right)}\\) 记从i出发经n步后首次到达 \\(j\\) 的概率（首达概率），则有\n\\[ f_{ij}^{\\left(n\\right)}= \\begin{cases} 0 \\quad n=0 \\\\[5pt] P\\set{X_n=j,X_k \\ne j\\left(k=1,2,\\cdots ,n-1\\right)| X_0=i} \\quad n \\ge 1 \\end{cases} \\tag{13} \\] 定义11（常返）：令 \\(f_{ij}=\\displaystyle\\sum_{n=1}^{\\infin}{f_{ij}^{\\left(n\\right)}}\\) ，若 \\(f_{jj}=1\\) ，则称状态 \\(j\\) 为常返状态，若 \\(f_{jj}\u003c1\\) ，称 \\(j\\) 为非常返状态或瞬过状态。\n\\(f_{ij}\\) 的含义可由如下得出：由集合 \\(A_n\\) 的定义 \\(A_n=\\set{X_n=j,X_k \\ne j, k=1,2,\\cdots n-1 | X_0=i}\\) 可知 \\(n\\) 不同的时候 \\(A_n\\) 不相交。而 \\(\\displaystyle\\bigcup_{n=1}^{\\infin}{A_n}\\) 表示的事件正是总有一个 \\(n\\) 使得过程经 \\(n\\) 步后可从 \\(i\\) 到达 \\(j\\) ,那么由不相交事件概率的可加性可得：\n\\[ P\\left(\\bigcup_{n=1}^{\\infin}{A_n}\\right)=\\sum_{n=1}^{\\infin}{P\\left(A_n\\right)}=\\sum_{n=1}^{\\infin}f_{ij}^{\\left(n\\right)}=f_{ij} \\tag{14} \\] 因此 \\(f_{ij}\\) 表示从 \\(i\\) 出发，有限步内可以到达 \\(j\\) 的概率。当 \\(i\\) 为常返状态时，以概率 \\(1\\) 从 \\(i\\) 出发，在有限步过程将重新返回 \\(i\\) ，而当 \\(i\\) 为非常返状态时，若也以概率 \\(1\\) 从 \\(i\\) 出发，则以概率 \\(1-f_{ii}\\) 不再回到 \\(i\\) （即从 \\(i\\) 滑过）。\n对于常返态 \\(i\\) ，定义\n\\[ \\mu_i=\\sum_{n=1}^{\\infin}{nf_{ii}^{\\left(n\\right)}} \\tag{15} \\] 表示由 \\(i\\) 出发再返回到 \\(i\\) 所需的平均步数（时间）。\n正常返、零常返、遍历、吸收 定义12（正常返、零常返、遍历、吸收）：对于常返态 \\(i\\) ，若 \\(\\mu_i\u003c+\\infin\\) ，则称 \\(i\\) 为正常返态；若 \\(\\mu_i=+\\infin\\) ，则称 \\(i\\) 为零常返态。特别地，若 \\(i\\) 正常返且是非周期的，则称之为遍历状态。若 \\(i\\) 是遍历状态，且 \\(f_{ii}^{\\left(1\\right)}=1\\) ，则称 \\(i\\) 为吸收状态。此时显然 \\(\\mu_i=1\\) 。\n若干性质证明 常返的极限判定 定理4：状态 \\(i\\) 为常返状态当且仅当 \\(\\displaystyle\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=+\\infin\\) 。状态 \\(i\\) 为非常返状态时\n\\[ \\sum_{n=0}^{\\left(\\infin\\right)}{p_{ii}^{\\left(n\\right)}}=\\frac{1}{1-f_{ii}} \\tag{16} \\] 因而此时有 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 。\n为了证明定理4，我们需要先证明结论2和引理1。\n结论2：对任意状态 \\(i,j\\) ，有\n\\[ f_{ij}^{\\left(l+1\\right)}=\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}} \\tag{17} \\] 证明（结论2）‌：由首达概率的定义、Markov链的定义、时齐的定义和全概率公式可得\n\\[ \\begin{aligned} f_{ij}^{\\left(l+1\\right)}=\u0026P\\set{X_{l+1}=j,X_m \\ne j\\left(m=1,2,\\cdots ,l\\right) | X_0=i}\\quad \\text{（首达概率）}\\\\[5pt] =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k | X_0=i}}\\text{（全概率公式）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{\\frac{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k,X_0=i}}{P\\set{X_0=i}}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{\\frac{P\\set{X_1=k,X_0=i}}{P\\set{X_0=i}}\\frac{P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right),X_1=k,X_0=i}}{P\\set{X_1=k,X_0=i}}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right)|X_1=k,X_0=i}}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_{l+1}=j,X_m \\ne j\\left(m=2,\\cdots ,l\\right)|X_1=k}}\\text{（Markov链）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{P\\set{X_1=k|X_0=i}P\\set{X_l=j,X_m \\ne j \\left(m=1,\\cdots ,l-1\\right)|X_0=k}}\\text{（时齐）}\\\\ =\u0026\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}} \\end{aligned} \\tag{18} \\] 引理1：对任意状态 \\(i,j\\) 及 \\(1 \\le n \u003c \\infin\\) ，有\n\\[ p_{ij}^{\\left(n\\right)}=\\sum_{l=1}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}} \\tag{19} \\] 证明（引理1）‌：用归纳法。对 \\(n=1\\) ，由 \\(p_{ij}^{\\left(1\\right)}=f_{ij}^{\\left(1\\right)}\\) ，易证上式成立。\n假设对 \\(n-1\\) ，已有 \\(p_{ij}^{\\left(n-1\\right)}=\\displaystyle\\sum_{l=1}^{n-1}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-1-l\\right)}}\\) 成立。\n当取 \\(n\\) 时，利用C-K方程、归纳假设和结论2，可以推导出\n\\[ \\begin{aligned} p_{ij}^{\\left(n\\right)}\u0026=\\sum_{k \\in S}{p_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}} \\qquad \\text{（C-K方程）}\\\\ \u0026=p_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}{p_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}p_{kj}^{\\left(n-1\\right)}} \\text{（归纳法n=1时的情况）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{k \\ne j,\\thinspace k \\in S}f_{ik}^{\\left(1\\right)}\\left(\\sum_{l=1}^{n-1}{f_{kj}^{\\left(l\\right)}p_{jj}^{\\left(n-1-l\\right)}}\\right) \\text{（归纳假设n-1时的情况）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=1}^{n-1}{\\left(\\sum_{k \\ne j,\\thinspace k \\in S}{f_{ik}^{\\left(1\\right)}f_{kj}^{\\left(l\\right)}}\\right)p_{jj}^{\\left(n-1-l\\right)}}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=1}^{n-1}{f_{ij}^{\\left(l+1\\right)}p_{jj}^{\\left(n-1-l\\right)}} \\quad \\text{（结论2）}\\\\ \u0026=f_{ij}^{\\left(1\\right)}p_{jj}^{\\left(n-1\\right)}+\\sum_{l=2}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}\\\\ \u0026=\\sum_{l=1}^{n}{f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}\\\\ \\end{aligned} \\tag{20} \\] 现在，我们可以用引理1证明定理4。\n证明（定理4）‌：\n\\[ \\begin{aligned} \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\u0026\\:p_{ii}^{\\left(0\\right)}+\\sum_{n=1}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\\\ =\u0026\\:1+\\sum_{n=1}^{\\infin}\\left(\\sum_{l=1}^{n}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(n-l\\right)}}\\right)\\\\ =\u0026\\:1+\\sum_{l=1}^{\\infin}\\sum_{n=l}^{\\infin}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(n-l\\right)}}\\\\ =\u0026\\:1+\\sum_{l=1}^{\\infin}\\sum_{m=0}^{\\infin}{f_{ii}^{\\left(l\\right)}p_{ii}^{\\left(m\\right)}}\\\\ =\u0026\\:1+\\left(\\sum_{l=1}^{\\infin}{f_{ii}^{\\left(l\\right)}}\\right)\\left(\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\right)\\\\ =\u0026\\:1+f_{ii}\\left(\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\right) \\end{aligned} \\tag{21} \\] 左右有相同项 \\(\\displaystyle\\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\) ，则解该等式得\n\\[ \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\\frac{1}{1-f_{ii}} \\tag{22} \\] 因此\n\\[ \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}\\text{收敛}\\iff f_{ii}\u003c1\\text{；} \\sum_{n=0}^{\\infin}{p_{ii}^{\\left(n\\right)}}=\\infin \\iff f_{ii}=1 \\tag{23} \\] 常返互通则必达 引理2：若 \\(i \\leftrightarrow j\\) 且 \\(i\\) 为常返态，则 \\(f_{ji}=1\\) 。\n证明（引理2）‌：用反证法。假设 \\(f_{ji}\u003c1\\) ，则从 \\(j\\) 出发不一定能在有限步内到达 \\(i\\) ，但是由于 \\(i \\rightarrow j\\) ，则从 \\(i\\) 出发一定能在有限步到达 \\(j\\) 。这意味着从 \\(i\\) 出发如果经过 \\(j\\) ，将不一定能在有限步之内再回到 \\(i\\) ，这与 \\(i\\) 的常返性相矛盾，假设不成立。因此 \\(f_{ij}=1\\) 。\n常返是一个类性质 定理5：常返性是一个类性质。即若 \\(i \\leftrightarrow j\\) 则 \\(i,j\\) 同为常返状态或非常返状态，且当 \\(i,j\\) 同为常返状态时，它们同为正常返态或零常返态。\n证明（定理5）‌：先证明若 \\(i \\leftrightarrow j\\) 则 \\(i,j\\) 同为常返状态或非常返状态。\n由 \\(i \\leftrightarrow j\\) 知。存在 \\(n, m\\) 使得 \\(p_{ij}^{\\left(n\\right)}\u003e0,p_{ji}^{\\left(m\\right)}\u003e0\\) ，由结论1易得\n\\[ p_{ii}^{\\left(n+m+l\\right)} \\ge p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(l\\right)}p_{ji}^{\\left(m\\right)}\\\\[5pt] p_{jj}^{\\left(n+m+l\\right)} \\ge p_{ji}^{\\left(n\\right)}p_{ii}^{\\left(l\\right)}p_{ij}^{\\left(m\\right)} \\tag{24} \\] 两边求和得到\n\\[ \\sum_{l=0}^{\\infin}{p_{ii}^{\\left(n+m+l\\right)}} \\ge \\sum_{l=0}^{\\infin}{p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(l\\right)}p_{ji}^{\\left(m\\right)}}\\\\[5pt] \\sum_{l=0}^{\\infin}{p_{jj}^{\\left(n+m+l\\right)}} \\ge \\sum_{l=0}^{\\infin}{p_{ji}^{\\left(n\\right)}p_{ii}^{\\left(l\\right)}p_{ij}^{\\left(m\\right)}} \\tag{25} \\] 考虑到 \\(\\displaystyle\\sum_{l=0}^{n+m-1}{p_{ii}^{\\left(l\\right)}}\\) 和 \\(\\displaystyle\\sum_{l=0}^{n+m-1}{p_{jj}^{\\left(l\\right)}}\\) 都是有限的，那么可以把上式写成这样：\n\\[ \\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}} - \\sum_{l=0}^{n+m-1}{p_{ii}^{\\left(l\\right)}} \\ge p_{ij}^{\\left(n\\right)}p_{ji}^{\\left(m\\right)}\\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}}\\\\[5pt] \\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}} - \\sum_{l=0}^{n+m-1}{p_{jj}^{\\left(l\\right)}} \\ge p_{ji}^{\\left(n\\right)}p_{ij}^{\\left(m\\right)}\\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}} \\tag{26} \\] 因此我们可以直观的看出 \\(\\displaystyle\\sum_{l=0}^{\\infin}{p_{ii}^{\\left(l\\right)}}\\) 和 \\(\\displaystyle\\sum_{l=0}^{\\infin}{p_{jj}^{\\left(l\\right)}}\\) 当中任意一个为无穷时，另一个必然也为无穷；任意一个为有限时，另一个必然也为有限。因此 \\(i,j\\) 同为常返状态或非常返状态。故常返性是一个类性质，类中任意成员满足，则其他成员也必定满足；反之若类中任一成员不满足，则其他成员也不满足。\n其次还能证明当 \\(i,j\\) 同为常返状态时，它们同为正常返态或零常返态。该证明需要用到下文的推论1。\n假设 \\(i\\) 为零常返状态且 \\(i \\leftrightarrow j\\) 。由推论1可知 \\(\\lim\\limits_{m \\rightarrow \\infin}p_{ii}^{\\left(m\\right)}=0\\) 。由于 \\(i \\leftrightarrow j\\) ，存在 \\(n,l\\) 使得 \\(p_{ij}^{\\left(n\\right)}\u003e0,p_{ji}^{\\left(l\\right)}\u003e0\\) 。同时由结论1可得 \\(p_{ii}^{\\left(n+m+l\\right)} \\ge p_{ij}^{\\left(n\\right)}p_{jj}^{\\left(m\\right)}p_{ji}^{\\left(l\\right)}\\ge0\\) 。令 \\(m \\rightarrow \\infin\\) ，由夹挤准则可知 \\(\\lim\\limits_{m \\rightarrow \\infin}p_{jj}^{\\left(m\\right)}=0\\) ，故由推论1，状态 \\(j\\) 也是零常返状态。\n状态空间分解定理 定理6（状态空间分解定理）：任意Markov链的状态空间 \\(S\\) ，可唯一分解为有限个或可列个互不相交的子集 \\(D,C_1,C_2,\\cdots\\) 之和，使得\n1. 每一个 \\(C_n\\) 是常返状态组成的不可约闭集， \\(D\\) 由全体非常返状态组成。。\n2. \\(C_n\\) 中的状态同类，或者全是正常返态，或者全是零常返态。它们有相同的周期且 \\(f_{ij}=1\\left(i,j \\in C_n\\right)\\) 。\n3. 自 \\(C_n\\) 中的状态出发不能到达 \\(D\\) 中状态。\n证明（状态空间分解定理）‌：设 \\(C\\) 为全体常返状态组成的集合，则 \\(D=S-C\\) 为非常返状态的全体组成的集合。注意到定义在 \\(C\\) 上的互通是一种等价关系，由等价关系与集合的划分可知， \\(C\\) 可以按互通关系划分为 \\(C_1 \\bigcup C_2 \\bigcup \\dots\\) ，其中每一个 \\(C_n\\) 是由同一类常返状态组成的不可约的闭集。因此 \\(S=D \\bigcup C_1 \\bigcup C_2 \\bigcup \\dots\\) 。定理假设和1. 证毕。由定理5可知 \\(C_n\\) 中的状态都是同类型的（正常返或零常返），由定理3可知 \\(C_n\\) 中的状态都有相同的周期，由引理2可知 \\(C_n\\) 中的状态都满足 \\(f_{ij}=1\\left(i,j \\in C_n\\right)\\) 。2. 证毕。对于3. ，可用反证法证明。假设 \\(C_n\\) 中的状态 \\(i\\) 可以到达 \\(D\\) 中的状态 \\(j\\) ，由于 \\(i\\) 是常返的，状态在到达 \\(j\\) 后必定还会再返回 \\(i\\) ，而后再由假设，状态还可能继续回到 \\(j\\) 。因此，状态从 \\(j\\) 出发后再次返回 \\(j\\) 的情况是可能出现的，这与 \\(j\\) 是非常返态相矛盾，因此假设不成立。故 \\(C_n\\) 中的状态 \\(i\\) 不可到达 \\(D\\) 中的状态 \\(j\\) 。3. 证毕。至此，状态空间分解定理证毕。\n不可约Markov链的转移 定理7：周期为 \\(d\\) 的不可约Markov链，其状态空间 \\(S\\) 可唯一地分解为 \\(d\\) 个互不相交的子集之和，即\n\\[ S=\\bigcup_{r=0}^{d-1}{S_r},\\quad S_r \\bigcap S_s=\\varnothing,\\quad r \\ne S \\tag{27} \\] 且使得自 \\(S_r\\) 任意状态出发，经 \\(1\\) 步转移必进入 \\(S_{r+1}\\) 中（其中 \\(S_d=S_0\\) ）。\n证明（定理7）‌：先给出子集 \\(S_r\\) 的定义：\n任意取状态 \\(i\\) ，对每一个 \\(r=0,1,\\cdots,d-1\\) ，定义集合\n\\[ S_r=\\set{j|存在n \\ge 0使得p_{ij}^{\\left(nd+r\\right)}\u003e0} \\tag{28} \\] 因为 \\(S\\) 不可约，故 \\(S\\) 中从 \\(i\\) 出发一定可以遍历每一个状态，而 \\(nd+r\\left(r=0,1,\\cdots,n-1\\right)\\) 可以遍历从 \\(i\\) 出发后的每一个时间，因此所有 \\(S_r\\) 的并集一定为 \\(S\\) ，即 \\(\\displaystyle\\bigcup_{r=0}^{d-1}{S_r}=S\\) 。\n接下来证明 \\(S_r\\) 不相交。用反证法，假设存在 \\(S_r,S_s\\) 和状态 \\(j\\) 满足 \\(j \\in S_r \\bigcap S_s\\) 。由 \\(S_r\\) 的定义知存在 \\(n,m\\) 使得 \\(p_{ij}^{\\left(nd+r\\right)}\u003e0,p_{ij}^{\\left(md+s\\right)}\u003e0\\) 。又因为 \\(i \\leftrightarrow j\\) ，故存在 \\(h\\) 使得 \\(p_{ji}^{\\left(h\\right)}\u003e0\\) ，于是由结论1可得：\n\\[ p_{ii}^{\\left(nd+r+h\\right)} \\ge p_{ij}^{\\left(nd+r\\right)}p_{ji}^{\\left(h\\right)}\u003e0\\\\[5pt] p_{ii}^{\\left(md+s+h\\right)} \\ge p_{ij}^{\\left(md+s\\right)}p_{ji}^{\\left(h\\right)}\u003e0 \\tag{29} \\] 由周期的定义可知 \\(nd+r+h\\) 和 \\(md+s+h\\) 都可以被 \\(d\\) 整除。省去前面的 \\(n\\) 和 \\(m\\) 可得 \\(r+h\\) 和 \\(s+h\\) 都可被 \\(d\\) 整除。从而其差 \\(\\left(r+h\\right)-\\left(s+h\\right)=r-s\\) 都能被 \\(d\\) 整除（见整除的基本性质）。但是 \\(0 \\le r \\le d-1,0 \\le s \\le d-1\\) ，故 \\(0 \\le r-s \\le d-1\\) ，因此 \\(r-s\\) 只能为 \\(0\\) ，也就是 \\(r=s\\) 。故 \\(S_r=S_s\\) ，假设不成立，故 \\(S_r\\) 不相交。\n接下来证明自 \\(S_r\\) 任意状态出发，经 \\(1\\) 步转移必进入 \\(S_{r+1}\\) 中（其中 \\(S_d=S_0\\) ）。等价于证明对任意 \\(j \\in S_r\\) ，有 \\(\\displaystyle\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}}=1\\) 。事实上，由 式(28)可知 \\(p_{ij}^{\\left(nd+r\\right)}\u003e0\\) ，同样可知对 \\(k \\notin S_{r+1}\\) 必有 \\(p_{ik}^{\\left(nd+r+1\\right)}=0\\) 。因此由结论1可推导：\n\\[ 0=p_{ik}^{\\left(nd+r+1\\right)} \\ge p_{ij}^{\\left(nd+r\\right)}p_{jk}^{\\left(1\\right)}\u003e0 \\tag{30} \\] 从而 \\(p_{jk}^{\\left(1\\right)}=0\\) 。于是\n\\[ 1\\:=\\sum_{k \\in S}{p_{jk}}=\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}} + \\sum_{k \\notin S_{r+1}}{p_{jk}^{\\left(1\\right)}}=\\sum_{k \\in S_{r+1}}{p_{jk}^{\\left(1\\right)}} \\tag{31} \\] 最后证明分解的唯一性。等价于与证明 \\(\\set{S_k}\\) 与初始的 \\(i\\) 无关。也就是，对于任意的 \\(i,i^\\prime\\) 生成的分解 \\(\\set{S_k},\\set{S_k^\\prime}\\) 必相等。\n首先，证明对于 \\(\\set{S_k}\\) 中的任意 \\({S_r}\\) ，存在 \\({S_s^\\prime}\\) 与其状态完全相等。首先证对所有 \\(j \\in S_r\\) ， \\(j\\) 都只能属于 \\(\\set{S_k^\\prime}\\) 中某个固定的集合。假设 \\(i^{\\prime}\\) 满足 \\(i^\\prime \\in S_s\\) 。由于自 \\(S_k\\) 任意状态出发经 \\(1\\) 步转移必进入 \\(S_{k+1}\\) 中，所以当 \\(s \\le r\\) 时，从 \\(i^{\\prime}\\) 到达 \\(j\\) 只可能通过如下过程之一：\n\\[ \\begin{cases} S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\\\ S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\rightarrow S_{r+1} \\rightarrow \\cdots \\rightarrow S_{d-1} \\rightarrow S_0 \\rightarrow S_1 \\rightarrow \\cdots \\rightarrow S_r\\\\ S_s \\rightarrow S_{s+1} \\rightarrow \\cdots \\rightarrow S_r\\rightarrow \\overbrace{S_{r+1} \\rightarrow \\cdots \\rightarrow S_{d-1} \\rightarrow S_0 \\rightarrow S_1 \\rightarrow \\cdots \\rightarrow S_r}^{重复2次}\\\\ \\quad \\vdots \\end{cases} \\tag{32} \\] 也就是从 \\(i^{\\prime}\\) 出发只能在 \\(r-s,r-s+d,r-s+2d,\\dots\\) 步上到达 \\(j\\) 。我们发现这刚好与 \\(S_{r-s}^{\\prime}\\) 的定义是一致的。因此 \\(j \\in S_{r-s}^{\\prime}\\) 。反过来讨论任意 \\(j^\\prime \\in S_{r-s}^{\\prime}\\) 。从 \\(i\\) 转移到 \\(i^\\prime\\) 需要 \\(s\\) 步，而从 \\(i^\\prime\\) 转移到 \\(j^\\prime\\) 需要 \\(r-s\\) 步，因此从 \\(i\\) 转移到 \\(j^\\prime\\) 需要 \\(r\\) 步，故 \\(j^\\prime \\in S_r\\) 。故 \\(S_r\\) 与 \\(S_{r-s}^\\prime\\) 完全对等。\n另外当 \\(s \u003e r\\) 时，由类似的方法可以证明从 \\(i^{\\prime}\\) 出发，只能在 \\(d-\\left(s-r\\right),2d-\\left(s-r\\right),\\dots\\) 步到达 \\(j\\) ，因此 \\(j \\in S_{d-\\left(s-r\\right)}^{\\prime}\\) 。类似的也可证明 \\(S_r\\) 与 \\(S_{d-\\left(s-r\\right)}^{\\prime}\\) 完全对等。综上，有\n\\[ \\begin{cases} S_r与S_{r-s}^{\\prime}完全对等，若r \\ge s \\\\[5pt] S_r与S_{d-\\left(s-r\\right)}^{\\prime}完全对等，若r \u003c s \\end{cases} \\tag{33} \\] 易证此时 \\(\\set{S_k},\\set{S_k^\\prime}\\) 一一对应。故分解是唯一的。\n极限定理与不变分布 极限定理及其衍生定理 极限定理 定理8（极限定理）：若状态 \\(j\\) 是周期为 \\(d\\) 的常返状态，则\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{jj}^{\\left(nd\\right)}=\\frac{d}{\\mu_j} \\tag{34} \\] 证明（极限定理）‌：对 \\(n \\ge 0\\) ，令：\n\\[ r_n=\\sum_{v=n+1}^{\\infin}{f_v} \\tag{35} \\] 其中 \\(f_v=f_{jj}^{\\left(v\\right)}\\) 。于是\n\\[ \\begin{aligned} \\sum_{n=0}^{\\infin}{r_n}=\u0026\\sum_{n=0}^{\\infin}\\sum_{v=n+1}^{\\infin}{f_v}\\\\ =\u0026\\left(f_1+f_2+f_3+\\cdots\\right)+\\left(f_2+f_3+\\cdots\\right)+\\left(f_3+\\cdots\\right)+\\cdots\\\\[5pt] =\u00261\\cdot f_1 + 2 \\cdot f_2 + 3 \\cdot f_3 + \\cdots\\\\ =\u0026\\sum_{n=1}^{\\infin}{nf_n}=\\mu_j \\end{aligned} \\tag{36} \\] 由 \\(r_n\\) 定义可知 \\(f_n=r_{v-1}-r_v\\) ，代入引理1并记 \\(p_v=p_{jj}^{\\left(v\\right)}\\) 可得\n\\[ p_n=p_{jj}^{\\left(n\\right)}=\\sum_{l=1}^{n}{f_{jj}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}}=-\\sum_{v=1}^{n}{\\left(r_v-r_{v-1}\\right)p_{n-v}} \\tag{37} \\] 注意 \\(j\\) 是常返状态，故 \\(r_0=1\\) 。则上式可以写成\n\\[ \\sum_{v=0}^{n}{r_vp_{n-v}}=\\sum_{v=0}^{n-1}r_vp_{n-1-v} \\tag{38} \\] 上面这个式子表示了一个很明显的结论： \\(\\displaystyle\\sum_{v=0}^{n}{r_vp_{n-v}}\\) 的值与 \\(n\\) 无关。因此：\n\\[ \\sum_{v=0}^{n}{r_vp_{n-v}}=r_0p_0=1,\\quad n \\ge 0 \\tag{39} \\] 设\n\\[ \\lambda=\\limsup\\limits_{n \\rightarrow \\infin}p_{nd} \\tag{40} \\] 根据上极限的定义可知，必然存在 \\(\\set{n}\\) 的子列 \\(\\set{n_m},n_m \\rightarrow \\infin\\) 使得\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}{p_{n_md}}=\\limsup\\limits_{m \\rightarrow \\infin}{p_{n_md}}=\\liminf\\limits_{m \\rightarrow \\infin}{p_{n_md}} \\tag{41} \\] 任取 \\(s\\) 使得 \\(f_s\u003e0\\) ，由引理1和下极限的性质可得\n\\[ \\begin{aligned} \\lambda=\u0026\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md}=\\liminf\\limits_{m \\rightarrow \\infin}p_{jj}^{\\left(n_md\\right)}=\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1}^{n_md}f_{jj}^{\\left(v\\right)}p_{jj}^{\\left(n_md-v\\right)}\\\\ =\u0026\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1}^{n_md}f_{v}p_{n_md-v}=\\liminf\\limits_{m \\rightarrow \\infin}\\left(f_sp_{n_md-s}+\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\right)\\\\ \\le\u0026\\liminf\\limits_{m \\rightarrow \\infin}f_sp_{n_md-s}+\\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}\\left(a_n+b_n\\right)\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n+\\liminf\\limits_{n \\rightarrow \\infin}b_n\\text{）} \\end{aligned} \\tag{42} \\] 由概率的非负性和上下极限的性质和可推导出\n\\[ \\begin{aligned} \\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}\\le\u0026\\sum_{v=1,v \\ne s}^{n_md}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}\\left(a_n+b_n\\right)\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n+\\liminf\\limits_{n \\rightarrow \\infin}b_n\\text{）}\\\\ \\le\u0026\\sum_{v=1,v \\ne s}^{\\infin}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}p_{n_md-v}\\quad\\text{（概率的非负性）}\\\\ \\le\u0026\\sum_{v=1,v \\ne s}^{\\infin}\\liminf\\limits_{m \\rightarrow \\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\quad\\text{（}\\liminf\\limits_{n \\rightarrow \\infin}a_nb_n\\le\\liminf\\limits_{n \\rightarrow \\infin}a_n\\limsup\\limits_{n \\rightarrow \\infin}b_n\\text{）}\\\\ =\u0026\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\\\ \\end{aligned} \\tag{43} \\] 注意当 \\(v\\) 不是 \\(d\\) 的倍数时 \\(p_{n_md-v}=0\\) ，此时 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v} \\le \\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}\\) ；若 \\(v\\) 是 \\(d\\) 的倍数，由上极限的性质可知仍有 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v} \\le \\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}\\) 。故接上式\n\\[ \\liminf\\limits_{m \\rightarrow \\infin}\\sum_{v=1,v \\ne s}^{n_md}f_{v}p_{n_md-v}=\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-v}\\le\\left(\\sum_{v=1,v \\ne s}^{\\infin}f_{v}\\right)\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md} \\tag{44} \\] 注意状态 \\(j\\) 是常返的，所以 \\(\\displaystyle\\sum_{v=1}^{\\infin}f_{v}=1\\) ，也就是 \\(\\displaystyle\\sum_{v=1,v \\ne s}^{\\infin}f_{v}=1-f_s\\) 。而将式(41)代入式(44)后再将式(44)代回式(42)得\n\\[ \\lambda\\le f_s\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}+\\left(1-f_s\\right)\\lambda \\tag{45} \\] 即\n\\[ \\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\lambda \\tag{46} \\] 由周期的定义和 \\(f_s\u003e0\\) 知 \\(d\\) 必整除 \\(s\\) 。因此 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md}=\\lambda\\) 。但是由上下极限的定义可知 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\) ，即 \\(\\lambda=\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}\\ge\\lambda\\) 。故由夹挤准则可知 \\(\\limsup\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\liminf\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lambda\\) 。又由式(41)可得：\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-s}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_md-2s}=\\cdots \\tag{47} \\] 任取 \\(l\\) 个正整数 \\(c_i\\) 和满足 \\(f_{d_i}\u003e0\\) 的 \\(l\\) 个正整数 \\(d_i,i=1,2,\\cdots,l\\) 。由式(47)可知有\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_md-c_id_i}=\\lambda \\tag{48} \\] 注意由周期的定义， \\(d\\) 一定可以整除 \\(d_i\\) 。假设 \\(d_i=k_id\\) ， \\(k_i\\) 为正整数，则上式又可以写为\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{\\left(n_m-c_ik_i\\right)d}=\\lambda \\tag{49} \\] 可以定义一个正整数 \\(n_m^\\prime=n_m-c_ik_i\\) 。则上式可以写成\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d}=\\lambda \\tag{50} \\] 我们发现上式和式(41)形式完全一样，因此再次重复从式(41)到式(48)的推导又可以得到\n\\[ \\lambda=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-s^\\prime}=\\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-2s^\\prime}=\\cdots \\tag{51} \\] 也就是\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_m^\\prime d-c_{i^\\prime}d_{i^\\prime}}=\\lambda \\tag{52} \\] 因此，不同的 \\(c_id_i\\) 可以叠加而不影响结论。故对 \\(u=\\displaystyle\\sum_{i=1}^{l}c_id_i\\) 也满足\n\\[ \\lim\\limits_{m \\rightarrow \\infin}p_{n_md-u}=\\lambda \\tag{53} \\] 由周期的定义知，存在满足 \\(f_{d_i}\u003e0\\) 的 \\(d_i,i=1,2,\\cdots,l\\) 使得 \\(d_1,d_2,\\cdots,d_l\\) 的最大公因子也是 \\(d\\) 。于是，当 \\(k\\) 大于某个正整数 \\(k_0\\) 时，必有正整数 \\(c_i\\) ，使得\n\\[ kd=\\sum_{i=1}^{l}c_id_i \\tag{54} \\] 上述结论见Frobenius问题（实际上 \\(k_0\\) 就是数论中著名的Frobenius数，该数在 \\(l\\ge3\\) 时无一般表示式，但是可以证明 \\(k_0\\le \\displaystyle\\sum_{i=2}^{l}\\frac{d_i\\cdot gcd\\left(d_1,d_2,\\dots,d_{i-1}\\right)}{d \\cdot gcd\\left(d_1,d_2,\\dots,d_i\\right)} - \\displaystyle\\sum_{i=1}^{l}\\frac{d_i}{d}\\) ）。于是，对每一个 \\(k\\ge k_0\\) 有\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{\\left(n_m-k\\right)d}=\\lambda \\tag{55} \\] 在式(39)中令 \\(n=\\left(n_m-k_0\\right)d\\) ， 并注意到 \\(v\\) 不是 \\(d\\) 的整数倍时 \\(p_v=0\\) ，故可把 \\(v\\) 替换为 \\(vd\\) ，则得\n\\[ \\sum_{v=0}^{n_m-k_0}r_{vd}p_{\\left(n_m-k_0-v\\right)d}=1 \\tag{56} \\] 令 \\(m \\rightarrow \\infin\\) 可得\n\\[ \\lambda=\\frac{1}{\\displaystyle\\sum_{v=0}^{\\infin}r_{vd}} \\tag{57} \\] 因为当 \\(v\\) 不是 \\(d\\) 的整数倍时， \\(f_v=0\\) ，由式(35)可得\n\\[ r_{vd} = r_{vd+1} = \\cdots = r_{vd+d-1} = \\frac{1}{d}\\sum_{j=vd}^{vd+d-1}r_j \\tag{58} \\] 从而由式(36)得\n\\[ \\sum_{v=0}^{\\infin}r_{vd}=\\frac{1}{d}\\sum_{v=0}^{\\infin}\\sum_{j=vd}^{vd+d-1}r_j=\\frac{1}{d}\\sum_{v=0}^{\\infin}r_v=\\frac{\\mu_j}{d} \\tag{59} \\] 代入式(57)可得\n\\[ \\lambda = \\frac{d}{\\mu_j} \\tag{60} \\] 把式(40)换成 \\(\\lambda=\\liminf\\limits_{n \\rightarrow \\infin}p_{nd}\\) ，下面的推导过程完全相同，仍可以得到 \\(\\lambda = \\displaystyle\\frac{d}{\\mu_j}\\) 。因此，由极限的性质可知\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{nd}=\\frac{d}{\\mu_j} \\tag{61} \\] 由此，极限定理证毕。\n推论1：设 \\(i\\) 为常返状态，则\n\\[ i\\text{为零常返状态}\\iff\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0 \\tag{62} \\] 证明（推论1）‌：若 \\(i\\) 为零常返状态，则 \\(\\mu_i \\rightarrow \\infin\\) ，从而由极限定理知 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(nd\\right)}=0\\) 。而当 \\(m\\) 不等于 \\(d\\) 的整数倍时， \\(p_{ii}^{\\left(m\\right)}=0\\) ，故 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 。反之，若 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) ，假如 \\(i\\) 为正常返状态，则由极限定理知 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(nd\\right)}\u003e0\\) ，由极限的性质知这与 \\(\\lim\\limits_{n \\rightarrow \\infin}p_{ii}^{\\left(n\\right)}=0\\) 矛盾，因此 \\(i\\) 为零常返状态。\n再论非常返与零常返 定理9：若 \\(j\\) 为非常返状态或零常返状态，则对 \\(\\forall i \\in S\\)\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{ij}^{\\left(n\\right)}=0 \\tag{63} \\] 证明（定理9）‌：由引理1得\n\\[ p_{ij}^{\\left(n\\right)}=\\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)} \\tag{64} \\] 对 \\( N \u003c n \\) ，由概率小于 \\(1\\) 可知 \\(f_{ij}^{\\left(l\\right)}\u003c1\\) ，因此上式可写成\n\\[ \\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}\\le \\sum_{l=1}^{N}f_{ij}^{\\left(l\\right)}p_{jj}^{\\left(n-l\\right)}+\\sum_{l=N+1}^{n}f_{ij}^{\\left(l\\right)} \\tag{65} \\] 先固定 \\(N\\) ，令 \\(n \\rightarrow \\infin\\) 。由极限定理知 \\(p_{jj}^{\\left(n\\right)} \\rightarrow 0\\) ，故上式右端第一项为 \\(0\\) 。再令 \\(N \\rightarrow \\infin\\) ，上式右端第二项因 \\(\\displaystyle\\sum_{l=1}^{n}f_{ij}^{\\left(l\\right)}\u003c1\\) 而趋于 \\(0\\) ，故\n\\[ \\lim\\limits_{n \\rightarrow \\infin}p_{ij}^{\\left(n\\right)}=0 \\tag{66} \\] 定理得证。\n推论2：有限状态的Markov链，不可能全为非常返状态，也不可能有零常返状态，从而不可约的有限Markov链是正常返的。\n证明（推论2）‌：设状态空间 \\(S=\\set{1,2,\\cdots,N}\\) ，若全部 \\(N\\) 个状态都是非常返，则任取其中两个状态 \\(i,j\\) ，若 \\(i \\rightarrow j \\) ，有 \\(p_{ij}^{\\left(n\\right)}\\rightarrow 0\\) （定理9）；若 \\(i \\nrightarrow j\\) ，则对 \\(\\forall n\\) ， \\(p_{ij}^{\\left(n\\right)}=0\\) 。不管是哪种情况， \\(\\displaystyle\\sum_{j=0}^{N}p_{ij}^{\\left(n\\right)}\\to 0\\) ，但是 \\(\\displaystyle\\sum_{j=0}^{N}p_{ij}^{\\left(n\\right)}=1\\) （与式(4)类似），矛盾。因此有限状态的Markov链，不可能全为非常返状态。\n若 \\(S\\) 中有零常返状态，设为 \\(i\\) ，令 \\(C=\\set{j | i \\rightarrow j}\\) ，则有 \\(\\displaystyle\\sum_{j \\in C}p_{ij}^{\\left(n\\right)}=1\\) 且 \\(j \\rightarrow i\\) （ \\(j \\nrightarrow i\\) 与 \\(i\\) 的常返性相矛盾，类似引理2的证明）。故 \\(i \\leftrightarrow j\\) ，从而 \\(j\\) 也为零常返状态（定理5）。则 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=0\\) （定理9），从而 \\(\\displaystyle\\sum_{j \\in C}^{}p_{ij}^{\\left(n\\right)}\\to 0\\) 。但是由 \\(j\\) 的定义知 \\(\\displaystyle\\sum_{j \\in C}^{}p_{ij}^{\\left(n\\right)}=1\\) ，矛盾。因此有限状态的Markov链不可能有零常返状态。\n推论3：若Markov链有一个零常返状态，则必有无限个零常返状态。\n证明（推论3）‌：假设Markov链有一个零常返状态。由状态空间分解定理可知这个零常返状态必然存在于某个不可约类中，又有定理5可知这个类必然全都是零常返状态。由推论2可知该不可约类不可能是有限状态的。因此，该Markov链必然有无限个零常返状态。\n再论正常返 定理10：若 \\(j\\) 为正常返状态且周期为 \\(d\\) ，则对 \\(\\forall i\\) 及 \\(0 \\le r \\le d-1\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd+r\\right)}=f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j} \\tag{67} \\] 其中 \\(f_{ij}\\left(r\\right)\\) 为：\n\\[ f_{ij}\\left(r\\right)=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md+r\\right)},\\quad 0 \\le r \\le d-1 \\tag{68} \\] 证明（定理10）‌：当 \\(n \\ne kd\\) 时， \\(p_{jj}^{\\left(n\\right)}=0\\) 。因此由引理1可得\n\\[ \\begin{aligned} p_{ij}^{\\left(nd+r\\right)}=\u0026\\sum_{k=0}^{\\left(nd+r\\right)}f_{ij}^{\\left(k\\right)}p_{jj}^{\\left(nd+r-k\\right)}\\quad\\text{（引理1）}\\\\ =\u0026\\sum_{m=0}^{n}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}\\text{（}换元k=md+r，其余的k的项值都为0\\text{）} \\end{aligned} \\tag{69} \\] 于是由 \\(0 \\le p_{jj}^{\\left(n-m\\right)d} \\le 1\\) （概率的性质），对 \\(1 \\le N \u003c n\\) 有\n\\[ \\sum_{m=0}^{N}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}\\le p_{ij}^{\\left(nd+r\\right)}\\le \\sum_{m=0}^{N}f_{ij}^{\\left(md+r\\right)}p_{jj}^{\\left(n-m\\right)d}+\\sum_{N+1}^{n}f_{ij}^{\\left(md+r\\right)} \\tag{70} \\] 类似于定理9的推导，先令 \\(n \\to \\infin\\) ，再令 \\(N \\to \\infin\\) ，由极限定理得\n\\[ f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j}\\le p_{ij}^{\\left(nd+r\\right)} \\le f_{ij}\\left(r\\right)\\space\\frac{d}{\\mu_j} \\tag{71} \\] 由夹挤准则可得定理10得证。\n推论4：设有不可约的、正常返的、周期为 \\(d\\) 的Markov链（即每个状态都是正常返的），其状态空间为 \\(S\\) ，则对任何状态 \\(i \\leftrightarrow j\\left(i,j \\in S\\right)\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd\\right)}= \\begin{cases} \\space\\displaystyle\\frac{d}{\\mu_j}\\quad\u0026若\\space i \\space 与\\space j \\space 同属于子集\\space S\\\\[10pt] \\space 0\\quad\u0026其他 \\end{cases} \\tag{72} \\] 其中 \\(S=\\displaystyle\\bigcup_{i=0}^{d-1}S_s\\) 即为定理7所给出的 \\(S_s\\) 。特别的，当 \\(d=1\\) 时， \\(\\forall i,j \\in S\\) 有\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\frac{1}{\\mu_j} \\tag{73} \\] 证明（推论4）‌：在定理10中取 \\(r=0\\) 得\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(nd\\right)}=f_{ij}\\left(0\\right)\\space\\frac{d}{\\mu_j} \\tag{74} \\] 其中 \\(f_{ij}\\left(0\\right)=\\displaystyle\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md\\right)}\\) 。若 \\(i\\) 与 \\(j\\) 不在同一个 \\(S_s\\) 中，则由定理7可知所有的 \\(f_{ij}^{\\left(md\\right)}=0\\) 。若 \\(i,j\\) 在同一个 \\(S_s\\) 中，注意当 \\(n\\) 不为 \\(d\\) 的倍数的时候 \\(p_{ij}^{\\left(n\\right)}=0\\) ，因此 \\(f_{ij}^{\\left(n\\right)}=0\\) （见常返）。此时有\n\\[ f_{ij}\\left(0\\right)=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(md\\right)}=\\sum_{m=0}^{\\infin}f_{ij}^{\\left(m\\right)}=f_{ij}=1 \\tag{75} \\] 综上，推论4得证。\nn步转移概率的期望 定理11：对于任意状态 \\(i,j \\in S\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}= \\begin{cases} \\space 0 \\quad j\\space 为非常返状态或零常返状态\\\\[10pt] \\space \\displaystyle\\frac{f_{ij}}{\\mu_{j}} \\quad j \\space 为正常返状态 \\end{cases} \\tag{76} \\] 为了证明定理11，我们需要先证明引理3。\n引理3：设有非负数列 \\(\\set{a_n}\\) 的 \\(d\\) 个子列 \\(\\set{a_{kd+s}}\\left(s=0,1,2,\\cdots,d-1\\right)\\) ，如果对每一个 \\(d\\) ，存在极限 \\(\\lim\\limits_{k \\to \\infin}a_{kd+s}=b_s\\) ，则有：\n\\[ \\lim_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}a_k=\\frac{1}{d}\\sum_{s=0}^{d-1}b_s \\tag{77} \\] 证明（引理3）‌：设 \\(n=md+r\\left(0 \\le r \u003c d-1\\right)\\) ，数列的前 \\(n\\) 项和 \\(\\displaystyle\\sum_{k=1}^{n}a_k\\) 可以写为：\n\\[ \\sum_{k=1}^{n}a_k=\\sum_{t=1}^{d-1}a_{t}+\\sum_{s=0}^{d-1}\\sum_{k=1}^{m-1}a_{kd+s}+\\sum_{t=0}^{r}a_{md+t} \\tag{78} \\] 等式两端除以 \\(m\\) 并令 \\(m \\to \\infin\\) 。右端第一项和第三项都为有限值，因此极限为 \\(0\\) 。讨论右端第二项，由Stolz定理可推导得：\n\\[ \\lim\\limits_{m \\to \\infin}\\frac{\\displaystyle\\sum_{k=1}^{m-1}a_{kd+s}}{m}=\\lim\\limits_{m \\to \\infin}\\frac{\\displaystyle\\sum_{k=1}^{m-1}a_{kd+s}-\\displaystyle\\sum_{k=1}^{m-2}a_{kd+s}}{m-\\left(m-1\\right)}=\\lim\\limits_{m \\to \\infin}a_{\\left(m-1\\right)d+s}=b_s \\tag{79} \\] 因此\n\\[ \\lim\\limits_{m \\to \\infin}\\frac{1}{m}\\sum_{k=1}^{n}a_k=\\sum_{s=0}^{d-1}b_s \\tag{80} \\] 最后再令 \\(n \\to \\infin\\) ，得\n\\[ \\lim_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}a_k=\\lim_{m \\to \\infin}\\frac{m}{md+r}\\cdot\\lim_{m \\to \\infin}\\frac{1}{m}\\sum_{k=1}^{n}a_k=\\frac{1}{d}\\sum_{s=0}^{d-1}b_s \\tag{81} \\] 现在，我们可以证明定理11。\n证明（定理11）‌：若 \\(j\\) 为非常返状态或零常返状态，由定理9可知 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=0\\) 。因此 \\(\\lim\\limits_{n \\to \\infin}\\displaystyle\\frac{1}{n}\\displaystyle\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=0\\) 。若 \\(j\\) 为正常返状态且有周期 \\(d\\) ，则令引理3中的 \\(a_{kd+s}=p_{ij}^{\\left(kd+s\\right)}\\) ，然后利用定理10得到 \\(b_s=f_{ij}\\left(s\\right)\\displaystyle\\space\\frac{d}{\\mu_j}\\) 。从而得\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=\\frac{1}{d}\\sum_{s=0}^{d-1}f_{ij}\\left(s\\right)\\space\\frac{d}{\\mu_j}=\\frac{1}{\\mu_j}\\sum_{s=0}^{d-1}f_{ij}\\left(s\\right)=f_{ij} \\tag{82} \\] 推论5：如果 \\(\\set{X_n}\\) 是不可约的、常返的Markov链（即每个状态都是常返的），则对任意状态 \\(i,j \\in S\\) ，有\n\\[ \\lim\\limits_{n \\to \\infin}\\frac{1}{n}\\sum_{k=1}^{n}p_{ij}^{\\left(k\\right)}=\\frac{1}{\\mu_j} \\tag{83} \\] 证明（推论5）‌：由引理2可知 \\(f_{ij}=1\\) ，又由推论2可知 \\(i,j\\) 都是正常返的。因此直接代入定理11可证得该推论。\n不变分布与极限分布 不变分布 定义13（不变分布）：对于Markov链，概率分布 \\(\\set{\\pi_j,j \\in S}\\) 称为不变的，若\n\\[ \\pi_j=\\sum_{i \\in S}\\pi_ip_{ij} \\tag{84} \\] 可见，若Markov链的初始分布 \\(P\\set{X_0=j}=p_j\\) 是不变分布，则 \\(X_1\\) 的分布将是\n\\[ \\begin{aligned} P\\set{X_1=j}=\u0026\\sum_{i \\in S}P\\set{X_1=j|X_0=i}P\\set{X_0=i}\\\\ =\u0026\\sum_{i \\in S}p_{ij}p_i=p_j \\end{aligned} \\tag{85} \\] 这与 \\(X_0\\) 的分布是相同的。依此类推， \\(X_n\\left(n=0,1,2,\\cdots\\right)\\) 将有相同的分布，这也是称 \\(\\set{p_i\\left(i \\in S\\right)}\\) 为不变分布的原因。\n极限分布 定义14（极限分布）：称Markov链是遍历的，如果所有状态相通且均是周期为 \\(1\\) 的正常返状态，对遍历的Markov链，极限\n\\[ \\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\pi_j\\quad j \\in S \\tag{86} \\] 称为Markov链的极限分布。由推论4知 \\(\\pi_j\\) 存在且 \\(\\pi_j=\\displaystyle\\frac{1}{\\mu_j}\\) 。\n定理12：对于不可约非周期的Markov链：\n1. 若它是遍历的，则 \\(\\pi_j=\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}\u003e0\\) 是不变分布且是唯一的不变分布（遍历定理）。\n2. 若状态都是瞬过的或全为零常返的，则不变分布不存在。\n证明（定理12）‌：1. 对遍历的Markov链，由推论4可知 \\(\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}\\) 存在，记为 \\(\\pi_j\\) 。首先证 \\(\\set{\\pi_j,j \\in S}\\) 是不变分布。由Fatou引理和C-K方程可得（因为级数是Riemann-Stieljes积分的特例， 也可以看成关于点测度的Lebesgue积分， 所以Fatou引理和下文出现的Lebesgue控制收敛定理仍成立）。\n\\[ \\pi_j=\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n+1\\right)}=\\lim\\limits_{n \\to \\infin}\\sum_{k \\in S}p_{ik}^{\\left(n\\right)}p_{kj}\\ge\\sum_{k \\in S}\\lim\\limits_{n \\to \\infin}p_{ik}^{\\left(n\\right)}p_{kj}=\\sum_{k \\in S}\\pi_kp_{kj} \\tag{87} \\] 两边对 \\(j\\) 求和，由概率归一性有\n\\[ \\sum_{j \\in S}\\pi_j\\ge\\sum_{j \\in S}\\sum_{k \\in S}\\pi_kp_{kj}=\\sum_{k \\in S}\\pi_k\\left(\\sum_{j \\in S}p_{kj}\\right)=\\sum_{k \\in S}\\pi_k \\tag{88} \\] 因此，上式的大于等于号必须取等，否则将产生矛盾。因此：\n\\[ \\pi_j=\\sum_{k \\in S}\\pi_kp_{kj} \\tag{89} \\] 从而 \\(\\set{\\pi_j,j \\in S}\\) 是不变分布。再来证 \\(\\set{\\pi_j,j \\in S}\\) 是唯一的不变分布。由上式和C-K方程可得\n\\[ \\pi_j=\\sum_{k \\in S}\\pi_kp_{kj}=\\sum_{k \\in S}\\sum_{l \\in S}\\pi_lp_{lk}p_{kj}=\\sum_{l \\in S}\\pi_lp_{lj}^{\\left(2\\right)}=\\cdots=\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)} \\tag{90} \\] 对 \\(\\displaystyle\\sum_{j \\in S}p_{ij}^{\\left(n\\right)}=1\\) 两边取 \\(n \\to \\infin\\) 并由Fatou引理可得\n\\[ 1=\\lim\\limits_{n \\to \\infin}\\sum_{j \\in S}p_{ij}^{\\left(n\\right)}\\ge\\sum_{j \\in S}\\lim\\limits_{n \\to \\infin}p_{ij}^{\\left(n\\right)}=\\sum_{j \\in S}\\pi_j \\tag{91} \\] 因此 \\(\\displaystyle\\sum_{j \\in S}\\pi_j\\le 1\\) 有限。将式(90)左右两边取 \\(n \\to \\infin\\) 并由Lebesgue控制收敛定理可得\n\\[ \\pi_j=\\lim\\limits_{n \\to \\infin}\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)}=\\sum_{k \\in S}\\lim\\limits_{n \\to \\infin}\\pi_kp_{kj}^{\\left(n\\right)}=\\pi_j\\left(\\sum_{k \\in S}\\pi_k\\right) \\tag{92} \\] 因此 \\(\\displaystyle\\sum_{k \\in S}\\pi_k=1\\) 。假设另外还有一个平衡分布 \\(\\set{\\tilde\\pi_j,j \\in S}\\) ，则有\n\\[ \\tilde\\pi_j=\\pi_j\\left(\\sum_{k \\in S}\\tilde\\pi_k\\right)=\\pi_j \\tag{93} \\] 因此 \\(\\tilde\\pi_j=\\pi_j\\) 。故分布唯一。接下来证2. 。假设存在一个不变分布 \\(\\set{\\pi_j,j \\in S}\\) ，则由1. 中证明可知 \\(\\pi_j=\\displaystyle\\sum_{k \\in S}\\pi_kp_{kj}^{\\left(n\\right)}\\left(n=1,2,\\dots\\right)\\) 。令 \\(n \\to \\infin\\) ，由定理9可知 \\(p_{kj}^{\\left(n\\right)} \\to 0\\) ，则任意 \\( \\pi_j = 0\\) ，然而这是不可能的。于是对非常返或零常返Markov链不存在不变分布。\n连续时间Markov链 基本定义和性质 连续时间Markov链的定义 定义15（连续时间Markov链）：过程 \\(\\set{X\\left(t\\right),t\\ge0}\\) 的状态空间 \\(S\\) 为离散空间，为方便书写，设 \\(S\\) 为 \\(\\set{0,1,2,\\cdots}\\) 或其子集。若对一切 \\(s,t\\ge0\\) 及 \\(i,j \\in S\\) 有\n\\[ \\begin{aligned} \u0026P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i,X\\left(u\\right)=x\\left(u\\right),0\\le u \u003c s}\\\\[5pt] =\u0026P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i} \\end{aligned} \\tag{94} \\] 成立，则称 \\(\\set{X\\left(t\\right),t \\ge 0}\\) 是一个连续时间Markov链。\n条件概率 \\(P\\set{X\\left(t+s\\right)=j|X\\left(s\\right)=i}\\) 记作 \\(p_{ij}\\left(s,t\\right)\\) 表示过程在时刻 \\(s\\) 处处于状态 \\(i\\) ，经过 \\(t\\) 时间后转移到 \\(j\\) 的转移概率，并称 \\(\\bm{P}\\left(s,t\\right)=\\left(p_{ij}\\left(s,t\\right)\\right)\\) 为相应的转移概率矩阵。\n时齐连续时间Markov链 定义16（时齐性）：称连续时间Markov链是时齐的，若 \\(p_{ij}\\left(s,t\\right)\\) 与 \\(s\\) 无关。简记 \\(p_{ij}\\left(s,t\\right)=p_{ij}\\left(t\\right)\\) ，相应的记 \\(\\bm{P}\\left(t\\right)=\\left(p_{ij}\\left(t\\right)\\right)\\) 。本篇只讨论时齐的连续时间Markov链，并简称为连续时间Markov链。\n定理13：设 \\(\\set{X\\left(t\\right),t\\ge 0}\\) 是连续时间Markov链，假定在时刻0过程刚刚到达 \\(i\\) ，以 \\(\\tau_i\\) 记过程离开 \\(i\\) 之前在 \\(i\\) 停留的时间，则 \\(\\tau_i\\) 服从指数分布。\n证明（定理13）‌：只需证明 \\(\\tau_i\\) 是无记忆性的，即证明对 \\(s,t \\ge 0\\) 有（见指数分布）\n\\[ P\\set{\\tau_i\u003es+t|\\tau_i\u003es}=P\\set{\\tau_i\u003et} \\tag{95} \\] 将上式写开并由连续时间Markov链和时齐性可得\n\\[ \\begin{aligned} \u0026P\\set{\\tau_i\u003es+t|\\tau_i\u003es}\\\\[5pt] =\u0026P\\set{X\\left(u\\right)=i\\space \\left(0 \u003c u \\le s\\right),X\\left(v\\right)=i\\space \\left(s \u003c v \\le s+t\\right)|X\\left(u\\right)=i\\space \\left(0 \u003c u \\le s\\right)}\\\\[5pt] =\u0026P\\set{X\\left(v\\right)=i\\space \\left(s \u003c v \\le s+t\\right)|X\\left(s\\right)=i}\\quad\\text{（连续时间Markov链的定义）}\\\\[5pt] =\u0026P\\set{X\\left(v\\right)=i\\space \\left(0 \u003c v \\le t\\right)|X\\left(0\\right)=i}\\quad\\text{（时齐性）}\\\\[5pt] =\u0026P\\set{\\tau_i\u003et} \\end{aligned} \\tag{96} \\] 正则连续时间Markov链 定义17（正则性）：称一个连续时间Markov链是正则的，若以概率1在任意有限长的时间内转移的次数是有限的。从而可得连续性条件\n\\[ \\lim\\limits_{t \\to 0}p_{ij}\\left(t\\right)=\\delta_{ij}= \\begin{cases} 1,\\quad i=j\\\\[5pt] 0,\\quad i \\ne j \\end{cases} \\tag{97} \\] 本文讨论的连续时间Markov链都是正则的。\n注：“成立”和“以概率1成立”是有很大区别的。在概率论中，“以概率1成立”意味着某个事件在无限多次试验中几乎肯定会发生，但并不意味着它在每一次试验中都会发生。换句话说，存在极小的可能性（尽管这个可能性可能非常小，接近于0）该事件不会发生。见以概率1收敛。\n转移概率和Kolmogorov微分方程 转移概率的性质 定理14：时齐连续时间Markov链的转移概率 \\(p_{ij}\\left(t\\right)\\) 满足：\n1. \\(p_{ij}\\left(t\\right)\\ge 0\\)\n2. \\(\\displaystyle\\sum_{j \\in S}p_{ij}\\left(t\\right)=1\\)\n3. \\(p_{ij}\\left(t+s\\right)=\\displaystyle\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(s\\right)\\) （连续时间Markov链的C-K方程）\n证明（定理14）‌：1. 和2. 由 \\(p_{ij}\\left(t\\right)\\) 的定义易知。下面证明3. 。由连续时间Markov链和时齐性可得\n\\[ \\begin{aligned} p_{ij}\\left(t+s\\right)=\u0026P\\set{X\\left(t+s\\right)=j|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}\\frac{P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(0\\right)=i}}\\\\[5pt] =\u0026\\sum_{k \\in S}\\frac{P\\set{X\\left(t+s\\right)=j,X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(t\\right)=k,X\\left(0\\right)=i}}\\frac{P\\set{X\\left(t\\right)=k,X\\left(0\\right)=i}}{P\\set{X\\left(0\\right)=i}}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j|X\\left(t\\right)=k,X\\left(0\\right)=i}P\\set{X\\left(t\\right)=k|X\\left(0\\right)=i}\\\\[5pt] =\u0026\\sum_{k \\in S}P\\set{X\\left(t+s\\right)=j|X\\left(t\\right)=k}p_{ik}\\left(t\\right)\\quad\\text{（连续时间Markov链）}\\\\[5pt] =\u0026\\sum_{k \\in S}p_{kj}\\left(s\\right)p_{ik}\\left(t\\right)=\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(s\\right)\\quad\\text{（时齐性）} \\end{aligned} \\tag{98} \\] 转移概率具有一致连续性 定理15：对固定的 \\(i,j \\in S=\\set{0,1,2,\\cdots}\\) ， \\(p_{ij}\\left(t\\right)\\) 是 \\(t\\) 的一致连续函数（见一致连续性）。\n证明（定理15）‌：设 \\(h\u003e0\\) ，则\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)=\u0026\\sum_{k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)-p_{ij}\\left(t\\right)\\\\ =\u0026p_{ii}\\left(h\\right)p_{ij}\\left(t\\right)-p_{ij}\\left(t\\right)+\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)\\\\ =\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right)+\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\end{aligned} \\tag{99} \\] 从而得到\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)\\ge\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right)\\\\ \\ge\u0026-\\left(1-p_{ii}\\left(h\\right)\\right)\\\\ \\end{aligned} \\tag{100} \\] 和\n\\[ \\begin{aligned} p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)\\le\u0026\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)\\\\ \\le\u0026\\sum_{k \\ne i, k \\in S}p_{ik}\\left(h\\right)=1-p_{ii}\\left(h\\right)\\\\ \\end{aligned} \\tag{101} \\] 因此得到\n\\[ |p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)|\\le 1-p_{ii}\\left(h\\right) \\tag{102} \\] 对 \\(h\u003c0\\) 也可以得到类似的结果。注意由正则性可知 \\(\\displaystyle\\lim\\limits_{h \\to 0}p_{ii}\\left(h\\right)=1\\) 。因此 \\(\\forall \\varepsilon \u003e 0\\) ， \\(\\exist \\delta \u003e 0\\) 满足 \\(h \u003c \\delta\\) 时恒有 \\(1-p_{ii}\\left(h\\right)\u003c\\varepsilon\\) ，即 \\(|p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)|\u003c\\varepsilon\\) 。因此， \\(p_{ij}\\left(t\\right)\\) 一致连续（见一致连续性）。\n转移速率 定理16：1. \\(\\displaystyle\\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=q_{ii}\\le+\\infin\\)\n2. \\(\\displaystyle\\lim\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t}=q_{ij}\u003c+\\infin\\) ( \\(i \\ne j\\) )\n称 \\(q_{ij}\\) 为从状态 \\(i\\) 转移到状态 \\(j\\) 的转移速率。\n证明（定理16）‌：先证1. 。首先由正则性可知对任意固定的 \\(t\u003e0\\) ，当 \\(n\\) 充分大时，有 \\(p_{ii}\\left(\\displaystyle\\frac{t}{n}\\right)\u003e0\\) ，再由定理14可得结论 \\(p_{ii}\\left(s+t\\right)=\\displaystyle\\sum_{k \\in S}p_{ik}\\left(s\\right)p_{ki}\\left(t\\right)\\ge p_{ii}\\left(s\\right)p_{ii}\\left(t\\right)\\) ，因此 \\(p_{ii}\\left(t\\right)\\ge \\left(p_{ii}\\left(\\displaystyle\\frac{t}{n}\\right)\\right)^n\u003e0\\) 。故可以定义 \\(\\phi\\left(t\\right)=-\\ln p_{ii}\\left(t\\right)\\) ，它非负有限，且由于 \\(p_{ii}\\left(s+t\\right)\\ge p_{ii}\\left(s\\right)p_{ii}\\left(t\\right)\\) ，有 \\(\\phi\\left(s+t\\right) \\le \\phi\\left(s\\right)+\\phi\\left(t\\right)\\) 。令 \\(q_{ii}=\\displaystyle\\sup\\limits_{t\u003e0}\\frac{\\phi\\left(t\\right)}{t}\\) ，现在要证明 \\(\\displaystyle\\frac{\\phi\\left(t\\right)}{t}\\) 极限存在且为其上确界。显然\n\\[ 0 \\le q_{ii} \\le \\infin,\\quad \\limsup\\limits_{t \\to 0}\\le q_{ii} \\tag{103} \\] 所以以下只需证下极限 \\(\\displaystyle\\liminf\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\ge q_{ii}\\) 。任给 \\(0 \u003c h \u003c t\\) ，取 \\(n\\) 使 \\(t=nh+\\varepsilon,\\space 0 \\le \\varepsilon \u003c h\\) ，得\n\\[ \\frac{\\phi\\left(t\\right)}{t} \\le \\frac{n\\phi\\left(h\\right)}{t}+\\frac{\\phi\\left(\\varepsilon\\right)}{t} = \\frac{nh}{t}\\frac{\\phi\\left(h\\right)}{h}+\\frac{\\phi\\left(\\varepsilon\\right)}{t} \\tag{104} \\] 注意当 \\(h \\to 0^+\\) 时， \\(\\varepsilon \\to 0\\) ， \\(\\displaystyle\\frac{nh}{t} \\to 1\\) ， \\(\\phi\\left(\\varepsilon\\right)=-\\ln p_{ii}\\left(\\varepsilon\\right) \\to 0\\) ，故 \\(\\displaystyle\\frac{\\phi\\left(t\\right)}{t}\\le\\liminf\\limits_{h \\to 0}\\frac{\\phi\\left(h\\right)}{h}\\) 因此 \\(q_{ii}=\\displaystyle\\sup\\limits_{t\u003e0}\\frac{\\phi\\left(t\\right)}{t}\\le\\liminf\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\) 。从而 \\(\\displaystyle q_{ii}=\\lim\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}\\) 。由 \\(\\phi\\left(t\\right)\\) 定义得\n\\[ \\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=\\lim\\limits_{t \\to 0}\\frac{1-e^{-\\phi\\left(t\\right)}}{\\phi\\left(t\\right)}\\frac{\\phi\\left(t\\right)}{t}=\\lim\\limits_{t \\to 0}\\frac{\\phi\\left(t\\right)}{t}=q_{ii} \\tag{105} \\] 再证2. 。由正则性，对任意 \\(\\displaystyle 0 \u003c \\varepsilon \u003c \\frac{1}{3}\\) ，存在 \\(0 \u003c \\delta \u003c 1\\) ，使当 \\(0 \u003c t \\le \\delta \\) 时，有 \\(p_{ii}\\left(t\\right)\u003e1-\\varepsilon\\) ， \\(p_{jj}\\left(t\\right)\u003e1-\\varepsilon\\) ， \\(p_{ji}\\left(t\\right)\u003c\\varepsilon\\) 。\n下面要证：对任意 \\(0 \\le h \u003c t\\) ，只要 \\(t \\le \\delta\\) ，则有\n\\[ p_{ij}\\left(h\\right)\\le\\frac{p_{ij}\\left(t\\right)}{n}\\frac{1}{1-3\\varepsilon} \\tag{106} \\] 其中 \\(\\displaystyle n=\\left\\lfloor \\frac{t}{h} \\right\\rfloor\\) （向下取整）。记\n\\[ \\begin{cases} _jp_{ik}\\left(h\\right)=p_{ik}\\left(h\\right)\\\\[10pt] _jp_{ik}\\left(mh\\right)=\\displaystyle\\sum_{r \\ne j}{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)} \\end{cases} \\tag{107} \\] 其中 \\(_jp_{ik}\\left(mh\\right)\\) 表示从 \\(i\\) 出发，在时刻 \\(h,2h,\\cdots,\\left(m-1\\right)h\\) 未到达 \\(j\\) 而在 \\(mh\\) 时刻到达 \\(k\\) 的概率。反复展开 \\(_jp_{ik}\\left(mh\\right)\\) 并由定理14可得\n\\[ \\begin{aligned} _jp_{ik}\\left(mh\\right)=\u0026\\sum_{r \\ne j}{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)}\\\\ =\u0026\\sum_r{_jp_{ir}\\left(\\left(m-1\\right)h\\right)p_{rk}\\left(h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\sum_r\\sum_{s \\ne j}{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sr}\\left(h\\right)p_{rk}\\left(h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\sum_{s \\ne j}{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\quad\\text{（定理14）}\\\\ =\u0026\\sum_s{_jp_{is}\\left(\\left(m-2\\right)h\\right)p_{sk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-2\\right)h\\right)p_{jk}\\left(2h\\right)}-{_jp_{ij}\\left(\\left(m-1\\right)h\\right)p_{jk}\\left(h\\right)}\\\\ =\u0026\\cdots\\\\ =\u0026\\sum_r{_jp_{ir}\\left(h\\right)p_{rk}\\left(\\left(m-1\\right)h\\right)}-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\\\ =\u0026\\sum_r{p_{ir}\\left(h\\right)p_{rk}\\left(\\left(m-1\\right)h\\right)}-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\\\ =\u0026p_{ik}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(m-l\\right)h\\right)p_{jk}\\left(lh\\right)}\\quad\\text{（定理14）}\\\\ =\u0026p_{ik}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)\\right)}\\quad（换元l \\to \\left(m-l\\right)） \\end{aligned} \\tag{108} \\] 由正则性可得\n\\[ \\begin{aligned} p_{ik}\\left(mh\\right)=\u0026_jp_{ik}\\left(mh\\right)+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\\\ =\u0026_jp_{ij}\\left(mh\\right)\\delta_{jk}+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\\\ =\u0026_jp_{ij}\\left(mh\\right)p_{jk}\\left(0\\right)+\\sum_{l=1}^{m-1}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)}\\quad（正则性）\\\\ =\u0026\\sum_{l=1}^{m}{_jp_{ij}\\left(lh\\right)p_{jk}\\left(\\left(m-l\\right)h\\right)} \\end{aligned} \\tag{109} \\] 由上式和定理14可得\n\\[ \\begin{aligned} p_{ij}\\left(t\\right)=\u0026\\sum_k{p_{ik}\\left(nh\\right)p_{kj}\\left(t-nh\\right)}\\\\ =\u0026\\sum_k\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jk}\\left(\\left(n-m\\right)h\\right)}p_{kj}\\left(t-nh\\right)\\\\ =\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)} \\end{aligned} \\tag{110} \\] 当 \\(h \u003c t \\le \\delta\\) 时，由上式可得\n\\[ \\begin{aligned} \\varepsilon \u003e 1-p_{ii}\\left(t\\right)=\u0026\\sum_{k \\ne i}p_{ik}\\left(t\\right)\\\\[10pt] \\ge\u0026p_{ij}\\left(t\\right)\\quad（注意i \\ne j）\\\\[5pt] \\ge\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)}\\\\ \\ge\u0026\\left(1-\\varepsilon\\right)\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)} \\end{aligned} \\tag{111} \\] 即\n\\[ \\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)} \\le \\frac{\\varepsilon}{1-\\varepsilon} \\tag{112} \\] 式(108)取 \\(k=i\\) 可得\n\\[ \\begin{aligned} _jp_{ii}\\left(mh\\right)=\u0026p_{ii}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)p_{ji}\\left(\\left(m-l\\right)h\\right)\\right)}\\\\ \\ge\u0026p_{ii}\\left(mh\\right)-\\sum_{l=1}^{m-1}{_jp_{ij}\\left(\\left(lh\\right)\\right)}\\\\ \\ge\u00261 - \\varepsilon - \\frac{\\varepsilon}{1-\\varepsilon} \\end{aligned} \\tag{113} \\] 因此由式(110)和定理14可得\n\\[ \\begin{aligned} p_{ij}\\left(t\\right)=\u0026\\sum_{m=1}^{n}{_jp_{ij}\\left(mh\\right)p_{jj}\\left(t-mh\\right)}\\\\[5pt] \\ge\u0026\\sum_{m=1}^{n}{_jp_{ii}\\left(\\left(m-1\\right)h\\right)p_{ij}\\left(h\\right)p_{jj}\\left(t-mh\\right)}\\\\[5pt] \\ge\u0026n\\left(1 - \\varepsilon - \\frac{\\varepsilon}{1-\\varepsilon}\\right)p_{ij}\\left(h\\right)\\left(1-\\varepsilon\\right)\\\\[10pt] \\ge\u0026n\\left(1-3\\varepsilon\\right)p_{ij}\\left(h\\right) \\end{aligned} \\tag{114} \\] 式(106)得证。两边除以 \\(h\\) 并注意当 \\(h \\to 0\\) 时 \\(nh \\to t\\) ，得\n\\[ \\limsup\\limits_{h \\to 0}\\frac{p_{ij}\\left(h\\right)}{h} \\le \\frac{1}{1+3\\varepsilon}\\frac{p_{ij}\\left(t\\right)}{t} \u003c \\infin \\tag{115} \\] 再令 \\(t \\to 0\\) ，有\n\\[ \\limsup\\limits_{h \\to 0}\\frac{p_{ij}\\left(h\\right)}{h} \\le \\frac{1}{1+3\\varepsilon}\\liminf\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t} \u003c \\infin \\tag{116} \\] 再令 \\(\\varepsilon \\to 0\\) ，定理得证。\n推论6：对有限状态时齐的连续时间的Markov链，有\n\\[ q_{ii}=\\sum_{j \\ne i}q_{ij} \u003c +\\infin \\tag{117} \\] 证明（推论6）‌：由定理14知， \\(\\displaystyle\\sum_{j \\in S}p_{ij}\\left(t\\right)=1\\) ，即\n\\[ 1-p_{ii}\\left(t\\right)=\\sum_{j \\ne i}p_{ij}\\left(t\\right) \\tag{118} \\] 故由定理16\n\\[ \\begin{aligned} \\lim\\limits_{t \\to 0}\\frac{1-p_{ii}\\left(t\\right)}{t}=\u0026\\lim\\limits_{t \\to 0}\\sum_{j \\ne i}\\frac{p_{ij}\\left(t\\right)}{t}\\\\ =\u0026\\sum_{j \\ne i}\\lim\\limits_{t \\to 0}\\frac{p_{ij}\\left(t\\right)}{t}\\\\ =\u0026\\sum_{j \\ne i}q_{ij} \u003c +\\infin \\end{aligned} \\tag{119} \\] 保守性 对于无限状态的情况，一般只能得到 \\(q_{ii} \\ge \\displaystyle\\sum_{j \\ne i}q_{ij}\\) （式(119)中积分和求和不可交换，因此只能使用Fatou引理）。设状态空间为 \\(S=\\set{1,2,\\cdots,n,\\cdots}\\) ，此时记\n\\[ \\bm{Q}= \\begin{pmatrix} -q_{11} \u0026 q_{12} \u0026 q_{13} \u0026 \\cdots \u0026 q_{1i} \u0026 \\cdots \\\\[5pt] q_{21} \u0026 -q_{22} \u0026 q_{23} \u0026 \\cdots \u0026 q_{2i} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\cdots \\\\[5pt] q_{i1} \u0026 q_{i2} \u0026 q_{i3} \u0026 \\cdots \u0026 -q_{ii} \u0026 \\cdots \\\\[5pt] \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\\\[5pt] \\end{pmatrix} \\tag{120} \\] 称为连续时间Markov链的 \\(\\bm{Q}\\) 矩阵。当矩阵元素 \\(q_{ii}=\\sum_{j \\ne i}q_{ij}\u003c+\\infin\\) 时，称该矩阵为保守的。\nKolmogorov微分方程 定理17（Kolmogorov微分方程）：对一切 \\(i,j \\in S，t \\ge 0\\) 且 \\(q_{ii}=\\displaystyle\\sum_{j \\ne i}q_{ij}\u003c+\\infin\\) ，有：\n1. 向后方程\n\\[ p_{ij}^\\prime\\left(t\\right)=\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right)-q_{ii}p_{ij}\\left(t\\right) \\tag{121} \\] 2. 向前方程（如果满足 \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{kj}\\left(h\\right)}{h}\\) 有限）\n\\[ p_{ij}^\\prime\\left(t\\right)=\\sum_{k \\ne j}q_{kj}p_{ik}\\left(t\\right)-q_{jj}p_{ij}\\left(t\\right) \\tag{122} \\] 证明（Kolmogorov微分方程）‌：先证明1. 。由定理14可得\n\\[ p_{ij}\\left(t+h\\right)=\\sum_{k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\tag{123} \\] 或等价地\n\\[ p_{ij}\\left(t+h\\right)-p_{ii}\\left(h\\right)p_{ij}\\left(t\\right)=\\sum_{k \\ne i,k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right) \\tag{124} \\] 变形为\n\\[ p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)=\\sum_{k \\ne i,k \\in S}p_{ik}\\left(h\\right)p_{kj}\\left(t\\right)-\\left(1-p_{ii}\\left(h\\right)\\right)p_{ij}\\left(t\\right) \\tag{125} \\] 于是\n\\[ \\lim\\limits_{h \\to 0}\\frac{p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)}{h}=\\lim\\limits_{h \\to 0}\\sum_{k \\ne i,k \\in S}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)-\\lim\\limits_{h \\to 0}\\frac{1-p_{ii}\\left(h\\right)}{h}p_{ij}\\left(t\\right) \\tag{126} \\] 若此时Markov链状态是有限的，应用定理16和推论6从上式直接可以得到1. （向后方程）\n下面证明对于无限状态下依然有1. 成立。由上式，我们只需证明其中的极限与求和可交换次序即可。由Fatou引理可推导出\n\\[ \\begin{aligned} \\liminf\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\ge\u0026\\sum_{k \\ne i}\\liminf\\limits_{h \\to 0}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\\\ =\u0026\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\end{aligned} \\tag{127} \\] 注意 \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\le\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}=\\frac{1-p_{ii}\\left(h\\right)}{h}\\) ，因此可以使用反向Fatou引理\n\\[ \\begin{aligned} \\limsup\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\le\u0026\\sum_{k \\ne i}\\limsup\\limits_{h \\to 0}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)\\\\ =\u0026\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\end{aligned} \\tag{128} \\] 因此\n\\[ \\lim\\limits_{h \\to 0}\\sum_{k \\ne i}\\frac{p_{ik}\\left(h\\right)}{h}p_{kj}\\left(t\\right)=\\sum_{k \\ne i}q_{ik}p_{kj}\\left(t\\right) \\tag{129} \\] 因此无限状态下1. 仍然成立。实际上1. 可以被写成矩阵形式，也就是 \\(\\bm{P}^\\prime\\left(t\\right)=\\bm{Q}\\bm{P}\\left(t\\right)\\) ，其中 \\(\\bm{P}\\left(t\\right)=\\left(p_{ij}\\left(t\\right)\\right)\\) ， \\(\\bm{Q}=\\left(q_{ij}\\right)\\) 。依Kolmogorov微分方程条件知 \\(\\bm{Q}\\) 是保守的。\n下面证明2. 。在1. 中计算 \\(t+h\\) 的状态时是对退后到时刻 \\(h\\) 的状态来取条件的（所以称为后退方程），这里我们考虑对时刻 \\(t\\) 的状态取条件，用定理14有\n\\[ p_{ij}\\left(t+h\\right)=\\sum_{k \\in S}p_{ik}\\left(t\\right)p_{kj}\\left(h\\right) \\tag{130} \\] 同理得到\n\\[ \\lim\\limits_{h \\to 0}\\frac{p_{ij}\\left(t+h\\right)-p_{ij}\\left(t\\right)}{h}=\\lim\\limits_{h \\to 0}\\sum_{k \\ne i,k \\in S}p_{ik}\\left(t\\right)\\frac{p_{kj}\\left(h\\right)}{h}-\\lim\\limits_{h \\to 0}\\frac{1-p_{jj}\\left(h\\right)}{h}p_{ij}\\left(t\\right) \\tag{131} \\] 注意上式的极限和求和不一定是能交换的（ \\(\\displaystyle\\sum_{k \\ne i}\\frac{p_{kj}\\left(h\\right)}{h}\\) 不一定有限，因此反向Fatou引理不可用）。如果上式的极限和求和运算可以交换，则可得2. 式成立。\n从明天起，做一个幸福的人 喂马、劈柴，周游世界\n从明天起，关心粮食和蔬菜\n我有一所房子，面朝大海，春暖花开\n― 海子, 《面朝大海，春暖花开》 ","date":"2024-09-14T21:05:01+08:00","image":"https://www.brasswrench.com/true","permalink":"https://www.brasswrench.com/posts/mathematics/probability_and_statistics/stochastic_processes/markov_process/","title":"随机过程（四）：Markov过程"}]